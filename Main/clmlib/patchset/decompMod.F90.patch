diff -Naurb org/decompMod.F90 patchd/decompMod.F90
--- org/decompMod.F90	2011-05-24 11:32:05.687004248 +0200
+++ patchd/decompMod.F90	2011-05-24 11:32:42.310376320 +0200
@@ -13,14 +13,14 @@
   use clm_mct_mod
   use shr_sys_mod , only : shr_sys_flush
   use abortutils  , only : endrun
+  use mod_clm
+  use mod_dynparam
 !
 ! !PUBLIC TYPES:
   implicit none
   integer, public :: clump_pproc ! number of clumps per MPI process
 !
 ! !PUBLIC MEMBER FUNCTIONS:
-!  public decomp_init             ! initializes land surface decomposition
-!                                 ! into clumps and processors
   public decomp_atm_init         ! initializes atm grid decomposition
                                  ! into clumps and processors
   public decomp_lnd_init         ! initializes lnd grid decomposition
@@ -136,577 +136,6 @@
 contains
 
 !------------------------------------------------------------------------------
-#if (1 == 0)
-! tcx DO NOT DELETE THIS YET
-!BOP
-!
-! !IROUTINE: decomp_init
-!
-! !INTERFACE:
-  subroutine decomp_init(wtxy)
-!
-! !DESCRIPTION:
-! This subroutine initializes the land surface decomposition into a clump
-! data structure.  This assumes each pe has the same number of clumps
-! set by clump_pproc
-!
-! !USES:
-    use domainMod , only : ldomain,adomain
-    use subgridMod, only : subgrid_get_gcellinfo
-    use clm_varctl, only : nsegspc
-!
-! !ARGUMENTS:
-    implicit none
-    real(r8), intent(in) :: wtxy(:,:)   ! subgrid patch weights
-!
-! !LOCAL VARIABLES:
-    integer :: lni,lnj                ! land domain global size
-    integer :: ani,anj                ! atm domain global size
-    integer :: lns,lg,ln,li,lj        ! indices
-    integer :: ans,ag,an,ai,aj        ! indices
-    integer :: anumg                  ! atm num gridcells
-    integer :: anumg_tot              ! precompute of anumg
-    real(r8):: rnsegspc               ! real value associated with nsegspc
-!    integer :: anumpc                 ! min atm gridcells/clump
-!    integer :: anumxtra               ! extra atm cells
-    integer :: cid,pid                ! indices
-    integer, pointer :: lcid(:)       ! temporary for setting adecomp
-    integer, pointer :: acid(:)       ! temporary for setting adecomp
-    integer :: n,m,np                 ! indices
-    integer :: ilunits, icols, ipfts  ! temporaries
-    integer :: ier                    ! error code
-    integer :: cnt                    ! local counter
-    integer, parameter :: dbug=3      ! 0 = min, 1=normal, 2=much, 3=max
-    integer :: npmin,npmax,npint      ! do loop values for printing
-    integer :: clmin,clmax,clint      ! do loop values for printing
-    integer :: beg,end,lsize,gsize    ! used for gsmap init
-    integer, pointer :: gindex(:)     ! global index for gsmap init
-
-    integer, pointer :: lncnt(:)      ! lnd cell count per atm cell
-    integer, pointer :: lnoff(:)      ! atm cell offset in lnmap
-    integer, pointer :: lnmap(:)      ! map from atm cell to lnd cells
-    integer, pointer :: lglo2gsn(:)   ! map from glo 2 gsn temporary
-    integer, pointer :: aglo2gsn(:)   ! map from glo 2 gsn temporary
-    integer :: lnidx
-
-! !CALLED FROM:
-! subroutine initialize
-!
-! !REVISION HISTORY:
-! 2002.09.11  Forrest Hoffman  Creation.
-! 2005.12.15  T Craig  Updated for finemesh
-! 2006.08.18  P Worley Performance optimizations
-!
-!EOP
-!------------------------------------------------------------------------------
-
-    lni = ldomain%ni
-    lnj = ldomain%nj
-    ani = adomain%ni
-    anj = adomain%nj
-    lns = ldomain%ns
-    ans = adomain%ns
-
-    !--- set and verify nclumps ---
-    if (clump_pproc > 0) then
-       nclumps = clump_pproc * npes
-       if (nclumps < npes) then
-          write (6,*) 'decomp_init(): Number of gridcell clumps= ',nclumps, &
-               ' is less than the number of processes = ', npes
-          call endrun()
-       end if
-    else
-       write(6,*)'clump_pproc= ',clump_pproc,'  must be greater than 0'
-       call endrun()
-    end if
-
-    !--- allocate and initialize procinfo and clumps ---
-    !--- beg and end indices initialized for simple addition of cells later ---
-
-    allocate(procinfo%cid(clump_pproc), stat=ier)
-    if (ier /= 0) then
-       write (6,*) 'decomp_init(): allocation error for procinfo%cid'
-       call endrun()
-    endif
-
-    procinfo%nclumps = clump_pproc
-    procinfo%cid(:)  = -1
-    procinfo%ncells  = 0
-    procinfo%nlunits = 0
-    procinfo%ncols   = 0
-    procinfo%npfts   = 0
-    procinfo%begg    = 1
-    procinfo%begl    = 1
-    procinfo%begc    = 1
-    procinfo%begp    = 1
-    procinfo%endg    = 0
-    procinfo%endl    = 0
-    procinfo%endc    = 0
-    procinfo%endp    = 0
-    procinfo%abegg   = 1
-    procinfo%aendg   = 0
-
-    allocate(clumps(nclumps), stat=ier)
-    if (ier /= 0) then
-       write (6,*) 'decomp_init(): allocation error for clumps'
-       call endrun()
-    end if
-    clumps(:)%owner   = -1
-    clumps(:)%ncells  = 0
-    clumps(:)%nlunits = 0
-    clumps(:)%ncols   = 0
-    clumps(:)%npfts   = 0
-    clumps(:)%begg    = 1
-    clumps(:)%begl    = 1
-    clumps(:)%begc    = 1
-    clumps(:)%begp    = 1
-    clumps(:)%endg    = 0
-    clumps(:)%endl    = 0
-    clumps(:)%endc    = 0
-    clumps(:)%endp    = 0
-
-    !--- assign clumps to proc round robin ---
-    cid = 0
-    do n = 1,nclumps
-       pid = mod(n-1,npes)
-       if (pid < 0 .or. pid > npes-1) then
-          write (6,*) 'decomp_init(): round robin pid error ',n,pid,npes
-          call endrun()
-       endif
-       clumps(n)%owner = pid
-       if (iam == pid) then
-          cid = cid + 1
-          if (cid < 1 .or. cid > clump_pproc) then
-             write (6,*) 'decomp_init(): round robin pid error ',n,pid,npes
-             call endrun()
-          endif
-          procinfo%cid(cid) = n
-       endif
-    enddo
-
-    allocate(lncnt(ans),lnoff(ans),lnmap(lns))
-
-    lncnt = 0
-    do ln = 1,lns
-       an = ldomain%gatm(ln)
-       if ((an > 0) .and. (an .le. ans)) then
-          lncnt(an) = lncnt(an) + 1
-       endif
-    enddo
-
-    lnoff(1) = 1
-    do an = 2,ans
-       lnoff(an) = lnoff(an-1) + lncnt(an-1)
-    enddo
-
-    lncnt = 0
-    lnmap = -1
-    do ln = 1,lns
-       an = ldomain%gatm(ln)
-       if ((an > 0) .and. (an .le. ans)) then
-         lnmap(lnoff(an)+lncnt(an)) = ln
-         lncnt(an) = lncnt(an) + 1
-       endif
-    enddo
-
-!    !--- count total pfts, like loop below, in case you need them "early"
-!    nump  = 0
-    anumg_tot = 0
-    do an = 1,ans
-       if (adomain%mask(an) == 1) then
-          anumg_tot  = anumg_tot  + 1
-!          do lnidx = 0,lncnt(an)-1
-!             ln = lnmap(lnoff(an)+lnidx)          
-!             call subgrid_get_gcellinfo (ln, wtxy, nlunits=ilunits, &
-!                                  ncols=icols, npfts=ipfts)
-!             nump = nump + ipfts
-!          enddo
-       endif
-    enddo
-!    nsegspc  = 1000000                  ! number of segments/clump
-    rnsegspc = min(float(nsegspc),float(anumg_tot)/float(nclumps))
-!    anumpc   = anumg_tot/nclumps
-!    anumxtra = mod(anumg_tot,nclumps)
-
-!    if (masterproc) write(6,*) 'precompute total pfts ',nump
-!    if (masterproc) write(6,*) 'precompute total anumg ',anumg_tot,anumpc,anumxtra
-    if (masterproc) write(6,*) 'precompute total anumg ',anumg_tot,rnsegspc
-
-    !--- assign gridcells to clumps (and thus pes) ---
-    allocate(lcid(lns),acid(ans))
-    lcid = 0
-    acid = 0
-    anumg = 0
-    numg  = 0
-    numl  = 0
-    numc  = 0
-    nump  = 0
-    do an = 1,ans
-       if (adomain%mask(an) == 1) then
-          anumg  = anumg  + 1
-
-#if (1 == 0) 
-          !--- find clump with fewest pfts ---
-          cid = 1
-          do n = 2,nclumps
-             if (clumps(n)%npfts < clumps(cid)%npfts) then
-                cid = n
-             endif
-          enddo
-#endif
-#if (1 == 0)
-          !--- give to clumps in simple round robin
-          cid = mod((anumg-1),nclumps) + 1
-#endif
-#if (1 == 1)
-          !--- give to clumps in order based on nsegspc
-          cid = int(rnsegspc*float(nclumps*(anumg-1))/float(anumg_tot))
-          cid = mod(cid,nclumps) + 1
-#endif
-          acid(an) = cid
-
-          !--- give atm cell to pe that owns cid ---
-          if (iam >  clumps(cid)%owner) then
-             procinfo%abegg = procinfo%abegg + 1
-          endif
-          if (iam >= clumps(cid)%owner) then
-             procinfo%aendg = procinfo%aendg + 1
-          endif
-
-          cnt = 0
-          do lnidx = 0,lncnt(an)-1
-             ln = lnmap(lnoff(an)+lnidx)          
-             cnt = cnt + 1
-             call subgrid_get_gcellinfo (ln, wtxy, nlunits=ilunits, &
-                                  ncols=icols, npfts=ipfts)
-             lcid(ln) = cid
-
-             !--- overall total ---
-             numg = numg + 1
-             numl = numl + ilunits
-             numc = numc + icols
-             nump = nump + ipfts
-
-             !--- give gridcell to cid ---
-             !--- increment the beg and end indices ---
-             clumps(cid)%ncells  = clumps(cid)%ncells  + 1
-             clumps(cid)%nlunits = clumps(cid)%nlunits + ilunits
-             clumps(cid)%ncols   = clumps(cid)%ncols   + icols
-             clumps(cid)%npfts   = clumps(cid)%npfts   + ipfts
-
-             do m = 1,nclumps
-                if ((clumps(m)%owner >  clumps(cid)%owner) .or. &
-                    (clumps(m)%owner == clumps(cid)%owner .and. m > cid)) then
-                   clumps(m)%begg = clumps(m)%begg + 1
-                   clumps(m)%begl = clumps(m)%begl + ilunits
-                   clumps(m)%begc = clumps(m)%begc + icols
-                   clumps(m)%begp = clumps(m)%begp + ipfts
-                endif
-
-                if ((clumps(m)%owner >  clumps(cid)%owner) .or. &
-                    (clumps(m)%owner == clumps(cid)%owner .and. m >= cid)) then
-                   clumps(m)%endg = clumps(m)%endg + 1
-                   clumps(m)%endl = clumps(m)%endl + ilunits
-                   clumps(m)%endc = clumps(m)%endc + icols
-                   clumps(m)%endp = clumps(m)%endp + ipfts
-                endif
-             enddo
-
-             !--- give gridcell to the proc that owns the cid ---
-             !--- increment the beg and end indices ---
-             if (iam == clumps(cid)%owner) then
-                procinfo%ncells  = procinfo%ncells  + 1
-                procinfo%nlunits = procinfo%nlunits + ilunits
-                procinfo%ncols   = procinfo%ncols   + icols
-                procinfo%npfts   = procinfo%npfts   + ipfts
-             endif
-
-             if (iam >  clumps(cid)%owner) then
-                procinfo%begg = procinfo%begg + 1
-                procinfo%begl = procinfo%begl + ilunits
-                procinfo%begc = procinfo%begc + icols
-                procinfo%begp = procinfo%begp + ipfts
-             endif
-
-             if (iam >= clumps(cid)%owner) then
-                procinfo%endg = procinfo%endg + 1
-                procinfo%endl = procinfo%endl + ilunits
-                procinfo%endc = procinfo%endc + icols
-                procinfo%endp = procinfo%endp + ipfts
-             endif
-          enddo
-          !--- check that atm cell has at least 1 lnd grid cell
-          if (cnt < 1) then
-             write (6,*) 'decomp_init(): map overlap error at ',an, &
-                adomain%mask(an),cnt
-             call endrun()
-          endif
-       end if
-    enddo
-
-    ! Error check on total number of gridcells
-
-    if (npes > anumg) then
-       write (6,*) 'decomp_init(): Number of processes exceeds number ', &
-            'of atm grid cells'
-       call endrun()
-    end if
-
-    ! Allocate dynamic memory for adecomp, ldecomp derived type
-
-    allocate(adecomp%gdc2gsn(anumg), adecomp%gsn2gdc(anumg), &
-             adecomp%gdc2glo(anumg), adecomp%glo2gdc(ani*anj), &
-             adecomp%gdc2i  (anumg), adecomp%gdc2j  (anumg), &
-             stat=ier)
-    if (ier /= 0) then
-       write (6,*) 'decomp_init(): allocation error1 for adecomp'
-       call endrun()
-    end if
-
-    adecomp%gdc2gsn(:)  = 0
-    adecomp%gsn2gdc(:)  = 0
-    adecomp%gdc2glo(:)  = 0
-    adecomp%glo2gdc(:)  = 0
-    adecomp%gdc2i(:)    = 0
-    adecomp%gdc2j(:)    = 0
-
-    allocate(ldecomp%gdc2gsn(numg), ldecomp%gsn2gdc(numg), &
-             ldecomp%gdc2glo(numg), ldecomp%glo2gdc(lni*lnj), &
-             ldecomp%gdc2i  (numg), ldecomp%gdc2j  (numg), &
-             stat=ier)
-    if (ier /= 0) then
-       write (6,*) 'decomp_init(): allocation error1 for ldecomp'
-       call endrun()
-    end if
-
-    ldecomp%gdc2gsn(:)  = 0
-    ldecomp%gsn2gdc(:)  = 0
-    ldecomp%gdc2glo(:)  = 0
-    ldecomp%glo2gdc(:)  = 0
-    ldecomp%gdc2i(:)    = 0
-    ldecomp%gdc2j(:)    = 0
-
-    !--- temporaries for decomp mappings
-    allocate(aglo2gsn(ani*anj),lglo2gsn(lni*lnj),stat=ier)
-    if (ier /= 0) then
-       write (6,*) 'decomp_init(): allocation error for al-glo2gsn'
-       call endrun()
-    end if
-    aglo2gsn(:) = 0
-    lglo2gsn(:) = 0
-
-    ag = 0
-    do aj = 1,anj
-    do ai = 1,ani
-       an = (aj-1)*ani + ai
-       if (acid(an) > 0) then
-          ag  = ag  + 1
-          aglo2gsn(an) = ag
-       endif
-    enddo
-    enddo
-
-    ! Set ldecomp sn indexing based on cells to be used and i,j order
-    lg  = 0
-    do lj = 1,lnj
-    do li = 1,lni
-       ln = (lj-1)*lni + li
-       if (lcid(ln) > 0) then
-          lg = lg + 1
-          lglo2gsn(ln) = lg
-       endif
-    enddo
-    enddo
-
-    ! Set ldecomp and adecomp data
-    ag = 0
-    lg = 0
-    do pid = 0,npes-1
-    do cid = 1,nclumps
-       if (clumps(cid)%owner == pid) then
-
-          do aj = 1,anj
-          do ai = 1,ani
-             an = (aj-1)*ani + ai
-             if (acid(an) == cid) then
-                ag = ag + 1
-                adecomp%gdc2i(ag) = ai
-                adecomp%gdc2j(ag) = aj
-                adecomp%gdc2gsn(ag) = aglo2gsn(an)
-                adecomp%gdc2glo(ag) = an
-                adecomp%gsn2gdc(aglo2gsn(an)) = ag
-                adecomp%glo2gdc(an) = ag
-             endif
-          enddo
-          enddo
-
-          do lj = 1,lnj
-          do li = 1,lni
-             ln = (lj-1)*lni + li
-             if (lcid(ln) == cid) then
-                lg = lg + 1
-                ldecomp%gdc2i(lg) = li
-                ldecomp%gdc2j(lg) = lj
-                ldecomp%gdc2gsn(lg) = lglo2gsn(ln)
-                ldecomp%gdc2glo(lg) = ln
-                ldecomp%gsn2gdc(lglo2gsn(ln)) = lg
-                ldecomp%glo2gdc(ln) = lg
-             endif
-          enddo
-          enddo
-       endif
-    enddo
-    enddo
-
-    deallocate(aglo2gsn,lglo2gsn)
-    deallocate(acid,lcid)
-    deallocate(lncnt,lnoff,lnmap)
-
-    ! set gsMap_lnd_gdc2glo, perm_lnd_gdc2glo
-    call get_proc_bounds(beg, end)
-    allocate(gindex(beg:end))
-    do n = beg,end
-       gindex(n) = ldecomp%gdc2glo(n)
-    enddo
-    lsize = end-beg+1
-    gsize = lni * lnj
-    allocate(perm_lnd_gdc2glo(lsize),stat=ier)
-    call mct_indexset(perm_lnd_gdc2glo)
-    call mct_indexsort(lsize,perm_lnd_gdc2glo,gindex)
-    call mct_permute(gindex,perm_lnd_gdc2glo,lsize)
-    call mct_gsMap_init(gsMap_lnd_gdc2glo, gindex, mpicom, comp_id, lsize, gsize )
-    deallocate(gindex)
-
-    ! set gsMap_atm_gdc2glo, perm_atm_gdc2glo
-    call get_proc_bounds_atm(beg, end)
-    allocate(gindex(beg:end))
-    do n = beg,end
-       gindex(n) = adecomp%gdc2glo(n)
-    enddo
-    lsize = end-beg+1
-    gsize = ani * anj
-    allocate(perm_atm_gdc2glo(lsize),stat=ier)
-    call mct_indexset(perm_atm_gdc2glo)
-    call mct_indexsort(lsize,perm_atm_gdc2glo,gindex)
-    call mct_permute(gindex,perm_atm_gdc2glo,lsize)
-    call mct_gsMap_init(gsMap_atm_gdc2glo, gindex, mpicom, comp_id, lsize, gsize )
-    deallocate(gindex)
-
-    ! Diagnostic output
-
-    if (masterproc) then
-       write (6,*)' Atm Grid Characteristics'
-       write (6,*)'   longitude points          = ',ani
-       write (6,*)'   latitude points           = ',anj
-       write (6,*)'   total number of gridcells = ',anumg
-       write (6,*)' Surface Grid Characteristics'
-       write (6,*)'   longitude points          = ',lni
-       write (6,*)'   latitude points           = ',lnj
-       write (6,*)'   total number of gridcells = ',numg
-       write (6,*)'   total number of landunits = ',numl
-       write (6,*)'   total number of columns   = ',numc
-       write (6,*)'   total number of pfts      = ',nump
-       write (6,*)' Decomposition Characteristics'
-       write (6,*)'   clumps per process        = ',clump_pproc
-       write (6,*)' gsMap Characteristics'
-       write (6,*) '  lnd gsmap glo num of segs = ',mct_gsMap_ngseg(gsMap_lnd_gdc2glo)
-       write (6,*) '  atm gsmap glo num of segs = ',mct_gsMap_ngseg(gsMap_atm_gdc2glo)
-       write (6,*)
-    end if
-
-    ! Write out clump and proc info, one pe at a time, 
-    ! barrier to control pes overwriting each other on stdout
-
-#ifndef UNICOSMP
-    call shr_sys_flush(6)
-#endif
-    call mpi_barrier(mpicom,ier)
-     npmin = 0
-     npmax = npes-1
-     npint = 1
-     if (dbug == 0) then
-        npmax = 0
-     elseif (dbug == 1) then
-        npmax = min(npes-1,4)
-     elseif (dbug == 2) then
-        npint = npes/8
-     endif
-     do np = npmin,npmax,npint
-       pid = np
-       if (dbug == 1) then
-          if (np == 2) pid=npes/2-1
-          if (np == 3) pid=npes-2
-          if (np == 4) pid=npes-1
-       endif
-       pid = max(pid,0)
-       pid = min(pid,npes-1)
-
-       if (iam == pid) then
-          write(6,*)
-          write(6,*)'proc= ',pid,' beg atmcell = ',procinfo%abegg, &
-               ' end atmcell = ',procinfo%aendg,                   &
-               ' total atmcells per proc = ',procinfo%aendg-procinfo%abegg+1
-          write(6,*)'proc= ',pid,' beg gridcell= ',procinfo%begg, &
-               ' end gridcell= ',procinfo%endg,                   &
-               ' total gridcells per proc= ',procinfo%ncells
-          write(6,*)'proc= ',pid,' beg landunit= ',procinfo%begl, &
-               ' end landunit= ',procinfo%endl,                   &
-               ' total landunits per proc= ',procinfo%nlunits
-          write(6,*)'proc= ',pid,' beg column  = ',procinfo%begc, &
-               ' end column  = ',procinfo%endc,                   &
-               ' total columns per proc  = ',procinfo%ncols
-          write(6,*)'proc= ',pid,' beg pft     = ',procinfo%begp, &
-               ' end pft     = ',procinfo%endp,                   &
-               ' total pfts per proc     = ',procinfo%npfts
-          write(6,*)'proc= ',pid,' lnd ngseg   = ',mct_gsMap_ngseg(gsMap_lnd_gdc2glo), &
-               ' lnd nlseg   = ',mct_gsMap_nlseg(gsMap_lnd_gdc2glo,iam)
-          write(6,*)'proc= ',pid,' atm ngseg   = ',mct_gsMap_ngseg(gsMap_atm_gdc2glo), &
-               ' atm nlseg   = ',mct_gsMap_nlseg(gsMap_atm_gdc2glo,iam)
-          write(6,*)'proc= ',pid,' nclumps = ',procinfo%nclumps
-
-          clmin = 1
-          clmax = procinfo%nclumps
-          if (dbug == 1) then
-            clmax = 1
-          elseif (dbug == 0) then
-            clmax = -1
-          endif
-          do n = clmin,clmax
-             cid = procinfo%cid(n)
-             write(6,*)'proc= ',pid,' clump no = ',n, &
-                  ' clump id= ',procinfo%cid(n),    &
-                  ' beg gridcell= ',clumps(cid)%begg, &
-                  ' end gridcell= ',clumps(cid)%endg, &
-                  ' total gridcells per clump= ',clumps(cid)%ncells
-             write(6,*)'proc= ',pid,' clump no = ',n, &
-                  ' clump id= ',procinfo%cid(n),    &
-                  ' beg landunit= ',clumps(cid)%begl, &
-                  ' end landunit= ',clumps(cid)%endl, &
-                  ' total landunits per clump = ',clumps(cid)%nlunits
-             write(6,*)'proc= ',pid,' clump no = ',n, &
-                  ' clump id= ',procinfo%cid(n),    &
-                  ' beg column  = ',clumps(cid)%begc, &
-                  ' end column  = ',clumps(cid)%endc, &
-                  ' total columns per clump  = ',clumps(cid)%ncols
-             write(6,*)'proc= ',pid,' clump no = ',n, &
-                  ' clump id= ',procinfo%cid(n),    &
-                  ' beg pft     = ',clumps(cid)%begp, &
-                  ' end pft     = ',clumps(cid)%endp, &
-                  ' total pfts per clump     = ',clumps(cid)%npfts
-          end do
-       end if
-#ifndef UNICOSMP
-       call shr_sys_flush(6)
-#endif
-       call mpi_barrier(mpicom,ier)
-    end do
-#ifndef UNICOSMP
-    call shr_sys_flush(6)
-#endif
-
-  end subroutine decomp_init
-#endif
-!------------------------------------------------------------------------------
 !BOP
 !
 ! !IROUTINE: decomp_lnd_init
@@ -818,6 +247,7 @@
              !--- increment the beg and end indices ---
              if (iam == clumps(cid)%owner) then
                 procinfo%ncells  = procinfo%ncells  + 1
+
              endif
 
              if (iam >  clumps(cid)%owner) then
@@ -828,6 +258,7 @@
                 procinfo%endg = procinfo%endg + 1
              endif
           enddo
+
           !--- check that atm cell has at least 1 lnd grid cell
           if (cnt < 1) then
              write (6,*) 'decomp_lnd_init(): map overlap error at ',an,cnt
@@ -983,7 +414,9 @@
     integer, allocatable :: allvecl(:,:)  ! temporary vector "local"
     integer, pointer :: lglo2gsn(:)   ! map from glo 2 gsn temporary
     integer :: lnidx
-
+!abt rcm below
+    integer :: dummy_in               !temporary variable to store ncells
+!abt above
 ! !CALLED FROM:
 ! subroutine initialize
 !
@@ -1231,6 +664,7 @@
 
     call shr_sys_flush(6)
     call mpi_barrier(mpicom,ier)
+
      npmin = 0
      npmax = npes-1
      npint = 1
@@ -1251,6 +685,7 @@
        pid = max(pid,0)
        pid = min(pid,npes-1)
 
+
        if (iam == pid) then
           write(6,*)
           write(6,*)'proc= ',pid,' beg atmcell = ',procinfo%abegg, &
@@ -1274,6 +709,7 @@
                ' atm nlseg   = ',mct_gsMap_nlseg(gsMap_atm_gdc2glo,iam)
           write(6,*)'proc= ',pid,' nclumps = ',procinfo%nclumps
 
+
           clmin = 1
           clmax = procinfo%nclumps
           if (dbug == 1) then
@@ -1308,8 +744,16 @@
 #ifndef UNICOSMP
        call shr_sys_flush(6)
 #endif
+
        call mpi_barrier(mpicom,ier)
     end do
+
+!!!! total # of cells given to each processor !!! abt rcm below
+    dummy_in = procinfo%ncells
+    call MPI_GATHER(dummy_in,1,MPI_INTEGER,c2rngc(iam+1),1,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
+    call MPI_BCAST(c2rngc(1),npes,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
+!!! abt above
+
     call shr_sys_flush(6)
 
   end subroutine decomp_glcp_init
@@ -1330,6 +774,7 @@
 ! !USES:
     use clm_varctl, only : nsegspc
     use domainMod , only : latlon_type
+    use clm_varsur, only : landmask
 !
 ! !ARGUMENTS:
     implicit none
@@ -1547,6 +992,18 @@
     enddo
     enddo
 
+
+! abt rcm below (from regcmoce)
+    do aj = 1,anj
+    do ai = 1,ani
+      c2rprocmap(ai,aj) = -1
+    end do
+    end do
+!rcm above
+
+
+
+
     ! Set ldecomp and adecomp data
     ag = 0
     do pid = 0,npes-1
@@ -1557,6 +1014,11 @@
           do ai = 1,ani
              an = (aj-1)*ani + ai
              if (acid(an) == cid) then
+
+!abt rcm below
+             if (amask(an) == 1) c2rprocmap(ai,aj) = pid
+!rcm above
+
                 ag = ag + 1
                 adecomp%gdc2i(ag) = ai
                 adecomp%gdc2j(ag) = aj
@@ -1608,6 +1070,7 @@
 
     call shr_sys_flush(6)
     call mpi_barrier(mpicom,ier)
+
      npmin = 0
      npmax = npes-1
      npint = 1
@@ -1639,6 +1102,7 @@
        end if
        call shr_sys_flush(6)
        call mpi_barrier(mpicom,ier)
+
     end do
 #ifndef UNICOSMP
     call shr_sys_flush(6)
