--- org/clm_atmlnd.F90	2010-06-02 15:27:38.000000000 -0400
+++ patchd/clm_atmlnd.F90	2010-06-04 05:40:53.000000000 -0400
@@ -22,6 +22,7 @@
 !
 ! !PUBLIC TYPES:
   implicit none
+
 !----------------------------------------------------
 ! atmosphere -> land variables structure
 !----------------------------------------------------
@@ -77,6 +78,20 @@
   real(r8), pointer :: qflx_evap_tot(:)!qflx_evap(_soi + _veg) + qflx_tran_veg
   real(r8), pointer :: fsa(:)          !solar rad absorbed (total) (W/m**2)
   real(r8), pointer :: nee(:)          !net CO2 flux (kg C/m**2/s) [+ to atm]
+!abt rcm below
+  real(r8), pointer :: smtot(:)          !total soil moisture
+  real(r8), pointer :: sm1m(:)           !soil moisture of first 1m
+  real(r8), pointer :: tlef(:)           !leaf temperature [Kelvin]
+  real(r8), pointer :: u10(:)            !10 meter wind
+  real(r8), pointer :: tgrnd(:)          !ground temperature
+  real(r8), pointer :: qflx_infl(:)      !infiltration [mm H2O/s]
+  real(r8), pointer :: qflx_surf(:)      !surface runoff [mm H2O/s]
+  real(r8), pointer :: qflx_drain(:)     !sub-surface runoff [mm H2O/s]
+  real(r8), pointer :: uvdrag(:)         !surface drag stress
+  real(r8), pointer :: sm10cm(:)         !soil moisture of top 10cm
+  real(r8), pointer :: frac_sno(:)       !fraction ground covered by snow
+  real(r8), pointer :: frac_veg_nosno(:) !fraction veg with no snow
+!abt rcm above
 #if (defined DUST || defined  PROGSSLT )
   real(r8), pointer :: ram1(:)         !aerodynamical resistance (s/m)
   real(r8), pointer :: fv(:)           !friction velocity (m/s) (for dust model)
@@ -98,9 +113,14 @@
   public :: clm_mapa2l
   public :: clm_mapl2a
   public :: clm_map2gcell
+!abt rcm below
+  public :: clm2rcm
+!abt rcm above
 !
 ! !REVISION HISTORY:
 ! Created by Mariana Vertenstein and Tony Craig, 2006-01-10
+! 2008.5.8    A Tawfik Revised to work with RegCM
+!
 !
 ! !PRIVATE MEMBER FUNCTIONS:
 
@@ -240,6 +260,22 @@
   allocate(l2a%qflx_evap_tot(beg:end))
   allocate(l2a%fsa(beg:end))
   allocate(l2a%nee(beg:end))
+!abt rcm below
+  allocate(l2a%smtot(beg:end))
+  allocate(l2a%sm1m(beg:end))
+  allocate(l2a%u10(beg:end))
+  allocate(l2a%tlef(beg:end))
+  allocate(l2a%sm10cm(beg:end))
+  allocate(l2a%uvdrag(beg:end))
+  allocate(l2a%qflx_infl(beg:end))
+  allocate(l2a%qflx_surf(beg:end))
+  allocate(l2a%qflx_drain(beg:end))
+  allocate(l2a%tgrnd(beg:end))
+  allocate(l2a%frac_sno(beg:end))
+  allocate(l2a%frac_veg_nosno(beg:end))
+!abt rcm above
+
+
 #if (defined DUST || defined  PROGSSLT )
   allocate(l2a%ram1(beg:end))
   allocate(l2a%fv(beg:end))
@@ -265,6 +301,20 @@
   l2a%qflx_evap_tot(beg:end) = ival
   l2a%fsa(beg:end) = ival
   l2a%nee(beg:end) = ival
+!abt rcm below
+  l2a%smtot(beg:end)      = ival
+  l2a%sm1m(beg:end)       = ival
+  l2a%u10(beg:end)        = ival
+  l2a%tlef(beg:end)       = ival
+  l2a%sm10cm(beg:end)     = ival
+  l2a%uvdrag(beg:end)     = ival
+  l2a%qflx_infl(beg:end)  = ival
+  l2a%qflx_surf(beg:end)  = ival
+  l2a%qflx_drain(beg:end) = ival
+  l2a%tgrnd(beg:end)      = ival
+  l2a%frac_sno(beg:end)   = ival
+  l2a%frac_veg_nosno(beg:end)      = ival
+!abt rcm above
 #if (defined DUST || defined  PROGSSLT )
   l2a%ram1(beg:end) = ival
   l2a%fv(beg:end) = ival
@@ -274,6 +324,283 @@
 #endif
 end subroutine init_lnd2atm_type
 
+! abt below rcm subrountine  
+!------------------------------------------------------------------------------
+!BOP
+!
+! !IROUTINE: clm_mapr2l
+!
+! !INTERFACE:
+  subroutine clm_mapr2l(a2l_src, a2l_dst)
+!
+! !DESCRIPTION:
+! Maps atm2lnd fields from external grid to clm grid
+!
+! !USES:
+  use decompMod, only : get_proc_bounds, get_proc_bounds_atm
+  use areaMod  , only : map_maparrayl, map1dl_a2l, map1dl_l2a, map_setptrs
+  use decompMod, only : ldecomp,adecomp
+  use domainMod, only : ldomain,adomain
+  use QSatMod,   only : QSat
+!
+! !ARGUMENTS:
+  implicit none
+  type(atm2lnd_type), intent(in)  :: a2l_src
+  type(atm2lnd_type), intent(out) :: a2l_dst
+!
+! !REVISION HISTORY:
+! 2005.11.15  T Craig  Creation.
+! 2006.3.30   P Worley Restructuring for improved vector performance
+!
+!EOP
+!
+! !LOCAL VARIABLES:
+  integer :: n                     ! loop counter
+  integer :: ix                    ! field index
+  integer :: nflds                 ! number of fields to be mapped
+  integer :: nradflds              ! size of 2nd dim in arrays
+  integer :: begg_s,endg_s         ! beg,end of input grid
+  integer :: begg_d,endg_d         ! beg,end of output grid
+  real(r8),pointer :: asrc(:,:)    ! temporary source data
+  real(r8),pointer :: adst(:,:)    ! temporary dest data
+  integer          :: nmap         ! size of map
+  integer          :: mo           ! size of map
+  integer, pointer :: src(:)       ! map src index
+  integer, pointer :: dst(:)       ! map dst index
+  real(r8),pointer :: wts(:)       ! map wts values
+  integer :: ns                    !source (atm) indexes
+  integer :: nd                    !destination (lnd) indexes
+  ! temporaries for topo downscaling:
+  real(r8):: hsurf_a,hsurf_l,Hbot,Hsrf,lapse
+  real(r8):: zbot_a, tbot_a, pbot_a, thbot_a, qbot_a, qs_a, es_a
+  real(r8):: zbot_l, tbot_l, pbot_l, thbot_l, qbot_l, qs_l, es_l
+  real(r8):: tsrf_l, psrf_l, egcm_l, rhos_l
+  real(r8):: dum1,dum2,sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8
+  real(r8),allocatable :: qsum(:)
+  logical :: first_call = .true.
+!------------------------------------------------------------------------------
+
+  if (first_call .and. masterproc) then
+    write(6,*) 'clm_mapa2l subroutine'
+  endif
+
+  nradflds = size(a2l_src%forc_solad,dim=2)
+  if (nradflds /= numrad) then
+    write(6,*) 'clm_mapa2l ERROR: nradflds ne numrad ',nradflds,numrad
+    call endrun()
+  endif
+
+  !--- allocate temporaries
+  call get_proc_bounds_atm(begg_s, endg_s)
+  call get_proc_bounds    (begg_d, endg_d)
+
+!  nflds = 21+2*numrad
+
+!  allocate(asrc(begg_s:endg_s,nflds))
+!  allocate(adst(begg_d:endg_d,nflds))
+
+!  ix = 0
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_t(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_u(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_v(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_wind(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_q(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_hgt(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_hgt_u(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_hgt_t(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_hgt_q(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_pbot(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_th(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_vp(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_rho(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_psrf(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_pco2(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_lwrad(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_solar(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_rain(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_snow(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_pc13o2(:)  
+!  ix=ix+1; asrc(:,ix) = a2l_src%forc_po2(:)  
+!  do n = 1,numrad
+!     ix=ix+1; asrc(:,ix) = a2l_src%forc_solad(:,n)  
+!     ix=ix+1; asrc(:,ix) = a2l_src%forc_solai(:,n)  
+!  enddo
+!-forc_ndep is not recd from atm,don't know why it's in a2l (TCFIX) ---
+!-forc_ndep cannot be updated here, array will be trashed and CN will fail ---
+!  asrc(:,xx) = a2l_src%forc_ndep(:)  
+
+#if (defined OFFLINE)
+  call map_maparrayl(begg_s, endg_s, begg_d, endg_d, 1, a2l_src%flfall, a2l_dst%flfall, map1dl_a2l)
+#endif
+!  call map_maparrayl(begg_s, endg_s, begg_d, endg_d, nflds, asrc, adst, map1dl_a2l)
+
+  a2l_dst%forc_t(:)     =     a2l_src%forc_t(:)
+  a2l_dst%forc_u(:)     =     a2l_src%forc_u(:)
+  a2l_dst%forc_v(:)     =     a2l_src%forc_v(:)
+  a2l_dst%forc_wind(:)  =     a2l_src%forc_wind(:)
+  a2l_dst%forc_q(:)     =     a2l_src%forc_q(:)
+  a2l_dst%forc_hgt(:)   =     a2l_src%forc_hgt(:)
+  a2l_dst%forc_hgt_u(:) =     a2l_src%forc_hgt_u(:)
+  a2l_dst%forc_hgt_t(:) =     a2l_src%forc_hgt_t(:)
+  a2l_dst%forc_hgt_q(:) =     a2l_src%forc_hgt_q(:)
+  a2l_dst%forc_pbot(:)  =   a2l_src%forc_pbot(:)
+  a2l_dst%forc_th(:)    =   a2l_src%forc_th(:)
+  a2l_dst%forc_vp(:)    =   a2l_src%forc_vp(:)
+  a2l_dst%forc_rho(:)   =   a2l_src%forc_rho(:)
+  a2l_dst%forc_psrf(:)  =   a2l_src%forc_psrf(:)
+  a2l_dst%forc_pco2(:)  =   a2l_src%forc_pco2(:)
+  a2l_dst%forc_lwrad(:) =   a2l_src%forc_lwrad(:)
+  a2l_dst%forc_solar(:) =   a2l_src%forc_solar(:)
+  a2l_dst%forc_rain(:)  =   a2l_src%forc_rain(:)
+  a2l_dst%forc_snow(:)  =   a2l_src%forc_snow(:)
+  a2l_dst%forc_pc13o2(:)=   a2l_src%forc_pc13o2(:)
+  a2l_dst%forc_po2(:)   =   a2l_src%forc_po2(:)
+  do n = 1,numrad
+     a2l_dst%forc_solad(:,n)  = a2l_src%forc_solad(:,n)
+     a2l_dst%forc_solai(:,n)  = a2l_src%forc_solai(:,n)
+  enddo
+
+!  deallocate(asrc)
+!  deallocate(adst)
+
+  if (first_call.and.masterproc) then
+    write(6,*) 'clm_mapr2l mapping complete'
+  endif
+
+!-topographic downscaling
+!-only call this if there is more than 1 land cell / atm cell somewhere
+  call map_setptrs(map1dl_l2a,dstmo=mo)
+  if (mo > 1) then
+
+  if (first_call.and.masterproc) then
+    write(6,*) 'clm_mapr2l downscaling ON'
+  endif
+
+  call map_setptrs(map1dl_a2l,nwts=nmap,src=src,dst=dst,dstmo=mo)
+  if (mo /= 1) then
+     write(6,*)' clm_mapr2l ERROR: map1dl_a2l mo not 1 ',mo
+     call endrun()
+  endif
+
+  lapse   = 0.0065_r8                  ! hardwired in multiple places in cam
+
+  do n = 1,nmap
+    ns = src(n)
+    nd = dst(n)
+
+    hsurf_a = adomain%topo(ns)        ! atm elevation
+    hsurf_l = ldomain%ntop(nd)        ! lnd elevation
+
+    if (abs(hsurf_a - hsurf_l) .gt. 0.1_r8) then
+
+       tbot_a = a2l_src%forc_t(ns)        ! atm temp at bot
+       thbot_a= a2l_src%forc_th(ns)       ! atm pot temp at bot
+       pbot_a = a2l_src%forc_pbot(ns)     ! atm press at bot
+       qbot_a = a2l_src%forc_q(ns)        ! atm sp humidity at bot
+       zbot_a = a2l_src%forc_hgt(ns)      ! atm ref height
+
+       zbot_l = zbot_a
+       tbot_l = tbot_a-lapse*(hsurf_l-hsurf_a)          ! lnd temp for topo
+
+       Hbot   = rair*0.5_r8*(tbot_a+tbot_l)/grav        ! scale ht at avg temp
+       pbot_l = pbot_a*exp(-(hsurf_l-hsurf_a)/Hbot)     ! lnd press for topo
+       thbot_l= tbot_l*exp((zbot_l/Hbot)*(rair/cpair))  ! pot temp calc
+
+       tsrf_l = tbot_l-lapse*(-zbot_l)                  ! lnd temp at surface
+       Hsrf   = rair*0.5_r8*(tbot_l+tsrf_l)/grav        ! scale ht at avg temp
+       psrf_l = pbot_l*exp(-(zbot_l)/Hsrf)              ! lnd press for topo
+
+       call Qsat(tbot_a,pbot_a,es_a,dum1,qs_a,dum2)
+       call Qsat(tbot_l,pbot_l,es_l,dum1,qs_l,dum2)
+       qbot_l = qbot_a*(qs_l/qs_a)
+
+       a2l_dst%forc_hgt(nd)  = zbot_l
+       a2l_dst%forc_t(nd)    = tbot_l
+       a2l_dst%forc_pbot(nd) = pbot_l
+       a2l_dst%forc_th(nd)   = thbot_l
+       a2l_dst%forc_q(nd)    = qbot_l
+       a2l_dst%forc_vp(nd)   = es_l
+       a2l_dst%forc_psrf(nd) = psrf_l
+
+    endif
+  enddo
+
+  allocate(qsum(begg_s:endg_s))
+  qsum = 0.0_r8
+  call map_setptrs(map1dl_l2a,nwts=nmap,src=src,dst=dst,wts=wts)
+  do n = 1,nmap
+    ns = dst(n)
+    nd = src(n)
+    qsum(ns) = qsum(ns) + wts(n)* a2l_dst%forc_q(nd)
+  enddo
+
+!abt below call map_setptrs(map1dl_a2l,nwts=nmap,src=src,dst=dst)
+!  do n = 1,nmap
+!    ns = src(n)
+!    nd = dst(n)
+
+!    qbot_a = a2l_src%forc_q(ns)        ! atm specific humidity
+!    qbot_l = a2l_dst%forc_q(nd)        ! lnd specific humidity
+!    pbot_l = a2l_dst%forc_pbot(nd)  
+!    tbot_l = a2l_dst%forc_t(nd)  
+
+!    qbot_l = qbot_l - (qsum(ns) - qbot_a)        ! normalize
+!    egcm_l = qbot_l*pbot_l/(0.622+0.378*qbot_l)
+!    rhos_l = (pbot_l-0.378*egcm_l) / (rair*tbot_l)
+
+!    a2l_dst%forc_q(nd)    = qbot_l
+!    a2l_dst%forc_rho(nd)  = rhos_l
+
+!abt above  enddo
+
+  deallocate(qsum)
+
+! --- check ---
+  call map_setptrs(map1dl_l2a,nwts=nmap,src=src,dst=dst,wts=wts)
+  do ns = begg_s,endg_s
+    sum1 = 0.0_r8
+    sum2 = 0.0_r8
+    sum3 = 0.0_r8
+    sum4 = 0.0_r8
+    sum5 = 0.0_r8
+    sum6 = 0.0_r8
+    do n = 1,nmap
+      if (dst(n) == ns) then
+        nd = src(n)
+        sum1 = sum1 + ldomain%ntop(nd)   * wts(n)
+        sum2 = sum2 + a2l_dst%forc_t(nd)    * wts(n)
+        sum3 = sum3 + a2l_dst%forc_q(nd)    * wts(n)
+        sum4 = sum4 + a2l_dst%forc_hgt(nd)  * wts(n)
+        sum5 = sum5 + a2l_dst%forc_pbot(nd) * wts(n)
+        sum6 = sum6 + a2l_dst%forc_th(nd)   * wts(n)
+      endif
+    enddo
+    if   ((abs(sum1 - adomain%topo(ns))   > 1.0e-8) &
+      .or.(abs(sum2 - a2l_src%forc_t(ns))    > 1.0e-3) &
+      .or.(abs(sum3 - a2l_src%forc_q(ns))    > 1.0e-8) &
+      .or.(abs(sum4 - a2l_src%forc_hgt(ns))  > 1.0e-6) &
+!      .or.(abs(sum5 - a2l_src%forc_pbot(ns)) > 1.0e-6) &
+!      .or.(abs(sum6 - a2l_src%forc_th(ns))   > 1.0e-6) &
+       ) then
+      write(6,*) 'clm_map2l check ERROR topo ',sum1,adomain%topo(ns)
+      write(6,*) 'clm_map2l check ERROR t    ',sum2,a2l_src%forc_t(ns)
+      write(6,*) 'clm_map2l check ERROR q    ',sum3,a2l_src%forc_q(ns)
+      write(6,*) 'clm_map2l check ERROR hgt  ',sum4,a2l_src%forc_hgt(ns)
+      write(6,*) 'clm_map2l check ERROR pbot ',sum5,a2l_src%forc_pbot(ns)
+      write(6,*) 'clm_map2l check ERROR th   ',sum6,a2l_src%forc_th(ns)
+!      call endrun()
+    endif
+  enddo
+
+  endif   ! mx_ovr > 1
+
+  first_call = .false.
+
+end subroutine clm_mapr2l
+
+
+
+
 !------------------------------------------------------------------------------
 !BOP
 !
@@ -694,6 +1021,10 @@
   use decompMod   , only : get_proc_bounds
   use clm_varcon  , only : sb
   use clm_varpar  , only : numrad
+!abt added below
+  use clm_varcon  , only : denh2o
+  use clm_varpar  , only : nlevsoi
+!abt added above
 !
 ! !ARGUMENTS:
   implicit none
@@ -702,6 +1033,7 @@
 !
 ! !REVISION HISTORY:
 ! Mariana Vertenstein: created 03/10-25
+! 2008.5.8    A Tawfik Revised to work with RegCM
 !
 !EOP
 !
@@ -720,11 +1052,22 @@
 !EOP
 !
 ! !LOCAL VARIABLES:
-  integer :: g                          ! indices
+  integer :: g,lev,c                    ! indices
   type(gridcell_type), pointer :: gptr  ! pointer to gridcell derived subtype
   type(landunit_type), pointer :: lptr  ! pointer to landunit derived subtype
   type(column_type)  , pointer :: cptr  ! pointer to column derived subtype
   type(pft_type)     , pointer :: pptr  ! pointer to pft derived subtype
+!abt rcm below
+  real(r8), pointer :: wtgcell(:)        ! weight of columns relative to gridcells
+  integer , pointer :: cgrid(:)          ! gridcell of corresponding column
+  real(r8), pointer :: rootfr(:,:)       ! fraction of roots in each soil layer
+  integer , pointer :: pcolumn(:)        ! column index of corresponding pft
+  real(r8),allocatable :: temp_sm10cm(:) ! temporary array for 10cm soil moisture
+  real(r8),allocatable :: temp_sm1m(:)   ! temporary array for 1m soil moisture
+  real(r8),allocatable :: temp_smtot(:)  ! temporary array for total soil moisture
+  real(r8),allocatable :: temp_root(:,:) ! temporary array for root fraction (nlevsoi)
+  integer :: p
+!abt rcm above
 #if (defined DUST)
   type(pft_dflux_type),pointer :: pdf   ! local pointer to derived subtype
   integer n
@@ -738,11 +1081,18 @@
   lptr => clm3%g%l
   cptr => clm3%g%l%c
   pptr => clm3%g%l%c%p
+!abt rcm below
+  wtgcell   => clm3%g%l%c%wtgcell
+  cgrid     => clm3%g%l%c%gridcell
+  rootfr    => clm3%g%l%c%p%pps%rootfr
+  pcolumn   => clm3%g%l%c%p%column
+!abt rcm above
 
   ! Determine processor bounds
 
   call get_proc_bounds(begg, endg, begl, endl, begc, endc, begp, endp)
 
+
   ! Compute gridcell averages. 
 
   if (present(init)) then
@@ -752,9 +1102,6 @@
           c2l_scale_type= 'unity', l2g_scale_type='unity')
 !dir$ concurrent
 !cdir nodep
-     do g = begg,endg
-        clm_l2a%h2osno(g) = clm_l2a%h2osno(g)/1000._r8
-     end do
       
      call p2g(begp, endp, begc, endc, begl, endl, begg, endg, numrad, &
           pptr%pps%albd, clm_l2a%albd,&
@@ -779,9 +1126,6 @@
           c2l_scale_type= 'unity', l2g_scale_type='unity')
 !dir$ concurrent
 !cdir nodep
-     do g = begg,endg
-        clm_l2a%h2osno(g) = clm_l2a%h2osno(g)/1000._r8
-     end do
 
      call p2g(begp, endp, begc, endc, begl, endl, begg, endg, numrad, &
           pptr%pps%albd, clm_l2a%albd, &
@@ -874,10 +1218,285 @@
         clm_l2a%t_rad(g) = sqrt(sqrt(clm_l2a%eflx_lwrad_out(g)/sb))
      end do
 
-  end if
+!!!!!! abt rcm below for grid-average for additional variables to be passed to atmo!!!!
+
+     allocate(temp_sm10cm(begg:endg))
+     allocate(temp_smtot(begg:endg))
+     allocate(temp_sm1m(begg:endg))
+     allocate(temp_root(begg:endg,1:nlevsoi))
+     temp_sm1m(:)   = 0._r8
+     temp_sm10cm(:) = 0._r8
+     temp_smtot(:)  = 0._r8
+     temp_root(:,:) = 0._r8
+
+     call p2g(begp, endp, begc, endc, begl, endl, begg, endg, &
+           nlevsoi,rootfr, temp_root, &
+           p2c_scale_type='unity', c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     do c = begc,endc
+        g = cgrid(c)
+!! averaging for smtot and sm1m are done without the p2g or c2g subrountines
+       do lev = 1,nlevsoi
+        if(cptr%cws%h2osoi_liq(c,lev) /= spval) then
+          if(lev.le.3) temp_sm10cm(g) = temp_sm10cm(g) + cptr%cws%h2osoi_liq(c,lev) &
+                                        * (1000./denh2o) * wtgcell(c) 
+          temp_smtot(g)  = temp_smtot(g) + cptr%cws%h2osoi_liq(c,lev) * &
+                           (1000./denh2o) * wtgcell(c) 
+          if(temp_root(g,lev) > 0._r8) temp_sm1m(g)   = temp_sm1m(g) +  &
+                            cptr%cws%h2osoi_liq(c,lev) * (1000./denh2o) *wtgcell(c)
+        endif       
+       enddo
+     enddo
+
+     clm_l2a%smtot(:)  = temp_smtot(:)
+     clm_l2a%sm10cm(:) = temp_sm10cm(:)
+     clm_l2a%sm1m(:)   = temp_sm1m(:)
+
+     call p2g(begp, endp, begc, endc, begl, endl, begg, endg, &
+          pptr%pps%u10, clm_l2a%u10, &
+          p2c_scale_type='unity', c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     call p2g(begp, endp, begc, endc, begl, endl, begg, endg, &
+          pptr%pes%t_veg, clm_l2a%tlef, & 
+          p2c_scale_type='unity', c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     call c2g(begc, endc, begl, endl, begg, endg, cptr%ces%t_grnd, &
+          clm_l2a%tgrnd,c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     call c2g(begc, endc, begl, endl, begg, endg, cptr%cps%frac_sno, &
+          clm_l2a%frac_sno,c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     call p2g(begp, endp, begc, endc, begl, endl, begg, endg, &
+          dble(pptr%pps%frac_veg_nosno), clm_l2a%frac_veg_nosno, &
+          p2c_scale_type='unity', c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     call p2g(begp, endp, begc, endc, begl, endl, begg, endg, &
+          pptr%pef%uvdrag, clm_l2a%uvdrag, &
+          p2c_scale_type='unity', c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     call c2g(begc, endc, begl, endl, begg, endg, cptr%cwf%qflx_infl, &
+          clm_l2a%qflx_infl,c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     call c2g(begc, endc, begl, endl, begg, endg, cptr%cwf%qflx_surf, &
+          clm_l2a%qflx_surf,c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     call c2g(begc, endc, begl, endl, begg, endg, cptr%cwf%qflx_drain, &
+          clm_l2a%qflx_drain,c2l_scale_type= 'unity', l2g_scale_type='unity')
+
+     deallocate(temp_sm10cm)
+     deallocate(temp_sm1m)
+     deallocate(temp_smtot)
+     deallocate(temp_root)
+     call clm2rcm(clm_l2a)
+
+!!!! abt above up for grid averaging !!!!!!!!!!!!!!!
+
+  end if  !if statement for initialize or not
 
 end subroutine clm_map2gcell
 
+
+! abt rcm below
+
+!------------------------------------------------------------------------------
+!BOP
+!
+! !IROUTINE: clm2rcm
+!
+! !INTERFACE:
+  subroutine clm2rcm(clm_l2a)
+!
+! !DESCRIPTION:
+! Maps lnd2atm fields from clm grid to external grid
+!
+! !USES:
+!abt rcm below
+  use spmdMod 
+  use decompMod        , only : ldecomp, get_proc_clumps, get_clump_bounds
+  use decompMod        , only : get_proc_global
+  use areaMod          , only : map_maparrayl, map1dl_l2a
+  use domainMod        , only : adomain,ldomain
+  use clm_varsur
+  use clm_varpar       , only : lsmlon,lsmlat
+  use mod_clm
+  use mod_dynparam
+!
+! !ARGUMENTS:
+  implicit none
+!rcm above
+  type(lnd2atm_type), intent(in)  :: clm_l2a
+!  type(lnd2atm_type), intent(out) :: l2a_dst
+!
+! !REVISION HISTORY:
+! 2009.1.8    A Tawfik Revised to work with RegCM
+!
+!EOP
+!
+! !LOCAL VARIABLES:
+  integer :: n,ni,nj,nt,nn         ! loop counter
+  integer :: nlon,nlat,ntot,ierr   ! abt grid values
+  integer :: nclumps               ! field index
+  integer :: nflds,nc              ! number of fields to be mapped
+  integer :: nradflds              ! size of 2nd dim in arrays
+  integer :: begg_s,endg_s         ! beg,end of input grid
+  integer :: begg_d,endg_d         ! beg,end of output grid
+  integer :: begg,endg,begc,endc   ! beg and end of grid and column
+  integer :: begl,endl,begp,endp
+  real(r8),allocatable :: c2r_all(:)    ! used to capture all c2r vars 
+  integer ,allocatable :: displace(:)   ! used for gathering
+  integer :: numg,numl,numc,nump        ! proc totals
+  integer :: nout                       ! number of vars going to regcm
+!------------------------------------------------------------------------------
+
+    ! Determine clump bounds for this processor
+
+    nclumps = get_proc_clumps()
+    if(nclumps.gt.1) then
+      write(6,*) "ERROR: not formatted for more than 1 clump per processor"
+      call endrun()
+    endif
+
+    ! Loop over clumps on this processor
+
+    do nc = 1,nclumps
+
+     call get_clump_bounds(nc, begg, endg, begl, endl, begc, endc, begp, endp)
+     call get_proc_global(numg,numl,numc,nump) 
+
+#ifdef MPP1
+     nt = endg-begg+1
+     if(AERTYP.ne.'AER00D0') then  !Aerosol scheme on
+       nout = 22
+       allocate(c2r_all(nt*nout))
+       allocate(c2r_allout(numg*nout))
+     else
+       nout = 20
+       allocate(c2r_all(nt*nout))
+       allocate(c2r_allout(numg*nout))
+     end if
+     allocate(displace(npes))
+
+!!!!!! below is transfering variables from CLM to RegCM !!!
+!!!!!!!!!!!!!!!!!!! by c2r* variables !!!!!!!!!!!!!!!!!!!!!
+!!!!!! rest of the transfer from clm to regcm is in !!!!!!!
+!!!!!! interf_clm(para/ser).F for inout = 2 !!!!!!!!!!!!!!!
+!!!!!! below merely stores all output into one array for !!
+!!!!!! quicker gathering                                 !!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+     nn = 0   
+     do n  = begg,endg   
+ 
+        nn = nn + 1
+        c2r_all(nn)       = clm_l2a%tgrnd(n)
+        c2r_all(nn+nt)    = clm_l2a%h2osno(n)
+        c2r_all(nn+nt*2)  = clm_l2a%eflx_sh_tot(n)
+        c2r_all(nn+3*nt)  = clm_l2a%qflx_evap_tot(n)
+        c2r_all(nn+4*nt)  = clm_l2a%uvdrag(n)
+        c2r_all(nn+5*nt)  = clm_l2a%albd(n,1)
+        c2r_all(nn+6*nt)  = clm_l2a%albd(n,2)
+        c2r_all(nn+7*nt)  = clm_l2a%albi(n,1)
+        c2r_all(nn+8*nt)  = clm_l2a%albi(n,2)
+        c2r_all(nn+9*nt)  = clm_l2a%t_rad(n)
+        c2r_all(nn+10*nt) = clm_l2a%t_ref2m(n)
+        c2r_all(nn+11*nt) = clm_l2a%q_ref2m(n)
+        c2r_all(nn+12*nt) = clm_l2a%u10(n)
+        c2r_all(nn+13*nt) = clm_l2a%tlef(n)
+        c2r_all(nn+14*nt) = clm_l2a%sm10cm(n)
+        c2r_all(nn+15*nt) = clm_l2a%sm1m(n)
+        c2r_all(nn+16*nt) = clm_l2a%smtot(n)
+        c2r_all(nn+17*nt) = clm_l2a%qflx_infl(n)*(24._r8 * 3600._r8)
+        c2r_all(nn+18*nt) = clm_l2a%qflx_surf(n)*(24._r8 * 3600._r8)
+        c2r_all(nn+19*nt) = clm_l2a%qflx_drain(n)*(24._r8 * 3600._r8)
+        if(AERTYP.ne.'AER00D0') then  !Aerosol scheme on
+          c2r_all(nn+20*nt) = clm_l2a%frac_sno(n)
+          c2r_all(nn+21*nt) = clm_l2a%frac_veg_nosno(n)
+        end if
+        
+    enddo !gridcell
+    enddo !nclumps
+
+    do nc = 1,npes
+      if(nc.eq.1) then
+        displace(nc) = 0
+      else
+        displace(nc) = displace(nc-1) + c2rngc(nc-1)*nout
+      endif
+    enddo  
+
+    if(nn .ne. nt) then
+      write(6,*) "ERROR: nn not equal to nt"
+      call endrun()
+    endif
+
+    call mpi_allgatherv(c2r_all(1),nn*nout,MPI_REAL8,c2r_allout, &
+                        c2rngc*nout,displace,MPI_REAL8,mpicom,ierr)     
+    
+    deallocate(c2r_all,displace)        
+!!!!!!!new code above
+
+#else
+!!!!!!below is for serial runs
+        do nt = begg,endg
+           ni = ldecomp%gdc2i(nt)
+           nj = ldecomp%gdc2j(nt)
+
+!!!! ground temp
+          c2rtgb(ni,nj)    = clm_l2a%tgrnd(nt)          
+
+!!!! snow depth in liquid water equiv [mm]
+          c2rsnowc(ni,nj)  = clm_l2a%h2osno(nt)
+
+!!!! sensible heat (FSH) [watt/m^2]
+          c2rsenht(ni,nj)  = clm_l2a%eflx_sh_tot(nt)
+
+!!!! evaporation rate [mm/day]
+          c2rlatht(ni,nj)  = clm_l2a%qflx_evap_tot(nt)
+
+!!!! Surface drag stress
+          c2ruvdrag(ni,nj) = clm_l2a%uvdrag(nt)
+
+!!!! land sea mask [0 = ocean, 1 = land, no sea-ice]
+          c2rlsmask(ni,nj) = landmask(ni,nj)
+
+!!!! surface albedos
+          c2ralbdirs(ni,nj) = clm_l2a%albd(nt,1)
+          c2ralbdirl(ni,nj) = clm_l2a%albd(nt,2)
+          c2ralbdifs(ni,nj) = clm_l2a%albi(nt,1)
+          c2ralbdifl(ni,nj) = clm_l2a%albi(nt,2)
+
+!!!! tgbb use radiative temperature or outgoing LW ???
+          c2rtgbb(ni,nj)    = clm_l2a%t_rad(nt)
+
+          c2r2mt(ni,nj)    = clm_l2a%t_ref2m(nt)
+          c2r2mq(ni,nj)    = clm_l2a%q_ref2m(nt)
+          c2ru10(ni,nj)    = clm_l2a%u10(nt)
+          c2rtlef(ni,nj)   = clm_l2a%tlef(nt)
+          c2rsm10cm(ni,nj) = clm_l2a%sm10cm(nt)
+          c2rsm1m(ni,nj)   = clm_l2a%sm1m(nt)
+          c2rsmtot(ni,nj)  = clm_l2a%smtot(nt)
+          c2rinfl(ni,nj)   = clm_l2a%qflx_infl(nt)*(24._r8 * 3600._r8)
+          c2rro_sur(ni,nj) = clm_l2a%qflx_surf(nt)*(24._r8 * 3600._r8)
+          c2rro_sub(ni,nj) = clm_l2a%qflx_drain(nt)*(24._r8 * 3600._r8)
+
+          if(AERTYP.ne.'AER00D0') then  !Aerosol scheme on
+             !!!! fraction of ground covered by snow
+             c2rfracsno(ni,nj) = clm_l2a%frac_sno(nt)
+             !!!! fraction of vegetation not covered by snow
+             c2rfvegnosno(ni,nj) = clm_l2a%frac_veg_nosno(nt)
+          end if
+
+        enddo !begg/endg loop
+
+    enddo !nclump loop
+#endif
+
+end subroutine clm2rcm
+
+
+!!!!!! abt rcm above
+
+
+
 !------------------------------------------------------------------------
 !------------------------------------------------------------------------
 end module clm_atmlnd
