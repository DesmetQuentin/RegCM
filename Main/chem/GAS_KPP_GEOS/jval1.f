c jval1.f           (altitude in kPA)
c
c SUCCESSFUL VERSION, 11-22-02 w/MODIFICATIONS.  Use with jvalmain1.f.
c  (use jval2.f, altitude in KM, to test -w/ tuvtest2.f)
c 
c  PROGRAM FOR PROCESSING TUV TABLE (TUVGRID)
c  Uses table generated by tuvtab2.f
c   with subroutines for use in testing program and photochemistry.
c  
c   MODIFICATIONS:   
c WITH SUNSET ZENITH:  change 442 to 510 (FEB 2003)
c WITH ADD FOR TEMPERATURE ADJUSTMENT (jtem=13)
c   DATE, adjustment for AEROSOL SSA, 2CLOUD ABOVE-BELOW. TEMPERATURE.
c   ALSO, ALLOWS NONZERO AEROSOL AS BASE.
c   Aerosol SSA adjustment is relative to aerosol=0, 1st aerosol-not nec. base.
c   Modified ALBEDO, buffered by surface-cloud-below fraction, included.
c    OPTION -  CLOUD ABOVE+BELOW CORRECTION FACTOR - 0.4 INCLUDED (0,0.2,0.4)
c       
c SUCCESSFUL VERSION, 9-26-02, used in TUVtest2.
c  (minor future fix:  cloud-above at alt=8, make  equal to alt=7
c    to allow for high  cloud).
c
c OPTION - altitude as kPa (2) or as km (21) (in readhv-ALTITUDE OPTION)
c OPTION - number of j-values to be read:  4 (test) 26 (trop) 56 (full)
c    (see jct in both subroutines)
c TEST WRITES - see iwri
c
c NOTE:  CHANGES FOR TEST GRID (TUVGRID1) vs FULL GRID (TUVTEST2):
c  TUVGRID1 (original test) HAS JUST 4 SPECIES (jc=1,4)
c  AND ALSO SKIP CLOUD-ABOVE AFTER 7 TROPOSPHERIC LAYERS. (i.le.7)
c TUVGRID2 (full) HAS 26 SPECIES (jc=1,26)
c   AND SKIPS CLOUD-ABOVE AFTER 8 TROPOSPHERIC LAYERS (i.le.8)
c   THESE MUST BE CHANGED IN jtab1.f - see CHANGE GRID OPTION
c -----------------------------------------------------------------

      subroutine readhv(lsin,nhv,hvmat, hvmatb, jarray)

c Output matrix:  jarray(k,ig,jc) for
c   k=cases:  k=1 base case, k>1 adjustment factors
c             for cases identified in hvmatrix.
c   ig=matrix of altitudes and zenith angles
c   jc=species j-values

c Includes AUTOMATIC FILL-IN OF LAST ZENITH VALUE (nighttime)
c  AND BASE CASE IN ADJUSTMENT FACTORS.
c    (read from input table.  Base j-values are 
c      0 (nighttime) for base case j-values;  
c      1 for most adjustment factors, but
c      0 for cloud adjustment factors 11 and 12 
c        (which are relative to original cloud factor)

c INPUTS (none)
c  OUTPUTS
      integer nhv(22), lsin
      real*8 hvmat(22,40), hvmatb(22)
      real*8 jarray(80,510,56)
c      (note: current scale jarray (k,ig,jc):  k=1,56)

c  INTERNAL 
      integer i, j, k, m, n, jct, iwri
      integer  jaer, jcld,jalb, jtem
      real*8 x,y, hvmatz(22)
      character*4 aaa
c --------------------------------------------------
c TEST WRITE:  WRITE IF iwri=1
      iwri=0

c OPTION:  TOTAL NUMBER OF J-VALUES TO BE READ. (jct=4 test 26 trop 56 full)
c  CHANGE GRID:  TUVGRID1 (jct=4) vs TUVGRID2 (jct=26)
C    see also CHANGE GRID below.
c     jct=4
      jct=26

c INDEX OPTION:  jaer (=6), jcld (originally =9) jalb (=8)
      jaer=6
      jcld=9
      jalb=8
      jtem=13
c
c ZERO INPUT MATRIX
      do i=1,22
       nhv(i)=0
       hvmatb(i)=0.
       do j=1,40
        hvmat(i,j)=0.
       enddo
      enddo

c READ INPUT CONTROLS  (note read index, k, as well)
      do i=1,22
       read(lsin,11) aaa
       if(iwri.eq.1) write( 57 ,11) aaa
11     format(a4)
       read(lsin,12) k,j,x, y
       if(iwri.eq.1) write(57 ,12) k,j,x, y
12     format(2i5,2f10.4)
       if(j.eq.0) go to 101
       if(k.eq.0) go to 101
       nhv(k)=j
       hvmatb(k)=x
       hvmatz(k)=y
       read(lsin,13) (hvmat(k,n),n=1,nhv(k))
       if(iwri.eq.1) write( 57,13) (hvmat(k,n),n=1,nhv(k))
13     format (8f10.4)
100   continue
      enddo
101   continue

c ALT  ALTITUDE OPTION:  kPa or km
      do j=1,40
       hvmat(22,j)=hvmat(2,j)
c ALTITUDE OPTION;  FOR KM, UNCOMMENT THIS LINE.  FOR KPA, COMMENT OUT
c      hvmat(2,j)=hvmat(21,j)
c END OPTION
      enddo

c SPECIAL TEMPERATURE TREATMENT:
c  INITIAL  READIN HAS nhv(jtem)=nhv(ialt);  and reads hvmat(jtem,j)
c   as standard temperature vs. altitude.
c  DATA READIN (jarray, below) reads  just one data  array,
c   representing parameter for std temp+10 degrees.
c  FOR THIS, RESET nhv(jtem)=2.
c  (hvmatb=hvmat(jtem,1); hvmatz=0.)

       if(jtem.gt.0) then
        if(nhv(jtem).gt.2)  nhv(jtem)=2
       endif

c SET INITIAL J-VALUES TO ZERO/ONE
c  J=0 FOR BASE CASE (k=1) AND CLOUD-ADJUSTMENT VALUES (k=11,12)
      do k=1,80
       do ig=1,510
        do jc=1,56
         jarray(k,ig,jc)=1.
         if(k.eq.1                      ) jarray(k,ig,jc)=0.
        enddo
       enddo
      enddo

c jarray(80,510,56)

c LOOP TO READ ARRAY BASE CASE (k=1) AND ADJUSTMENT CASES (k>1)
c  N REPRESENTS PARAMETER VALUE FROM J-MATRIX.    
c READ FROM ARRAY AND ENTER IMPLICIT VALUES OMITTED FROM ARRAY
       k=0
       do m=2,20
        nmax=1
        if(m.ge.3) nmax=nhv(m)
        if(iwri.eq.1) write(57,*) m,nmax,k
c      (Exit if nhv=0)
        if(nhv(m).le.0) go to 1001
c      (Note: for nhv=1, omit from jarray)       
        if(nhv(m).le.1) go to 1000
        do n=1,nmax
         k=k+1

         if(iwri.eq.1) write(57,*) m,n,k

c ENTER IMPLICIT VALUES FOR ARRAY (nighttime or base case adjustment factors)  
          do ig=1,510
           do jc=1,56 
            jarray(k,ig,jc)=hvmatz(m)
           enddo
          enddo

c READ ARRAY VALUES (skip for nighttime and base-case adjustment factors)
c                   (skip for cloud-above at alt>7)

c   altitude and zenith loop (skips nighttime zenith)
c     with control to skip base case adjustment factor
c     and to skip for ialt>7 for cloud-above (9, 11:  jcld, jcld+2)
c     NOTE CHANGE with added 1km layer:  ialt>8 skip

c   SKIPS BASE CASE ADJUSTMENT FACTOR IN ALL SUBSEQUENT LOOPS
c   BUT INCLUDES IT IN FIRST LOOP (m=2, k=2 was early error)
c         if(k.eq.2.or.(hvmat(m,n).ne.hvmatb(m))) then
          if(m.eq.2.or.(hvmat(m,n).ne.hvmatb(m))) then

c CASE HEADING
           read(lsin,11) aaa
           if(iwri.eq.1) write(57,*) k
           if(iwri.eq.1) write(57, 11) aaa
           do i=1,nhv(2)
c CHANGE GRID OPTION:   SKIP CONTROL - i.le.7 (TUVGRID1). i.le.8 FOR TUVGRID2
c  This  skips read for alt>8 for cloud-above or cl-alt-above.
c            if(i.le.7.or.(m.ne.9.and.m.ne.11)) then
             if(i.le.8.or.(m.ne.jcld.and.m.ne.jcld+2)) then

              read(lsin,11) aaa
              if(iwri.eq.1) write(57,*) k,i
              if(iwri.eq.1) write(57 ,11) aaa
              do iz=1,(nhv(1)-1)
               ig=iz+nhv(1)*(i-1)
               read(lsin,1002) (jarray(k,ig,jc),jc=1,jct)
               if(iwri.eq.1) write( 57 ,1002) (jarray(k,ig,jc),jc=1,4)
               if(ig.eq.1.and.iwri.eq.1) write(57,  * ) k
               if(k.eq.1.and.iz.le.2.and.i.le.2.and.iwri.eq.1)
     *          write(57,*) k,i,iz, ig
               if(k.eq.1.and.iz.le.2.and.i.le.2.and.iwri.eq.1)
     *         write( 57 ,1002) (jarray(k,ig,jc),jc=1,4)
 1002          format(8(1PE10.3))
              enddo
            endif
           enddo
          endif

c END LOOP TO READ
        enddo
1000   continue
       enddo
1001   continue

2000  return
      end
c -----------------------------------------------------------------



      subroutine jvalpro(nhv,hvmat, hvmatb, jarray,jparam, jval)

c  This Subroutine takes jparams (zenith, altitude, etc.)
c    and generates jvals from table, for up to 56 species.
c
c  Critical INDEX OPTION:  jaer index (6) jcld index (9)
c   identifies aerosol optical depth index (always followed by SSA)
c   and cloud-above optical depth (followed by cloud-below and alt. adjustmts)

c NOTE:  for future VECTORIZATION:  variables listed as (   n)
c        may be switched to ( kk,n)
c        Look out for indices:  ig11, etc.

c  INPUTS (parameters for specified case)
      real*8 jparam(    22)
c INPUT ARRAY DATA
      integer nhv(22)
      real*8 hvmat(22,40), hvmatb(22)
      real*8 jarray(80,510,56)
c      (note: current scale jarray (k,ig,jc):  k=1,56)
c OUTPUTS
      real*8 jval(    56)

c INTERNAL
      real*8 jfx(    20), jfrac(    20,56)
      real*8 jfsur(56), jfaerz(56), cfac(56)
      real*8 fzen    , falt    , x  , ppi
      integer k,ig,jc, jct, iwri, i, ij
      integer izen   , ialt   , ig11   , ig12   , ig21   , ig22
     *               ,ig01, ig02
      integer iy, im, id
      integer jaer, jcld,  jalb, jtem

c cfac = 2CLOUD ABOVE-BELOW FACTOR  (link to OPTION below)

c CORRECT FACTORS BASED ON JTAB AND (jclb*jclbm-1)*(1-jcla*jclam)
      data  cfac/       0.,6.175E-01,2.079E+00,1.774E+00,2.407E+00, 
     *           2.479E+00,2.365E+00,1.495E+00,       0.,       0., 
     *           1.424E+00,1.732E+00,1.180E+00,1.202E+00,1.373E+00,
     *           1.538E+00,9.732E-01,       0.,0.000E+00,1.228E+00,
     *           1.911E+00,1.831E+00,8.667E-01,1.481E+00,1.170E+00,
     *           1.336E+00, 0.,0.,0.,0.,
     *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
     *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
     *           0.,0.,0.,0.,0.,0./

c ORIGINAL (OLD) FACTORS CALCULATED BASED  ON JTAB (old correct)
c (4=1.319, 1.699,  1.839 2.147)
c     data  cfac/ 0.,      5.973E-01,2.025E+00,1.839E+00,2.322E+00, 
c    *           2.397E+00,       0.,1.557E+00,       0.,       0., 
c    *           1.470E+00,1.809E+00,1.187E+00,1.204E+00,1.400E+00,
c    *           1.602E+00,9.530E-01,       0.,0.000E+00,1.234E+00,
c    *           1.926E+00,1.877E+00,8.461E-01,1.531E+00,1.177E+00,
c    *           1.373E+00, 0.,0.,0.,0.,
c    *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
c    *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
c    *           0.,0.,0.,0.,0.,0./

c FACTORS CALCULATED BASED  ON JBASE (OLD)
c     data  cfac/ 0., 4.896E-01, 1.056E+00, 1.319E+00, 1.134E+00, 
c    *           1.215E+00,   0., 1.255E+00,  0.     ,   0.      ,
c    *           1.189E+00,1.343E+00,9.741E-01,9.885E-01,1.145E+00,
c    *           1.281E+00, 7.782E-01,   0.   ,0.000E+00,1.011E+00,
c    *           1.218E+00,1.281E+00,6.906E-01,1.227E+00, 9.677E-01,
c    *           1.122E+00, 0.,0.,0.,0.,
c    *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
c    *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
c    *           0.,0.,0.,0.,0.,0./

c -----------------------------------------------------------------

c VECTOR PARAMETER - MAYBE ADD LATER
c     kk=1

c TEST WRITE INDEX (=1 to write) 
c  (=2 for SPECIAL WRITE TO 58-for 2CLOUD ABOVE-BELOW PARAMETERIZATION)
      iwri=0

c PI
      ppi= 3.141592653559

c INDEX OPTION:  jaer (=6), jcld (originally =9) jalb (=8)
      jaer=6
      jcld=9
      jalb=8
      jtem=13

c OPTION:  TOTAL NUMBER OF J-VALUES TO BE READ. (jct=4 test 26 trop 56 full)
c     jct=4
      jct=26

c PRELIMINARY:  ENTER JVALS AS ZERO.
c RETURN IF ZENITH>94.  (CUT IF VECTORIZED)
      do jc=1,jct
       jval(   jc) = 0.
      enddo
      if(jparam(   1).ge.hvmat(1, nhv(1)) ) return
  

c LOOP:  Establish index and fractions for each j-parameter
c  Note:  allow for hvmat intervals monotonically increasing or decreasing.
c  Note:  SKIP (but do not exit) for nhv=1.
c  NOTE:  Loop was 1,20; before TEMP.  Does DATE use this?  Probably not.
c     do i=1,20
      do i=1,19
       jfx(    i) = 0.
       if(nhv(i).le.0) go to 101
       if(nhv(i).eq.1) go to 100

c SPECIAL TEMPERATURE:
c    (not here!  AFTER jfx() set, reset.)
c    jfx(jtem)=2.  Only  one value.

c Test to exit if matrix intervals are zero
c  (note:  matrix must be monotonically increasing or decreasing)
       if(hvmat(i,1).eq.hvmat(i,nhv(i)) ) go to 100
       do j=1,(nhv(i)-1)
        if(hvmat(i,j).eq.hvmat(i,j+1) ) go to 100
       enddo

c Enter fraction for parameter outside matrix range
        if(hvmat(i,1).lt.hvmat(i,nhv(i))  ) then
         if(jparam(    i).le.hvmat(i,1))  jfx(    i) = 1.0
         if(jparam(    i).ge.hvmat(i,nhv(i)))  
     *                           jfx(    i) = float(nhv(i))
        endif
        if(hvmat(i,1).gt.hvmat(i,nhv(i)) ) then
         if(jparam(    i).ge.hvmat(i,1))  jfx(    i) = 1.0
         if(jparam(    i).le.hvmat(i,nhv(i)))  
     *                           jfx(    i) = float(nhv(i))
        endif

c Enter fraction for parameter inside matrix range
        do j=1,(nhv(i)-1)
         if(  (jparam(    i).ge.hvmat(i,j).and.
     *         jparam(    i).le.hvmat(i,j+1)).or.
     *        (jparam(    i).le.hvmat(i,j).and.
     *         jparam(    i).ge.hvmat(i,j+1))  ) then
         jfx(    i) = float(j) + 
     *    (jparam(   i)-hvmat(i,j))/(hvmat(i,j+1)-hvmat(i,j))
         endif
        enddo

c SPECIAL TEMPERATURE:
c    jfx(jtem)=2.  Only  one value is entered in hvarray matrix for jtem;
c    This represents  delta  parameter for t(ialt)+10 degrees.
c    jfx(jtem)=2 ensures that  jtem interpolation will  select jfrac(jtem)
c    as zenith/altitude interpolation from this one data set.
c    (jfx(jtem)=1 would correspond to base case parameter value = hvmatz=0.)

      if(i.eq.jtem) jfx(i)=2.

c TEST WRITE
          if(iwri.eq.1) then
        write(57,111) i, jparam(i), jfx(i)
 111     format(' TEST I JPARAM JFX (then hvmat(i,j)):', i5,2f10.3)
        write(57,112) (hvmat(i,j),j=1,nhv(i))
 112     format(8f10.3)
           endif

c END LOOP:  establish index and fraction for j-parameters
100   continue
      enddo   
101   continue

c Establish ig parameters for base interpolation:  zenith and altitude
c   zenith and altitude are controlled by ig index in jarray(k,ig,jc)
c   ig11=lower zenith index, lower altitude index
c   ig12=upper zenith index, lower altitude index
c   ig21=lower zenith index, upper altitude index
c   ig22=upper zenith index, upper altitude index

c   ig01=lower zenith index, surface altitude index
c   ig02=upper zenith index, surface altitude index

c  NOTE:  TO VECTORIZE:  fzen, falt, izen, ialt, ig11, etc
c    must all be vectors.  Skip.

      izen    =int(jfx(    1))
      if(izen.eq.nhv(1)) izen=izen-1
      fzen    =1.+float(izen    )-jfx(    1)
      ialt    =int(jfx(    2))
      if(ialt.eq.nhv(2)) ialt=ialt-1
      falt    =1.+float(ialt    )-jfx(    2)

      ig11    = izen    +nhv(1)*(ialt    -1)
      ig12    =ig11    
      if(izen    .lt.nhv(1)) ig12    =ig11    +1
      ig21    =ig11    
      if(ialt    .lt.nhv(2)) ig21    =ig11    +nhv(1)
      ig22    =ig21    
      if(izen    .lt.nhv(1)) ig22    =ig21    +1


      ig01    = izen    
      ig02    =ig01    
      if(izen    .lt.nhv(1)) ig02    =ig01    +1

c Establish base j-values.  Enter into jval output.
      do jc=1,jct
       jval(   jc)=     jarray(1,ig11,jc)*fzen    *falt    
     *               +   jarray(1,ig12,jc)*(1.-fzen    )*falt    
     *               +   jarray(1,ig21,jc)*fzen    *(1.-falt    )
     *               +   jarray(1,ig22,jc)*(1.-fzen    )*(1.-falt    )
c
c NONLINEAR CORRECTION for variation with altitude - NO EFFECT
c  (effects HNO3 at 24 km, otherwise zero effect.)
       if(jval(  jc).gt.0.and.ialt.le.(nhv(2)-2)) then
        x   = 2.*jarray(1,ig21,jc)/
     *        (jarray(1,ig11,jc)+jarray(1,(ig21+nhv(1)),jc))
     *     - 1.
        jval(   jc)=jval(   jc)* (1.+x*falt*(1.-falt))
       endif
      enddo

c TEST WRITE
            if(iwri.eq.1) then
      write(57,301)    izen, ialt, ig11, ig12, ig21, ig22,
     *               fzen, falt
 301   format(' TEST izen ialt ig11 ig12 ig21 ig22 fzen falt=',/,
     *          6i4,2f10.3)
      write(57,302) jval(1), jarray(1,ig11,1), jarray(1,ig12,1),
     *   jarray(1,ig21,1), jarray(1,ig22,1)
      write(57,302) jval(2), jarray(1,ig11,2), jarray(1,ig12,2),
     *   jarray(1,ig21,2), jarray(1,ig22,2)
      write(57,302) jval(4), jarray(1,ig11,4), jarray(1,ig12,4),
     *   jarray(1,ig21,4), jarray(1,ig22,4)
 302    format(' TEST INITIAL JVAL:',  8(1PE10.3))
           endif

c  LOOP: Establish fractional adjustments
C  LOOP for each fraction.  Set k-index
      k=1
c     do i=3,20
      do i=3,19

c  Set initial fraction equal to base value  
c   (watch special 11, 12! Make sure base value is OK if nhv=1 and skipped)
        do jc=1,jct
         jfrac(    i,jc)=1.
        enddo

c       if(i.eq.6)then
        if(i.eq.jaer)then
         do jc=1,jct
          jfaerz(jc)=1.
         enddo
        endif

c       if(i.eq.9)then
        if(i.eq.jcld)then
         do jc=1,jct
           jfsur(jc)=1.
         enddo
        endif

c  If nhv=1, skip this loop.  Automatically enter jfract=1.
c    Note if nhv=1, values are omitted from jarray(k,ig,jc)
       if(nhv(i).eq.1) go to 200
c  If nhv=0, exit.
       if(nhv(i).le.0) go to 201

c SPECIAL TEMPERATURE:  
c   Just one array  value is entered for temperature array.
c   Set  jfx(i) so that jfx(i)=nhv(i)=2.
c   This insures that jfrac(jtem)=direct interpol.  from single value.

c  Establish adjustment factor and k-index for jarray (VECTORIZE)
       kn   = k + int(jfx(   i))
       if(int(jfx(    i)).eq.nhv(i)) kn=kn-1
       fkn    =1.+float(kn    -k)-jfx(     i     )
c
c    

c TEST WRITE:
       if(fkn.lt.0.or.fkn.gt.1) write(56,251) i, k, kn,jfx(i), fkn
251     format ('ERROR fkn(<0 or>1): i k kn jfx fkn(0-1)=',3i3,2f10.4)

c Establish fraction from jarray.
c  Use zenith interpolation, itself interpolated between two fractions.
      do jc=1,jct
       jfrac(   i,jc)=     fkn*(
     *      jarray(kn,ig11,jc)*fzen    *falt    
     *  +   jarray(kn,ig12,jc)*(1.-fzen    )*falt    
     *  +   jarray(kn,ig21,jc)*fzen    *(1.-falt    )
     *  +   jarray(kn,ig22,jc)*(1.-fzen    )*(1.-falt    )
     *                                           ) + (1.-fkn)*(
     *      jarray(kn+1,ig11,jc)*fzen    *falt    
     *  +   jarray(kn+1,ig12,jc)*(1.-fzen    )*falt    
     *  +   jarray(kn+1,ig21,jc)*fzen    *(1.-falt    )
     *  +   jarray(kn+1,ig22,jc)*(1.-fzen    )*(1.-falt    )
     *                                                      )
      enddo

c Establish surface fraction-FOR SURFACE IMPACT OF CLOUD BELOW.
c  This uses the CLOUD-BELOW value of cloud optical depth 
c   (from the 10th index) 
c  but it uses it with the CLOUD-ABOVE value (9th index)
c  Representing the CLOUD-BELOW impact (as CLOUD ABOVE) at the surface.
c  THIS IS USED TO ADJUST THE ALBEDO FRACTION (8)

c ALSO - EXPERIMENTAL - USED TO ADJUST CLOUD-ABOVE
c  TO CORRECT UNDERESTIMATE IN CASE WITH CLOUD-ABOVE AND CLOUD-BELOW.
c  (totally empirical, no reason.)

c     if(i.eq.10) then
      if(i.eq.jcld+1) then
c TEST WRITE
      if(iwri.eq.1) write(57,307) 
     *       jfrac(jalb,1), jfrac(jalb,2), jfrac(jalb,4)
c    *       ,jfrac(jcld,1), jfrac(jcld,2), jfrac(jcld,4)
307   format('ALBEDO ADJUSTMENT FOR CLOUD-BELOW:',/,
     *       'PRIOR    ALBEDO FR (O2 O1D NO2)=',3f12.6)
c    *        ,/,'PRIOR CLOUD-ABOVE  (O2 O1D NO2)=',3f12.6)
      do jc=1,jct
       jfsur(     jc)=     fkn*(
c    *      jarray(kn-nhv(9),ig01,jc)*fzen             
     *      jarray(kn-nhv(jcld),ig01,jc)*fzen             
     *  +   jarray(kn-nhv(jcld),ig02,jc)*(1.-fzen    )         
     *                                           ) + (1.-fkn)*(
     *      jarray(kn+1-nhv(jcld),ig01,jc)*fzen    
     *  +   jarray(kn+1-nhv(jcld),ig02,jc)*(1.-fzen    )
     *                                                      )

c ALBEDO
c     jfrac(8,jc)=1-jfsur(jc)*(1.-jfrac(8,jc))
      jfrac(jalb,jc)=1-jfsur(jc)*(1.-jfrac(jalb,jc))
c OLD 2CLOUD ABOVE-BELOW CORRECTION FACTOR -   (0, 0.2, 0.4*)
c c     jfrac(9,jc)=1.-(1-jfrac(9,jc))*(0.8+0.2*jfsur(jc))
c c     jfrac(9,jc)=1.-(1-jfrac(9,jc))*(0.6+0.4*jfsur(jc))
c ORIGINAL 2CLOUD ABOVE-BELOW CORRECTION FACTOR -          (see data above)
c  WAS HERE, MOVED BELOW
c c     jfrac(9,jc)=jfrac(9,jc) 
c c    *       *(1.+ cfac(jc)*(1.-jfsur(jc))*(1.-jfrac(9,jc)) )

      enddo
c TEST WRITE
      if(iwri.eq.1) write(57,308) jfsur(1), jfsur(2), jfsur(4),
     *       jfrac(jalb,1), jfrac(jalb,2), jfrac(jalb,4)
c    *       ,jfrac(jcld,1), jfrac(jcld,2), jfrac(jcld,4)
308   format('SURFACE   CLOUD FR (O2 O1D NO2)=',3f12.6,/,
     *       'MODIFIED ALBEDO FR (O2 O1D NO2)=',3f12.6)
c    *       ,/,'MODIFIED CLOUDabove(O2 O1D NO2)=',3f12.6)

c SPECIAL WRITE FOR CREATING 2CLOUD ABOVE-BELOW CORRECTION  FACTOR.
c  was here, moved below.


c END IF - Establish surface fraction and adjust albedo,  cloud above-below.
      endif

c Establish AEROSOL ZERO fraction:  case i=6, 1st fraction value.
c   fraction k index is k+1 instead of kn
      if(i.eq.jaer) then
      do jc=1,jct
       jfaerz(     jc)=         (
     *      jarray(k+1,ig11,jc)*fzen    *falt    
     *  +   jarray(k+1,ig12,jc)*(1.-fzen    )*falt    
     *  +   jarray(k+1,ig21,jc)*fzen    *(1.-falt    )
     *  +   jarray(k+1,ig22,jc)*(1.-fzen    )*(1.-falt    )
     *                                                      )
      enddo
      endif

c TEST WRITE
           if(iwri.eq.1) then
      write(57,309) i, k, kn, jfx(i), fkn
 309   format('TEST INDEX I K KN JFX(I): kn=k+int(jfx):',3i3,2f10.4)
      write(57,311) i,kn,fkn ,fzen, falt, jfrac(i,1)  
      write(57,311) i,kn,fkn ,fzen, falt, jfrac(i,2)  
      write(57,311) i,kn,fkn ,fzen, falt, jfrac(i,4)  
311    format(' TEST FRACTION i,kn, fkn fzen falt jfrac =',/,2i5,5f10.4)
      write(57,312)          jarray(kn,ig11,1), jarray(kn,ig12,1),
     *   jarray(kn,ig21,1), jarray(kn,ig22,1)
     *                      ,jarray(kn+1,ig11,1), jarray(kn+1,ig12,1),
     *   jarray(kn+1,ig21,1), jarray(kn+1,ig22,1)
      write(57,312)          jarray(kn,ig11,2), jarray(kn,ig12,2),
     *   jarray(kn,ig21,2), jarray(kn,ig22,2)
     *                      ,jarray(kn+1,ig11,2), jarray(kn+1,ig12,2),
     *   jarray(kn+1,ig21,2), jarray(kn+1,ig22,2)
      write(57,312)          jarray(kn,ig11,4), jarray(kn,ig12,4),
     *   jarray(kn,ig21,4), jarray(kn,ig22,4)
     *                      ,jarray(kn+1,ig11,4), jarray(kn+1,ig12,4),
     *   jarray(kn+1,ig21,4), jarray(kn+1,ig22,4)
 312      format(8(1Pe10.3))
             endif

c Special adjustment:  cloud height adjustment factors (j=11, 12)
c  represent an adjustment to the cloud-above and cloud-below (j=9,10).
c  These are converted to straight fractions here.

c  The adjustment parameter in the array is:  
c      Fadj=(1-Ftot/Fcloud)/(1-Fcloud)
c    where Ftot is combined fraction, Fcloud is cloud-alone fraction.
c    Here, the adjustment factor Fadj is replaced with F':  
c  Where Ftot=Fc*F'; F'=1-Fadj(1-Fcloud);  F' limited, between 0.1 and 10.

c  The same adjustment is applied for AEROSOL SSA (j=7)
c   as an adjustment to the AEROSOL OPTICAL DEPTH fraction (j=6)

c     if(i.eq.11.or.i.eq.12          ) then
      if(i.eq.jcld+2.or.i.eq.jcld+3      ) then
       ij=i-2
       do jc=1,jct
        jfrac(   i,jc)=1.- jfrac(    i,jc)*(1.-jfrac(   (ij ),jc))
        if(jfrac(    i,jc).lt.0.1) jfrac(    i,jc)=0.1
        if(jfrac(    i,jc).gt.10.) jfrac(    i,jc)=10.
       enddo
c TEST WRITE
           if(iwri.eq.1) then
       write(57,313) i, jfrac(i,1)  
       write(57,313) i, jfrac(i,2)  
       write(57,313) i, jfrac(i,4)  
 313    format(' TEST ADJ. FRACTION i, jfrac =',i5,2f10.4)
           endif
      endif

c Special adjustment:  aerosol SSA (i=7)
c  represent an adjustment to the zero-aerosol fraction (i=6, jfaerz)
c  These are converted to straight fractions here.

c  The adjustment parameter in the array is:  
c      Fadj=(1-Ftot/Faerbase)/(1-Faerbase/Faerzero)
c    where Ftot is combined fraction, Faerbase is base aerosol and SSA fr,
c    and Faerzero is fraction for zero aerosol case.
c    (This is necessary because initial value, F=1, does not have zero aerosol)
c    Here, the adjustment factor Fadj is replaced with F':  
c  Where Ftot=Fc*F'; F'=1-Fadj(1-Faerbase/Faerzero);  
c    F' limited, between 0.1 and 10.

c     if(i.eq.7) then
      if(i.eq.jaer+1) then
c       ij=6
        ij=jaer
       do jc=1,jct
        if(jfaerz(jc).gt.0) then
          jfrac(   i,jc)=1.- jfrac(    i,jc)*
     *      (1.-jfrac(   (ij ),jc)/jfaerz(jc))
        else
          jfrac(   i,jc)=1.- jfrac(    i,jc)*
     *      (1.-jfrac(   (ij ),jc)           )
        endif
        if(jfrac(    i,jc).lt.0.1) jfrac(    i,jc)=0.1
        if(jfrac(    i,jc).gt.10.) jfrac(    i,jc)=10.
       enddo
c TEST WRITE
           if(iwri.eq.1) then
       write(57,313) i, jfrac(i,1)  
       write(57,313) i, jfrac(i,2)  , jfaerz(2)
       write(57,313) i, jfrac(i,4)  
           endif
      endif



c Special adjustment:  albedo fraction in case of cloud-below.
c  Adjust fractional change (relative to 1) based on 
c    cloud-below impact on surface:  

c    (To do this:  establish special jfrac using CLOUD-BELOW jfx,
c     but for CLOUD-ABOVE and for SURFACE.
c     Then adjust albedo fraction:  falb'=1-(1-falb)*fclsurf  
c DONE WITH jfsur() ABOVE.
c --------------------

c 2CLOUD ABOVE-BELOW NONLINEAR ADJUSTMENT:  OPTION.
c For case with BOTH cloud-above and cloud-below, 
c  table fractions underestimate j-values.
c  THIS IS TOTALLY EMPIRICAL-no reason for it.
c
c    Cloud-above fraction is corrected:
c    CLA' = F*(1-CLA*CLAm)*(CLB*CLBm-1)
c     where CLA, CLAm=f9,  f11 (after modification);  CLB, CLBm=f10,f12.
c MOVED HERE - PREVIOUSLY w/ jfsur() ABOVE.

c      if(i.eq.12) then
       if(i.eq.jcld+3) then
c TEST WRITE
         if(iwri.eq.1) write(57,317)
     *       jfrac(jcld,1), jfrac(jcld,2), jfrac(jcld,4)
     *       ,jfrac(jcld+1,4), jfrac(jcld+2,4), jfrac(jcld+3,4)
317   format('2CLOUD ABOVE-BELOW ADJUSTMENT:    ',/,
     *       'PRIOR CLOUD-ABOVE  (O2 O1D NO2)=',3f12.6,/,
c    *       'jfrac10, 11, 12 (CLB,m)   (NO2)=',3f12.6)
     *       'CLD-BELOW, CLaltA, CLaltB (NO2)=',3f12.6)
        do jc=1,jct
c 2CLOUD AB0VE-BELOW OPTION:  MODIFY HERE..  (use with data OPTION, above)
c  FINAL CORRECT VERSION
c   with INDEX CONTROL:  
c   WITHOUT INDEX
         if(jfrac(jcld,jc)*jfrac(jcld+2,jc).lt.1)
     *   jfrac(jcld,jc)=jfrac(jcld,jc) *(1.+
     *       cfac(jc)*(jfrac(jcld+1,jc)*jfrac(jcld+3,jc)-1.)*
     *                  (1.-jfrac(jcld,jc)*jfrac(jcld+2,jc)) )
c        if(jfrac(9,jc)*jfrac(11,jc).lt.1)
c    *   jfrac(9,jc)=jfrac(9,jc) *(1.+
c    *       cfac(jc)*(jfrac(10,jc)*jfrac(12,jc)-1.)*
c    *                  (1.-jfrac(9,jc)*jfrac(11,jc)) )
c OLDER-ORIGINAL MODIFICATION.  (use with data OPTION, above)
c        jfrac(9,jc)=jfrac(9,jc) *(1.+
c    *       cfac(jc)*(1.-jfsur(jc))*(1.-jfrac(9,jc)) )
        enddo
c TEST WRITE
        if(iwri.eq.1) write(57,318)
     *       jfrac(jcld,1), jfrac(jcld,2), jfrac(jcld,4)
318     format( 'ADJUSTED CLOUD-ABOVE  (O2 O1D NO2)=',3f12.6,/,
     *       'jfrac10, 11, 12 (CLB,m)   (NO2)=',3f12.6)
       endif
c
c
c SPECIAL WRITE FOR CREATING 2CLOUD ABOVE-BELOW CORRECTION  FACTOR.
c  (Save table:  jfsur, jf9,jtab-base, jtuv, jtab for 26 species.
c   Then cloud  factor f= (jtuv-jtab)/[jtab*jsurf*(1-jf9)]
c    where j's are summed over table.
       if(i.eq.jcld+3) then
        if(iwri.ge.1) write(58,310) (jfsur(jc),jc=1,26)
        if(iwri.ge.1) write(58,310) (jfrac( jcld,jc),jc=1,26)
        if(iwri.ge.1) write(58,310) (jfrac(jcld+1,jc),jc=1,26)
        if(iwri.ge.1) write(58,310) (jfrac(jcld+2,jc),jc=1,26)
        if(iwri.ge.1) write(58,310) (jfrac(jcld+3,jc),jc=1,26)
        if(iwri.ge.1) write(58,310) (jval(jc)    ,jc=1,26)
        if(iwri.eq.1) write(57,310) (jfsur(jc),jc=1,26)
        if(iwri.eq.1) write(57,310) (jfrac( jcld,jc),jc=1,26)
        if(iwri.eq.1) write(57,310) (jfrac(jcld+1,jc),jc=1,26)
        if(iwri.eq.1) write(57,310) (jfrac(jcld+2,jc),jc=1,26)
        if(iwri.eq.1) write(57,310) (jfrac(jcld+3,jc),jc=1,26)
        if(iwri.ge.1) write(57,310) (jval(jc)    ,jc=1,26)
c 310     format(8f10.6)
310     format(8(1Pe10.3))
      endif

c SPECIAL TEMPERATURE ADJUSTMENT:  
c   Just one array  value is entered for temperature array.
c   Above, set  jfx(i) so that jfx(i)=nhv(i)=2.
c   This insures that jfrac(jtem)=direct interpol.  from single value.

c   Here, establish temperature parameter from jparam(jtem)
c    jparam(jtem)= dtem if less than  50; 
c     else jparam(jtem)=temp, and dtem found as jparam(jtem)-t(alt)
c      where t(alt), std temp, found  from interpolating hvmat(jtem,j), j=alt.
c  
c   Then  jfrac(jtem) = 1 + 0.1*dtem*jf(jtem); jf(jtem) is factor from table
c     (previously  entered as jfrac(jtem), interpolated for  zenith and alt).
c     (0.1 factor because jf(jtem) is % change for 10 degree increase.)

c   OPTION - CHANGE JPARAM=dtem FOR TEST

       if(i.eq.jtem) then
c TEST WRITE
        if(iwri.eq.1) write(57,331) i, jparam(i), jfrac(i,2),
     *          jfrac(i,4)
331     format(' TEST BEFORE TEMPERATURE ADJ: i, jparam,jfrac O1D,NO2=',
     *          i5,4f10.4)

        x=jparam(i)
        if(jparam(i).gt.50) then
         x= jparam(i)
     *    -(hvmat(jtem,ialt)*falt + hvmat(jtem,ialt+1)*(1.-falt))
c OPTIONAL LINE FOR TESTS
c        jparam(i)=x
c TEST WRITE
         if(iwri.eq.1) write(57,332) ialt, falt, hvmat(jtem,ialt),
     *     hvmat(jtem,ialt+1)
332      format (' TEST ialt falt hvmat(jt,ialt), hvmat(jt,ia+1)=',
     *             i5, 5f10.4)
        endif
        do jc=1,jct
         jfrac(jtem,jc)=1.  +  0.1*x*jfrac(jtem,jc)
        enddo

c TEST WRITE 
       if(iwri.eq.1) write (57, 333) x, jfrac(jtem,2),jfrac(jtem,4)
333    format(' TEST AFTER  TEMPERATURE ADJ: dtem, fO1D, fNO2=',
     *    f10.4, 2(1Pe10.3))

c END SPECIAL TEMPERATURE ADJUSTMENT
       endif



c -------
c ADJUST BASE -JVALUE BY FRACTION - WAS HERE, MOVED TO SEPARATE LOOP BELOW.
c ------


c ADVANCE K-COUNTER FOR NEXT LOOP
c    (due to screw-up in TUVGRID1, advance even for NHV=1? No.)
       if(nhv(i).gt.1) k=k+nhv(i)

c END LOOP:  fractional adjustments
200    continue
      enddo
201   continue

c TEST J-VALUE  FINAL FRACTIONAL ADJUSTMENT
       if(iwri.eq.1.)
     *    write(57,314)            jval(2),             jval(4)
314    format(' BEFORE-FRACTION jO1D,jNO2=',2(      1Pe10.3))

c LOOP TO ADJUST BASE J-VALUE BY FRACTION

      do i=3,19
       if(nhv(i).gt.1) then

c ADJUST BASE J-VALUE BY FRACTION
       do jc=1,jct
        jval(   jc) = jval(    jc)* jfrac(    i,jc)
       enddo

c TEST J-VALUE  FINAL FRACTIONAL ADJUSTMENT
       if(iwri.eq.1.and.jfrac(i,1).ne.1.and.jfrac(i,2).ne.1) 
     *    write(57,316) i,jfrac(i,2), jval(2), jfrac(i,4), jval(4)
316    format(' FINAL J-CALC: F2,J2,F4,J4=',i3,2(f10.3,1Pe10.3))
     
       endif
      enddo

c DATE ADJUSTMENT:  
c  ASSUME THAT INPUT jparam(20)= DATE  (decimal)
c    either as date factor (-1 to +1)
c    or DAY NUMBER (1-365)
c    or YYMMDD (not 00)
c    DAY FACTOR (X) IS cos(nd*2.*pi/365)

      x=jparam(20)
      if(x.gt.1.and.x.lt.10000.) x=cos(2.*ppi*(jparam(20)/365.))
      if(x.ge.10000.) then
       iy=int((x+0.001)/10000.)
       im=int((x+0.001-10000.*float(iy))/100.)
       id=int((x+0.001-10000.*float(iy)-100.*float(im)))
       x=cos(2.*ppi*(float(id+30*(im-1))/365.) )
      endif

c ADJUSTMENT:  x IS DAY FACTOR, -1. to +1.  NOW MAKE DAY ADJUSTMENT.
      x=1.+0.0344*x 
c ADJUST BASE J-VALUE FOR DATE
       do jc=1,jct
        jval(   jc) = jval(    jc)* x
       enddo

2000  return
      end

c -----------------------------------------------------------------
c -----------------------------------------------------------------
c END

