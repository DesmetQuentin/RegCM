! jval1.f           (altitude in kPA)                                   
!                                                                       
! SUCCESSFUL VERSION, 11-22-02 w/MODIFICATIONS.  Use with jvalmain1.f.  
!  (use jval2.f, altitude in KM, to test -w/ tuvtest2.f)                
!                                                                       
!  PROGRAM FOR PROCESSING TUV TABLE (TUVGRID)                           
!  Uses table generated by tuvtab2.f                                    
!   with subroutines for use in testing program and photochemistry.     
!                                                                       
!   MODIFICATIONS:                                                      
! WITH SUNSET ZENITH:  change 442 to 510 (FEB 2003)                     
! WITH ADD FOR TEMPERATURE ADJUSTMENT (jtem=13)                         
!   DATE, adjustment for AEROSOL SSA, 2CLOUD ABOVE-BELOW. TEMPERATURE.  
!   ALSO, ALLOWS NONZERO AEROSOL AS BASE.                               
!   Aerosol SSA adjustment is relative to aerosol=0, 1st aerosol-not nec
!   Modified ALBEDO, buffered by surface-cloud-below fraction, included.
!    OPTION -  CLOUD ABOVE+BELOW CORRECTION FACTOR - 0.4 INCLUDED (0,0.2
!                                                                       
! SUCCESSFUL VERSION, 9-26-02, used in TUVtest2.                        
!  (minor future fix:  cloud-above at alt=8, make  equal to alt=7       
!    to allow for high  cloud).                                         
!                                                                       
! OPTION - altitude as kPa (2) or as km (21) (in readhv-ALTITUDE OPTION)
! OPTION - number of j-values to be read:  4 (test) 26 (trop) 56 (full) 
!    (see jct in both subroutines)                                      
! TEST WRITES - see iwri                                                
!                                                                       
! NOTE:  CHANGES FOR TEST GRID (TUVGRID1) vs FULL GRID (TUVTEST2):      
!  TUVGRID1 (original test) HAS JUST 4 SPECIES (jc=1,4)                 
!  AND ALSO SKIP CLOUD-ABOVE AFTER 7 TROPOSPHERIC LAYERS. (i.le.7)      
! TUVGRID2 (full) HAS 26 SPECIES (jc=1,26)                              
!   AND SKIPS CLOUD-ABOVE AFTER 8 TROPOSPHERIC LAYERS (i.le.8)          
!   THESE MUST BE CHANGED IN jtab1.f - see CHANGE GRID OPTION           
! -----------------------------------------------------------------     
                                                                        
      subroutine readhv(lsin,nhv,hvmat, hvmatb, jarray) 
                                                                        
! Output matrix:  jarray(k,ig,jc) for                                   
!   k=cases:  k=1 base case, k>1 adjustment factors                     
!             for cases identified in hvmatrix.                         
!   ig=matrix of altitudes and zenith angles                            
!   jc=species j-values                                                 
                                                                        
! Includes AUTOMATIC FILL-IN OF LAST ZENITH VALUE (nighttime)           
!  AND BASE CASE IN ADJUSTMENT FACTORS.                                 
!    (read from input table.  Base j-values are                         
!      0 (nighttime) for base case j-values;                            
!      1 for most adjustment factors, but                               
!      0 for cloud adjustment factors 11 and 12                         
!        (which are relative to original cloud factor)                  
                                                                        
! INPUTS (none)                                                         
!  OUTPUTS                                                              
      integer nhv(22), lsin 
      real*8 hvmat(22,40), hvmatb(22) 
      real*8 jarray(80,510,56) 
!      (note: current scale jarray (k,ig,jc):  k=1,56)                  
                                                                        
!  INTERNAL                                                             
      integer i, j, k, m, n, jct, iwri 
      integer  jaer, jcld,jalb, jtem 
      real*8 x,y, hvmatz(22) 
      character*4 aaa 
! --------------------------------------------------                    
! TEST WRITE:  WRITE IF iwri=1                                          
         write(*,*)'HVREAD     TUVGRID' 
      iwri=0 
                                                                        
! OPTION:  TOTAL NUMBER OF J-VALUES TO BE READ. (jct=4 test 26 trop 56 f
!  CHANGE GRID:  TUVGRID1 (jct=4) vs TUVGRID2 (jct=26)                  
!    see also CHANGE GRID below.                                        
!     jct=4                                                             
      jct=26 
                                                                        
! INDEX OPTION:  jaer (=6), jcld (originally =9) jalb (=8)              
      jaer=6 
      jcld=9 
      jalb=8 
      jtem=13 
!                                                                       
! ZERO INPUT MATRIX                                                     
      do i=1,22 
       nhv(i)=0 
       hvmatb(i)=0. 
       do j=1,40 
        hvmat(i,j)=0. 
       enddo 
      enddo 
                                                                        
! READ INPUT CONTROLS  (note read index, k, as well)                    
      REWIND lsin 
      do i=1,22 
       read(lsin,11) aaa 
       if(iwri.eq.1) write( 57 ,11) aaa 
   11  format(a4) 
       read(lsin,12) k,j,x, y 
       if(iwri.eq.1) write(57 ,12) k,j,x, y 
   12  format(2i5,2f10.4) 
       if(j.eq.0) go to 101 
       if(k.eq.0) go to 101 
       nhv(k)=j 
       hvmatb(k)=x 
       hvmatz(k)=y 
       read(lsin,13) (hvmat(k,n),n=1,nhv(k)) 
       if(iwri.eq.1) write( 57,13) (hvmat(k,n),n=1,nhv(k)) 
   13  format (8f10.4) 
  100 continue 
      enddo 
  101 continue 
                                                                        
! ALT  ALTITUDE OPTION:  kPa or km                                      
      do j=1,40 
       hvmat(22,j)=hvmat(2,j) 
! ALTITUDE OPTION;  FOR KM, UNCOMMENT THIS LINE.  FOR KPA, COMMENT OUT  
!      hvmat(2,j)=hvmat(21,j)                                           
! END OPTION                                                            
      enddo 
                                                                        
! SPECIAL TEMPERATURE TREATMENT:                                        
!  INITIAL  READIN HAS nhv(jtem)=nhv(ialt);  and reads hvmat(jtem,j)    
!   as standard temperature vs. altitude.                               
!  DATA READIN (jarray, below) reads  just one data  array,             
!   representing parameter for std temp+10 degrees.                     
!  FOR THIS, RESET nhv(jtem)=2.                                         
!  (hvmatb=hvmat(jtem,1); hvmatz=0.)                                    
                                                                        
       if(jtem.gt.0) then 
        if(nhv(jtem).gt.2)  nhv(jtem)=2 
       endif 
                                                                        
! SET INITIAL J-VALUES TO ZERO/ONE                                      
!  J=0 FOR BASE CASE (k=1) AND CLOUD-ADJUSTMENT VALUES (k=11,12)        
      do k=1,80 
       do ig=1,510 
        do jc=1,56 
         jarray(k,ig,jc)=1. 
         if(k.eq.1                      ) jarray(k,ig,jc)=0. 
        enddo 
       enddo 
      enddo 
                                                                        
! jarray(80,510,56)                                                     
                                                                        
! LOOP TO READ ARRAY BASE CASE (k=1) AND ADJUSTMENT CASES (k>1)         
!  N REPRESENTS PARAMETER VALUE FROM J-MATRIX.                          
! READ FROM ARRAY AND ENTER IMPLICIT VALUES OMITTED FROM ARRAY          
       k=0 
       do m=2,20 
        nmax=1 
        if(m.ge.3) nmax=nhv(m) 
        if(iwri.eq.1) write(57,*) m,nmax,k 
!      (Exit if nhv=0)                                                  
        if(nhv(m).le.0) go to 1001 
!      (Note: for nhv=1, omit from jarray)                              
        if(nhv(m).le.1) go to 1000 
        do n=1,nmax 
         k=k+1 
                                                                        
         if(iwri.eq.1) write(57,*) m,n,k 
                                                                        
! ENTER IMPLICIT VALUES FOR ARRAY (nighttime or base case adjustment fac
          do ig=1,510 
           do jc=1,56 
            jarray(k,ig,jc)=hvmatz(m) 
           enddo 
          enddo 
                                                                        
! READ ARRAY VALUES (skip for nighttime and base-case adjustment factors
!                   (skip for cloud-above at alt>7)                     
                                                                        
!   altitude and zenith loop (skips nighttime zenith)                   
!     with control to skip base case adjustment factor                  
!     and to skip for ialt>7 for cloud-above (9, 11:  jcld, jcld+2)     
!     NOTE CHANGE with added 1km layer:  ialt>8 skip                    
                                                                        
!   SKIPS BASE CASE ADJUSTMENT FACTOR IN ALL SUBSEQUENT LOOPS           
!   BUT INCLUDES IT IN FIRST LOOP (m=2, k=2 was early error)            
!         if(k.eq.2.or.(hvmat(m,n).ne.hvmatb(m))) then                  
          if(m.eq.2.or.(hvmat(m,n).ne.hvmatb(m))) then 
                                                                        
! CASE HEADING                                                          
           read(lsin,11) aaa 
           if(iwri.eq.1) write(57,*) k 
           if(iwri.eq.1) write(57, 11) aaa 
           do i=1,nhv(2) 
! CHANGE GRID OPTION:   SKIP CONTROL - i.le.7 (TUVGRID1). i.le.8 FOR TUV
!  This  skips read for alt>8 for cloud-above or cl-alt-above.          
!            if(i.le.7.or.(m.ne.9.and.m.ne.11)) then                    
             if(i.le.8.or.(m.ne.jcld.and.m.ne.jcld+2)) then 
                                                                        
              read(lsin,11) aaa 
              if(iwri.eq.1) write(57,*) k,i 
              if(iwri.eq.1) write(57 ,11) aaa 
              do iz=1,(nhv(1)-1) 
               ig=iz+nhv(1)*(i-1) 
               read(lsin,1002) (jarray(k,ig,jc),jc=1,jct) 
               if(iwri.eq.1) write( 57 ,1002) (jarray(k,ig,jc),jc=1,4) 
               if(ig.eq.1.and.iwri.eq.1) write(57,  * ) k 
               if(k.eq.1.and.iz.le.2.and.i.le.2.and.iwri.eq.1)          &
     &          write(57,*) k,i,iz, ig                                  
               if(k.eq.1.and.iz.le.2.and.i.le.2.and.iwri.eq.1)          &
     &         write( 57 ,1002) (jarray(k,ig,jc),jc=1,4)                
 1002          format(8(1PE10.3)) 
              enddo 
            endif 
           enddo 
          endif 
                                                                        
! END LOOP TO READ                                                      
        enddo 
 1000  continue 
       enddo 
 1001  continue 
                                                                        
 2000 return 
      END                                           
! -----------------------------------------------------------------     
                                                                        
                                                                        
                                                                        
      subroutine jvalpro(nhv,hvmat, hvmatb, jarray,jparam, jval) 
                                                                        
!  This Subroutine takes jparams (zenith, altitude, etc.)               
!    and generates jvals from table, for up to 56 species.              
!                                                                       
!  Critical INDEX OPTION:  jaer index (6) jcld index (9)                
!   identifies aerosol optical depth index (always followed by SSA)     
!   and cloud-above optical depth (followed by cloud-below and alt. adju
                                                                        
! NOTE:  for future VECTORIZATION:  variables listed as (   n)          
!        may be switched to ( kk,n)                                     
!        Look out for indices:  ig11, etc.                              
                                                                        
!  INPUTS (parameters for specified case)                               
      real*8 jparam(    22) 
! INPUT ARRAY DATA                                                      
      integer nhv(22) 
      real*8 hvmat(22,40), hvmatb(22) 
      real*8 jarray(80,510,56) 
!      (note: current scale jarray (k,ig,jc):  k=1,56)                  
! OUTPUTS                                                               
      real*8 jval(    56) 
                                                                        
! INTERNAL                                                              
      real*8 jfx(    20), jfrac(    20,56) 
      real*8 jfsur(56), jfaerz(56), cfac(56) 
      real*8 fzen    , falt    , x  , ppi 
      integer k,ig,jc, jct, iwri, i, ij 
      integer izen   , ialt   , ig11   , ig12   , ig21   , ig22         &
     &               ,ig01, ig02                                        
      integer iy, im, id 
      integer jaer, jcld,  jalb, jtem 
                                                                        
! cfac = 2CLOUD ABOVE-BELOW FACTOR  (link to OPTION below)              
                                                                        
! CORRECT FACTORS BASED ON JTAB AND (jclb*jclbm-1)*(1-jcla*jclam)       
      data  cfac/       0.,6.175E-01,2.079E+00,1.774E+00,2.407E+00,     &
     &           2.479E+00,2.365E+00,1.495E+00,       0.,       0.,     &
     &           1.424E+00,1.732E+00,1.180E+00,1.202E+00,1.373E+00,     &
     &           1.538E+00,9.732E-01,       0.,0.000E+00,1.228E+00,     &
     &           1.911E+00,1.831E+00,8.667E-01,1.481E+00,1.170E+00,     &
     &           1.336E+00, 0.,0.,0.,0.,                                &
     &           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,                         &
     &           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,                         &
     &           0.,0.,0.,0.,0.,0./                                     
                                                                        
! ORIGINAL (OLD) FACTORS CALCULATED BASED  ON JTAB (old correct)        
! (4=1.319, 1.699,  1.839 2.147)                                        
!     data  cfac/ 0.,      5.973E-01,2.025E+00,1.839E+00,2.322E+00,     
!    *           2.397E+00,       0.,1.557E+00,       0.,       0.,     
!    *           1.470E+00,1.809E+00,1.187E+00,1.204E+00,1.400E+00,     
!    *           1.602E+00,9.530E-01,       0.,0.000E+00,1.234E+00,     
!    *           1.926E+00,1.877E+00,8.461E-01,1.531E+00,1.177E+00,     
!    *           1.373E+00, 0.,0.,0.,0.,                                
!    *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,                         
!    *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,                         
!    *           0.,0.,0.,0.,0.,0./                                     
                                                                        
! FACTORS CALCULATED BASED  ON JBASE (OLD)                              
!     data  cfac/ 0., 4.896E-01, 1.056E+00, 1.319E+00, 1.134E+00,       
!    *           1.215E+00,   0., 1.255E+00,  0.     ,   0.      ,      
!    *           1.189E+00,1.343E+00,9.741E-01,9.885E-01,1.145E+00,     
!    *           1.281E+00, 7.782E-01,   0.   ,0.000E+00,1.011E+00,     
!    *           1.218E+00,1.281E+00,6.906E-01,1.227E+00, 9.677E-01,    
!    *           1.122E+00, 0.,0.,0.,0.,                                
!    *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,                         
!    *           0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,                         
!    *           0.,0.,0.,0.,0.,0./                                     
                                                                        
! -----------------------------------------------------------------     
                                                                        
! VECTOR PARAMETER - MAYBE ADD LATER                                    
!     kk=1                                                              
                                                                        
! TEST WRITE INDEX (=1 to write)                                        
!  (=2 for SPECIAL WRITE TO 58-for 2CLOUD ABOVE-BELOW PARAMETERIZATION) 
      iwri=0 
                                                                        
! PI                                                                    
      ppi= 3.141592653559 
                                                                        
! INDEX OPTION:  jaer (=6), jcld (originally =9) jalb (=8)              
      jaer=6 
      jcld=9 
      jalb=8 
      jtem=13 
                                                                        
! OPTION:  TOTAL NUMBER OF J-VALUES TO BE READ. (jct=4 test 26 trop 56 f
!     jct=4                                                             
      jct=26 
                                                                        
! PRELIMINARY:  ENTER JVALS AS ZERO.                                    
! RETURN IF ZENITH>94.  (CUT IF VECTORIZED)                             
      do jc=1,jct 
       jval(   jc) = 0. 
      enddo 
      if(jparam(   1).ge.hvmat(1, nhv(1)) ) return 
                                                                        
                                                                        
! LOOP:  Establish index and fractions for each j-parameter             
!  Note:  allow for hvmat intervals monotonically increasing or decreasi
!  Note:  SKIP (but do not exit) for nhv=1.                             
!  NOTE:  Loop was 1,20; before TEMP.  Does DATE use this?  Probably not
!     do i=1,20                                                         
      do i=1,19 
       jfx(    i) = 0. 
       if(nhv(i).le.0) go to 101 
       if(nhv(i).eq.1) go to 100 
                                                                        
! SPECIAL TEMPERATURE:                                                  
!    (not here!  AFTER jfx() set, reset.)                               
!    jfx(jtem)=2.  Only  one value.                                     
                                                                        
! Test to exit if matrix intervals are zero                             
!  (note:  matrix must be monotonically increasing or decreasing)       
       if(hvmat(i,1).eq.hvmat(i,nhv(i)) ) go to 100 
       do j=1,(nhv(i)-1) 
        if(hvmat(i,j).eq.hvmat(i,j+1) ) go to 100 
       enddo 
                                                                        
! Enter fraction for parameter outside matrix range                     
        if(hvmat(i,1).lt.hvmat(i,nhv(i))  ) then 
         if(jparam(    i).le.hvmat(i,1))  jfx(    i) = 1.0 
         if(jparam(    i).ge.hvmat(i,nhv(i)))                           &
     &                           jfx(    i) = float(nhv(i))             
        endif 
        if(hvmat(i,1).gt.hvmat(i,nhv(i)) ) then 
         if(jparam(    i).ge.hvmat(i,1))  jfx(    i) = 1.0 
         if(jparam(    i).le.hvmat(i,nhv(i)))                           &
     &                           jfx(    i) = float(nhv(i))             
        endif 
                                                                        
! Enter fraction for parameter inside matrix range                      
        do j=1,(nhv(i)-1) 
         if(  (jparam(    i).ge.hvmat(i,j).and.                         &
     &         jparam(    i).le.hvmat(i,j+1)).or.                       &
     &        (jparam(    i).le.hvmat(i,j).and.                         &
     &         jparam(    i).ge.hvmat(i,j+1))  ) then                   
         jfx(    i) = float(j) +                                        &
     &    (jparam(   i)-hvmat(i,j))/(hvmat(i,j+1)-hvmat(i,j))           
         endif 
        enddo 
                                                                        
! SPECIAL TEMPERATURE:                                                  
!    jfx(jtem)=2.  Only  one value is entered in hvarray matrix for jtem
!    This represents  delta  parameter for t(ialt)+10 degrees.          
!    jfx(jtem)=2 ensures that  jtem interpolation will  select jfrac(jte
!    as zenith/altitude interpolation from this one data set.           
!    (jfx(jtem)=1 would correspond to base case parameter value = hvmatz
                                                                        
      if(i.eq.jtem) jfx(i)=2. 
                                                                        
! TEST WRITE                                                            
          if(iwri.eq.1) then 
        write(57,111) i, jparam(i), jfx(i) 
  111    format(' TEST I JPARAM JFX (then hvmat(i,j)):', i5,2f10.3) 
        write(57,112) (hvmat(i,j),j=1,nhv(i)) 
  112    format(8f10.3) 
           endif 
                                                                        
! END LOOP:  establish index and fraction for j-parameters              
  100 continue 
      enddo 
  101 continue 
                                                                        
! Establish ig parameters for base interpolation:  zenith and altitude  
!   zenith and altitude are controlled by ig index in jarray(k,ig,jc)   
!   ig11=lower zenith index, lower altitude index                       
!   ig12=upper zenith index, lower altitude index                       
!   ig21=lower zenith index, upper altitude index                       
!   ig22=upper zenith index, upper altitude index                       
                                                                        
!   ig01=lower zenith index, surface altitude index                     
!   ig02=upper zenith index, surface altitude index                     
                                                                        
!  NOTE:  TO VECTORIZE:  fzen, falt, izen, ialt, ig11, etc              
!    must all be vectors.  Skip.                                        
                                                                        
      izen    =int(jfx(    1)) 
      if(izen.eq.nhv(1)) izen=izen-1 
      fzen    =1.+float(izen    )-jfx(    1) 
      ialt    =int(jfx(    2)) 
      if(ialt.eq.nhv(2)) ialt=ialt-1 
      falt    =1.+float(ialt    )-jfx(    2) 
                                                                        
      ig11    = izen    +nhv(1)*(ialt    -1) 
      ig12    =ig11 
      if(izen    .lt.nhv(1)) ig12    =ig11    +1 
      ig21    =ig11 
      if(ialt    .lt.nhv(2)) ig21    =ig11    +nhv(1) 
      ig22    =ig21 
      if(izen    .lt.nhv(1)) ig22    =ig21    +1 
                                                                        
                                                                        
      ig01    = izen 
      ig02    =ig01 
      if(izen    .lt.nhv(1)) ig02    =ig01    +1 
                                                                        
! Establish base j-values.  Enter into jval output.                     
      do jc=1,jct 
       jval(   jc)=     jarray(1,ig11,jc)*fzen    *falt                 &
     &               +   jarray(1,ig12,jc)*(1.-fzen    )*falt           &
     &               +   jarray(1,ig21,jc)*fzen    *(1.-falt    )       &
     &               +   jarray(1,ig22,jc)*(1.-fzen    )*(1.-falt    )  
!                                                                       
! NONLINEAR CORRECTION for variation with altitude - NO EFFECT          
!  (effects HNO3 at 24 km, otherwise zero effect.)                      
       if(jval(  jc).gt.0.and.ialt.le.(nhv(2)-2)) then 
        x   = 2.*jarray(1,ig21,jc)/                                     &
     &        (jarray(1,ig11,jc)+jarray(1,(ig21+nhv(1)),jc))            &
     &     - 1.                                                         
        jval(   jc)=jval(   jc)* (1.+x*falt*(1.-falt)) 
       endif 
      enddo 
                                                                        
! TEST WRITE                                                            
            if(iwri.eq.1) then 
      write(57,301)    izen, ialt, ig11, ig12, ig21, ig22,              &
     &               fzen, falt                                         
  301  format(' TEST izen ialt ig11 ig12 ig21 ig22 fzen falt=',/,       &
     &          6i4,2f10.3)                                             
      write(57,302) jval(1), jarray(1,ig11,1), jarray(1,ig12,1),        &
     &   jarray(1,ig21,1), jarray(1,ig22,1)                             
      write(57,302) jval(2), jarray(1,ig11,2), jarray(1,ig12,2),        &
     &   jarray(1,ig21,2), jarray(1,ig22,2)                             
      write(57,302) jval(4), jarray(1,ig11,4), jarray(1,ig12,4),        &
     &   jarray(1,ig21,4), jarray(1,ig22,4)                             
  302   format(' TEST INITIAL JVAL:',  8(1PE10.3)) 
           endif 
                                                                        
!  LOOP: Establish fractional adjustments                               
!  LOOP for each fraction.  Set k-index                                 
      k=1 
!     do i=3,20                                                         
      do i=3,19 
                                                                        
!  Set initial fraction equal to base value                             
!   (watch special 11, 12! Make sure base value is OK if nhv=1 and skipp
        do jc=1,jct 
         jfrac(    i,jc)=1. 
        enddo 
                                                                        
!       if(i.eq.6)then                                                  
        if(i.eq.jaer)then 
         do jc=1,jct 
          jfaerz(jc)=1. 
         enddo 
        endif 
                                                                        
!       if(i.eq.9)then                                                  
        if(i.eq.jcld)then 
         do jc=1,jct 
           jfsur(jc)=1. 
         enddo 
        endif 
                                                                        
!  If nhv=1, skip this loop.  Automatically enter jfract=1.             
!    Note if nhv=1, values are omitted from jarray(k,ig,jc)             
       if(nhv(i).eq.1) go to 200 
!  If nhv=0, exit.                                                      
       if(nhv(i).le.0) go to 201 
                                                                        
! SPECIAL TEMPERATURE:                                                  
!   Just one array  value is entered for temperature array.             
!   Set  jfx(i) so that jfx(i)=nhv(i)=2.                                
!   This insures that jfrac(jtem)=direct interpol.  from single value.  
                                                                        
!  Establish adjustment factor and k-index for jarray (VECTORIZE)       
       kn   = k + int(jfx(   i)) 
       if(int(jfx(    i)).eq.nhv(i)) kn=kn-1 
       fkn    =1.+float(kn    -k)-jfx(     i     ) 
!                                                                       
!                                                                       
                                                                        
! TEST WRITE:                                                           
       if(fkn.lt.0.or.fkn.gt.1) write(56,251) i, k, kn,jfx(i), fkn 
  251   format ('ERROR fkn(<0 or>1): i k kn jfx fkn(0-1)=',3i3,2f10.4) 
                                                                        
! Establish fraction from jarray.                                       
!  Use zenith interpolation, itself interpolated between two fractions. 
      do jc=1,jct 
       jfrac(   i,jc)=     fkn*(                                        &
     &      jarray(kn,ig11,jc)*fzen    *falt                            &
     &  +   jarray(kn,ig12,jc)*(1.-fzen    )*falt                       &
     &  +   jarray(kn,ig21,jc)*fzen    *(1.-falt    )                   &
     &  +   jarray(kn,ig22,jc)*(1.-fzen    )*(1.-falt    )              &
     &                                           ) + (1.-fkn)*(         &
     &      jarray(kn+1,ig11,jc)*fzen    *falt                          &
     &  +   jarray(kn+1,ig12,jc)*(1.-fzen    )*falt                     &
     &  +   jarray(kn+1,ig21,jc)*fzen    *(1.-falt    )                 &
     &  +   jarray(kn+1,ig22,jc)*(1.-fzen    )*(1.-falt    )            &
     &                                                      )           
      enddo 
                                                                        
! Establish surface fraction-FOR SURFACE IMPACT OF CLOUD BELOW.         
!  This uses the CLOUD-BELOW value of cloud optical depth               
!   (from the 10th index)                                               
!  but it uses it with the CLOUD-ABOVE value (9th index)                
!  Representing the CLOUD-BELOW impact (as CLOUD ABOVE) at the surface. 
!  THIS IS USED TO ADJUST THE ALBEDO FRACTION (8)                       
                                                                        
! ALSO - EXPERIMENTAL - USED TO ADJUST CLOUD-ABOVE                      
!  TO CORRECT UNDERESTIMATE IN CASE WITH CLOUD-ABOVE AND CLOUD-BELOW.   
!  (totally empirical, no reason.)                                      
                                                                        
!     if(i.eq.10) then                                                  
      if(i.eq.jcld+1) then 
! TEST WRITE                                                            
      if(iwri.eq.1) write(57,307)                                       &
     &       jfrac(jalb,1), jfrac(jalb,2), jfrac(jalb,4)                
!    *       ,jfrac(jcld,1), jfrac(jcld,2), jfrac(jcld,4)               
  307 format('ALBEDO ADJUSTMENT FOR CLOUD-BELOW:',/,                    &
     &       'PRIOR    ALBEDO FR (O2 O1D NO2)=',3f12.6)                 
!    *        ,/,'PRIOR CLOUD-ABOVE  (O2 O1D NO2)=',3f12.6)             
      do jc=1,jct 
       jfsur(     jc)=     fkn*(                                        &
     &      jarray(kn-nhv(jcld),ig01,jc)*fzen                           &
     &  +   jarray(kn-nhv(jcld),ig02,jc)*(1.-fzen    )                  &
     &                                           ) + (1.-fkn)*(         &
     &      jarray(kn+1-nhv(jcld),ig01,jc)*fzen                         &
     &  +   jarray(kn+1-nhv(jcld),ig02,jc)*(1.-fzen    )                &
     &                                                      )           
!    *      jarray(kn-nhv(9),ig01,jc)*fzen                              
                                                                        
! ALBEDO                                                                
!     jfrac(8,jc)=1-jfsur(jc)*(1.-jfrac(8,jc))                          
      jfrac(jalb,jc)=1-jfsur(jc)*(1.-jfrac(jalb,jc)) 
! OLD 2CLOUD ABOVE-BELOW CORRECTION FACTOR -   (0, 0.2, 0.4*)           
! c     jfrac(9,jc)=1.-(1-jfrac(9,jc))*(0.8+0.2*jfsur(jc))              
! c     jfrac(9,jc)=1.-(1-jfrac(9,jc))*(0.6+0.4*jfsur(jc))              
! ORIGINAL 2CLOUD ABOVE-BELOW CORRECTION FACTOR -          (see data abo
!  WAS HERE, MOVED BELOW                                                
! c     jfrac(9,jc)=jfrac(9,jc)                                         
! c    *       *(1.+ cfac(jc)*(1.-jfsur(jc))*(1.-jfrac(9,jc)) )         
                                                                        
      enddo 
! TEST WRITE                                                            
      if(iwri.eq.1) write(57,308) jfsur(1), jfsur(2), jfsur(4),         &
     &       jfrac(jalb,1), jfrac(jalb,2), jfrac(jalb,4)                
!    *       ,jfrac(jcld,1), jfrac(jcld,2), jfrac(jcld,4)               
  308 format('SURFACE   CLOUD FR (O2 O1D NO2)=',3f12.6,/,               &
     &       'MODIFIED ALBEDO FR (O2 O1D NO2)=',3f12.6)                 
!    *       ,/,'MODIFIED CLOUDabove(O2 O1D NO2)=',3f12.6)              
                                                                        
! SPECIAL WRITE FOR CREATING 2CLOUD ABOVE-BELOW CORRECTION  FACTOR.     
!  was here, moved below.                                               
                                                                        
                                                                        
! END IF - Establish surface fraction and adjust albedo,  cloud above-be
      endif 
                                                                        
! Establish AEROSOL ZERO fraction:  case i=6, 1st fraction value.       
!   fraction k index is k+1 instead of kn                               
      if(i.eq.jaer) then 
      do jc=1,jct 
       jfaerz(     jc)=         (                                       &
     &      jarray(k+1,ig11,jc)*fzen    *falt                           &
     &  +   jarray(k+1,ig12,jc)*(1.-fzen    )*falt                      &
     &  +   jarray(k+1,ig21,jc)*fzen    *(1.-falt    )                  &
     &  +   jarray(k+1,ig22,jc)*(1.-fzen    )*(1.-falt    )             &
     &                                                      )           
      enddo 
      endif 
                                                                        
! TEST WRITE                                                            
           if(iwri.eq.1) then 
      write(57,309) i, k, kn, jfx(i), fkn 
  309  format('TEST INDEX I K KN JFX(I): kn=k+int(jfx):',3i3,2f10.4) 
      write(57,311) i,kn,fkn ,fzen, falt, jfrac(i,1) 
      write(57,311) i,kn,fkn ,fzen, falt, jfrac(i,2) 
      write(57,311) i,kn,fkn ,fzen, falt, jfrac(i,4) 
  311  format(' TEST FRACTION i,kn, fkn fzen falt jfrac =',/,2i5,5f10.4) 
      write(57,312)          jarray(kn,ig11,1), jarray(kn,ig12,1),      &
     &   jarray(kn,ig21,1), jarray(kn,ig22,1)                           &
     &                      ,jarray(kn+1,ig11,1), jarray(kn+1,ig12,1),  &
     &   jarray(kn+1,ig21,1), jarray(kn+1,ig22,1)                       
      write(57,312)          jarray(kn,ig11,2), jarray(kn,ig12,2),      &
     &   jarray(kn,ig21,2), jarray(kn,ig22,2)                           &
     &                      ,jarray(kn+1,ig11,2), jarray(kn+1,ig12,2),  &
     &   jarray(kn+1,ig21,2), jarray(kn+1,ig22,2)                       
      write(57,312)          jarray(kn,ig11,4), jarray(kn,ig12,4),      &
     &   jarray(kn,ig21,4), jarray(kn,ig22,4)                           &
     &                      ,jarray(kn+1,ig11,4), jarray(kn+1,ig12,4),  &
     &   jarray(kn+1,ig21,4), jarray(kn+1,ig22,4)                       
  312     format(8(1Pe10.3)) 
             endif 
                                                                        
! Special adjustment:  cloud height adjustment factors (j=11, 12)       
!  represent an adjustment to the cloud-above and cloud-below (j=9,10). 
!  These are converted to straight fractions here.                      
                                                                        
!  The adjustment parameter in the array is:                            
!      Fadj=(1-Ftot/Fcloud)/(1-Fcloud)                                  
!    where Ftot is combined fraction, Fcloud is cloud-alone fraction.   
!    Here, the adjustment factor Fadj is replaced with F':              
!  Where Ftot=Fc*F'; F'=1-Fadj(1-Fcloud);  F' limited, between 0.1 and 1
                                                                        
!  The same adjustment is applied for AEROSOL SSA (j=7)                 
!   as an adjustment to the AEROSOL OPTICAL DEPTH fraction (j=6)        
                                                                        
!     if(i.eq.11.or.i.eq.12          ) then                             
      if(i.eq.jcld+2.or.i.eq.jcld+3      ) then 
       ij=i-2 
       do jc=1,jct 
        jfrac(   i,jc)=1.- jfrac(    i,jc)*(1.-jfrac(   (ij ),jc)) 
        if(jfrac(    i,jc).lt.0.1) jfrac(    i,jc)=0.1 
        if(jfrac(    i,jc).gt.10.) jfrac(    i,jc)=10. 
       enddo 
! TEST WRITE                                                            
           if(iwri.eq.1) then 
       write(57,313) i, jfrac(i,1) 
       write(57,313) i, jfrac(i,2) 
       write(57,313) i, jfrac(i,4) 
  313   format(' TEST ADJ. FRACTION i, jfrac =',i5,2f10.4) 
           endif 
      endif 
                                                                        
! Special adjustment:  aerosol SSA (i=7)                                
!  represent an adjustment to the zero-aerosol fraction (i=6, jfaerz)   
!  These are converted to straight fractions here.                      
                                                                        
!  The adjustment parameter in the array is:                            
!      Fadj=(1-Ftot/Faerbase)/(1-Faerbase/Faerzero)                     
!    where Ftot is combined fraction, Faerbase is base aerosol and SSA f
!    and Faerzero is fraction for zero aerosol case.                    
!    (This is necessary because initial value, F=1, does not have zero a
!    Here, the adjustment factor Fadj is replaced with F':              
!  Where Ftot=Fc*F'; F'=1-Fadj(1-Faerbase/Faerzero);                    
!    F' limited, between 0.1 and 10.                                    
                                                                        
!     if(i.eq.7) then                                                   
      if(i.eq.jaer+1) then 
!       ij=6                                                            
        ij=jaer 
       do jc=1,jct 
        if(jfaerz(jc).gt.0) then 
          jfrac(   i,jc)=1.- jfrac(    i,jc)*                           &
     &      (1.-jfrac(   (ij ),jc)/jfaerz(jc))                          
        else 
          jfrac(   i,jc)=1.- jfrac(    i,jc)*                           &
     &      (1.-jfrac(   (ij ),jc)           )                          
        endif 
        if(jfrac(    i,jc).lt.0.1) jfrac(    i,jc)=0.1 
        if(jfrac(    i,jc).gt.10.) jfrac(    i,jc)=10. 
       enddo 
! TEST WRITE                                                            
           if(iwri.eq.1) then 
       write(57,313) i, jfrac(i,1) 
       write(57,313) i, jfrac(i,2)  , jfaerz(2) 
       write(57,313) i, jfrac(i,4) 
           endif 
      endif 
                                                                        
                                                                        
                                                                        
! Special adjustment:  albedo fraction in case of cloud-below.          
!  Adjust fractional change (relative to 1) based on                    
!    cloud-below impact on surface:                                     
                                                                        
!    (To do this:  establish special jfrac using CLOUD-BELOW jfx,       
!     but for CLOUD-ABOVE and for SURFACE.                              
!     Then adjust albedo fraction:  falb'=1-(1-falb)*fclsurf            
! DONE WITH jfsur() ABOVE.                                              
! --------------------                                                  
                                                                        
! 2CLOUD ABOVE-BELOW NONLINEAR ADJUSTMENT:  OPTION.                     
! For case with BOTH cloud-above and cloud-below,                       
!  table fractions underestimate j-values.                              
!  THIS IS TOTALLY EMPIRICAL-no reason for it.                          
!                                                                       
!    Cloud-above fraction is corrected:                                 
!    CLA' = F*(1-CLA*CLAm)*(CLB*CLBm-1)                                 
!     where CLA, CLAm=f9,  f11 (after modification);  CLB, CLBm=f10,f12.
! MOVED HERE - PREVIOUSLY w/ jfsur() ABOVE.                             
                                                                        
!      if(i.eq.12) then                                                 
       if(i.eq.jcld+3) then 
! TEST WRITE                                                            
         if(iwri.eq.1) write(57,317)                                    &
     &       jfrac(jcld,1), jfrac(jcld,2), jfrac(jcld,4)                &
     &       ,jfrac(jcld+1,4), jfrac(jcld+2,4), jfrac(jcld+3,4)         
  317 format('2CLOUD ABOVE-BELOW ADJUSTMENT:    ',/,                    &
     &       'PRIOR CLOUD-ABOVE  (O2 O1D NO2)=',3f12.6,/,               &
     &       'CLD-BELOW, CLaltA, CLaltB (NO2)=',3f12.6)                 
!    *       'jfrac10, 11, 12 (CLB,m)   (NO2)=',3f12.6)                 
        do jc=1,jct 
! 2CLOUD AB0VE-BELOW OPTION:  MODIFY HERE..  (use with data OPTION, abov
!  FINAL CORRECT VERSION                                                
!   with INDEX CONTROL:                                                 
!   WITHOUT INDEX                                                       
         if(jfrac(jcld,jc)*jfrac(jcld+2,jc).lt.1)                       &
     &   jfrac(jcld,jc)=jfrac(jcld,jc) *(1.+                            &
     &       cfac(jc)*(jfrac(jcld+1,jc)*jfrac(jcld+3,jc)-1.)*           &
     &                  (1.-jfrac(jcld,jc)*jfrac(jcld+2,jc)) )          
!        if(jfrac(9,jc)*jfrac(11,jc).lt.1)                              
!    *   jfrac(9,jc)=jfrac(9,jc) *(1.+                                  
!    *       cfac(jc)*(jfrac(10,jc)*jfrac(12,jc)-1.)*                   
!    *                  (1.-jfrac(9,jc)*jfrac(11,jc)) )                 
! OLDER-ORIGINAL MODIFICATION.  (use with data OPTION, above)           
!        jfrac(9,jc)=jfrac(9,jc) *(1.+                                  
!    *       cfac(jc)*(1.-jfsur(jc))*(1.-jfrac(9,jc)) )                 
        enddo 
! TEST WRITE                                                            
        if(iwri.eq.1) write(57,318)                                     &
     &       jfrac(jcld,1), jfrac(jcld,2), jfrac(jcld,4)                
  318   format( 'ADJUSTED CLOUD-ABOVE  (O2 O1D NO2)=',3f12.6,/,         &
     &       'jfrac10, 11, 12 (CLB,m)   (NO2)=',3f12.6)                 
       endif 
!                                                                       
!                                                                       
! SPECIAL WRITE FOR CREATING 2CLOUD ABOVE-BELOW CORRECTION  FACTOR.     
!  (Save table:  jfsur, jf9,jtab-base, jtuv, jtab for 26 species.       
!   Then cloud  factor f= (jtuv-jtab)/[jtab*jsurf*(1-jf9)]              
!    where j's are summed over table.                                   
       if(i.eq.jcld+3) then 
        if(iwri.ge.1) write(58,310) (jfsur(jc),jc=1,26) 
        if(iwri.ge.1) write(58,310) (jfrac( jcld,jc),jc=1,26) 
        if(iwri.ge.1) write(58,310) (jfrac(jcld+1,jc),jc=1,26) 
        if(iwri.ge.1) write(58,310) (jfrac(jcld+2,jc),jc=1,26) 
        if(iwri.ge.1) write(58,310) (jfrac(jcld+3,jc),jc=1,26) 
        if(iwri.ge.1) write(58,310) (jval(jc)    ,jc=1,26) 
        if(iwri.eq.1) write(57,310) (jfsur(jc),jc=1,26) 
        if(iwri.eq.1) write(57,310) (jfrac( jcld,jc),jc=1,26) 
        if(iwri.eq.1) write(57,310) (jfrac(jcld+1,jc),jc=1,26) 
        if(iwri.eq.1) write(57,310) (jfrac(jcld+2,jc),jc=1,26) 
        if(iwri.eq.1) write(57,310) (jfrac(jcld+3,jc),jc=1,26) 
        if(iwri.ge.1) write(57,310) (jval(jc)    ,jc=1,26) 
! 310     format(8f10.6)                                                
  310   format(8(1Pe10.3)) 
      endif 
                                                                        
! SPECIAL TEMPERATURE ADJUSTMENT:                                       
!   Just one array  value is entered for temperature array.             
!   Above, set  jfx(i) so that jfx(i)=nhv(i)=2.                         
!   This insures that jfrac(jtem)=direct interpol.  from single value.  
                                                                        
!   Here, establish temperature parameter from jparam(jtem)             
!    jparam(jtem)= dtem if less than  50;                               
!     else jparam(jtem)=temp, and dtem found as jparam(jtem)-t(alt)     
!      where t(alt), std temp, found  from interpolating hvmat(jtem,j), 
!                                                                       
!   Then  jfrac(jtem) = 1 + 0.1*dtem*jf(jtem); jf(jtem) is factor from t
!     (previously  entered as jfrac(jtem), interpolated for  zenith and 
!     (0.1 factor because jf(jtem) is % change for 10 degree increase.) 
                                                                        
!   OPTION - CHANGE JPARAM=dtem FOR TEST                                
                                                                        
       if(i.eq.jtem) then 
! TEST WRITE                                                            
        if(iwri.eq.1) write(57,331) i, jparam(i), jfrac(i,2),           &
     &          jfrac(i,4)                                              
  331   format(' TEST BEFORE TEMPERATURE ADJ: i, jparam,jfrac O1D,NO2=',&
     &          i5,4f10.4)                                              
                                                                        
        x=jparam(i) 
        if(jparam(i).gt.50) then 
         x= jparam(i)                                                   &
     &    -(hvmat(jtem,ialt)*falt + hvmat(jtem,ialt+1)*(1.-falt))       
! OPTIONAL LINE FOR TESTS                                               
!        jparam(i)=x                                                    
! TEST WRITE                                                            
         if(iwri.eq.1) write(57,332) ialt, falt, hvmat(jtem,ialt),      &
     &     hvmat(jtem,ialt+1)                                           
  332    format (' TEST ialt falt hvmat(jt,ialt), hvmat(jt,ia+1)=',     &
     &             i5, 5f10.4)                                          
        endif 
        do jc=1,jct 
         jfrac(jtem,jc)=1.  +  0.1*x*jfrac(jtem,jc) 
        enddo 
                                                                        
! TEST WRITE                                                            
       if(iwri.eq.1) write (57, 333) x, jfrac(jtem,2),jfrac(jtem,4) 
  333  format(' TEST AFTER  TEMPERATURE ADJ: dtem, fO1D, fNO2=',        &
     &    f10.4, 2(1Pe10.3))                                            
                                                                        
! END SPECIAL TEMPERATURE ADJUSTMENT                                    
       endif 
                                                                        
                                                                        
                                                                        
! -------                                                               
! ADJUST BASE -JVALUE BY FRACTION - WAS HERE, MOVED TO SEPARATE LOOP BEL
! ------                                                                
                                                                        
                                                                        
! ADVANCE K-COUNTER FOR NEXT LOOP                                       
!    (due to screw-up in TUVGRID1, advance even for NHV=1? No.)         
       if(nhv(i).gt.1) k=k+nhv(i) 
                                                                        
! END LOOP:  fractional adjustments                                     
  200  continue 
      enddo 
  201 continue 
                                                                        
! TEST J-VALUE  FINAL FRACTIONAL ADJUSTMENT                             
       if(iwri.eq.1.)                                                   &
     &    write(57,314)            jval(2),             jval(4)         
  314  format(' BEFORE-FRACTION jO1D,jNO2=',2(      1Pe10.3)) 
                                                                        
! LOOP TO ADJUST BASE J-VALUE BY FRACTION                               
                                                                        
      do i=3,19 
       if(nhv(i).gt.1) then 
                                                                        
! ADJUST BASE J-VALUE BY FRACTION                                       
       do jc=1,jct 
        jval(   jc) = jval(    jc)* jfrac(    i,jc) 
       enddo 
                                                                        
! TEST J-VALUE  FINAL FRACTIONAL ADJUSTMENT                             
       if(iwri.eq.1.and.jfrac(i,1).ne.1.and.jfrac(i,2).ne.1)            &
     &    write(57,316) i,jfrac(i,2), jval(2), jfrac(i,4), jval(4)      
  316  format(' FINAL J-CALC: F2,J2,F4,J4=',i3,2(f10.3,1Pe10.3)) 
                                                                        
       endif 
      enddo 
                                                                        
! DATE ADJUSTMENT:                                                      
!  ASSUME THAT INPUT jparam(20)= DATE  (decimal)                        
!    either as date factor (-1 to +1)                                   
!    or DAY NUMBER (1-365)                                              
!    or YYMMDD (not 00)                                                 
!    DAY FACTOR (X) IS cos(nd*2.*pi/365)                                
                                                                        
      x=jparam(20) 
      if(x.gt.1.and.x.lt.10000.) x=cos(2.*ppi*(jparam(20)/365.)) 
      if(x.ge.10000.) then 
       iy=int((x+0.001)/10000.) 
       im=int((x+0.001-10000.*float(iy))/100.) 
       id=int((x+0.001-10000.*float(iy)-100.*float(im))) 
       x=cos(2.*ppi*(float(id+30*(im-1))/365.) ) 
      endif 
                                                                        
! ADJUSTMENT:  x IS DAY FACTOR, -1. to +1.  NOW MAKE DAY ADJUSTMENT.    
      x=1.+0.0344*x 
! ADJUST BASE J-VALUE FOR DATE                                          
       do jc=1,jct 
        jval(   jc) = jval(    jc)* x 
       enddo 
                                                                        
 2000 return 
      END                                           
