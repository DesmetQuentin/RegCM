<HTML>

<HEAD>
<TITLE>mod_projections.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_projections.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_projections.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_projections><H3>mod_projections</H3></a></p>20:       module mod_projections
21: 
22:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : earthrad , eomeg2
23:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : mathpi , degrad , raddeg
24: 
25:       implicit none
26: 
27:       contains
28: 
<p><a name=lambrt><H3>lambrt</H3></a></p> Click <a href="./callingtree/lambrt_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where lambrt is used.
<hr>
29:       subroutine lambrt(xlon,xlat,smap,coriol,iy,jx,clon,clat,ds,idot,  &
30:                       & xn,truelatl,truelath)
31: 
32:       implicit none
33: !
34: ! Dummy arguments
35: !
36:       real(4) :: clat , clon , ds , truelath , truelatl , xn
37:       integer :: idot , iy , jx
38:       real(4) , dimension(iy,jx) :: coriol , smap , xlat , xlon
39:       intent (in) clat , clon , ds , idot , iy , jx , truelath ,        &
40:                 & truelatl
41:       intent (out) coriol , smap , xlat , xlon , xn
42: !
43: ! Local variables
44: !
45:       real(8) :: cell , cell1 , cell2 , cntri , cntrj , flp , flpp ,    &
46:                & pole , psi1 , psix , psx , r , xsign , truelat1 ,      &
47:                & truelat2 , x , xcntr , y , ycntr
48:       integer :: i , j
49: !
50: !     CLAT IS THE CENTRAL LATITUDE OF THE COARSE DOMAIN.
51: !     CLON IS THE CENTRAL LONGITUDE OF THE COARSE DOMAIN.
52: !
53: !     THIS ROUTINE CALCULATES MESO MAP(LAT,LONG,CORIOLIS,MAP SCALE)
54: !     FOR LAMBERT CONFORMAL PROJECTION
55: !
56: !     IY IS THE I DIMENSION FOR THIS DOMAIN.
57: !     JX IS THE J DIMENSION FOR THIS DOMAIN.
58: !     IDOT IS ICROSS ( = 1)  OR IDOT ( = 0).
59: !
60: !---------------------------------------------------------------------
61: !
62: !
63: !     XN IS CONE FACTOR FOR THE PROJECTION (FROM PROGRAM TERRAIN).
64: !     PSI1 IS THE COLATITUDE OF TRUELAT 1, IN RADIANS.
65: !     PI IS PI.
66: !
67: !---------------------------------------------------------------------
68: !
69:       if ( clat<0. ) then
70:         xsign = -1.       ! SOUTH HEMESPHERE
71:       else
72:         xsign = 1.        ! NORTH HEMESPHERE
73:       end if
74:       pole = xsign*90.0
75:  
76:       truelat1 = truelath
77:       truelat2 = truelatl
78:       if ( abs(truelat1-truelat2)>1.E-1 ) then
79:         xn = (dlog10(cos(truelat1*degrad))-dlog10(cos(truelat2*degrad)))&
80:            & /(dlog10(tan((45.0-xsign*truelat1/2.0)*degrad))            &
81:            & -dlog10(tan((45.0-xsign*truelat2/2.0)*degrad)))
82:       else
83:         xn = xsign*sin(truelat1*degrad)
84:       end if
85: !     XN=0.716
86:  
87:       psi1 = 90. - xsign*truelat1
88:       if ( clat<0. ) psi1 = -psi1
89: !
90:       psi1 = psi1*degrad
91:       cntrj = (jx+idot)/2.
92:       cntri = (iy+idot)/2.
93: !
94:       psx = (pole-clat)*degrad
95:       cell = earthrad*sin(psi1)/xn
96:       write (*,*) 'PSX,PSI1 = ' , psx , psi1
97:       cell2 = (tan(psx/2.))/(tan(psi1/2.))
98:       r = cell*(cell2)**xn
99:       xcntr = 0.
100:       ycntr = -r
101: !
102:       do j = 1 , jx
103:         x = xcntr + (j-cntrj)*ds
104:         do i = 1 , iy
105:           y = ycntr + (i-cntri)*ds
106:           r = sqrt(x*x+y*y)
107:           if ( y==0. ) then
108:             if ( x>=0. ) then
109:               flp = 90.*degrad
110:             else
111:               flp = -90.*degrad
112:             end if
113:           else if ( clat<0.0 ) then
114:             flp = atan2(x,y)
115:           else
116:             flp = atan2(x,-y)
117:           end if
118:           flpp = flp/xn/degrad + clon
119: !         IF (FLPP.GT.180.0) FLPP = FLPP-360.0
120: !         IF (FLPP.LT.-180.0) FLPP = FLPP+360.0
121:           xlon(i,j) = flpp
122:           if ( clat<0.0 ) r = -r
123:           cell = r*xn/(earthrad*sin(psi1))
124:           cell1 = tan(psi1/2.)*cell**(1./xn)
125:           cell2 = atan(cell1)
126:           psx = 2.*cell2/degrad
127:           xlat(i,j) = pole - psx
128:           psix = psx*degrad
129:           smap(i,j) = (sin(psi1)/sin(psix))                             &
130:                     & *((tan(psix/2.)/tan(psi1/2.))**xn)
131:         end do
132:       end do
133:       if ( idot==1 ) then
134:         do i = 1 , iy
135:           do j = 1 , jx
136:             coriol(i,j) = eomeg2*sin(xlat(i,j)*degrad)
137:           end do
138:         end do
139:       end if
140:       end subroutine lambrt
141: 
<p><a name=mappol><H3>mappol</H3></a></p> Click <a href="./callingtree/mappol_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where mappol is used.
<hr>
142:       subroutine mappol(xlon,xlat,xmap,coriol,iy,jx,clon,clat,delx,idot)
143: 
144:       implicit none
145: !
146: ! Dummy arguments
147: !
148:       real(4) :: clat , clon , delx
149:       integer :: idot , iy , jx
150:       real(4) , dimension(iy,jx) :: coriol , xlat , xlon , xmap
151:       intent (in) clat , clon , delx , idot , iy , jx
152:       intent (out) coriol , xlat , xlon , xmap
153: !
154: ! Local variables
155: !
156:       real(4) :: cell , cell1 , cell2 , cntri , cntrj , flp , flpp ,    &
157:                & pole , psi1 , psix , psx , r , x , xcntr , xn , y ,    &
158:                & ycntr
159:       integer :: i , ii1 , j , jj1
160: !
161: !     XN IS CONE FACTOR FOR THE PROJECTION (FROM PROGRAM TERRAIN).
162: !     PSI1 IS THE COLATITUDE OF TRUELAT 1, IN RADIANS.
163: !     PI IS PI.
164: !
165: !---------------------------------------------------------------------
166:  
167: !     COMPUTE LATS, LONS, AND MAP-SCALE FACTORS FOR
168: !     LAMBERT CONFORMAL MAP CENTERED AT CLON,CLAT. TRUE AT 30.N AND
169:  
170: !     60.N. IY IS NUMBER OF N-S POINTS.  JX IS NUMBER OF E-W POINTS.
171: !     CLON, CLAT IS LAT, LON OF CENTER OF GRID (DEGREES EAST, NORTH).
172: !     DELX IS GRID SPACING IN METERS.
173: !     ALWAYS FOR CROSS GRID.
174:  
175: !
176:       xn = 1.0
177: !
178:       pole = 90.
179:       psi1 = 30.
180:       psi1 = psi1*degrad
181:       if ( clat<0.0 ) then
182:         pole = -90.0
183:         psi1 = -30.
184:         psi1 = psi1*degrad
185:       end if
186:       cntrj = float(jx+idot)/2.
187:       cntri = float(iy+idot)/2.
188: !
189:       psx = (pole-clat)*degrad
190:       cell = earthrad*sin(psx)/xn
191:       cell2 = (1.+cos(psi1))/(1.+cos(psx))
192:       r = cell*(cell2)**xn
193:       xcntr = 0.
194:       ycntr = -r
195: !
196:       ii1 = iy
197:       jj1 = jx
198:       do i = 1 , ii1
199:         y = ycntr + (i-cntri)*delx
200:         do j = 1 , jj1
201:           x = xcntr + (j-cntrj)*delx
202:           r = sqrt(x*x+y*y)
203:           if ( y==0. ) then
204:             if ( x>=0. ) then
205:               flp = 90.*degrad
206:             else
207:               flp = -90.*degrad
208:             end if
209:           else if ( clat<0.0 ) then
210:             flp = atan2(x,y)
211:           else
212:             flp = atan2(x,-y)
213:           end if
214:           flpp = flp/xn/degrad + clon
215: !         IF (FLPP.GT.180.0) FLPP = FLPP-360.0
216: !         IF (FLPP.LT.-180.0) FLPP = FLPP+360.0
217:           xlon(i,j) = flpp
218:           if ( clat<0.0 ) r = -r
219:           cell = r/earthrad
220:           cell1 = cell/(1.0+cos(psi1))
221:           cell2 = atan(cell1)
222:           psx = 2.*cell2/degrad
223:           xlat(i,j) = pole - psx
224:           psix = psx*degrad
225:           xmap(i,j) = ((1.0+cos(psi1))/(1.0+cos(psix)))**xn
226:         end do
227:       end do
228:  
229:       if ( idot==1 ) then
230:         do i = 1 , iy
231:           do j = 1 , jx
232:             coriol(i,j) = eomeg2*sin(xlat(i,j)*degrad)
233:           end do
234:         end do
235:       end if
236:       end subroutine mappol
237: 
<p><a name=normer><H3>normer</H3></a></p> Click <a href="./callingtree/normer_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where normer is used.
<hr>
238:       subroutine normer(xlon,xlat,xmap,coriol,iy,jx,clon,clat,delx,idot)
239: 
240:       implicit none
241: !
242: ! Dummy arguments
243: !
244:       real(4) :: clat , clon , delx
245:       integer :: idot , iy , jx
246:       real(4) , dimension(iy,jx) :: coriol , xlat , xlon , xmap
247:       intent (in) clat , clon , delx , idot , iy , jx
248:       intent (out) coriol , xlat , xlon , xmap
249: !
250: ! Local variables
251: !
252:       real(4) :: c2 , cell , cntri , cntrj , deglat , phi1 , phictr ,   &
253:                & pole , x , xcntr , y , ycntr
254:       integer :: i , ii1 , j , jj1
255: !
256: !     COMPUTE LATS, LONS, AND MAP-SCALE FACTORS FOR
257: !     LAMBERT CONFORMAL MAP CENTERED AT CLON,CLAT. TRUE AT 30.N AND
258: !     60.N. IY IS NUMBER OF N-S POINTS.  JX IS NUMBER OF E-W POINTS.
259: !     CLON, CLAT IS LAT, LON OF CENTER OF GRID (DEGREES EAST, NORTH).
260: !     DELX IS GRID SPACING IN METERS.
261: !     ALWAYS FOR CROSS GRID.
262:  
263:       pole = 90.
264:       cntrj = (jx+idot)/2.
265:       cntri = (iy+idot)/2.
266:       if ( clat<0.0 ) pole = -90.0
267: !
268: !     FOR MERCATOR PROJECTION TRUE AT PHI1
269: !
270:       phi1 = 0.
271:       phi1 = phi1*degrad
272:       c2 = earthrad*cos(phi1)
273:       xcntr = 0.
274:       phictr = clat*degrad
275:       cell = cos(phictr)/(1.+sin(phictr))
276:       ycntr = -c2*log(cell)
277: !
278:       ii1 = iy
279:       jj1 = jx
280:       do i = 1 , ii1
281:         y = ycntr + (i-cntri)*delx
282:         do j = 1 , jj1
283:           x = xcntr + (j-cntrj)*delx
284: !
285: !         CALCULATIONS FOR MERCATOR
286: !
287:           xlon(i,j) = clon + ((x-xcntr)/c2)/degrad
288:           cell = exp(y/c2)
289:           xlat(i,j) = 2.*(atan(cell)/degrad) - 90.
290:           deglat = xlat(i,j)*degrad
291:           xmap(i,j) = cos(phi1)/cos(deglat)
292:         end do
293:       end do
294:  
295:       if ( idot==1 ) then
296:         do i = 1 , iy
297:           do j = 1 , jx
298:             coriol(i,j) = eomeg2*sin(xlat(i,j)*degrad)
299:           end do
300:         end do
301:       end if
302:  
303:       end subroutine normer
304: 
<p><a name=rotmer><H3>rotmer</H3></a></p> Click <a href="./callingtree/rotmer_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rotmer is used.
<hr>
305:       subroutine rotmer(xlon,xlat,xmap,coriol,iy,jx,clon,clat,pollon,   &
306:                       & pollat,ds,idot)
307: 
308:       implicit none
309: !
310: ! Dummy arguments
311: !
312:       real(4) :: clat , clon , ds , pollat , pollon
313:       integer :: idot , iy , jx
314:       real(4) , dimension(iy,jx) :: coriol , xlat , xlon , xmap
315:       intent (in) clat , clon , ds , idot , iy , jx
316:       intent (out) coriol , xlat , xlon , xmap
317: !
318: ! Local variables
319: !
320:       real(8) :: cntri , cntrj , ddeg , fai , xoff , yoff
321:       real(8) :: xr , yr , x , y , plat , plon
322:       integer :: i , j
323: !
324: !---------------------------------------------------------------------
325: !     COMPUTE LATS, LONS, MAP-SCALE FACTORS, AND CORIOLIS PARAMETER FOR
326: !     ROTATED POLE MAP CENTERED AT CLON,CLAT. ORIGIN OF ROTATED GRID IS
327: !     GIVEN BY POLLON AND POLLAT.
328: !     IMX,JMX,KSV,KSH AND LSIG2 MUST CORRESPOND TO IY,JMAX,KSTRPV,KSTRPH
329: !     AND NVERT2 IN THE MASTER INPUT FILE; OTHERWISE THE PROGRAM WILL
330: !     ABORT:LMX MUST BE THE MAXIMUM NUMBER OF LEVELS
331: !     (PRESSURE--OR--SIGMA) IMAXN AND IMXC ARE NESTED AND NON-EXPANDED
332: !     GRID DIMENSIONS. IMXC IS EQUAL TO IMX IF YOU ARE NOT USING THE
333: !     EXPANDED GRID. SAME FOR J.
334: !
335: !-----CENTER OF GRID
336: !
337:       cntrj = (jx+idot)/2.
338:       cntri = (iy+idot)/2.
339: 
340: !     GRID SPACING IN DEGREES
341: 
342:       ddeg = ds*raddeg/earthrad
343:       plat = pollat
344:       plon = pollon
345: !
346:       xoff = clon - pollon
347:       yoff = clat - pollat
348: !
349: !-----CALCULATE X AND Y POSITIONS OF GRID
350: !
351:       do i = 1 , iy
352:         do j = 1 , jx
353:           xr = xoff + (j-cntrj)*ddeg
354:           yr = yoff + (i-cntri)*ddeg
355: !
356: !-----NOW CALCULATE LAT AND LON OF THIS POINT
357: !-----    ROTATE COORDINATES BACK TO NONRATED POLE
358: !
359:           call <a href="./mod_projections.f90.html#rot2nrot" TARGET=CENT_PANEL>rot2nrot</a>(xr,yr,plon,plat,x,y)
360: !
361:           xlon(i,j) = x
362:           xlat(i,j) = y
363:           fai = degrad*yr
364:           xmap(i,j) = 1.0/cos(fai)
365:         end do
366:       end do
367:  
368:       if ( idot==1 ) then
369:         do i = 1 , iy
370:           do j = 1 , jx
371:             coriol(i,j) = eomeg2*sin(xlat(i,j)*degrad)
372:           end do
373:         end do
374:       end if
375:  
376:       end subroutine rotmer
377: 
<p><a name=rot2nrot><H3>rot2nrot</H3></a></p> Click <a href="./callingtree/rot2nrot_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rot2nrot is used.
<hr>
378:       subroutine rot2nrot(lams,phis,pollon,pollat,lam,phi)
379: 
380:       implicit none
381: !
382: ! Dummy arguments
383: !
384:       real(8) :: lam , lams , phi , phis , pollat , pollon
385:       intent (in) lams , phis , pollat , pollon
386:       intent (out) lam , phi
387: !
388: ! Local variables
389: !
390:       real(8) :: arg , plam , pphi , zarg1 , zarg2 , zcospol , zlampol ,&
391:               &  zlams , zphis , zsinpol
392: !
393: !----------------------------------------------------------------------------
394: !     Purpose:
395: !     Adaption of the DWD-Functions to convert rotated pole coordinates
396: !     (PHIS,LAMS) into geogrphic coordinates (PHI,LAM). The location of
397: !     the rotated pole is passed trough POLLON and POLLAT. POLLON and
398: !     POLLAT give the origin of the rotated grid. The
399: !     first four arguments are input, the last two are output. All
400: !     angles are in degrees (north>0, east>0)
401: !     History:
402: !     05/90   D.MAJEWSKI (DWD)
403: !     03/93   D.BRESCH (ETHZ)
404: !     09/96   D.LUETHI (ETHZ)
405:  
406:       plam = pollon + 180.
407:       pphi = 90. - pollat
408:  
409:       if ( plam>180. ) plam = plam - 360.
410:       zsinpol = sin(degrad*pphi)
411:       zcospol = cos(degrad*pphi)
412:       zlampol = degrad*plam
413:  
414:       zphis = 2*atan(exp(degrad*phis)) - atan(1.)*2.
415:       zlams = lams
416:       if ( zlams>180.0 ) zlams = zlams - 360.0
417:       zlams = degrad*zlams
418:  
419: !     first, the conversion of PHIS to PHI:
420:       arg = zcospol*cos(zphis)*cos(zlams) + zsinpol*sin(zphis)
421:       phi = raddeg*asin(arg)
422:  
423: !     follows conversion of LAMS to LAM:
424:       zarg1 = sin(zlampol)                                              &
425:             & *(-zsinpol*cos(zlams)*cos(zphis)+zcospol*sin(zphis))      &
426:             & - cos(zlampol)*sin(zlams)*cos(zphis)
427:       zarg2 = cos(zlampol)                                              &
428:             & *(-zsinpol*cos(zlams)*cos(zphis)+zcospol*sin(zphis))      &
429:             & + sin(zlampol)*sin(zlams)*cos(zphis)
430:       if ( abs(zarg2)>=1.E-37 ) then
431:         lam = raddeg*atan2(zarg1,zarg2)
432:       else if ( abs(zarg1)<1.E-37 ) then
433:         lam = 0.0
434:       else if ( zarg1>0. ) then
435:         lam = 90.0
436:       else
437:         lam = -90.0
438:       end if
439: 
440:       end subroutine rot2nrot
441: 
<p><a name=nrot2rot><H3>nrot2rot</H3></a></p> Click <a href="./callingtree/nrot2rot_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where nrot2rot is used.
<hr>
442:       subroutine nrot2rot(lam,phi,pollon,pollat,lams,phis)
443: 
444:       implicit none
445: !
446: ! Dummy arguments
447: !
448:       real(8) :: lam , lams , phi , phis , pollat , pollon
449:       intent (in) lam , phi , pollat , pollon
450:       intent (out) lams , phis
451: !
452: ! Local variables
453: !
454:       real(8) :: plam , pphi , zarg , zarg1 , zarg2 , zcospol , zlam ,  &
455:              &   zlampol , zphi , zsinpol
456: !
457: ! ----------------------------------------------------------------------
458: !     Purpose:
459: !     Adaption of the DWD-Functions to convert real geographical
460: !     coordinates (PHI,LAM) into coordinates in the rotated system
461: !     (PHIS,LAMS). The rotated pole is passed trough POLLON and POLLAT.
462: !     POLLON and POLLAT give the origin of the new rotated grid. The
463: !     first four arguments are input, the second two are output. All
464: !     angles are in degrees (north>0, east>0)
465: !     History:
466: !     05/90   D.MAJEWSKI (DWD), G. DE MORSIER (SMA)
467: !     03/93   D.BRESCH (ETHZ)
468: !     11/97   D.LUETHI (ETHZ)
469:  
470:       plam = pollon + 180.
471:       pphi = 90. - pollat
472:  
473:       if ( plam>180. ) plam = plam - 360.
474:  
475:       zsinpol = sin(degrad*pphi)
476:       zcospol = cos(degrad*pphi)
477:       zlampol = degrad*plam
478:  
479: !     first, the conversion of PHI to PHIS:
480:       zphi = degrad*phi
481:       zlam = lam
482:       if ( zlam>180.0 ) zlam = zlam - 360.0
483:       zlam = degrad*zlam
484:       zarg = zcospol*cos(zphi)*cos(zlam-zlampol) + zsinpol*sin(zphi)
485:       phis = asin(zarg)
486:       phis = log(tan(phis/2.+atan(1.)))*raddeg
487:  
488: !     now, the conversion for LAMS follws:
489:       zphi = degrad*phi
490:       zlam = lam
491:       if ( zlam>180.0 ) zlam = zlam - 360.0
492:       zlam = degrad*zlam
493:       zarg1 = -sin(zlam-zlampol)*cos(zphi)
494:       zarg2 = -zsinpol*cos(zphi)*cos(zlam-zlampol) + zcospol*sin(zphi)
495:       if ( abs(zarg2)>=1.E-37 ) then
496:         lams = raddeg*atan2(zarg1,zarg2)
497:       else if ( abs(zarg1)<1.E-37 ) then
498:         lams = 0.0
499:       else if ( zarg1>0. ) then
500:         lams = 90.0
501:       else
502:         lams = -90.0
503:       end if
504:  
505:       end subroutine nrot2rot
506: 
<p><a name=xyobsll><H3>xyobsll</H3></a></p> Click <a href="./callingtree/xyobsll_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where xyobsll is used.
<hr>
507:       subroutine xyobsll(iy,jx,iproj,clat,clon,plat,plon,truelath)
508:       use <a href="./mod_block.f90.html#mod_block" TARGET=CENT_PANEL>mod_block</a>
509:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : raddeg , degrad , erkm
510:       implicit none
511: !
512: ! Dummy arguments
513: !
514:       real(4) :: clat , clon , plat , plon , truelath
515:       character(6) :: iproj
516:       integer :: iy , jx
517:       intent (in) clat , clon , iproj , iy , jx , truelath
518: !
519: ! Local variables
520: !
521:       real(8) :: c2 , cell , cell2 , cntri , cntrj , flp , flpp ,       &
522:                & phi1 , phic , phir , phix , pole , psi1 , psx , r ,    &
523:                & xcntr , xlonx ,  xrot , ycntr
524:       real(8) :: xnr , ynr , xr , yr , pla , plo, cla , clo
525:       integer :: ie , je , ii , im , ilen
526: !
527:       pla = plat
528:       plo = plon
529:       cla = clat
530:       clo = clon
531:       ilen = iy*jx + 2
532:       ie = iy - 1
533:       je = jx - 1
534:       psi1 = 1.0D+36
535:       pole = 90.0D+00
536:       if ( iproj=='LAMCON' ) psi1 = 90. - truelath
537:       if ( iproj=='POLSTR' ) psi1 = 30.0
538:       psi1 = psi1/raddeg
539: 
540: !-----psi1 is colatitude of lat where cone or plane intersects earth
541: 
542:       cell = 0.0
543:       cell2 = 0.0
544:       ycntr = 0.0
545: 
546:       if ( cla<0. ) then
547:         if ( truelath>0. ) then
548:           psi1 = -(90.-truelath)
549:         else
550:           psi1 = -(90.+truelath)
551:         end if
552:         pole = -90.
553:         psi1 = psi1/raddeg
554:       end if
555:       if ( iproj=='LAMCON' .or. iproj=='POLSTR' ) then
556:         psx = (pole-cla)/raddeg
557:         if ( iproj=='LAMCON' ) then
558:           cell = erkm*sin(psi1)/xn
559:           cell2 = (tan(psx/2.))/(tan(psi1/2.))
560:         else if ( iproj=='POLSTR' ) then
561:           cell = erkm*sin(psx)/xn
562:           cell2 = (1.+cos(psi1))/(1.+cos(psx))
563:         else
564:         end if
565:         r = cell*(cell2)**xn
566:         xcntr = 0.0
567:         ycntr = -r
568:       end if
569:       cntrj = float(je)/2.
570:       cntri = float(ie)/2.
571: !
572: !-----grid incoming data.  grdltmn=minimum latitude of incoming data.
573: !-----grdlnmn=minimum longitude of incoming data.
574: !
575:       do ii = 1 , nobs
576:         im = ii - 1
577:         if ( iproj=='LAMCON' .or. iproj=='POLSTR' ) then
578:           xrot = clo + 90./xn
579:           phix = yobs(ii)
580:           xlonx = xobs(ii)
581:           flpp = (xlonx-xrot)/raddeg
582:           flp = xn*flpp
583:           psx = (pole-phix)/raddeg
584:           if ( iproj=='LAMCON' ) then
585:             cell = erkm*sin(psi1)/xn
586:             cell2 = (tan(psx/2.))/(tan(psi1/2.))
587:           else if ( iproj=='POLSTR' ) then
588:             cell = erkm*sin(psx)/xn
589:             cell2 = (1.+cos(psi1))/(1.+cos(psx))
590:           else
591:           end if
592:           r = cell*(cell2)**xn
593:           xobs(ii) = (r*cos(flp)-xcntr)*1000.
594:           yobs(ii) = (r*sin(flp)-ycntr)*1000.
595:           if ( cla<0.0 ) xobs(ii) = -xobs(ii)
596:         end if
597:         if ( iproj=='NORMER' ) then
598:           phi1 = 0.0   ! plat/raddeg
599:           phir = yobs(ii)/raddeg
600:           phic = cla/raddeg
601:           c2 = erkm*cos(phi1)
602:           cell = cos(phir)/(1.0+sin(phir))
603:           cell2 = cos(phic)/(1.0+sin(phic))
604:           ycntr = -c2*log(cell2)
605:           xobs(ii) = (c2*(xobs(ii)-clo)/raddeg)*1000.
606:           yobs(ii) = (-c2*log(cell)-ycntr)*1000.
607:         end if
608:         if ( iproj=='ROTMER' ) then
609:           xcntr = plo - clo
610:           ycntr = pla - cla
611:           xnr = xobs(ii)
612:           ynr = yobs(ii)
613:           call <a href="./mod_projections.f90.html#nrot2rot" TARGET=CENT_PANEL>nrot2rot</a>(xnr,ynr,plo,pla,xr,yr)
614:           xobs(ii) = erkm*degrad*(xcntr+xr)*1000.
615:           yobs(ii) = erkm*degrad*(ycntr+yr)*1000.
616:         end if
617:         ht(ii) = ht(ii)/100.
618:         ht2(ii) = ht2(ii)/100000.
619:       end do
620: 
621:       end subroutine xyobsll
622: !
623:       end module mod_projections
</PRE>

<HR>

</BODY>
</HTML>
