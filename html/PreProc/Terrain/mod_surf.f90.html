<HTML>

<HEAD>
<TITLE>mod_surf.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_surf.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_surf.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_surf><H3>mod_surf</H3></a></p>20:       module mod_surf
21: 
22:       contains
23: 
<p><a name=surf><H3>surf</H3></a></p> Click <a href="./callingtree/surf_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where surf is used.
<hr>
24:       subroutine surf(xlat,xlon,lnduse,iy,jx,incr,dsgrid,lndout,land,   &
25:                     & nrec,h2opct,lsmtyp,sanda,sandb,claya,clayb,       &
26:                     & frac_lnd,nveg,aertyp,intext,texout,frac_tex,ntex)
27:       use <a href="./mod_block.f90.html#mod_block" TARGET=CENT_PANEL>mod_block</a>
28:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : bint
29:       implicit none
30: !
31: ! Dummy arguments
32: !
33:       character(7) :: aertyp
34:       real(4) :: dsgrid , h2opct
35:       integer :: incr , iy , jx , nrec , ntex , nveg
36:       character(4) :: lsmtyp
37:       real(4) , dimension(iy,jx) :: claya , clayb , lndout , sanda ,    &
38:                                   & sandb , texout , xlat , xlon
39:       real(4) , dimension(iy,jx,nveg) :: frac_lnd
40:       real(4) , dimension(iy,jx,ntex) :: frac_tex
41:       integer , dimension(iy,jx) :: intext , lnduse
42:       real(4) , dimension(iy,jx,2) :: land
43:       intent (in) aertyp , dsgrid , h2opct , incr , &
44:                 & iy , jx , lsmtyp , nrec , ntex , nveg , xlat
45:       intent (out) claya , clayb , frac_lnd , frac_tex , intext ,       &
46:                  & lnduse , sanda , sandb
47:       intent (inout) land , lndout , texout , xlon
48: !
49: ! Local variables
50: !
51:       logical :: flag
52:       integer :: i , ii , iindex , ilev , j , jindex , jj , k , lrec ,  &
53:                & lengdo , nbase
54:       real(4) , dimension(iy,jx,2) :: itex
55:       real(8) :: xx , yy
56: !
57: !---------------------------------------------------------------------
58: !
59: !     imx,jmx must correspond to iy,jx in the master input file;
60: !     otherwise the program will abort.
61: !
62: !-----------------------------------------------------------------------
63: !
64:       flag = .true.
65:       lrec = 0
66:       do k = 1 , 2
67:         do j = 1 , jx
68:           do i = 1 , iy
69:             land(i,j,k) = 0
70:             itex(i,j,k) = 0
71:           end do
72:         end do
73:       end do
74: !
75:       if ( aertyp(7:7)=='1' ) then
76:         if ( lsmtyp=='BATS' ) then
77:           lengdo = nveg + ntex
78:         else if ( lsmtyp=='USGS' ) then
79:           lengdo = nveg + 4 + ntex
80:         else
81:         end if
82:       else if ( lsmtyp=='BATS' ) then
83:         lengdo = nveg
84:       else if ( lsmtyp=='USGS' ) then
85:         lengdo = nveg + 4
86:       else
87:       end if
88:       do ilev = 1 , lengdo
89:         rewind (48)
90:         do lrec = 1 , nrec
91:           read (48) stores
92:           jindex = (stores(2)-grdlnmn)*incr + 1.1
93:           iindex = (stores(1)-grdltmn)*incr + 1.1
94:           if ( iindex>iter .or. jindex>jter ) then
95:             print 99001 , iindex , jindex , lrec , stores(1) , stores(2)&
96:                 & , grdltmn , grdlnmn
97:             stop 60
98:           end if
99:           lnd8(iindex,jindex) = stores(ilev+4)
100:         end do
101: !
102:         if ( ilev<=nveg ) then
103:           do ii = 1 , iy
104:             do jj = 1 , jx
105:               yy = -(grdltmn-xlat(ii,jj))/dsgrid + 1.0
106:               if ( grdlnmn<=-180.0 .and. xlon(ii,jj)>0.0 ) xlon(ii,jj)  &
107:                  & = xlon(ii,jj) - 360.
108:               xx = -(grdlnmn-xlon(ii,jj))/dsgrid + 1.0
109:               lndout(ii,jj) = <a href="./mod_interp.f90.html#bint" TARGET=CENT_PANEL>bint</a>(yy,xx,lnd8,iter,jter,flag)
110:               frac_lnd(ii,jj,ilev) = lndout(ii,jj)
111: !
112: !             note: it is desirable to force grid boxes with less
113: !             than 75 percent water to be a land category,
114: !             even if water is the largest single category.
115: !
116:               if ( .not.(lsmtyp=='BATS' .and. (ilev==14 .or. ilev==15)  &
117:                  & .and. lndout(ii,jj)<h2opct) ) then
118:                 if ( lsmtyp/='USGS' .or. ilev/=25 .or. lndout(ii,jj)    &
119:                    & >=h2opct ) then
120:  
121:                   if ( lndout(ii,jj)>land(ii,jj,1) ) then
122:                     land(ii,jj,1) = lndout(ii,jj)
123:                     land(ii,jj,2) = ilev
124:                   end if
125:                 end if
126:               end if
127:             end do
128:           end do
129:         else if ( ((lsmtyp=='USGS' .and. ilev>nveg+4) .or.              &
130:                  &(lsmtyp=='BATS' .and. ilev>nveg)) .and. aertyp(7:7)   &
131:                  &=='1' ) then
132:           if ( lsmtyp=='BATS' ) then
133:             nbase = nveg
134:           else if ( lsmtyp=='USGS' ) then
135:             nbase = nveg + 4
136:           else
137:           end if
138:           do ii = 1 , iy
139:             do jj = 1 , jx
140:               yy = -(grdltmn-xlat(ii,jj))/dsgrid + 1.0
141:               if ( grdlnmn<=-180.0 .and. xlon(ii,jj)>0.0 ) xlon(ii,jj)  &
142:                  & = xlon(ii,jj) - 360.
143:               xx = -(grdlnmn-xlon(ii,jj))/dsgrid + 1.0
144:               texout(ii,jj) = <a href="./mod_interp.f90.html#bint" TARGET=CENT_PANEL>bint</a>(yy,xx,lnd8,iter,jter,flag)
145:               frac_tex(ii,jj,ilev-nbase) = texout(ii,jj)
146: !
147: !             note: it is desirable to force grid boxes with less
148: !             than 75 percent water to be a land category,
149: !             even if water is the largest single category.
150: !
151:               if ( lsmtyp/='BATS' .or. ilev/=nveg+14 .or. texout(ii,jj) &
152:                  & >=h2opct ) then
153:                 if ( lsmtyp/='USGS' .or. ilev/=nveg+18 .or.             &
154:                    & texout(ii,jj)>=h2opct ) then
155:                   if ( texout(ii,jj)>itex(ii,jj,1) ) then
156:                     itex(ii,jj,1) = texout(ii,jj)
157:                     if ( lsmtyp=='BATS' ) then
158:                       itex(ii,jj,2) = ilev - nbase
159:                     else if ( lsmtyp=='USGS' ) then
160:                       itex(ii,jj,2) = ilev - nbase
161:                     else
162:                     end if
163:                   end if
164:                 end if
165:               end if
166:             end do
167:           end do
168:         else if ( lsmtyp=='USGS' ) then
169:           do ii = 1 , iy
170:             do jj = 1 , jx
171:               yy = -(grdltmn-xlat(ii,jj))/dsgrid + 1.0
172:               if ( grdlnmn<=-180.0 .and. xlon(ii,jj)>0.0 ) xlon(ii,jj)  &
173:                  & = xlon(ii,jj) - 360.
174:               xx = -(grdlnmn-xlon(ii,jj))/dsgrid + 1.0
175:               if ( ilev==nveg+1 ) then
176:                 sanda(ii,jj) = <a href="./mod_interp.f90.html#bint" TARGET=CENT_PANEL>bint</a>(yy,xx,lnd8,iter,jter,flag)
177:               else if ( ilev==nveg+2 ) then
178:                 sandb(ii,jj) = <a href="./mod_interp.f90.html#bint" TARGET=CENT_PANEL>bint</a>(yy,xx,lnd8,iter,jter,flag)
179:               else if ( ilev==nveg+3 ) then
180:                 claya(ii,jj) = <a href="./mod_interp.f90.html#bint" TARGET=CENT_PANEL>bint</a>(yy,xx,lnd8,iter,jter,flag)
181:               else if ( ilev==nveg+4 ) then
182:                 clayb(ii,jj) = <a href="./mod_interp.f90.html#bint" TARGET=CENT_PANEL>bint</a>(yy,xx,lnd8,iter,jter,flag)
183:               else
184:               end if
185:             end do
186:           end do
187:         else
188:         end if
189:       end do
190: !
191:       do i = 1 , iy
192:         do j = 1 , jx
193:           lndout(i,j) = land(i,j,2)
194:           lnduse(i,j) = int(land(i,j,2))
195:           if ( aertyp(7:7)=='1' ) then
196:             texout(i,j) = itex(i,j,2)
197:             intext(i,j) = int(itex(i,j,2))
198:           end if
199:         end do
200:       end do
201: !
202: !
203: !-----grid the data.  grdltmn=minimum latitude of incoming data.
204: !-----grdlnmn = minimum longitude of incoming data.  point(1,1)
205: !-----is value at (grdltmn,grdlnmn)
206: !
207: 99001 format (1x,'*** iindex = ',i4,'   jindex = ',i4,'   lrec = ',i5,  &
208:              &'   lat = ',f10.3,3x,'lon = ',f10.3,3x,'grdltmn = ',f10.3,&
209:             & 5x,'grdlnmn = ',f10.3)
210: !
211:       end subroutine surf
212: 
213:       end module mod_surf
</PRE>

<HR>

</BODY>
</HTML>
