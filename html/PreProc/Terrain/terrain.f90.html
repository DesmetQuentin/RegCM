<HTML>

<HEAD>
<TITLE>terrain.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>terrain.f90</H1>
<HR>
<H2 ALIGN=CENTER>terrain.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=terrain><H3>terrain</H3></a></p>20:       program terrain
21: !
22: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
23: !                                                                      !
24: !   TERRAIN is the first component of the REGional Climate Modeling    !
25: !   (RegCM) system version 3.0 and used to access archived terrain     !
26: !   height and landuse charactistics data at regular latitude-         !
27: !   longititude intervals and interpolate to the mesoscale grid for    !
28: !   a specified map projection.                                        !
29: !                                                                      !
30: !                                     PWC group, Abdus Salam ICTP      !
31: !                                                   May. 27, 2006      !
32: !                                                                      !
33: !   The authors wish to acknowledge the authors of NCAR MM4/5          !
34: !   terrain codes, their works is our code base.                       !
35: !                                                                      !
36: !       MM4 terrain code: A. Mcnab, T. Tarbell and N. Seaman           !
37: !                         C. Larkin and N. Seaman  (before 1986)       !
38: !       MM5 terrain code: Yong-Run Guo and Sue Chen  10/21/1993        !
39: !                                                                      !
40: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
41: !
42: !  In the present version of RegCM, all the variables, which directly
43: !  related to map factors, are just calculated and stored in TERRAIN
44: !  for later use.
45: !
46: !  This program reads terrain height data from the NCAR air force
47: !  terrain tapes (1 deg., 30', or 5') or terrain and landuse data
48: !  from the PSU/NCAR combined landuse tapes (1 deg., 30', 10'), or 10'
49: !  GLCC landuse data (Loveland et al 1999) and analyzes heights and/or
50: !  landuse values to a given grid.
51: !
52: !  terrain will be read from unit 12, landuse from unit 10 or 11,
53: !  output variables unit 9.
54: !---------------------------------------------------------------------
55:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
56:       use <a href="./mod_maps.f90.html#mod_maps" TARGET=CENT_PANEL>mod_maps</a>
57:       use <a href="./mod_block.f90.html#mod_block" TARGET=CENT_PANEL>mod_block</a>
58:       use <a href="./mod_smooth.f90.html#mod_smooth" TARGET=CENT_PANEL>mod_smooth</a> , only : smth121 , smthtr
59:       use <a href="./mod_projections.f90.html#mod_projections" TARGET=CENT_PANEL>mod_projections</a> , only : lambrt , mappol , normer , rotmer ,  &
60:                                 &  xyobsll
61:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : anal2 , interp
62:       use <a href="./mod_fudge.f90.html#mod_fudge" TARGET=CENT_PANEL>mod_fudge</a> , only : lndfudge , texfudge , lakeadj
63:       use <a href="./mod_rdldtr.f90.html#mod_rdldtr" TARGET=CENT_PANEL>mod_rdldtr</a> , only : rdldtr , rdldtr_nc
64:       use <a href="./mod_write.f90.html#mod_write" TARGET=CENT_PANEL>mod_write</a> , only : setup , output
65:       use <a href="./mod_header.F90.html#mod_header" TARGET=CENT_PANEL>mod_header</a> , only : header
66:       use <a href="./mod_surf.f90.html#mod_surf" TARGET=CENT_PANEL>mod_surf</a> , only : surf
67:       implicit none
68: !
69: ! Local variables
70: !
71:       integer :: maxiter , maxjter , maxdim
72:       character(256) :: char_lnd , char_tex
73:       character(256) :: namelistfile , prgname
74:       character(256) :: ctlfile_s , datafile_s
75:       character(256) :: ctlfile , datafile
76:       integer :: i , j , k , minsize , ierr , i0 , j0 , m , n
77:       logical :: ibndry
78:       integer :: nunitc , nunitc_s , ctlunit , ctlunit_s
79:       real(4) :: clong , dsx , dsx_s , htave , htgrid_a
80: !
81:       call <a href="./mod_header.F90.html#header" TARGET=CENT_PANEL>header</a>(1)
82: !
83: !     Read input global namelist
84: !
85:       call <a href="#" TARGET=CENT_PANEL>getarg</a>(0, prgname)
86:       call <a href="#" TARGET=CENT_PANEL>getarg</a>(1, namelistfile)
87:       call <a href="./mod_dynparam.F90.html#initparam" TARGET=CENT_PANEL>initparam</a>(namelistfile, ierr)
88:       if ( ierr/=0 ) then
89:         write ( 6, * ) 'Parameter initialization not completed'
90:         write ( 6, * ) 'Usage : '
91:         write ( 6, * ) '          ', trim(prgname), ' regcm.in'
92:         write ( 6, * ) ' '
93:         write ( 6, * ) 'Check argument and namelist syntax'
94:         stop
95:       end if
96: !
97: !     Preliminary consistency check to avoid I/O format errors
98: !
99:       minsize = (kz+1)+16
100:       if ((iym2*jxm2) .lt. minsize) then
101:         write (6, *) 'Please increase domain size.'
102:         write (6, *) 'Minsize (iy-2)*(jx-2) is ', minsize
103:         call <a href="#" TARGET=CENT_PANEL>abort</a>
104:       end if
105: 
106:       call <a href="./mod_maps.f90.html#allocate_grid" TARGET=CENT_PANEL>allocate_grid</a>(iy,jx,kz,nveg,ntex)
107:       if ( nsg>1 ) call <a href="./mod_maps.f90.html#allocate_subgrid" TARGET=CENT_PANEL>allocate_subgrid</a>(iysg,jxsg,nveg,ntex)
108: !
109: !     Setup hardcoded sigma levels
110: 
111:       if ( kz==14 ) then                      ! RegCM2
112:         sigma(1) = 0.0
113:         sigma(2) = 0.04
114:         sigma(3) = 0.10
115:         sigma(4) = 0.17
116:         sigma(5) = 0.25
117:         sigma(6) = 0.35
118:         sigma(7) = 0.46
119:         sigma(8) = 0.56
120:         sigma(9) = 0.67
121:         sigma(10) = 0.77
122:         sigma(11) = 0.86
123:         sigma(12) = 0.93
124:         sigma(13) = 0.97
125:         sigma(14) = 0.99
126:         sigma(15) = 1.0
127:       else if ( kz==18 ) then                 ! RegCM3, default
128:         sigma(1) = 0.0
129:         sigma(2) = 0.05
130:         sigma(3) = 0.10
131:         sigma(4) = 0.16
132:         sigma(5) = 0.23
133:         sigma(6) = 0.31
134:         sigma(7) = 0.39
135:         sigma(8) = 0.47
136:         sigma(9) = 0.55
137:         sigma(10) = 0.63
138:         sigma(11) = 0.71
139:         sigma(12) = 0.78
140:         sigma(13) = 0.84
141:         sigma(14) = 0.89
142:         sigma(15) = 0.93
143:         sigma(16) = 0.96
144:         sigma(17) = 0.98
145:         sigma(18) = 0.99
146:         sigma(19) = 1.0
147:       else if ( kz==23 ) then                 ! MM5V3
148:         sigma(1) = 0.0
149:         sigma(2) = 0.05
150:         sigma(3) = 0.1
151:         sigma(4) = 0.15
152:         sigma(5) = 0.2
153:         sigma(6) = 0.25
154:         sigma(7) = 0.3
155:         sigma(8) = 0.35
156:         sigma(9) = 0.4
157:         sigma(10) = 0.45
158:         sigma(11) = 0.5
159:         sigma(12) = 0.55
160:         sigma(13) = 0.6
161:         sigma(14) = 0.65
162:         sigma(15) = 0.7
163:         sigma(16) = 0.75
164:         sigma(17) = 0.8
165:         sigma(18) = 0.85
166:         sigma(19) = 0.89
167:         sigma(20) = 0.93
168:         sigma(21) = 0.96
169:         sigma(22) = 0.98
170:         sigma(23) = 0.99
171:         sigma(24) = 1.0
172:       else
173:         write (*,*) 'You vertical level number is not 14, 18, or 23'
174:         write (*,*) 'Please set your sigma parameters in OUTPUT'
175:         stop
176:       end if
177: 
178: !---------------------------------------------------------------------
179: !
180: !     iblk = dimension of arrays xobs,yobs,ht,htsd
181: !     estimate iblk = ihmax*jhmax where ihmax = (xmaxlat-xminlat)/xnc
182: !     and jhmax = (xmaxlon-xminlon)/xnc.  xnc = 1,0.5,1./6.or 5./60. for
183: !     1 deg, 30 min, 10 min or 5 min data, respectively.  add 1-2000 to
184: !     estimate of iblk for safety.  if you underestimate the
185: !     dimensions the program will abort with a diagnostic message
186: !     indicating the correct dimensions required .
187: !     iter,jter = dimensions of array lnd8.
188: !     within the search region. at present, iter and jter must be
189: !     equal and >= max(ihmax,jhmax) where ihmax and jhmax are
190: !     as calculated above.
191: !
192:       open (48,status='scratch',form='unformatted')
193: 
194:       dxcen = 0.0
195:       dycen = 0.0
196: !
197:       clong = clon
198:       if ( clong>180. ) clong = clong - 360.
199:       if ( clong<=-180. ) clong = clong + 360.
200:       nunitc  = 109
201:       ctlunit = 110
202:       if ( nsg>1 ) then
203:         nunitc_s  = 119
204:         ctlunit_s = 120
205:         write (datafile_s,99001)                                        &
206:               & trim(dirter), pthsep, trim(domname) , nsg , '.INFO'
207:         write (ctlfile_s,99001)                                         &
208:               & trim(dirter), pthsep, trim(domname) , nsg , '.CTL'
209:         call <a href="./mod_write.f90.html#setup" TARGET=CENT_PANEL>setup</a>(nunitc_s,ctlunit_s,iysg,jxsg,ntypec_s,iproj,ds/nsg,  &
210:                  & clat,clong,igrads,ibyte,datafile_s,ctlfile_s)
211:         if ( iproj=='LAMCON' ) then
212:           call <a href="./mod_projections.f90.html#lambrt" TARGET=CENT_PANEL>lambrt</a>(xlon_s,xlat_s,xmap_s,coriol_s,iysg,jxsg,clong,    &
213:                     & clat,dsinm,0,xn,truelatl,truelath)
214:           call <a href="./mod_projections.f90.html#lambrt" TARGET=CENT_PANEL>lambrt</a>(dlon_s,dlat_s,dmap_s,coriol_s,iysg,jxsg,clong,    &
215:                     & clat,dsinm,1,xn,truelatl,truelath)
216:           write (*,*) 'XN,TRUELATL,TRUELATH = ' , xn , truelatl ,       &
217:                     & truelath
218:         else if ( iproj=='POLSTR' ) then
219:           call <a href="./mod_projections.f90.html#mappol" TARGET=CENT_PANEL>mappol</a>(xlon_s,xlat_s,xmap_s,coriol_s,iysg,jxsg,clong,    &
220:                     & clat,dsinm,0)
221:           call <a href="./mod_projections.f90.html#mappol" TARGET=CENT_PANEL>mappol</a>(dlon_s,dlat_s,dmap_s,coriol_s,iysg,jxsg,clong,    &
222:                     & clat,dsinm,1)
223:           xn = 1.
224:         else if ( iproj=='NORMER' ) then
225:           call <a href="./mod_projections.f90.html#normer" TARGET=CENT_PANEL>normer</a>(xlon_s,xlat_s,xmap_s,coriol_s,iysg,jxsg,clong,    &
226:                     & clat,dsinm,0)
227:           call <a href="./mod_projections.f90.html#normer" TARGET=CENT_PANEL>normer</a>(dlon_s,dlat_s,dmap_s,coriol_s,iysg,jxsg,clong,    &
228:                     & clat,dsinm,1)
229:           xn = 0.
230:         else if ( iproj=='ROTMER' ) then
231:           call <a href="./mod_projections.f90.html#rotmer" TARGET=CENT_PANEL>rotmer</a>(xlon_s,xlat_s,xmap_s,coriol_s,iysg,jxsg,clon,     &
232:                     & clat,plon,plat,dsinm,0)
233:           call <a href="./mod_projections.f90.html#rotmer" TARGET=CENT_PANEL>rotmer</a>(dlon_s,dlat_s,dmap_s,coriol_s,iysg,jxsg,clon,     &
234:                     & clat,plon,plat,dsinm,1)
235:           xn = 0.
236:         else
237:           print * , 'iproj MAP PROJECTION IS NOT AN OPTION'
238:           stop 999
239:         end if
240:         dsx_s = dsinm
241:         print * , 'after calling MAP PROJECTION, for subgrid'
242: !
243: !       reduce the search area for the domain
244: !       [minlat:maxlat,minlon:maxlon]
245:         call <a href="./mod_block.f90.html#mxmnll" TARGET=CENT_PANEL>mxmnll</a>(iysg,jxsg,clong,xlon_s,xlat_s,ntypec_s)
246:         print * , 'after calling MXMNLL, for subgrid'
247: !
248:         maxiter = (xmaxlat-xminlat)/xnc
249:         maxjter = (xmaxlon-xminlon)/xnc
250:         maxdim = max(maxiter,maxjter) + 1000
251:         print *, 'Allocating ' , maxdim
252:         call <a href="./mod_block.f90.html#allocate_block" TARGET=CENT_PANEL>allocate_block</a>(maxdim,maxdim)
253: !
254: !       read in the terrain & landuse data
255:         if ( itype_in==1 ) then
256:           call <a href="./mod_rdldtr.f90.html#rdldtr" TARGET=CENT_PANEL>rdldtr</a>(inpter,ntypec_s,nveg,ntex,lsmtyp,aertyp,ibyte)
257:           print * , 'after calling RDLDTR_s, for subgrid'
258:         else if ( itype_in==2 ) then
259:           call <a href="./mod_rdldtr.f90.html#rdldtr_nc" TARGET=CENT_PANEL>rdldtr_nc</a>(inpter,ntypec_s,nveg,ntex,lsmtyp,aertyp)
260:           print * , 'after calling RDLDTR_nc, for subgrid'
261:         else
262:           print * , 'Unknown Itype for input'
263:           stop
264:         endif
265:         if ( ifanal ) then
266: !         convert xobs and yobs from LON and LAT to x and y in mesh
267:           call <a href="./mod_projections.f90.html#xyobsll" TARGET=CENT_PANEL>xyobsll</a>(iysg,jxsg,iproj,clat,clong,plat,plon,        &
268:                      & truelath)
269:           print * , 'after calling XYOBSLL, for subgrid'
270: !
271: !         create the terrain height fields
272:           call <a href="./mod_interp.f90.html#anal2" TARGET=CENT_PANEL>anal2</a>(htsdgrid_s,ht2,nobs,iysg,jxsg,corc_s,sumc_s,       &
273:                    & nsc_s,wtmaxc_s,htsavc_s)
274:           call <a href="./mod_interp.f90.html#anal2" TARGET=CENT_PANEL>anal2</a>(htgrid_s,ht,nobs,iysg,jxsg,corc_s,sumc_s,nsc_s,    &
275:                    & wtmaxc_s,htsavc_s)
276:           print * , 'after calling ANAL2, for subgrid'
277:           do j = 1 , jxsg
278:             do i = 1 , iysg
279:               htgrid_s(i,j) = amax1(htgrid_s(i,j)*100.,0.0)
280:               htsdgrid_s(i,j) = amax1(htsdgrid_s(i,j)*100000.,0.0)
281:               htsdgrid_s(i,j) = sqrt(amax1(htsdgrid_s(i,j)-htgrid_s(i,j)&
282:                               & **2,0.0))
283:             end do
284:           end do
285:         else
286:           call <a href="./mod_interp.f90.html#interp" TARGET=CENT_PANEL>interp</a>(jxsg,iysg,xlat_s,xlon_s,htgrid_s,htsdgrid_s,      &
287:                     & ntypec_s)
288:           print * , 'after calling INTERP, for subgrid'
289: !         print*, '  Note that the terrain standard deviation is'
290: !         print*, '  underestimated using INTERP. (I dont know why?)'
291:         end if
292: !       create surface landuse types
293:         call <a href="./mod_surf.f90.html#surf" TARGET=CENT_PANEL>surf</a>(xlat_s,xlon_s,lnduse_s,iysg,jxsg,nnc,       &
294:                 & xnc,lndout_s,land_s,nobs,h2opct, &
295:                 & lsmtyp,sanda_s,sandb_s,claya_s,clayb_s,frac_lnd_s,    &
296:                 & nveg,aertyp,intext_s,texout_s,frac_tex_s,ntex)
297:         print * , 'after calling SURF, for subgrid'
298: !       **** Adjust the Great Lake Heights to their actual values.
299:         if ( lakadj ) then
300:           print * ,                                                     &
301:                &'CALLING LAKEADJ FOR THE FIRST TIME (before 2dx pass)'
302:           call <a href="./mod_fudge.f90.html#lakeadj" TARGET=CENT_PANEL>lakeadj</a>(lsmtyp,lnduse_s,htgrid_s,xlat_s,xlon_s,iysg,     &
303:                      & jxsg)
304:           print * , 'after calling LAKEADJ, for subgrid'
305:         end if
306:         call <a href="./mod_smooth.f90.html#smth121" TARGET=CENT_PANEL>smth121</a>(htgrid_s,iysg,jxsg,hscr1_s)
307:         call <a href="./mod_smooth.f90.html#smth121" TARGET=CENT_PANEL>smth121</a>(htsdgrid_s,iysg,jxsg,hscr1_s)
308: !       **** Readjust the Great Lake Heights to their actual values
309: !       again.
310:         if ( lakadj ) then
311:           print * ,                                                     &
312:                &'CALLING LAKEADJ FOR THE FIRST TIME (before 2dx pass)'
313:           call <a href="./mod_fudge.f90.html#lakeadj" TARGET=CENT_PANEL>lakeadj</a>(lsmtyp,lnduse_s,htgrid_s,xlat_s,xlon_s,iysg,     &
314:                      & jxsg)
315:           print * , 'after calling LAKEADJ, for subgrid'
316:         end if
317:         ibndry = .true.
318:         if ( ibndry ) then
319:           do j = 2 , jxsg - 1
320:             htgrid_s(1,j) = htgrid_s(2,j)
321:             htgrid_s(iysg,j) = htgrid_s(iysg-1,j)
322:             lnduse_s(1,j) = lnduse_s(2,j)
323:             lnduse_s(iysg,j) = lnduse_s(iysg-1,j)
324:             lndout_s(1,j) = lndout_s(2,j)
325:             lndout_s(iysg,j) = lndout_s(iysg-1,j)
326:  
327:             if ( lsmtyp=='USGS' ) then
328:               sanda_s(1,j) = sanda_s(2,j)
329:               sanda_s(iysg,j) = sanda_s(iysg-1,j)
330:               sandb_s(1,j) = sandb_s(2,j)
331:               sandb_s(iysg,j) = sandb_s(iysg-1,j)
332:               claya_s(1,j) = claya_s(2,j)
333:               claya_s(iysg,j) = claya_s(iysg-1,j)
334:               clayb_s(1,j) = clayb_s(2,j)
335:               clayb_s(iysg,j) = clayb_s(iysg-1,j)
336:               do k = 1 , nveg
337:                 frac_lnd_s(1,j,k) = frac_lnd_s(2,j,k)
338:                 frac_lnd_s(iysg,j,k) = frac_lnd_s(iysg-1,j,k)
339:               end do
340:             end if
341:             if ( aertyp(7:7)=='1' ) then
342:               intext_s(1,j) = intext_s(2,j)
343:               intext_s(iysg,j) = intext_s(iysg-1,j)
344:               texout_s(1,j) = texout_s(2,j)
345:               texout_s(iysg,j) = texout_s(iysg-1,j)
346:               do k = 1 , ntex
347:                 frac_tex_s(1,j,k) = frac_tex_s(2,j,k)
348:                 frac_tex_s(iysg,j,k) = frac_tex_s(iysg-1,j,k)
349:               end do
350:             end if
351:           end do
352:           do i = 1 , iysg
353:             htgrid_s(i,1) = htgrid_s(i,2)
354:             htgrid_s(i,jxsg) = htgrid_s(i,jxsg-1)
355:             lnduse_s(i,1) = lnduse_s(i,2)
356:             lnduse_s(i,jxsg) = lnduse_s(i,jxsg-1)
357:             lndout_s(i,1) = lndout_s(i,2)
358:             lndout_s(i,jxsg) = lndout_s(i,jxsg-1)
359:  
360:             if ( lsmtyp=='USGS' ) then
361:               sanda_s(i,1) = sanda_s(i,2)
362:               sanda_s(i,jxsg) = sanda_s(i,jxsg-1)
363:               sandb_s(i,1) = sandb_s(i,2)
364:               sandb_s(i,jxsg) = sandb_s(i,jxsg-1)
365:               claya_s(i,1) = claya_s(i,2)
366:               claya_s(i,jxsg) = claya_s(i,jxsg-1)
367:               clayb_s(i,1) = clayb_s(i,2)
368:               clayb_s(i,jxsg) = clayb_s(i,jxsg-1)
369:               do k = 1 , nveg
370:                 frac_lnd_s(i,1,k) = frac_lnd_s(i,2,k)
371:                 frac_lnd_s(i,jxsg,k) = frac_lnd_s(i,jxsg-1,k)
372:               end do
373:             end if
374:             if ( aertyp(7:7)=='1' ) then
375:               intext_s(i,1) = intext_s(i,2)
376:               intext_s(i,jxsg) = intext_s(i,jxsg-1)
377:               texout_s(i,1) = texout_s(i,2)
378:               texout_s(i,jxsg) = texout_s(i,jxsg-1)
379:               do k = 1 , ntex
380:                 frac_tex_s(i,1,k) = frac_tex_s(i,2,k)
381:                 frac_tex_s(i,jxsg,k) = frac_tex_s(i,jxsg-1,k)
382:               end do
383:             end if
384:           end do
385:         end if
386:         do i = 1 , iysg
387:           do j = 1 , jxsg
388:             snowam_s(i,j) = 0.0
389:           end do
390:         end do
391: !       land/sea mask fudging
392:         write (char_lnd,99003) trim(dirter), pthsep, trim(domname),     &
393:            &   '_LANDUSE_' , nsg
394:         write (char_tex,99003) trim(dirter), pthsep, trim(domname),     &
395:            &   'TEXTURE_' , nsg
396:         call <a href="./mod_fudge.f90.html#lndfudge" TARGET=CENT_PANEL>lndfudge</a>(fudge_lnd_s,ch_s,lndout_s,htgrid_s,iysg,jxsg,     &
397:                     & lsmtyp,trim(char_lnd))
398:         if ( aertyp(7:7)=='1' ) call <a href="./mod_fudge.f90.html#texfudge" TARGET=CENT_PANEL>texfudge</a>(fudge_tex_s,ch_s,texout_s,&
399:            & htgrid_s,iysg,jxsg,trim(char_tex))
400:         print * , 'after calling FUDGE, for subgrid'
401: !       output terrestrial fields
402: !       OUTPUT is used to output also the fraction of each
403: !       LANDUSE legend and TEXTURE type
404: 
405:         call <a href="./mod_block.f90.html#free_block" TARGET=CENT_PANEL>free_block</a>
406: 
407:       end if
408: !
409:       dxcen = 0.0
410:       dycen = 0.0
411: !
412: !     set up the parameters and constants
413:       write (datafile,99002)                                            &
414:            & trim(dirter), pthsep, trim(domname) , '.INFO'
415:       write (ctlfile,99002)                                             &
416:            & trim(dirter), pthsep, trim(domname) , '.CTL'
417:       call <a href="./mod_write.f90.html#setup" TARGET=CENT_PANEL>setup</a>(nunitc,ctlunit,iy,jx,ntypec,iproj,ds,clat,clong,igrads,&
418:                & ibyte,datafile,ctlfile)
419:       print * , 'after calling SETUP'
420: !
421: !-----calling the map projection subroutine
422:       if ( iproj=='LAMCON' ) then
423:         call <a href="./mod_projections.f90.html#lambrt" TARGET=CENT_PANEL>lambrt</a>(xlon,xlat,xmap,coriol,iy,jx,clong,clat,dsinm,0,xn,  &
424:                   & truelatl,truelath)
425:         call <a href="./mod_projections.f90.html#lambrt" TARGET=CENT_PANEL>lambrt</a>(dlon,dlat,dmap,coriol,iy,jx,clong,clat,dsinm,1,xn,  &
426:                   & truelatl,truelath)
427:         write (*,*) 'XN,TRUELATL,TRUELATH = ' , xn , truelatl , truelath
428:       else if ( iproj=='POLSTR' ) then
429:         call <a href="./mod_projections.f90.html#mappol" TARGET=CENT_PANEL>mappol</a>(xlon,xlat,xmap,coriol,iy,jx,clong,clat,dsinm,0)
430:         call <a href="./mod_projections.f90.html#mappol" TARGET=CENT_PANEL>mappol</a>(dlon,dlat,dmap,coriol,iy,jx,clong,clat,dsinm,1)
431:         xn = 1.
432:       else if ( iproj=='NORMER' ) then
433:         call <a href="./mod_projections.f90.html#normer" TARGET=CENT_PANEL>normer</a>(xlon,xlat,xmap,coriol,iy,jx,clong,clat,dsinm,0)
434:         call <a href="./mod_projections.f90.html#normer" TARGET=CENT_PANEL>normer</a>(dlon,dlat,dmap,coriol,iy,jx,clong,clat,dsinm,1)
435:         xn = 0.
436:       else if ( iproj=='ROTMER' ) then
437:         call <a href="./mod_projections.f90.html#rotmer" TARGET=CENT_PANEL>rotmer</a>(xlon,xlat,xmap,coriol,iy,jx,clong,clat,plon,plat,   &
438:                   & dsinm,0)
439:         call <a href="./mod_projections.f90.html#rotmer" TARGET=CENT_PANEL>rotmer</a>(dlon,dlat,dmap,coriol,iy,jx,clong,clat,plon,plat,   &
440:                   & dsinm,1)
441:         xn = 0.
442:       else
443:         print * , 'iproj MAP PROJECTION IS NOT AN OPTION'
444:         stop 999
445:       end if
446:       dsx = dsinm
447:       print * , 'after calling MAP PROJECTION'
448: !
449: !     reduce the search area for the domain
450: !     [minlat:maxlat,minlon:maxlon]
451:       call <a href="./mod_block.f90.html#mxmnll" TARGET=CENT_PANEL>mxmnll</a>(iy,jx,clong,xlon,xlat,ntypec)
452:       print * , 'after calling MXMNLL'
453: 
454:       maxiter = (xmaxlat-xminlat)/xnc
455:       maxjter = (xmaxlon-xminlon)/xnc
456:       maxdim = max(maxiter,maxjter) + 1000
457:       print *, 'Allocating ' , maxdim
458:       call <a href="./mod_block.f90.html#allocate_block" TARGET=CENT_PANEL>allocate_block</a>(maxdim,maxdim)
459: !
460: !     read in the terrain & landuse data
461:       if ( itype_in==1 ) then
462:         call <a href="./mod_rdldtr.f90.html#rdldtr" TARGET=CENT_PANEL>rdldtr</a>(inpter,ntypec,nveg,ntex,lsmtyp,aertyp,ibyte)
463:         print * , 'after calling RDLDTR'
464:       else if (itype_in==2 ) then
465:         call <a href="./mod_rdldtr.f90.html#rdldtr_nc" TARGET=CENT_PANEL>rdldtr_nc</a>(inpter,ntypec,nveg,ntex,lsmtyp,aertyp)
466:         print * , 'after calling RDLDTR_nc'
467:       else
468:       endif
469:  
470: !     compute the scaled standard deviation of terrain height.
471: !     (must be called before XYOBSLL because xobs/yobs are modified)
472: !     CALL SCALESD
473: !     print*, 'after calling SCALESD'
474:  
475:       if ( ifanal ) then
476: !       convert xobs and yobs from LON and LAT to x and y in mesh
477:         call <a href="./mod_projections.f90.html#xyobsll" TARGET=CENT_PANEL>xyobsll</a>(iy,jx,iproj,clat,clong,plat,plon,truelath)
478:         print * , 'after calling XYOBSLL'
479:  
480: !       create the terrain height fields
481:         call <a href="./mod_interp.f90.html#anal2" TARGET=CENT_PANEL>anal2</a>(htsdgrid,ht2,nobs,iy,jx,corc,sumc,nsc,wtmaxc,htsavc)
482:         call <a href="./mod_interp.f90.html#anal2" TARGET=CENT_PANEL>anal2</a>(htgrid,ht,nobs,iy,jx,corc,sumc,nsc,wtmaxc,htsavc)
483:         print * , 'after calling ANAL2'
484:         do j = 1 , jx
485:           do i = 1 , iy
486:             htgrid(i,j) = amax1(htgrid(i,j)*100.,0.0)
487:             htsdgrid(i,j) = amax1(htsdgrid(i,j)*100000.,0.0)
488:             htsdgrid(i,j) = sqrt(amax1(htsdgrid(i,j)-htgrid(i,j)**2,0.0)&
489:                           & )
490:           end do
491:         end do
492:       else
493:         call <a href="./mod_interp.f90.html#interp" TARGET=CENT_PANEL>interp</a>(jx,iy,xlat,xlon,htgrid,htsdgrid,ntypec)
494: !       print*, 'after calling INTERP'
495: !       print*, '  Note that the terrain standard deviation is'
496: !       print*, '  underestimated using INTERP. (I dont know why!)'
497:       end if
498:  
499:  
500: !     create surface landuse types
501:       call <a href="./mod_surf.f90.html#surf" TARGET=CENT_PANEL>surf</a>(xlat,xlon,lnduse,iy,jx,nnc,xnc,lndout,land,   &
502:               & nobs,h2opct,lsmtyp,sanda,sandb,    &
503:               & claya,clayb,frac_lnd,nveg,aertyp,intext,texout,frac_tex,&
504:               & ntex)
505:       print * , 'after calling SURF'
506:  
507: !     **** Adjust the Great Lake Heights to their actual values.
508:       if ( lakadj ) then
509:         print * , 'CALLING LAKEADJ FOR THE FIRST TIME (before 2dx pass)'
510:         call <a href="./mod_fudge.f90.html#lakeadj" TARGET=CENT_PANEL>lakeadj</a>(lsmtyp,lnduse,htgrid,xlat,xlon,iy,jx)
511:         print * , 'after calling LAKEADJ'
512:       end if
513:  
514: !     ******           preliminary heavy smoothing of boundaries
515:       if ( smthbdy ) call <a href="./mod_smooth.f90.html#smthtr" TARGET=CENT_PANEL>smthtr</a>(htgrid,iy,jx)
516:  
517: !     ******           grell smoothing to eliminate 2 delx wave (6/90):
518:       call <a href="./mod_smooth.f90.html#smth121" TARGET=CENT_PANEL>smth121</a>(htgrid,iy,jx,hscr1)
519:       call <a href="./mod_smooth.f90.html#smth121" TARGET=CENT_PANEL>smth121</a>(htsdgrid,iy,jx,hscr1)
520:  
521: !     **** Readjust the Great Lake Heights to their actual values again.
522:       if ( lakadj ) then
523:         print * , 'CALLING LAKEADJ FOR THE SECOND TIME (after 2dx pass)'
524:         call <a href="./mod_fudge.f90.html#lakeadj" TARGET=CENT_PANEL>lakeadj</a>(lsmtyp,lnduse,htgrid,xlat,xlon,iy,jx)
525:       end if
526:  
527:       ibndry = .true.
528:       if ( ibndry ) then
529:         do j = 2 , jx - 1
530:           htgrid(1,j) = htgrid(2,j)
531:           htgrid(iy,j) = htgrid(iy-1,j)
532:           lnduse(1,j) = lnduse(2,j)
533:           lnduse(iy,j) = lnduse(iy-1,j)
534:           lndout(1,j) = lndout(2,j)
535:           lndout(iy,j) = lndout(iy-1,j)
536:  
537:           if ( lsmtyp=='USGS' ) then
538:             sanda(1,j) = sanda(2,j)
539:             sanda(iy,j) = sanda(iy-1,j)
540:             sandb(1,j) = sandb(2,j)
541:             sandb(iy,j) = sandb(iy-1,j)
542:             claya(1,j) = claya(2,j)
543:             claya(iy,j) = claya(iy-1,j)
544:             clayb(1,j) = clayb(2,j)
545:             clayb(iy,j) = clayb(iy-1,j)
546:             do k = 1 , nveg
547:               frac_lnd(1,j,k) = frac_lnd(2,j,k)
548:               frac_lnd(iy,j,k) = frac_lnd(iy-1,j,k)
549:             end do
550:           end if
551:           if ( aertyp(7:7)=='1' ) then
552:             intext(1,j) = intext(2,j)
553:             intext(iy,j) = intext(iy-1,j)
554:             texout(1,j) = texout(2,j)
555:             texout(iy,j) = texout(iy-1,j)
556:             do k = 1 , ntex
557:               frac_tex(1,j,k) = frac_tex(2,j,k)
558:               frac_tex(iy,j,k) = frac_tex(iy-1,j,k)
559:             end do
560:           end if
561:         end do
562:         do i = 1 , iy
563:           htgrid(i,1) = htgrid(i,2)
564:           htgrid(i,jx) = htgrid(i,jx-1)
565:           lnduse(i,1) = lnduse(i,2)
566:           lnduse(i,jx) = lnduse(i,jx-1)
567:           lndout(i,1) = lndout(i,2)
568:           lndout(i,jx) = lndout(i,jx-1)
569:  
570:           if ( lsmtyp=='USGS' ) then
571:             sanda(i,1) = sanda(i,2)
572:             sanda(i,jx) = sanda(i,jx-1)
573:             sandb(i,1) = sandb(i,2)
574:             sandb(i,jx) = sandb(i,jx-1)
575:             claya(i,1) = claya(i,2)
576:             claya(i,jx) = claya(i,jx-1)
577:             clayb(i,1) = clayb(i,2)
578:             clayb(i,jx) = clayb(i,jx-1)
579:             do k = 1 , nveg
580:               frac_lnd(i,1,k) = frac_lnd(i,2,k)
581:               frac_lnd(i,jx,k) = frac_lnd(i,jx-1,k)
582:             end do
583:           end if
584:           if ( aertyp(7:7)=='1' ) then
585:             intext(i,1) = intext(i,2)
586:             intext(i,jx) = intext(i,jx-1)
587:             texout(i,1) = texout(i,2)
588:             texout(i,jx) = texout(i,jx-1)
589:             do k = 1 , ntex
590:               frac_tex(i,1,k) = frac_tex(i,2,k)
591:               frac_tex(i,jx,k) = frac_tex(i,jx-1,k)
592:             end do
593:           end if
594:         end do
595:       end if
596:  
597:       do i = 1 , iy
598:         do j = 1 , jx
599:           snowam(i,j) = 0.0
600:         end do
601:       end do
602: !     land/sea mask fudging
603:       write (char_lnd,99004) trim(dirter), pthsep, trim(domname),       &
604:            &   '_LANDUSE'
605:       write (char_tex,99004) trim(dirter), pthsep, trim(domname),       &
606:            &   '_TEXTURE'
607:       call <a href="./mod_fudge.f90.html#lndfudge" TARGET=CENT_PANEL>lndfudge</a>(fudge_lnd,ch,lndout,htgrid,iy,jx,lsmtyp,            &
608:          & trim(char_lnd))
609:       if ( aertyp(7:7)=='1' ) call <a href="./mod_fudge.f90.html#texfudge" TARGET=CENT_PANEL>texfudge</a>(fudge_tex,ch,texout,htgrid, &
610:          & iy,jx,trim(char_tex))
611:       print * , 'after calling FUDGE'
612: !     output terrestrial fields
613: !     OUTPUT is used to output also the fraction of each
614: !     LANDUSE legend and TEXTURE type
615:       call <a href="./mod_block.f90.html#free_block" TARGET=CENT_PANEL>free_block</a>
616: 
617:       if ( nsg>1 ) then
618:         do i = 1 , iy
619:           do j = 1 , jx
620:             i0 = (i-1)*nsg
621:             j0 = (j-1)*nsg
622:             htave = 0.0
623:             do m = 1 , nsg
624:               do n = 1 , nsg
625:                 if ( lsmtyp=='BATS' ) then
626:                   if ( htgrid(i,j)<0.1 .and.                            &
627:                      & (lndout(i,j)>14.5 .and. lndout(i,j)<15.5) ) then
628:                     htgrid_s(i0+m,j0+n) = 0.0
629:                     lndout_s(i0+m,j0+n) = 15.
630:                   end if
631:                 else if ( lsmtyp=='USGS' ) then
632:                   if ( htgrid(i,j)<0.1 .and. lndout(i,j)>24.5 ) then
633:                     htgrid_s(i0+m,j0+n) = 0.0
634:                     lndout_s(i0+m,j0+n) = 25.
635:                   end if
636:                 else
637:                 end if
638:                 htave = htave + htgrid_s(i0+m,j0+n)
639:               end do
640:             end do
641:             htgrid_a = htave/float(nsg*nsg)
642:             do m = 1 , nsg
643:               do n = 1 , nsg
644:                 htgrid_s(i0+m,j0+n) = htgrid_s(i0+m,j0+n) - htgrid_a +  &
645:                                     & htgrid(i,j)
646:               end do
647:             end do
648:           end do
649:         end do
650:         call <a href="./mod_write.f90.html#output" TARGET=CENT_PANEL>output</a>(nunitc_s,ctlunit_s,iysg,jxsg,dsx_s,clat,clong,      &
651:                   & plat,plon,iproj,htgrid_s,htsdgrid_s,lndout_s,       &
652:                   & xlat_s,xlon_s,dlat_s,dlon_s,xmap_s,dattyp,dmap_s,   &
653:                   & coriol_s,snowam_s,igrads,ibigend,kz,sigma,mask_s,   &
654:                   & ptop,nsg,truelatl,truelath,xn,domname,lsmtyp,       &
655:                   & sanda_s,sandb_s,claya_s,clayb_s,frac_lnd_s,nveg,    &
656:                   & aertyp,texout_s,frac_tex_s,ntex,.false.)
657:         print * , 'after calling OUTPUT, for subgrid'
658:         call <a href="./mod_maps.f90.html#free_subgrid" TARGET=CENT_PANEL>free_subgrid</a>
659:       end if
660: 
661:       call <a href="./mod_write.f90.html#output" TARGET=CENT_PANEL>output</a>(nunitc,ctlunit,iy,jx,dsx,clat,clong,plat,plon,iproj,  &
662:                 & htgrid,htsdgrid,lndout,xlat,xlon,dlat,dlon,xmap,      &
663:                 & dattyp,dmap,coriol,snowam,igrads,ibigend,kz,sigma,    &
664:                 & mask,ptop,nsg,truelatl,truelath,xn,domname,           &
665:                 & lsmtyp,sanda,sandb,claya,clayb,frac_lnd,nveg,aertyp,  &
666:                 & texout,frac_tex,ntex,.true.)
667:       print * , 'after calling OUTPUT'
668:       call <a href="./mod_maps.f90.html#free_grid" TARGET=CENT_PANEL>free_grid</a>
669: 
670:       close (48, status='delete')
671: 
672:       print *, 'Successfully completed terrain fields generation'
673:  
674: !     stop 9999
675: !
676: 99001 format (a,a,a,i0.3,a)
677: 99002 format (a,a,a,a)
678: 99003 format (a,a,a,a8,i0.3)
679: 99004 format (a,a,a,a8)
680:       end program terrain
</PRE>

<HR>

</BODY>
</HTML>
