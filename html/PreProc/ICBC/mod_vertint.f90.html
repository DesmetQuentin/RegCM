<HTML>

<HEAD>
<TITLE>mod_vertint.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_vertint.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_vertint.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_vertint><H3>mod_vertint</H3></a></p>20:       module mod_vertint
21: 
22:       contains
23: 
<p><a name=intlin><H3>intlin</H3></a></p> Click <a href="./callingtree/intlin_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intlin is used.
<hr>
24:       subroutine intlin(fp,f,ps,p3d,im,jm,km,p,kp)
25:       implicit none
26: !
27: ! Dummy arguments
28: !
29:       integer :: im , jm , km , kp
30:       real(4) , dimension(im,jm,km) :: f , p3d
31:       real(4) , dimension(im,jm,kp) :: fp
32:       real(4) , dimension(kp) :: p
33:       real(4) , dimension(im,jm) :: ps
34:       intent (in) f , im , jm , km , kp , p , p3d , ps
35:       intent (out) fp
36: !
37: ! Local variables
38: !
39:       integer :: i , j , k , k1 , k1p , n
40:       real(4) , dimension(61) :: sig
41:       real(4) :: sigp , w1 , wp
42: !
43: !     INTLIN IS FOR VERTICAL INTERPOLATION OF U, V, AND RELATIVE
44: !     HUMIDITY. THE INTERPOLATION IS LINEAR IN P.  WHERE EXTRAPOLATION
45: !     IS NECESSARY, FIELDS ARE CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
46: !
47:       do j = 1 , jm
48:         do i = 1 , im
49:           if ( ps(i,j)>-9995.0 ) then
50:             do k = 1 , km
51:               sig(k) = p3d(i,j,k)/ps(i,j)
52:             end do
53:             do n = 1 , kp
54:               sigp = p(n)/ps(i,j)
55:               k1 = 0
56:               do k = 1 , km
57:                 if ( sigp>sig(k) ) k1 = k
58:               end do
59:               if ( sigp<=sig(1) ) then
60:                 fp(i,j,n) = f(i,j,1)
61:               else if ( (sigp>sig(1)) .and. (sigp<sig(km)) ) then
62:                 k1p = k1 + 1
63:                 wp = (sigp-sig(k1))/(sig(k1p)-sig(k1))
64:                 w1 = 1. - wp
65:                 fp(i,j,n) = w1*f(i,j,k1) + wp*f(i,j,k1p)
66:               else if ( sigp>=sig(km) ) then
67:                 fp(i,j,n) = f(i,j,km)
68:               else
69:               end if
70:             end do
71:           else
72:             do n = 1 , kp
73:               fp(i,j,n) = -9999.0
74:             end do
75:           end if
76:         end do
77:       end do
78:       end subroutine intlin
79: !
80: !-----------------------------------------------------------------------
81: !
<p><a name=intlin_o><H3>intlin_o</H3></a></p> Click <a href="./callingtree/intlin_o_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intlin_o is used.
<hr>
82:       subroutine intlin_o(fp,f,pstar,sig,ptop,im,jm,km,p,kp)
83:       implicit none
84: !
85: ! Dummy arguments
86: !
87:       integer :: im , jm , km , kp
88:       real(4) :: ptop
89:       real(4) , dimension(im,jm,km) :: f
90:       real(4) , dimension(im,jm,kp) :: fp
91:       real(4) , dimension(kp) :: p
92:       real(4) , dimension(im,jm) :: pstar
93:       real(4) , dimension(km) :: sig
94:       intent (in) f , im , jm , km , kp , p , pstar , ptop , sig
95:       intent (out) fp
96: !
97: ! Local variables
98: !
99:       integer :: i , j , k , k1 , k1p , n
100:       real(4) :: sigp , w1 , wp
101: !
102: !     INTLIN IS FOR VERTICAL INTERPOLATION OF U, V, AND RELATIVE
103: !     HUMIDITY. THE INTERPOLATION IS LINEAR IN P.  WHERE EXTRAPOLATION
104: !     IS NECESSARY, FIELDS ARE CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
105: !
106:       do j = 1 , jm
107:         do i = 1 , im
108:           do n = 1 , kp
109:             sigp = (p(n)-ptop)/(pstar(i,j)-ptop)
110:             k1 = 0
111:             do k = 1 , km
112:               if ( sigp>sig(k) ) k1 = k
113:             end do
114:             if ( sigp<=sig(1) ) then
115:               fp(i,j,n) = f(i,j,1)
116:             else if ( (sigp>sig(1)) .and. (sigp<sig(km)) ) then
117:               k1p = k1 + 1
118:               wp = (sigp-sig(k1))/(sig(k1p)-sig(k1))
119:               w1 = 1. - wp
120:               fp(i,j,n) = w1*f(i,j,k1) + wp*f(i,j,k1p)
121:             else if ( sigp>=sig(km) ) then
122:               fp(i,j,n) = f(i,j,km)
123:             else
124:             end if
125:           end do
126:         end do
127:       end do
128:       end subroutine intlin_o
129: !
130: !-----------------------------------------------------------------------
131: !
<p><a name=intgtb><H3>intgtb</H3></a></p> Click <a href="./callingtree/intgtb_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intgtb is used.
<hr>
132:       subroutine intgtb(pa,za,tlayer,zrcm,tp,zp,sccm,ni,nj,nlev1)
133:       implicit none
134: !
135: ! Dummy arguments
136: !
137:       integer :: ni , nj , nlev1
138:       real(4) , dimension(ni,nj) :: pa , tlayer , za , zrcm
139:       real(4) , dimension(nlev1) :: sccm
140:       real(4) , dimension(ni,nj,nlev1) :: tp , zp
141:       intent (in) ni , nj , nlev1 , sccm , tp , zp , zrcm
142:       intent (out) pa , za
143:       intent (inout) tlayer
144: !
145: ! Local variables
146: !
147:       integer :: i , j , k , kb , kt
148: !
149: !     INTGTB CALCULATES ALL VARIABLES NEEDED TO COMPUTE P* ON THE RCM
150: !     TOPOGRAPHY.  THE MEAN TEMPERATURE IN THE LAYER BETWEEN
151: !     THE TOPOGRAPHY AND THE PRESSURE LEVEL ABOVE IS CALULATED
152: !     BY LINEARLY INTERPOLATING WITH HEIGHT THE TEMPS ON
153: !     PRESSURE LEVELS.
154: !     INPUT:    TP        TEMPS ON ECMWF PRESSURE LEVELS
155: !     ZP        HEIGHTS OF ECMWF PRESSURE LEVELS
156: !     ZRCM      RCM TOPOGRAPHY
157: !     SCCM      ECMWF PRESSURE LEVELS (DIVIDED BY 1000.)
158: !     OUTPUT:   TLAYER    MEAN LAYER TEMP ABOVE RCM SURFACE
159: !     PA        PRESSURE AT TOP OF LAYER
160: !     ZA        HEIGHT AT PRESSURE PA
161: !
162:       do i = 1 , ni
163:         do j = 1 , nj
164:  
165:           kt = 0
166:           do k = 1 , nlev1 - 1
167:             if ( zrcm(i,j)<=zp(i,j,nlev1+1-k) .and. zrcm(i,j)           &
168:                & >zp(i,j,nlev1-k) ) kt = k
169:           end do
170:           kb = kt + 1
171:  
172:           if ( kt/=0 ) then
173:             tlayer(i,j) = (tp(i,j,nlev1+1-kt)*(zrcm(i,j)-zp(i,j,nlev1+1-&
174:                         & kb))+tp(i,j,nlev1+1-kb)                       &
175:                         & *(zp(i,j,nlev1+1-kt)-zrcm(i,j)))              &
176:                         & /(zp(i,j,nlev1+1-kt)-zp(i,j,nlev1+1-kb))
177:             tlayer(i,j) = (tp(i,j,nlev1+1-kt)+tlayer(i,j))/2.
178:             za(i,j) = zp(i,j,nlev1+1-kt)
179:             pa(i,j) = 100.*sccm(kt)
180:           else
181:             tlayer(i,j) = tp(i,j,1)
182:             za(i,j) = zp(i,j,1)
183:             pa(i,j) = 100.
184:           end if
185:  
186:         end do
187:       end do
188:  
189: !     PRINT *, 'ZRCM, ZP(6)   =', ZRCM(5,5), ZP(5,5,NLEV1+1-6)
190: !     PRINT *, '      TP(6)   =',            TP(5,5,NLEV1+1-6)
191: !     PRINT *, 'TLAYER, ZA, PA =', TLAYER(5,5), ZA(5,5), PA(5,5)
192:  
193:       end subroutine intgtb
194: !
195: !-----------------------------------------------------------------------
196: !
<p><a name=intlog><H3>intlog</H3></a></p> Click <a href="./callingtree/intlog_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intlog is used.
<hr>
197:       subroutine intlog(fp,f,ps,p3d,im,jm,km,p,kp)
198:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgas , rgti , lrate
199:       implicit none
200: !
201: ! Dummy arguments
202: !
203:       integer :: im , jm , km , kp
204:       real(4) , dimension(im,jm,km) :: f , p3d
205:       real(4) , dimension(im,jm,kp) :: fp
206:       real(4) , dimension(kp) :: p
207:       real(4) , dimension(im,jm) :: ps
208:       intent (in) f , im , jm , km , kp , p , p3d , ps
209:       intent (out) fp
210: !
211: ! Local variables
212: !
213:       real(4) :: sigp , w1 , wp
214:       integer :: i , j , k , k1 , k1p , kbc , n
215:       real(4) , dimension(61) :: sig
216:       real(4) , parameter :: bltop = 0.96
217: !
218: !     INTLOG IS FOR VERTICAL INTERPOLATION OF T.  THE INTERPOLATION IS
219: !     LINEAR IN LOG P.  WHERE EXTRAPOLATION UPWARD IS NECESSARY,
220: !     THE T FIELD IS CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
221: !     WHERE EXTRAPOLATION DOWNWARD IS NECESSARY, THE T FIELD IS
222: !     CONSIDERED TO HAVE A LAPSE RATE OF TLAPSE (K/M), AND THE
223: !     THICKNESS IS DETERMINED HYDROSTATICALLY FROM THE MEAN OF THE
224: !     TWO EXTREME TEMPERATURES IN THE LAYER.
225:  
226: !
227: !**   FIND FIRST SIGMA LEVEL ABOVE BOUNDARY LAYER (LESS THAN SIG=BLTOP)
228:       do j = 1 , jm
229:         do i = 1 , im
230:           if ( ps(i,j)>-9995.0 ) then
231:             kbc = 1
232:             do k = 1 , km
233:               sig(k) = p3d(i,j,k)/ps(i,j)
234:               if ( sig(k)<bltop ) kbc = k
235:             end do
236:             do n = 1 , kp
237:               sigp = p(n)/ps(i,j)
238:               k1 = 0
239:               do k = 1 , km
240:                 if ( sigp>sig(k) ) k1 = k
241:               end do
242:               if ( sigp<=sig(1) ) then
243:                 fp(i,j,n) = f(i,j,1)
244:               else if ( (sigp>sig(1)) .and. (sigp<sig(km)) ) then
245:                 k1p = k1 + 1
246:                 wp = log(sigp/sig(k1))/log(sig(k1p)/sig(k1))
247:                 w1 = 1. - wp
248:                 fp(i,j,n) = w1*f(i,j,k1) + wp*f(i,j,k1p)
249:               else if ( (sigp>=sig(km)) .and. (sigp<=1.) ) then
250:                 fp(i,j,n) = f(i,j,km)
251:               else if ( sigp>1. ) then
252:                 fp(i,j,n) = f(i,j,kbc)                                  &
253:                           & *exp(+rgas*lrate*log(sigp/sig(kbc))*rgti)
254: !               ***** FROM R. ERRICO, SEE ROUTINE HEIGHT *****
255:               else
256:               end if
257:             end do
258:           else
259:             do n = 1 , kp
260:               fp(i,j,n) = -9999.0
261:             end do
262:           end if
263:         end do
264:       end do
265:  
266:       end subroutine intlog
267: !
268: !-----------------------------------------------------------------------
269: !
<p><a name=intlog_o><H3>intlog_o</H3></a></p> Click <a href="./callingtree/intlog_o_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intlog_o is used.
<hr>
270:       subroutine intlog_o(fp,f,pstar,sig,ptop,im,jm,km,p,kp)
271:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgas , rgti , lrate 
272:       implicit none
273: !
274: ! Dummy arguments
275: !
276:       integer :: im , jm , km , kp
277:       real(4) :: ptop
278:       real(4) , dimension(im,jm,km) :: f
279:       real(4) , dimension(im,jm,kp) :: fp
280:       real(4) , dimension(kp) :: p
281:       real(4) , dimension(im,jm) :: pstar
282:       real(4) , dimension(km) :: sig
283:       intent (in) f , im , jm , km , kp , p , pstar , ptop , sig
284:       intent (out) fp
285: !
286: ! Local variables
287: !
288:       real(4) :: sigp , w1 , wp
289:       integer :: i , j , k , k1 , k1p , kbc , n
290:       real(4) , parameter :: bltop = .96
291: !
292: !     INTLOG IS FOR VERTICAL INTERPOLATION OF T.  THE INTERPOLATION IS
293: !     LINEAR IN LOG P.  WHERE EXTRAPOLATION UPWARD IS NECESSARY,
294: !     THE T FIELD IS CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
295: !     WHERE EXTRAPOLATION DOWNWARD IS NECESSARY, THE T FIELD IS
296: !     CONSIDERED TO HAVE A LAPSE RATE OF TLAPSE (K/M), AND THE
297: !     THICKNESS IS DETERMINED HYDROSTATICALLY FROM THE MEAN OF THE
298: !     TWO EXTREME TEMPERATURES IN THE LAYER.
299:  
300: !
301: !**   FIND FIRST SIGMA LEVEL ABOVE BOUNDARY LAYER (LESS THAN SIG=BLTOP)
302:       kbc = 1
303:       do k = 1 , km
304:         if ( sig(k)<bltop ) kbc = k
305:       end do
306:       do j = 1 , jm
307:         do i = 1 , im
308:           do n = 1 , kp
309:             sigp = (p(n)-ptop)/(pstar(i,j)-ptop)
310:             k1 = 0
311:             do k = 1 , km
312:               if ( sigp>sig(k) ) k1 = k
313:             end do
314:             if ( sigp<=sig(1) ) then
315:               fp(i,j,n) = f(i,j,1)
316:             else if ( (sigp>sig(1)) .and. (sigp<sig(km)) ) then
317:               k1p = k1 + 1
318:               wp = log(sigp/sig(k1))/log(sig(k1p)/sig(k1))
319:               w1 = 1. - wp
320:               fp(i,j,n) = w1*f(i,j,k1) + wp*f(i,j,k1p)
321:             else if ( (sigp>=sig(km)) .and. (sigp<=1.) ) then
322:               fp(i,j,n) = f(i,j,km)
323:             else if ( sigp>1. ) then
324:               fp(i,j,n) = f(i,j,kbc)                                    &
325:                         & *exp(rgas*lrate*log(sigp/sig(kbc))*rgti)
326: !             ***** FROM R. ERRICO, SEE ROUTINE HEIGHT *****
327:             else
328:             end if
329:           end do
330:         end do
331:       end do
332:  
333:       end subroutine intlog_o
334: !
335: !-----------------------------------------------------------------------
336: !
<p><a name=intpsn><H3>intpsn</H3></a></p> Click <a href="./callingtree/intpsn_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intpsn is used.
<hr>
337:       subroutine intpsn(psrcm,zrcm,pa,za,tlayer,pt,ni,nj)
338:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : govr
339:       implicit none
340: !
341: ! Dummy arguments
342: !
343:       integer :: ni , nj
344:       real(4) :: pt
345:       real(4) , dimension(ni,nj) :: pa , psrcm , tlayer , za , zrcm
346:       intent (in) ni , nj , pa , pt , tlayer , za , zrcm
347:       intent (out) psrcm
348: !
349: ! Local variables
350: !
351:       real(4) :: tb
352:       integer :: i , j
353: !
354: !     EXTRAPOLATE SURFACE PRESSURE FROM CLOSEST PRESSURE LEVEL ABOVE.
355: !     USE TLAYER CALCULATED IN INTGTB.
356: !     PSRCM = SURFACE PRESSURE - PTOP
357: !
358:       do i = 1 , ni
359:         do j = 1 , nj
360:           tb = tlayer(i,j)
361:           psrcm(i,j) = pa(i,j)*exp(-govr*(zrcm(i,j)-za(i,j))/tb) - pt
362:         end do
363:       end do
364:  
365: !     PRINT *, 'ZRCM, ZA, PA, PT =', ZRCM(5,5), ZA(5,5), PA(5,5), PT
366: !     PRINT *, 'TLAYER(5,5), PSRCM(5,5) = ', TLAYER(5,5), PSRCM(5,5)
367:  
368:       end subroutine intpsn
369: !
370: !-----------------------------------------------------------------------
371: !
<p><a name=intv1><H3>intv1</H3></a></p> Click <a href="./callingtree/intv1_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intv1 is used.
<hr>
372:       subroutine intv1(frcm,fccm,psrcm,srcm,sccm,pt,ni,nj,krcm,kccm)
373:       implicit none
374: !
375: ! PARAMETER definitions
376: !
377:       real(4) , parameter :: psccm = 100.
378: !
379: ! Dummy arguments
380: !
381:       integer :: kccm , krcm , ni , nj
382:       real(4) :: pt
383:       real(4) , dimension(ni,nj,kccm) :: fccm
384:       real(4) , dimension(ni,nj,krcm) :: frcm
385:       real(4) , dimension(ni,nj) :: psrcm
386:       real(4) , dimension(kccm) :: sccm
387:       real(4) , dimension(krcm) :: srcm
388:       intent (in) fccm , kccm , krcm , ni , nj , psrcm , pt , sccm ,    &
389:                 & srcm
390:       intent (out) frcm
391: !
392: ! Local variables
393: !
394:       real(4) :: dp1 , pt1 , rc , rc1 , sc
395:       integer :: i , j , k , k1 , k1p , n
396: !
397: !     INTV1 IS FOR VERTICAL INTERPOLATION OF U, V, AND RELATIVE
398: !     HUMIDITY. THE INTERPOLATION IS LINEAR IN P.  WHERE EXTRAPOLATION
399: !     IS NECESSARY, FIELDS ARE CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
400: !     INTV2 IS FOR VERTICAL INTERPOLATION OF T.  THE INTERPOLATION IS
401: !     LINEAR IN LOG P.  WHERE EXTRAPOLATION UPWARD IS NECESSARY,
402: !     THE T FIELD IS CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
403: !     WHERE EXTRAPOLATION DOWNWARD IS NECESSARY, THE T FIELD IS
404: !     CONSIDERED TO HAVE A LAPSE RATE OF RLAPSE (K/M), AND THE
405: !     THICKNESS IS DETERMINED HYDROSTATICALLY FROM THE MEAN OF THE
406: !     TWO EXTREME TEMPERATUES IN THE LAYER.
407: ! 
408:       do i = 1 , ni
409:         do j = 1 , nj
410:           dp1 = psrcm(i,j)/psccm
411:           pt1 = pt/psccm
412:           do n = 1 , krcm
413:             sc = srcm(n)*dp1 + pt1
414:             k1 = 0
415:             do k = 1 , kccm
416:               if ( sc>sccm(k) ) k1 = k
417:             end do
418: !
419: !           CONDITION FOR SC .LT. SCCM(1) FOLLOWS
420: !
421:             if ( k1==0 ) then
422:               frcm(i,j,n) = fccm(i,j,kccm)
423: !
424: !             CONDITION FOR SCCM(1) .LT. SC .LT. SCCM(KCCM) FOLLOWS
425: !
426:             else if ( k1/=kccm ) then
427:               k1p = k1 + 1
428:               rc = (sc-sccm(k1))/(sccm(k1)-sccm(k1p))
429:               rc1 = rc + 1.
430:               frcm(i,j,n) = rc1*fccm(i,j,kccm+1-k1) -                   &
431:                           & rc *fccm(i,j,kccm+1-k1p)
432: !
433: !             CONDITION FOR SC .GT. SCCM(KCCM) FOLLOWS
434: !
435:             else
436:               frcm(i,j,n) = fccm(i,j,1)
437:             end if
438: !
439:           end do
440:         end do
441:       end do
442:  
443:       end subroutine intv1
444: !
445: !-----------------------------------------------------------------------
446: !
<p><a name=intv2><H3>intv2</H3></a></p> Click <a href="./callingtree/intv2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intv2 is used.
<hr>
447:       subroutine intv2(frcm,fccm,psrcm,srcm,sccm,pt,ni,nj,krcm,kccm)
448:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgas , gti , lrate
449:       implicit none
450: !
451: ! PARAMETER definitions
452: !
453:       real(4) , parameter :: rgas2 = rgas/2.
454:       real(4) , parameter :: b1 = -gti/lrate
455:       real(4) , parameter :: psccm = 100.
456: !
457: ! Dummy arguments
458: !
459:       integer :: kccm , krcm , ni , nj
460:       real(4) :: pt
461:       real(4) , dimension(ni,nj,kccm) :: fccm
462:       real(4) , dimension(ni,nj,krcm) :: frcm
463:       real(4) , dimension(ni,nj) :: psrcm
464:       real(4) , dimension(kccm) :: sccm
465:       real(4) , dimension(krcm) :: srcm
466:       intent (in) fccm , kccm , krcm , ni , nj , psrcm , pt , sccm ,    &
467:                 & srcm
468:       intent (out) frcm
469: !
470: ! Local variables
471: !
472:       real(4) :: a1 , dp1 , pt1 , rc , rc1 , sc
473:       integer :: i , j , k , k1 , k1p , n
474: !
475: !     INTV1 IS FOR VERTICAL INTERPOLATION OF U, V, AND RELATIVE
476: !     HUMIDITY. THE INTERPOLATION IS LINEAR IN P.  WHERE EXTRAPOLATION
477: !     IS NECESSARY, FIELDS ARE CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
478: !     INTV2 IS FOR VERTICAL INTERPOLATION OF T.  THE INTERPOLATION IS
479: !     LINEAR IN LOG P.  WHERE EXTRAPOLATION UPWARD IS NECESSARY,
480: !     THE T FIELD IS CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
481: !     WHERE EXTRAPOLATION DOWNWARD IS NECESSARY, THE T FIELD IS
482: !     CONSIDERED TO HAVE A LAPSE RATE OF RLAPSE (K/M), AND THE
483: !     THICKNESS IS DETERMINED HYDROSTATICALLY FROM THE MEAN OF THE
484: !     TWO EXTREME TEMPERATUES IN THE LAYER.
485: !
486:       do i = 1 , ni
487:         do j = 1 , nj
488:           dp1 = psrcm(i,j)/psccm
489:           pt1 = pt/psccm
490:           do n = 1 , krcm
491:             sc = srcm(n)*dp1 + pt1
492:             k1 = 0
493:             do k = 1 , kccm
494:               if ( sc>sccm(k) ) k1 = k
495:             end do
496: !
497: !           CONDITION FOR SC .LT. SCCM(1) FOLLOWS
498: !
499:             if ( k1==0 ) then
500:               frcm(i,j,n) = fccm(i,j,kccm)
501: !
502: !             CONDITION FOR SCCM(1) .LT. SC .LT. SCCM(KCCM) FOLLOWS
503: !
504:             else if ( k1/=kccm ) then
505:               k1p = k1 + 1
506:               rc = log(sc/sccm(k1))/log(sccm(k1)/sccm(k1p))
507:               rc1 = rc + 1.
508:               frcm(i,j,n) = rc1*fccm(i,j,kccm+1-k1)                     &
509:                           & - rc*fccm(i,j,kccm+1-k1p)
510: !
511: !             CONDITION FOR SC .GT. SCCM(KCCM) FOLLOWS
512: !
513:             else
514:               a1 = rgas2*log(sc/sccm(kccm))
515:               frcm(i,j,n) = fccm(i,j,1)*(b1-a1)/(b1+a1)
516: !
517:             end if
518:           end do
519:         end do
520:       end do
521:  
522:       end subroutine intv2
523: !
524: !-----------------------------------------------------------------------
525: !
<p><a name=intv3><H3>intv3</H3></a></p> Click <a href="./callingtree/intv3_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where intv3 is used.
<hr>
526:       subroutine intv3(fsccm,fccm,psrccm,sccm,ptop,ni,nj,kccm)
527:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgas , gti , lrate
528:       implicit none
529: !
530: ! PARAMETER definitions
531: !
532:       real(4) , parameter :: rgas2 = rgas/2.
533:       real(4) , parameter :: b1 = -gti/lrate
534: !
535: ! Dummy arguments
536: !
537:       integer :: kccm , ni , nj
538:       real(4) :: ptop
539:       real(4) , dimension(ni,nj,kccm) :: fccm
540:       real(4) , dimension(ni,nj) :: fsccm , psrccm
541:       real(4) , dimension(kccm) :: sccm
542:       intent (in) fccm , kccm , ni , nj , psrccm , ptop , sccm
543:       intent (out) fsccm
544: !
545: ! Local variables
546: !
547:       real(4) :: a1 , rc , rc1 , sc
548:       integer :: i , j , k , k1 , kp1
549: !
550: !**   INTV3 IS FOR VERTICAL INTERPOLATION OF TSCCM.  THE INTERPOLATION
551: !     IS LINEAR IN LOG P.  WHERE EXTRAPOLATION UPWARD IS NECESSARY,
552: !     THE T FIELD IS CONSIDERED TO HAVE 0 VERTICAL DERIVATIVE.
553: !     WHERE EXTRAPOLATION DOWNWARD IS NECESSARY, THE T FIELD IS
554: !     CONSIDERED TO HAVE A LAPSE RATE OF RLAPSE (K/M), AND THE
555: !     THICKNESS IS DETERMINED HYDROSTATICALLY FROM THE MEAN OF THE
556: !     TWO EXTREME TEMPERATUES IN THE LAYER.
557: !
558:       do i = 1 , ni
559:         do j = 1 , nj
560:           sc = (psrccm(i,j)+ptop)/100.
561:           k1 = 0
562: 
563:           !TAO: Search through the GCM's levels from the top down
564:           !to find where the sigma of the RCM's surface is just greater 
565:           !than one of the GCM's sigmal levels.  Since sigma levels
566:           !increase from the TOA downward, k1 should be equal to k
567:           !until the GCM's level goes below the RCM's surface.  If this
568:           !condition is not met, then assume that interpolation is
569:           !happening at the upper boundary of the model.
570:           do k = 1, kccm
571:             if(sc > sccm(k))k1 = k
572:           end do
573: 
574:           !bugfix TAO: the below condition does not allow the RCM level
575:           !to be below the GCM's lowest layer; no extrapolation can
576:           !occur in this case.
577: !          do k = 1 , kccm - 1
578: !            if ( sc<=sccm(k+1) .and. sc>=sccm(k) ) k1 = k
579: !          end do
580: ! 
581:           if ( k1==0 ) then
582:             write ( 6,* ) 'Error: the RCM surface is above the GCM'
583:             write ( 6,* ) 'model top at i,j=',i,j
584:             write ( 6,* ) 'This might reasonably happen if you have a'
585:             write ( 6,* ) 'very tall mountain in your domain. Setting '
586:             write ( 6,* ) 'ptop to a smaller value could help.'
587:             write ( 6,* ) 'Otherwise, this indicates a bug somewhere...'
588:             write ( 6,* ) sc , ' => ', psrccm(i,j) , ', ', ptop
589:             stop
590:           end if
591: 
592:           !If the surface is below the GCM's lowest level,
593:           !then extrapolate temperature
594:           if ( k1 >= kccm ) then
595:             a1 = rgas2*log(sc/sccm(kccm))
596:             fsccm(i,j) = fccm(i,j,kccm+1-kccm)*(b1-a1)/(b1+a1)
597:           !Otherwise, interpolate the surface temperature between
598:           !the two adjacent GCM levels
599:           else
600:             kp1 = k1 + 1
601:             rc = log(sc/sccm(k1))/log(sccm(k1)/sccm(kp1))
602:             rc1 = rc + 1.
603:             fsccm(i,j) = rc1 * fccm(i,j,kccm+1-k1) -                    &
604:                        & rc  * fccm(i,j,kccm+1-kp1)
605:           end if
606: !
607:         end do
608:       end do
609:  
610:       end subroutine intv3
611: !
612:       end module mod_vertint
</PRE>

<HR>

</BODY>
</HTML>
