<HTML>

<HEAD>
<TITLE>mod_sst_ccsm.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_sst_ccsm.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_sst_ccsm.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_sst_ccsm><H3>mod_sst_ccsm</H3></a></p>20:       module mod_sst_ccsm
21: 
22:       contains
23: 
<p><a name=sst_ccsm><H3>sst_ccsm</H3></a></p> Click <a href="./callingtree/sst_ccsm_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sst_ccsm is used.
<hr>
24:       subroutine sst_ccsm
25: !
26: !*******************************************************************************
27: !
28: ! This is a package of subroutines to read CCSM SST 1x1 degree data in
29: ! NETCDF format and interpolate SST at RCM grid
30: ! Written By Moetasim Ashfaq Dec-2005 @ PURDUE.EDU
31: !
32: !******************************************************************************
33: !******************************************************************************
34: !       DATA PREPARATION
35: !       Dataset required to use this code can be preapred using NCO utilitiles
36: !       such as NCKS, NCRCAT etc.
37: !       We need top level of TEMP for SSTs which can be extarcted as following:
38: !       ncks -v time,TEMP -d z_t,0 input.nc output.nc
39: !       Files can be further concatenated using 'ncrcat'
40: !       Finally, the POP grid can be converted into lat/lon grid at 1x1 degree
41: !       resolution  using PopLatLon function in NCL
42: !******************************************************************************
43: !     NAMING CONVENTION (Global Data File)
44: !       ccsm_mn.sst.nc  for TEMP
45: !     PATH /DATA/SST/
46: !
47: !******************************************************************************
48:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
49:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : bilinx
50:       use <a href="./mod_printl.f90.html#mod_printl" TARGET=CENT_PANEL>mod_printl</a>
51: 
52:       implicit none
53: !
54: ! PARAMETER definitions
55: !
56:       integer , parameter :: ilon = 360 , jlat = 180
57: !
58: ! Local variables
59: !
60:       real(4) , dimension(jlat) :: glat
61:       real(4) , dimension(ilon) :: glon
62:       real(4) , dimension(ilon,jlat) :: sst
63:       integer :: idate , idate0
64:       integer :: i , idatef , idateo , j , k , ludom , lumax , mrec ,   &
65:                & nday , nmo , nyear
66:       integer , dimension(20) :: lund
67:       character(256) :: terfile , sstfile , inpfile
68: !
69:       real(4) , allocatable , dimension(:,:) :: lu , sstmm , xlat , xlon
70: !
71:       allocate(lu(iy,jx))
72:       allocate(sstmm(iy,jx))
73:       allocate(xlat(iy,jx))
74:       allocate(xlon(iy,jx))
75: 
76:       do i = 1 , ilon
77:         glon(i) = 0.5 + float(i-1)
78:       end do
79:       do j = 1 , jlat
80:         glat(j) = -89.5 + 1.*float(j-1)
81:       end do
82:  
83:       write (sstfile,99001) trim(dirglob), pthsep, trim(domname),       &
84:            & '_SST.RCM'
85:       open (21,file=sstfile,form='unformatted',status='replace')
86:  
87: !     ******    ON WHAT RegCM GRID ARE SST DESIRED?
88:       write (terfile,99001)                                             &
89:         & trim(dirter), pthsep, trim(domname), '.INFO'
90:       open (10,file=terfile,form='unformatted',recl=iy*jx*ibyte,        &
91:           & access='direct',status='unknown',err=100)
92:       idate = globidate1/10000
93:       if ( idate-(idate/100)*100==1 ) then
94:         idate = idate - 89
95:       else
96:         idate = idate - 1
97:       end if
98:       idateo = idate
99:       idate0 = idateo*10000 + 100
100:       idate = globidate2/10000
101:       if ( idate-(idate/100)*100==12 ) then
102:         idate = idate + 89
103:       else
104:         idate = idate + 1
105:       end if
106:       idatef = idate
107:       print * , globidate1 , globidate2 , idateo , idatef
108:  
109:       write (sstfile,99001) trim(dirglob), pthsep, trim(domname),       &
110:          &  '_RCM_SST.dat'
111:       open (25,file=sstfile,status='unknown',form='unformatted',        &
112:           & recl=iy*jx*ibyte,access='direct')
113:       if ( igrads==1 ) then
114:         write (sstfile,99001) trim(dirglob), pthsep, trim(domname),     &
115:           & '_RCM_SST.ctl'
116:         open (31,file=sstfile,status='replace')
117:         write (31,'(a,a,a)') 'dset ^',trim(domname),'_RCM_SST.dat'
118:       end if
119:       call <a href="./mod_sst_ccsm.f90.html#gridmlc" TARGET=CENT_PANEL>gridmlc</a>(xlon,xlat,lu,iy,jx,idateo,idatef)
120:       mrec = 0
121:  
122:       idate = idateo
123:       do while ( idate<=idatef )
124:         nyear = idate/100
125:         nmo = idate - nyear*100
126:  
127:         inpfile = trim(inpglob)//'/SST/ccsm_mn.sst.nc'
128:         call <a href="./mod_sst_ccsm.f90.html#ccsm_sst" TARGET=CENT_PANEL>ccsm_sst</a>(idate*10000+100,idate0,ilon,jlat,sst,inpfile)
129:  
130: !       ******           PRINT OUT DATA AS A CHECK
131:         if ( nmo==1 ) call <a href="./mod_printl.f90.html#printl" TARGET=CENT_PANEL>printl</a>(sst,jlat,ilon)
132:         call <a href="./aerosol.f90.html#bilinx" TARGET=CENT_PANEL>bilinx</a>(sst,sstmm,xlon,xlat,glon,glat,ilon,jlat,iy,jx,1)
133:         print * , 'XLON,XLAT,SST=' , xlon(1,1) , xlat(1,1) , sstmm(1,1) &
134:             & + 273.
135:  
136:         do j = 1 , jx
137:           do i = 1 , iy
138:             if ( sstmm(i,j)<-5000 .and.                                 &
139:                & (lu(i,j)>13.5 .and. lu(i,j)<15.5) ) then
140:               do k = 1 , 20
141:                 lund(k) = 0.0
142:               end do
143:               lund(nint(lu(i-1,j-1))) = lund(nint(lu(i-1,j-1))) + 2
144:               lund(nint(lu(i-1,j))) = lund(nint(lu(i-1,j))) + 3
145:               lund(nint(lu(i-1,j+1))) = lund(nint(lu(i-1,j+1))) + 2
146:               lund(nint(lu(i,j-1))) = lund(nint(lu(i,j-1))) + 3
147:               lund(nint(lu(i,j+1))) = lund(nint(lu(i,j+1))) + 3
148:               lund(nint(lu(i+1,j-1))) = lund(nint(lu(i+1,j-1))) + 2
149:               lund(nint(lu(i+1,j))) = lund(nint(lu(i+1,j))) + 3
150:               lund(nint(lu(i+1,j+1))) = lund(nint(lu(i+1,j+1))) + 2
151:               ludom = 18
152:               lumax = 0
153:               do k = 1 , 20
154:                 if ( k<=13 .or. k>=16 ) then
155:                   if ( lund(k)>lumax ) then
156:                     ludom = k
157:                     lumax = lund(k)
158:                   end if
159:                 end if
160:               end do
161:               lu(i,j) = float(ludom)
162:               print * , ludom , sstmm(i,j)
163:             end if
164:             if ( sstmm(i,j)>-100. ) then
165:               sstmm(i,j) = sstmm(i,j) + 273.15
166:             else
167:               sstmm(i,j) = -9999.
168:             end if
169:           end do
170:         end do
171:         write (21) nday , nmo , nyear , sstmm
172:         print * , 'WRITING OUT CCSM SST DATA:' , nmo , nyear
173:         idate = idate + 1
174:         if ( nmo==12 ) idate = idate + 88
175:         mrec = mrec + 1
176:         write (25,rec=mrec) ((sstmm(i,j),j=1,jx),i=1,iy)
177: !       print*, sstmm
178:       end do
179:       write (10,rec=4) ((lu(i,j),j=1,jx),i=1,iy)
180:  
181:       deallocate(lu)
182:       deallocate(sstmm)
183:       deallocate(xlat)
184:       deallocate(xlon)
185: 
186:       return
187: 
188:  100  continue
189:       print * , 'ERROR OPENING DOMAIN HEADER FILE'
190:       stop '4830 in PROGRAM RDSST'
191: 
192: 99001 format (a,a,a,a)
193:       end subroutine sst_ccsm
194: !
195: !-----------------------------------------------------------------------
196: !
<p><a name=gridmlc><H3>gridmlc</H3></a></p> Click <a href="./callingtree/gridmlc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where gridmlc is used.
<hr>
197:       subroutine gridmlc(xlon,xlat,lu,iy,jx,idate1,idate2)
198:       implicit none
199: !
200: ! Dummy arguments
201: !
202:       integer :: idate1 , idate2 , iy , jx
203:       real(4) , dimension(iy,jx) :: lu , xlat , xlon
204:       intent (in) idate1 , idate2 , iy , jx
205:       intent (out) lu , xlat , xlon
206: !
207: ! Local variables
208: !
209:       real(4) :: truelath , truelatl
210:       real(4) :: alatmax , alatmin , alonmax , alonmin , centeri ,      &
211:             & centerj , clat , clon , dsinm , grdfac , plat , plon ,    &
212:             & ptop , rlatinc , rloninc
213:       character(3) , dimension(12) :: cmonth
214:       integer :: i , ibigend , igrads , iyy , j , jxx , k , kz ,        &
215:                & month , nx , ny , period
216:       character(6) :: iproj
217:       real(4) , dimension(30) :: sigmaf
218: !
219:       data cmonth/'jan' , 'feb' , 'mar' , 'apr' , 'may' , 'jun' ,       &
220:          & 'jul' , 'aug' , 'sep' , 'oct' , 'nov' , 'dec'/
221: !
222:       alatmin = 999999.
223:       alatmax = -999999.
224:       alonmin = 999999.
225:       alonmax = -999999.
226:       nx = 0
227:       ny = 0
228:       read (10,rec=1) iyy , jxx , kz , dsinm , clat , clon , plat ,     &
229:                     & plon , grdfac , iproj , (sigmaf(k),k=1,kz+1) ,    &
230:                     & ptop , igrads , ibigend
231:       if ( iyy/=iy .or. jxx/=jx ) then
232:         write (*,*) 'IY,JX,IYY,JXX' , iy , jx , iyy , jxx
233:         stop
234:       end if
235:       read (10,rec=4) ((lu(i,j),j=1,jx),i=1,iy)
236:       read (10,rec=5) ((xlat(i,j),j=1,jx),i=1,iy)
237:       read (10,rec=6) ((xlon(i,j),j=1,jx),i=1,iy)
238: !
239:       if ( igrads==1 ) then
240:         write (31,'(a)') 'title SST fields for RegCM domain'
241:         if ( ibigend==1 ) then
242:           write (31,'(a)') 'options big_endian'
243:         else
244:           write (31,'(a)') 'options little_endian'
245:         end if
246:         write (31,'(a)') 'undef -9999.'
247:         if ( iproj=='LAMCON' .or. iproj=='ROTMER' ) then
248:           do j = 1 , jx
249:             if ( xlat(1,j)<alatmin ) alatmin = xlat(1,j)
250:             if ( xlat(iy,j)>alatmax ) alatmax = xlat(iy,j)
251:           end do
252:           do i = 1 , iy
253:             do j = 1 , jx
254:               if ( clon>=0.0 ) then
255:                 if ( xlon(i,j)>=0.0 ) then
256:                   alonmin = amin1(alonmin,xlon(i,j))
257:                   alonmax = amax1(alonmax,xlon(i,j))
258:                 else if ( abs(clon-xlon(i,j))<abs(clon-(xlon(i,j)+360.))&
259:                         & ) then
260:                   alonmin = amin1(alonmin,xlon(i,j))
261:                   alonmax = amax1(alonmax,xlon(i,j))
262:                 else
263:                   alonmin = amin1(alonmin,xlon(i,j)+360.)
264:                   alonmax = amax1(alonmax,xlon(i,j)+360.)
265:                 end if
266:               else if ( xlon(i,j)<0.0 ) then
267:                 alonmin = amin1(alonmin,xlon(i,j))
268:                 alonmax = amax1(alonmax,xlon(i,j))
269:               else if ( abs(clon-xlon(i,j))<abs(clon-(xlon(i,j)-360.)) )&
270:                       & then
271:                 alonmin = amin1(alonmin,xlon(i,j))
272:                 alonmax = amax1(alonmax,xlon(i,j))
273:               else
274:                 alonmin = amin1(alonmin,xlon(i,j)-360.)
275:                 alonmax = amax1(alonmax,xlon(i,j)-360.)
276:               end if
277:             end do
278:           end do
279:           rlatinc = dsinm*0.001/111./2.
280:           rloninc = dsinm*0.001/111./2.
281:           ny = 2 + nint(abs(alatmax-alatmin)/rlatinc)
282:           nx = 1 + nint(abs((alonmax-alonmin)/rloninc))
283:  
284:           centerj = jx/2.
285:           centeri = iy/2.
286:         end if
287:         if ( iproj=='LAMCON' ) then        ! Lambert projection
288:           write (31,99001) jx , iy , clat , clon , centerj , centeri ,  &
289:                          & truelatl , truelath , clon , dsinm , dsinm
290:           write (31,99002) nx + 2 , alonmin - rloninc , rloninc
291:           write (31,99003) ny + 2 , alatmin - rlatinc , rlatinc
292:         else if ( iproj=='POLSTR' ) then   !
293:         else if ( iproj=='NORMER' ) then
294:           write (31,99004) jx , xlon(1,1) , xlon(1,2) - xlon(1,1)
295:           write (31,99005) iy
296:           write (31,99006) (xlat(i,1),i=1,iy)
297:         else if ( iproj=='ROTMER' ) then
298:           write (*,*) 'Note that rotated Mercartor (ROTMER)' ,          &
299:                      &' projections are not supported by GrADS.'
300:           write (*,*) '  Although not exact, the eta.u projection' ,    &
301:                      &' in GrADS is somewhat similar.'
302:           write (*,*) ' FERRET, however, does support this projection.'
303:           write (31,99007) jx , iy , plon , plat , dsinm/111000. ,      &
304:                          & dsinm/111000.*.95238
305:           write (31,99002) nx + 2 , alonmin - rloninc , rloninc
306:           write (31,99003) ny + 2 , alatmin - rlatinc , rlatinc
307:         else
308:           write (*,*) 'Are you sure your map projection is correct ?'
309:           stop
310:         end if
311:         write (31,99008) 1 , 1000.
312:         month = idate1 - (idate1/100)*100
313:         period = (idate2/100-idate1/100)*12 + (idate2-(idate2/100)*100) &
314:                & - (idate1-(idate1/100)*100) + 1
315:         write (31,99009) period , cmonth(month) , idate1/100
316:         write (31,99010) 1
317:         write (31,99011) 'sst ' , 'surface elevation          '
318:         write (31,'(a)') 'endvars'
319:         close (31)
320:       end if
321: 99001 format ('pdef ',i4,1x,i4,1x,'lcc',7(1x,f7.2),1x,2(f7.0,1x))
322: 99002 format ('xdef ',i4,' linear ',f7.2,1x,f7.4)
323: 99003 format ('ydef ',i4,' linear ',f7.2,1x,f7.4)
324: 99004 format ('xdef ',i3,' linear ',f9.4,' ',f9.4)
325: 99005 format ('ydef ',i3,' levels')
326: 99006 format (10F7.2)
327: 99007 format ('pdef ',i4,1x,i4,1x,'eta.u',2(1x,f7.3),2(1x,f9.5))
328: 99008 format ('zdef ',i1,' levels ',f7.2)
329: 99009 format ('tdef ',i4,' linear 00z16',a3,i4,' 1mo')
330: 99010 format ('vars ',i1)
331: 99011 format (a4,'0 99 ',a26)
332: !
333:       end subroutine gridmlc
334: !
335: !-----------------------------------------------------------------------
336: !
337: !     Subroutine to read required records from SST data file
338: !
<p><a name=ccsm_sst><H3>ccsm_sst</H3></a></p> Click <a href="./callingtree/ccsm_sst_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ccsm_sst is used.
<hr>
339:       subroutine ccsm_sst(idate,idate0,ilon,jlat,sst,pathaddname)
340: 
341:       use <a href="#" TARGET=CENT_PANEL>netcdf</a>
342: 
343:       implicit none
344: 
345:       integer , intent (in) :: idate , idate0
346:       integer , intent (in) :: ilon , jlat
347:       character(len=256) ,intent(in) :: pathaddname
348:       real(4) , dimension(ilon, jlat) , intent(out) :: sst
349: 
350:       integer, dimension(12) :: ndays
351:       character(len=4), dimension(2) :: varname
352:       integer, allocatable ::  work1(:)
353:       real(4) , dimension (ilon , jlat) :: work2
354:       real(4) :: imisng
355: 
356:       integer :: nyear , month
357:       integer :: inet1
358:       integer, dimension(10) :: istart , icount , istartt , icountt
359:       integer, dimension(2) :: ivar2
360:       integer :: it , icode , i , j , npos , nrec
361:       integer :: latid , lonid , timid
362:       integer :: latlen , lonlen , timlen
363:       logical :: there
364:       integer :: istatus
365: 
366:       data ndays/31,59,90,120,151,181,212,243,273,304,334,365/
367:       data varname/'time','TEMP'/
368:       
369:       nyear = idate/1000000
370:       month = idate/10000 - nyear*100
371:       
372:       if (idate == idate0) then
373:          inquire(file=pathaddname,exist=there)
374:          if (.not.there) then
375:             print *, trim(pathaddname),' is not available'
376:             stop
377:          endif
378:          istatus = nf90_open(pathaddname,nf90_nowrite,inet1)
379:          if ( istatus/=nf90_noerr ) then
380:            write ( 6,*) 'Error opening ', trim(pathaddname)
381:            stop 'ERROR OPEN FILE'
382:          end if
383:          
384:          write(*,*) inet1 , trim(pathaddname) , icode
385:       endif  
386: !     GET DIMENSION IDs
387:       istatus = nf90_inq_dimid(inet1,'lat',latid)
388:       istatus = nf90_inq_dimid(inet1,'lon',lonid)
389:       istatus = nf90_inq_dimid(inet1,'time',timid)
390: 
391: !     GET DIMENSION LENGTHS
392:       istatus = nf90_inquire_dimension(inet1,latid,len=latlen)
393:       istatus = nf90_inquire_dimension(inet1,lonid,len=lonlen)
394:       istatus = nf90_inquire_dimension(inet1,timid,len=timlen)
395:       allocate(work1(timlen))
396:       
397: !     MAKE SURE THAT SST DATA IS AT 1X1 DEGREE
398:       if(latlen /= jlat .or. lonlen /= ilon) then
399:          print*,'DIMENSIONS DO NOT MATCH'
400:          print*,'No. of LON in SST file =',lonlen
401:          print*,'No. of LON in 1x1 degree gloabl grid =',ilon
402:          print*,'No. of LAT in SST file =',latlen
403:          print*,'No. of LON in 1x1 degree gloabl grid =',jlat
404:          STOP   'Check SST data file' 
405:       endif
406: !     GET VARIABLE IDs
407:       istatus = nf90_inq_varid(inet1,varname(1),ivar2(1))
408:       istatus = nf90_inq_varid(inet1,varname(2),ivar2(2))
409: !     GET MISSING DATA VALUE
410:       istatus = nf90_get_att(inet1,ivar2(2),'_FillValue',imisng)
411: !     GET TIME VALUES
412:       istartt(1) = 1
413:       icountt(1) = timlen
414:       istatus = nf90_get_var(inet1,ivar2(1),work1,istartt,icountt)
415:       
416: !     CHECK FOR THE REQUIRED RECORD IN DATA FILE  
417:       npos = (nyear - 1000) * 365 + ndays(month)
418:       i = 0
419:       print *,  npos
420:  10   continue
421:       i = i + 1
422:       if (npos < work1(i) .or. npos > work1(timlen)) then
423:          print *, 'Error in finding SST data for',(idate-100)/10000
424:          print *, 'Required NREC=',npos
425:          stop    'Check SST data file' 
426:       else if (work1(i) == npos) then
427:          nrec=i
428:          go to 20
429:       end if
430:       go to 10
431:  
432:  20   it = nrec
433:       icount(1) = ilon
434:       icount(2) = jlat
435:       icount(3) = 1
436:       istart(1) = 1
437:       istart(2) = 1
438:       istart(3) = 1
439:       istart(3) = it
440:       istatus = nf90_get_var(inet1,ivar2(2),work2,istart,icount)
441:       do j = 1 , jlat
442:          do i = 1 , ilon
443:             if (work2(i,j) > (imisng+10) .and. work2(i,j) < 10000.0) then
444:                sst(i,j) = work2(i,j)
445:             else
446:                sst(i,j) = -9999.
447:             end if
448:          end do
449:       end do
450: 
451:       end subroutine ccsm_sst
452: !
453:       end module mod_sst_ccsm
</PRE>

<HR>

</BODY>
</HTML>
