<HTML>

<HEAD>
<TITLE>mod_sst_1deg.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_sst_1deg.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_sst_1deg.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_sst_1deg><H3>mod_sst_1deg</H3></a></p>20:       module mod_sst_1deg
21: 
22:       contains
23: 
<p><a name=sst_1deg><H3>sst_1deg</H3></a></p> Click <a href="./callingtree/sst_1deg_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sst_1deg is used.
<hr>
24:       subroutine sst_1deg
25: 
26: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
27: ! Comments on dataset sources and location:                          c
28: !                                                                    c
29: ! GISST2.3b    UKMO SST (Rayner et al 1996), 1 degree                c
30: !              from UKMO DATA archive (http://www.badc.rl.ac.uk/)    c
31: !              and reformed as direct-accessed binary GrADS format   c
32: !              in file GISST_187101_200209                           c
33: !              ML= 1 is-179.5; ML= 2 is-178.5; => ML=360 is 179.5E   c
34: !              NL= 1 is -89.5; NL= 2 is -88.5; => NL=180 is  89.5    c
35: !              see the GrADS control file for details.               c
36: !                                                                    c
37: ! OISST        from CAC Optimal Interpolation dataset.               c
38: !              in the original netCDF format.                        c
39: !              ML= 1 is   0.5; ML= 2 is   1.5; => ML=360 is 359.5E   c
40: !              NL= 1 is -89.5; NL= 2 is -88.5; => NL=180 is  89.5    c
41: !                                                                    c
42: ! OI2ST        both SST and SeaIce in the original netCDF format.    c
43: !                                                                    c
44: ! OI_WK        weekly OISST in the original netCDF format.           c
45: !                                                                    c
46: ! OI2WK        weekly OISST and SeaIce in the original netCDF format.c
47: !                                                                    c
48: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
49: 
50:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
51:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : bilinx
52:       use <a href="./mod_printl.f90.html#mod_printl" TARGET=CENT_PANEL>mod_printl</a>
53: 
54:       implicit none
55: !
56: ! PARAMETER definitions
57: !
58:       integer , parameter :: ilon = 360 , jlat = 180
59: !
60: ! Local variables
61: !
62:       real(4) , dimension(ilon,jlat) :: sst , ice
63:       integer :: idate , idate0 , kend , kstart
64:       integer , dimension(427+1097) :: wkday
65:       integer :: i , idatef , idateo , j , k , ludom , lumax , mrec ,   &
66:                & nday , nmo , nrec , nyear
67:       real(4) , dimension(jlat) :: lati
68:       real(4) , dimension(ilon) :: loni
69:       integer , dimension(25) :: lund
70:       character(256) :: terfile , sstfile , inpfile
71:       logical :: there
72:       real(4) , allocatable , dimension(:,:) :: lu , sstmm , icemm ,    &
73:                                   &             xlat , xlon
74: !
75:       allocate(lu(iy,jx))
76:       allocate(sstmm(iy,jx))
77:       allocate(icemm(iy,jx))
78:       allocate(xlat(iy,jx))
79:       allocate(xlon(iy,jx))
80:       kstart = 0
81:       kend = 0
82: !
83:       if ( ssttyp=='GISST' ) then
84:         if ( globidate1<1947121512 .or. globidate2>2002091512 ) then
85:           print * , 'GISST data required are not available'
86:           print * , 'IDATE1, IDATE2 = ' , globidate1 , globidate2
87:           stop
88:         end if
89:         open (11,file=trim(inpglob)//'/SST/GISST_194712_200209',        &
90:              &form='unformatted',recl=ilon*jlat*ibyte,access='direct',  &
91:             & status='old',err=100)
92:       else if ( ssttyp=='OISST' .or. ssttyp=='OI_NC' .or.               &
93:             &   ssttyp=='OI2ST' ) then
94:         if ( globidate1<1981121512 .or. globidate2<1981121512 ) then
95:           print * , 'OISST data required are not available'
96:           print * , 'IDATE1, IDATE2 = ' , globidate1 , globidate2
97:           stop
98:         end if
99:         inquire (file=trim(inpglob)//'/SST/sst.mnmean.nc',exist=there)
100:         if ( .not.there ) print * , 'sst.mnmean.nc is not available' ,  &
101:                                &' under ',trim(inpglob),'/SST/'
102:         if ( ssttyp=='OI2ST' ) then
103:           inquire (file=trim(inpglob)//'/SST/icec.mnmean.nc',           &
104:               &    exist=there)
105:           if ( .not. there )                                            &
106:             & print *, 'icec.mnmean.nc is not available' ,              &
107:                    &' under ',trim(inpglob),'/SST/'
108:         end if
109:       else if ( ssttyp=='OI_WK' .or. ssttyp=='OI2WK' ) then
110:         if ( globidate1<1981110100 .or. globidate2<1981110106 ) then
111:           print * , 'OI_WK (or OI2WK) data required are not available'
112:           print * , 'IDATE1, IDATE2 = ' , globidate1 , globidate2
113:           stop
114:         end if
115:         inquire (file=trim(inpglob)//'/SST/sst.wkmean.1981-1989.nc',    &
116:              &   exist=there)
117:         if ( .not.there ) print * ,                                     &
118:                              &'sst.wkmean.1981-1989.nc is not available'&
119:                             & , ' under ',trim(inpglob),'/SST/'
120:         inquire (file=trim(inpglob)//'/SST/sst.wkmean.1990-present.nc', &
121:                & exist=there)
122:         if ( .not.there ) print * ,                                     &
123:                           &'sst.wkmean.1990-present.nc is not available'&
124:                          & , ' under ',trim(inpglob),'/SST/'
125:         call <a href="./mod_date.f90.html#headwk" TARGET=CENT_PANEL>headwk</a>(wkday)
126:         if ( ssttyp=='OI2WK' ) then
127:           inquire (file=trim(inpglob)//'/SST/icec.wkmean.1981-1989.nc', &
128:                 & exist=there)
129:           if ( .not.there ) then
130:             print *, 'icec.wkmean.1981-1989.nc is not available',       &
131:                 &    ' under ',trim(inpglob),'/SST/'
132:           end if
133:           inquire (file=trim(inpglob)//                                 &
134:                  '/SST/icec.wkmean.1990-present.nc',exist=there)
135:           if ( .not.there ) then
136:             print *, 'icec.wkmean.1990-present.nc is not available',    &
137:                 &    ' under ',trim(inpglob),'/SST/'
138:           end if
139:         end if
140:       else
141:         write (*,*) 'PLEASE SET right SSTTYP in regcm.in'
142:         write (*,*) 'Supported are GISST OISST OI_NC OI2ST OI_WK OI2WK'
143:         stop
144:       end if
145:       write (sstfile,99001) trim(dirglob), pthsep, trim(domname),       &
146:              & '_SST.RCM'
147:       open (21,file=sstfile,form='unformatted',status='replace')
148:  
149: !     ******    ON WHAT RegCM GRID ARE SST DESIRED?
150:       write (terfile,99001)                                             &
151:         & trim(dirter), pthsep, trim(domname), '.INFO'
152:       open (10,file=terfile,form='unformatted',recl=iy*jx*ibyte,        &
153:           & access='direct',status='unknown',err=200)
154:       write (sstfile,99001) trim(dirglob), pthsep, trim(domname),       &
155:           & '_RCM_SST.dat'
156:       open (25,file=sstfile,status='unknown',form='unformatted',        &
157:           & recl=iy*jx*ibyte,access='direct')
158:       if ( igrads==1 ) then
159:         write (sstfile,99001) trim(dirglob), pthsep, trim(domname),     &
160:            &  '_RCM_SST.ctl'
161:         open (31,file=sstfile,status='replace')
162:         write (31,'(a,a,a)') 'dset ^',trim(domname),'_RCM_SST.dat'
163:       end if
164:       if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
165:         write (sstfile,99001) trim(dirglob), pthsep, trim(domname),     &
166:            &  '_RCM_ICE.dat'
167:         open (26,file=sstfile,status='unknown',form='unformatted',      &
168:           & recl=iy*jx*ibyte,access='direct')
169:         if ( igrads==1 ) then
170:           write (sstfile,99001) trim(dirglob), pthsep, trim(domname),   &
171:             & '_RCM_ICE.ctl'
172:           open ( 32,file=sstfile,status='replace')
173:           write (32,'(a,a,a)') 'dset ^',trim(domname),'_RCM_ICE.dat'
174:         end if
175:       end if
176: !#####
177:       if ( ssttyp/='OI_WK' .and. ssttyp/='OI2WK' ) then
178: !#####
179:         idate = globidate1/10000
180:         if ( idate-(idate/100)*100==1 ) then
181:           idate = idate - 89
182:         else
183:           idate = idate - 1
184:         end if
185:         idateo = idate
186:         idate0 = idateo*10000 + 100
187:         idate = globidate2/10000
188:         if ( idate-(idate/100)*100==12 ) then
189:           idate = idate + 89
190:         else
191:           idate = idate + 1
192:         end if
193:         idatef = idate
194:         print * , globidate1 , globidate2 , idateo , idatef
195:         call <a href="./mod_sst_1deg.f90.html#gridml1d" TARGET=CENT_PANEL>gridml1d</a>(xlon,xlat,lu,iy,jx,idateo,idatef,ibyte,ssttyp)
196: !#####
197:       else
198: !#####
199:         idate = globidate1/100
200:         do k = 427 + 1097 , 1 , -1
201:           if ( wkday(k)<=idate ) then
202:             kstart = k
203:             exit
204:           end if
205:         end do
206:         idate = globidate2/100
207:         do k = 1 , 427 + 1097
208:           if ( wkday(k)>idate ) then
209:             kend = k
210:             exit
211:           end if
212:         end do
213:         idateo = wkday(kstart)
214:         idate0 = wkday(kstart)*100
215:         idatef = wkday(kend)
216:         print * , globidate1 , globidate2 , idateo , idatef ,           &
217:                 &  kend - kstart + 1
218:         call <a href="./mod_sst_1deg.f90.html#gridml2" TARGET=CENT_PANEL>gridml2</a>(xlon,xlat,lu,iy,jx,idateo,kend-kstart+1,ibyte,     &
219:                    & ssttyp)
220: !#####
221:       end if
222: !#####
223:       mrec = 0
224:  
225: !     ******    SET UP LONGITUDES AND LATITUDES FOR SST DATA
226:       do i = 1 , ilon
227:         loni(i) = .5 + float(i-1)
228:       end do
229:       do j = 1 , jlat
230:         lati(j) = -89.5 + 1.*float(j-1)
231:       end do
232:  
233: !#####
234:       if ( ssttyp/='OI_WK' .and. ssttyp/='OI2WK' ) then
235: !#####
236: !       ****** OISST SST DATA, 1 Deg data, AVAILABLE FROM 12/1981 TO
237: !       PRESENT ****** GISST SST DATA, 1 Deg data, AVAILABLE FROM
238: !       12/1947 TO 9/2002
239:         idate = idateo
240:         do while ( idate<=idatef )
241:           nyear = idate/100
242:           nmo = idate - nyear*100
243:           if ( ssttyp=='GISST' ) then
244:             nrec = (nyear-1947)*12 + nmo - 11
245:             read (11,rec=nrec) sst
246:           else if ( ssttyp=='OISST' .or. ssttyp=='OI_NC' .or.           &
247:                     ssttyp=='OI2ST') then
248:             write (*,*) idate*10000 + 100 , idate0
249:             inpfile = trim(inpglob)//'/SST/sst.mnmean.nc'
250:             call <a href="./mod_sst_1deg.f90.html#sst_mn" TARGET=CENT_PANEL>sst_mn</a>(idate*10000+100,idate0,ilon,jlat,sst,inpfile)
251:             if ( ssttyp=='OI2ST' ) then
252:               inpfile = trim(inpglob)//'/SST/icec.mnmean.nc'
253:               call <a href="./mod_sst_1deg.f90.html#ice_mn" TARGET=CENT_PANEL>ice_mn</a>(idate*10000+100,idate0,ilon,jlat,ice,inpfile)
254:             end if
255:           else
256:           end if
257:  
258: !         ******           PRINT OUT DATA AS A CHECK
259:           if ( nmo==1 ) call <a href="./mod_printl.f90.html#printl" TARGET=CENT_PANEL>printl</a>(sst,ilon,jlat)
260:  
261:           call <a href="./aerosol.f90.html#bilinx" TARGET=CENT_PANEL>bilinx</a>(sst,sstmm,xlon,xlat,loni,lati,ilon,jlat,iy,jx,1)
262:           print * , 'XLON,XLAT,SST=' , xlon(1,1) , xlat(1,1) ,          &
263:               & sstmm(1,1)
264:  
265:           if ( ssttyp=='OI2ST' ) call <a href="./aerosol.f90.html#bilinx" TARGET=CENT_PANEL>bilinx</a>(ice,icemm,xlon,xlat,       &
266:               & loni,lati,ilon,jlat,iy,jx,1)
267:           do j = 1 , jx
268:             do i = 1 , iy
269:               if ( lsmtyp=='BATS' .and. sstmm(i,j)<-5000. .and.         &
270:                  & (lu(i,j)>13.5 .and. lu(i,j)<15.5) ) then
271:                 do k = 1 , 20
272:                   lund(k) = 0.0
273:                 end do
274:                 lund(nint(lu(i-1,j-1))) = lund(nint(lu(i-1,j-1))) + 2
275:                 lund(nint(lu(i-1,j))) = lund(nint(lu(i-1,j))) + 3
276:                 lund(nint(lu(i-1,j+1))) = lund(nint(lu(i-1,j+1))) + 2
277:                 lund(nint(lu(i,j-1))) = lund(nint(lu(i,j-1))) + 3
278:                 lund(nint(lu(i,j+1))) = lund(nint(lu(i,j+1))) + 3
279:                 lund(nint(lu(i+1,j-1))) = lund(nint(lu(i+1,j-1))) + 2
280:                 lund(nint(lu(i+1,j))) = lund(nint(lu(i+1,j))) + 3
281:                 lund(nint(lu(i+1,j+1))) = lund(nint(lu(i+1,j+1))) + 2
282:                 ludom = 18
283:                 lumax = 0
284:                 do k = 1 , 20
285:                   if ( k<=13 .or. k>=16 ) then
286:                     if ( lund(k)>lumax ) then
287:                       ludom = k
288:                       lumax = lund(k)
289:                     end if
290:                   end if
291:                 end do
292:                 lu(i,j) = float(ludom)
293:                 print * , ludom , sstmm(i,j)
294:               else if ( lsmtyp=='USGS' .and. sstmm(i,j)<-5000. .and.    &
295:                       & lu(i,j)>24.5 ) then
296:                 do k = 1 , 25
297:                   lund(k) = 0.0
298:                 end do
299:                 lund(nint(lu(i-1,j-1))) = lund(nint(lu(i-1,j-1))) + 2
300:                 lund(nint(lu(i-1,j))) = lund(nint(lu(i-1,j))) + 3
301:                 lund(nint(lu(i-1,j+1))) = lund(nint(lu(i-1,j+1))) + 2
302:                 lund(nint(lu(i,j-1))) = lund(nint(lu(i,j-1))) + 3
303:                 lund(nint(lu(i,j+1))) = lund(nint(lu(i,j+1))) + 3
304:                 lund(nint(lu(i+1,j-1))) = lund(nint(lu(i+1,j-1))) + 2
305:                 lund(nint(lu(i+1,j))) = lund(nint(lu(i+1,j))) + 3
306:                 lund(nint(lu(i+1,j+1))) = lund(nint(lu(i+1,j+1))) + 2
307:                 ludom = 13
308:                 lumax = 0
309:                 do k = 1 , 24
310:                   if ( lund(k)>lumax ) then
311:                     ludom = k
312:                     lumax = lund(k)
313:                   end if
314:                 end do
315:                 lu(i,j) = float(ludom)
316:                 print * , ludom , sstmm(i,j)
317:               else
318:               end if
319:               if ( sstmm(i,j)>-100. ) then
320:                 sstmm(i,j) = sstmm(i,j) + 273.15
321:               else
322:                 sstmm(i,j) = -9999.
323:               end if
324:             end do
325:           end do
326:  
327: !         ******           WRITE OUT SST DATA ON MM4 GRID
328:           nday = 1
329:           if ( ssttyp/='OI2ST' ) then
330:             write (21) nday , nmo , nyear , sstmm
331:           else
332:             write (21) nday , nmo , nyear , sstmm , icemm
333:           end if
334:           print * , 'WRITING OUT MM4 SST DATA:' , nmo , nyear
335:           idate = idate + 1
336:           if ( nmo==12 ) idate = idate + 88
337:           mrec = mrec + 1
338:           write (25,rec=mrec) ((sstmm(i,j),j=1,jx),i=1,iy)
339:           if ( ssttyp=='OI2ST' )                                        &
340:            &    write (26,rec=mrec) ((icemm(i,j),j=1,jx),i=1,iy)
341:         end do
342:         write (10,rec=4) ((lu(i,j),j=1,jx),i=1,iy)
343: !#####
344:       else
345: !#####
346:         do k = kstart , kend
347:           idate = wkday(k)
348:           nyear = idate/10000
349:           nmo = idate/100 - nyear*100
350:           nday = mod(idate,100)
351:           write (*,*) idate*100 , idate0 , k
352:           if ( idate<19891231 ) then
353:             inpfile = trim(inpglob)//'/SST/sst.wkmean.1981-1989.nc'
354:           else
355:             inpfile = trim(inpglob)//'/SST/sst.wkmean.1990-present.nc'
356:           end if
357:           call <a href="./mod_sst_1deg.f90.html#sst_wk" TARGET=CENT_PANEL>sst_wk</a>(idate*100,idate0,k,ilon,jlat,sst,inpfile)
358:  
359:           call <a href="./aerosol.f90.html#bilinx" TARGET=CENT_PANEL>bilinx</a>(sst,sstmm,xlon,xlat,loni,lati,ilon,jlat,iy,jx,1)
360:           print * , 'XLON,XLAT,SST=' , xlon(1,1) , xlat(1,1) ,          &
361:               & sstmm(1,1)
362:           if ( ssttyp=='OI2WK') then
363:             if ( idate<19891231 ) then
364:               inpfile = trim(inpglob)//'/SST/icec.wkmean.1981-1989.nc'
365:             else
366:              inpfile = trim(inpglob)//'/SST/icec.wkmean.1990-present.nc'
367:             end if
368:             call <a href="./mod_sst_1deg.f90.html#ice_wk" TARGET=CENT_PANEL>ice_wk</a>(idate*100,idate0,k,ilon,jlat,sst,inpfile)
369:             call <a href="./aerosol.f90.html#bilinx" TARGET=CENT_PANEL>bilinx</a>(ice,icemm,xlon,xlat,loni,lati,ilon,jlat,iy,jx,1)
370:           end if 
371: 
372:           do j = 1 , jx
373:             do i = 1 , iy
374:               if ( sstmm(i,j)>-100. ) then
375:                 sstmm(i,j) = sstmm(i,j) + 273.15
376:               else
377:                 sstmm(i,j) = -9999.
378:               end if
379:             end do
380:           end do
381:  
382: !         ******           WRITE OUT SST DATA ON MM4 GRID
383:           write (21) nday , nmo , nyear , sstmm
384:           idate = wkday(k)
385:           print * , 'WRITING OUT MM4 SST DATA:' , nmo , nyear , idate
386:           mrec = mrec + 1
387:           write (25,rec=mrec) ((sstmm(i,j),j=1,jx),i=1,iy)
388:         end do
389:  
390: !#####
391:       end if
392: !#####
393:       deallocate(lu)
394:       deallocate(sstmm)
395:       deallocate(icemm)
396:       deallocate(xlat)
397:       deallocate(xlon)
398:  
399:       return
400: 
401:  100  continue
402:       print * , 'ERROR OPENING GISST FILE'
403:       stop '4810 IN PROGRAM RDSST'
404:  200  continue
405:       print * , 'ERROR OPENING DOMAIN HEADER FILE'
406:       stop '4830 IN PROGRAM RDSST'
407: 
408: 99001 format (a,a,a,a)
409:       end subroutine sst_1deg
410: !
411: !-----------------------------------------------------------------------
412: !
<p><a name=gridml1d><H3>gridml1d</H3></a></p> Click <a href="./callingtree/gridml1d_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where gridml1d is used.
<hr>
413:       subroutine gridml1d(xlon,xlat,lu,iy,jx,idate1,idate2,ibyte,ssttyp)
414:       implicit none
415: !
416: ! Dummy arguments
417: !
418:       integer :: ibyte , idate1 , idate2 , iy , jx
419:       real(4) , dimension(iy,jx) :: lu , xlat , xlon
420:       character(5) :: ssttyp
421:       intent (in) ibyte , idate1 , idate2 , iy , jx , ssttyp
422:       intent (out) lu , xlat , xlon
423: !
424: ! Local variables
425: !
426:       real(4) :: truelath , truelatl
427:       real(4) :: alatmax , alatmin , alonmax , alonmin , centeri ,      &
428:             & centerj , clat , clon , dsinm , grdfac , plat , plon ,    &
429:             & ptop , rlatinc , rloninc
430:       character(3) , dimension(12) :: cmonth
431:       integer :: i , ibigend , ierr , igrads , iyy , j , jxx , k , kz , &
432:                & month , nx , ny , period
433:       character(6) :: iproj
434:       real(4) , dimension(30) :: sigmaf
435: !
436:       data cmonth/'jan' , 'feb' , 'mar' , 'apr' , 'may' , 'jun' ,       &
437:          & 'jul' , 'aug' , 'sep' , 'oct' , 'nov' , 'dec'/
438: !
439:       alatmin = 999999.
440:       alatmax = -999999.
441:       alonmin = 999999.
442:       alonmax = -999999.
443:       nx = 0
444:       ny = 0
445:       read (10,rec=1,iostat=ierr) iyy , jxx , kz , dsinm , clat , clon ,&
446:                                 & plat , plon , grdfac , iproj ,        &
447:                                 & (sigmaf(k),k=1,kz+1) , ptop , igrads ,&
448:                                 & ibigend , truelatl , truelath
449:       if ( iyy/=iy .or. jxx/=jx ) then
450:         print * , 'IMPROPER DIMENSION SPECIFICATION (SST_1DEG.f)'
451:         print * , '  regcm.in   : ' , iy , jx
452:         print * , '  DOMAIN.INFO: ' , iyy , jxx
453:         print * , '  Also check ibyte in icbc.param: ibyte= ' , ibyte
454:         stop 'Dimensions (subroutine gridml1d)'
455:       end if
456:       read (10,rec=4,iostat=ierr) ((lu(i,j),j=1,jx),i=1,iy)
457:       read (10,rec=5,iostat=ierr) ((xlat(i,j),j=1,jx),i=1,iy)
458:       read (10,rec=6,iostat=ierr) ((xlon(i,j),j=1,jx),i=1,iy)
459:       if ( ierr/=0 ) then
460:         print * , 'END OF FILE REACHED (SST_1DEG.f)'
461:         print * , '  Check ibyte in icbc.param: ibyte= ' , ibyte
462:         stop 'EOF (subroutine gridml1d)'
463:       end if
464: !
465:       if ( igrads==1 ) then
466:         write (31,'(a)') 'title SST fields for RegCM domain'
467:         if ( ibigend==1 ) then
468:           write (31,'(a)') 'options big_endian'
469:         else
470:           write (31,'(a)') 'options little_endian'
471:         end if
472:         write (31,'(a)') 'undef -9999.'
473:         if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
474:            write (32,'(a)') 'title SeaIce fields for RegCM domain'
475:            if ( ibigend.eq.1 ) then
476:              write (32,'(a)') 'options big_endian'
477:            else
478:              write (32,'(a)') 'options little_endian'
479:            end if
480:            write (32,'(a)') 'undef -9999.'
481:         end if
482:         if ( iproj=='LAMCON' .or. iproj=='ROTMER' ) then
483:           do j = 1 , jx
484:             if ( xlat(1,j)<alatmin ) alatmin = xlat(1,j)
485:             if ( xlat(iy,j)>alatmax ) alatmax = xlat(iy,j)
486:           end do
487:           do i = 1 , iy
488:             do j = 1 , jx
489:               if ( clon>=0.0 ) then
490:                 if ( xlon(i,j)>=0.0 ) then
491:                   alonmin = amin1(alonmin,xlon(i,j))
492:                   alonmax = amax1(alonmax,xlon(i,j))
493:                 else if ( abs(clon-xlon(i,j))<abs(clon-(xlon(i,j)+360.))&
494:                         & ) then
495:                   alonmin = amin1(alonmin,xlon(i,j))
496:                   alonmax = amax1(alonmax,xlon(i,j))
497:                 else
498:                   alonmin = amin1(alonmin,xlon(i,j)+360.)
499:                   alonmax = amax1(alonmax,xlon(i,j)+360.)
500:                 end if
501:               else if ( xlon(i,j)<0.0 ) then
502:                 alonmin = amin1(alonmin,xlon(i,j))
503:                 alonmax = amax1(alonmax,xlon(i,j))
504:               else if ( abs(clon-xlon(i,j))<abs(clon-(xlon(i,j)-360.)) )&
505:                       & then
506:                 alonmin = amin1(alonmin,xlon(i,j))
507:                 alonmax = amax1(alonmax,xlon(i,j))
508:               else
509:                 alonmin = amin1(alonmin,xlon(i,j)-360.)
510:                 alonmax = amax1(alonmax,xlon(i,j)-360.)
511:               end if
512:             end do
513:           end do
514:           rlatinc = dsinm*0.001/111./2.
515:           rloninc = dsinm*0.001/111./2.
516:           ny = 2 + nint(abs(alatmax-alatmin)/rlatinc)
517:           nx = 1 + nint(abs((alonmax-alonmin)/rloninc))
518:  
519:           centerj = jx/2.
520:           centeri = iy/2.
521:         end if
522:         if ( iproj=='LAMCON' ) then        ! Lambert projection
523:           write (31,99001) jx , iy , clat , clon , centerj , centeri ,  &
524:                          & truelatl , truelath , clon , dsinm , dsinm
525:           write (31,99002) nx + 2 , alonmin - rloninc , rloninc
526:           write (31,99003) ny + 2 , alatmin - rlatinc , rlatinc
527:           if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
528:             write (32,99001) jx , iy , clat , clon , centerj , centeri ,&
529:                            & truelatl , truelath , clon , dsinm , dsinm
530:             write (32,99002) nx + 2 , alonmin - rloninc , rloninc
531:             write (32,99003) ny + 2 , alatmin - rlatinc , rlatinc
532:           end if
533:         else if ( iproj=='POLSTR' ) then   !
534:         else if ( iproj=='NORMER' ) then
535:           write (31,99004) jx , xlon(1,1) , xlon(1,2) - xlon(1,1)
536:           write (31,99005) iy
537:           write (31,99006) (xlat(i,1),i=1,iy)
538:           if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
539:             write (32,99004) jx , xlon(1,1) , xlon(1,2) - xlon(1,1)
540:             write (32,99005) iy
541:             write (32,99006) (xlat(i,1),i=1,iy)
542:           end if 
543:         else if ( iproj=='ROTMER' ) then
544:           write (*,*) 'Note that rotated Mercartor (ROTMER)' ,          &
545:                      &' projections are not supported by GrADS.'
546:           write (*,*) '  Although not exact, the eta.u projection' ,    &
547:                      &' in GrADS is somewhat similar.'
548:           write (*,*) ' FERRET, however, does support this projection.'
549:           write (31,99007) jx , iy , plon , plat , dsinm/111000. ,      &
550:                          & dsinm/111000.*.95238
551:           write (31,99002) nx + 2 , alonmin - rloninc , rloninc
552:           write (31,99003) ny + 2 , alatmin - rlatinc , rlatinc
553:           if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
554:             write (32,99007) jx , iy , plon , plat , dsinm/111000. ,    &
555:                            & dsinm/111000.*.95238
556:             write (32,99002) nx + 2 , alonmin - rloninc , rloninc
557:             write (32,99003) ny + 2 , alatmin - rlatinc , rlatinc
558:           end if
559:         else
560:           write (*,*) 'Are you sure your map projection is correct ?'
561:           stop
562:         end if
563:         write (31,99008) 1 , 1000.
564:         month = idate1 - (idate1/100)*100
565:         period = (idate2/100-idate1/100)*12 + (idate2-(idate2/100)*100) &
566:                & - (idate1-(idate1/100)*100) + 1
567:         write (31,99009) period , cmonth(month) , idate1/100
568:         write (31,99010) 1
569:         write (31,99011) 'sst ' , 'Sea Surface Temperature    '
570:         write (31,'(a)') 'endvars'
571:         close (31)
572:         if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
573:           write (32,99008) 1 , 1000.
574:           write (32,99009) period , cmonth(month) , idate1/100
575:           write (32,99010) 1
576:           write (32,99011) 'ice ' , 'Sea Ice fraction           '
577:           write (32,'(a)') 'endvars'
578:           close (32)
579:         end if
580:       end if
581: 99001 format ('pdef ',i4,1x,i4,1x,'lcc',7(1x,f7.2),1x,2(f7.0,1x))
582: 99002 format ('xdef ',i4,' linear ',f7.2,1x,f7.4)
583: 99003 format ('ydef ',i4,' linear ',f7.2,1x,f7.4)
584: 99004 format ('xdef ',i3,' linear ',f9.4,' ',f9.4)
585: 99005 format ('ydef ',i3,' levels')
586: 99006 format (10F7.2)
587: 99007 format ('pdef ',i4,1x,i4,1x,'eta.u',2(1x,f7.3),2(1x,f9.5))
588: 99008 format ('zdef ',i1,' levels ',f7.2)
589: 99009 format ('tdef ',i4,' linear 00z16',a3,i4,' 1mo')
590: 99010 format ('vars ',i1)
591: 99011 format (a4,'0 99 ',a26)
592: !
593:       end subroutine gridml1d
594: !
595: !-----------------------------------------------------------------------
596: !
<p><a name=gridml2><H3>gridml2</H3></a></p> Click <a href="./callingtree/gridml2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where gridml2 is used.
<hr>
597:       subroutine gridml2(xlon,xlat,lu,iy,jx,idate1,inumber,ibyte,ssttyp)
598:       implicit none
599: !
600: ! Dummy arguments
601: !
602:       integer :: ibyte , idate1 , iy , jx , inumber
603:       real(4) , dimension(iy,jx) :: lu , xlat , xlon
604:       character(5) :: ssttyp
605:       intent (in) ibyte , idate1 , iy , jx , inumber , ssttyp
606:       intent (out) lu , xlat , xlon
607: !
608: ! Local variables
609: !
610:       real(4) :: truelath , truelatl
611:       real(4) :: alatmax , alatmin , alonmax , alonmin , centeri ,      &
612:             & centerj , clat , clon , dsinm , grdfac , plat , plon ,    &
613:             & ptop , rlatinc , rloninc
614:       character(2) , dimension(31) :: cday
615:       character(3) , dimension(12) :: cmonth
616:       integer :: day , i , ibigend , ierr , igrads , iyy , j , jxx , k ,&
617:                & kz , month , nx , ny
618:       character(6) :: iproj
619:       real(4) , dimension(30) :: sigmaf
620: !
621:       data cmonth/'jan' , 'feb' , 'mar' , 'apr' , 'may' , 'jun' ,       &
622:          & 'jul' , 'aug' , 'sep' , 'oct' , 'nov' , 'dec'/
623:       data cday/'01' , '02' , '03' , '04' , '05' , '06' , '07' , '08' , &
624:          & '09' , '10' , '11' , '12' , '13' , '14' , '15' , '16' ,      &
625:          & '17' , '18' , '19' , '20' , '21' , '22' , '23' , '24' ,      &
626:          & '25' , '26' , '27' , '28' , '29' , '30' , '31'/
627: !
628:       alatmin = 999999.
629:       alatmax = -999999.
630:       alonmin = 999999.
631:       alonmax = -999999.
632:       nx = 0
633:       ny = 0
634:       read (10,rec=1,iostat=ierr) iyy , jxx , kz , dsinm , clat , clon ,&
635:                                 & plat , plon , grdfac , iproj ,        &
636:                                 & (sigmaf(k),k=1,kz+1) , ptop , igrads ,&
637:                                 & ibigend , truelatl , truelath
638:       if ( iyy/=iy .or. jxx/=jx ) then
639:         print * , 'IMPROPER DIMENSION SPECIFICATION (SST_1DEG.f)'
640:         print * , '  regcm.in   : ' , iy , jx
641:         print * , '  DOMAIN.INFO: ' , iyy , jxx
642:         print * , '  Also check ibyte in icbc.param: ibyte= ' , ibyte
643:         stop 'Dimensions (subroutine gridml2)'
644:       end if
645:       read (10,rec=4,iostat=ierr) ((lu(i,j),j=1,jx),i=1,iy)
646:       read (10,rec=5,iostat=ierr) ((xlat(i,j),j=1,jx),i=1,iy)
647:       read (10,rec=6,iostat=ierr) ((xlon(i,j),j=1,jx),i=1,iy)
648:       if ( ierr/=0 ) then
649:         print * , 'END OF FILE REACHED (SST_1DEG.f)'
650:         print * , '  Check ibyte in icbc.param: ibyte= ' , ibyte
651:         stop 'EOF (subroutine gridml2)'
652:       end if
653: !
654:       if ( igrads==1 ) then
655:         write (31,'(a)') 'title SST fields for RegCM domain'
656:         if ( ibigend==1 ) then
657:           write (31,'(a)') 'options big_endian'
658:         else
659:           write (31,'(a)') 'options little_endian'
660:         end if
661:         write (31,'(a)') 'undef -9999.'
662:         if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
663:            write (32,'(a)') 'title SeaIce fields for RegCM domain'
664:            if ( ibigend.eq.1 ) then
665:              write (32,'(a)') 'options big_endian'
666:            else
667:              write (32,'(a)') 'options little_endian'
668:            end if
669:            write (32,'(a)') 'undef -9999.'
670:         end if
671:         if ( iproj=='LAMCON' .or. iproj=='ROTMER' ) then
672:           do j = 1 , jx
673:             if ( xlat(1,j)<alatmin ) alatmin = xlat(1,j)
674:             if ( xlat(iy,j)>alatmax ) alatmax = xlat(iy,j)
675:           end do
676:           do i = 1 , iy
677:             do j = 1 , jx
678:               if ( clon>=0.0 ) then
679:                 if ( xlon(i,j)>=0.0 ) then
680:                   alonmin = amin1(alonmin,xlon(i,j))
681:                   alonmax = amax1(alonmax,xlon(i,j))
682:                 else if ( abs(clon-xlon(i,j))<abs(clon-(xlon(i,j)+360.))&
683:                         & ) then
684:                   alonmin = amin1(alonmin,xlon(i,j))
685:                   alonmax = amax1(alonmax,xlon(i,j))
686:                 else
687:                   alonmin = amin1(alonmin,xlon(i,j)+360.)
688:                   alonmax = amax1(alonmax,xlon(i,j)+360.)
689:                 end if
690:               else if ( xlon(i,j)<0.0 ) then
691:                 alonmin = amin1(alonmin,xlon(i,j))
692:                 alonmax = amax1(alonmax,xlon(i,j))
693:               else if ( abs(clon-xlon(i,j))<abs(clon-(xlon(i,j)-360.)) )&
694:                       & then
695:                 alonmin = amin1(alonmin,xlon(i,j))
696:                 alonmax = amax1(alonmax,xlon(i,j))
697:               else
698:                 alonmin = amin1(alonmin,xlon(i,j)-360.)
699:                 alonmax = amax1(alonmax,xlon(i,j)-360.)
700:               end if
701:             end do
702:           end do
703:           rlatinc = dsinm*0.001/111./2.
704:           rloninc = dsinm*0.001/111./2.
705:           ny = 2 + nint(abs(alatmax-alatmin)/rlatinc)
706:           nx = 1 + nint(abs((alonmax-alonmin)/rloninc))
707:  
708:           centerj = jx/2.
709:           centeri = iy/2.
710:         end if
711:         if ( iproj=='LAMCON' ) then        ! Lambert projection
712:           write (31,99001) jx , iy , clat , clon , centerj , centeri ,  &
713:                          & truelatl , truelath , clon , dsinm , dsinm
714:           write (31,99002) nx + 2 , alonmin - rloninc , rloninc
715:           write (31,99003) ny + 2 , alatmin - rlatinc , rlatinc
716:           if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
717:             write (32,99001) jx , iy , clat , clon , centerj , centeri ,&
718:                            & truelatl , truelath , clon , dsinm , dsinm
719:             write (32,99002) nx + 2 , alonmin - rloninc , rloninc
720:             write (32,99003) ny + 2 , alatmin - rlatinc , rlatinc
721:           end if
722:         else if ( iproj=='POLSTR' ) then   !
723:         else if ( iproj=='NORMER' ) then
724:           write (31,99004) jx , xlon(1,1) , xlon(1,2) - xlon(1,1)
725:           write (31,99005) iy
726:           write (31,99006) (xlat(i,1),i=1,iy)
727:           if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
728:             write (32,99004) jx , xlon(1,1) , xlon(1,2) - xlon(1,1)
729:             write (32,99005) iy
730:             write (32,99006) (xlat(i,1),i=1,iy)
731:           end if 
732:         else if ( iproj=='ROTMER' ) then
733:           write (*,*) 'Note that rotated Mercartor (ROTMER)' ,          &
734:                      &' projections are not supported by GrADS.'
735:           write (*,*) '  Although not exact, the eta.u projection' ,    &
736:                      &' in GrADS is somewhat similar.'
737:           write (*,*) ' FERRET, however, does support this projection.'
738:           write (31,99007) jx , iy , plon , plat , dsinm/111000. ,      &
739:                          & dsinm/111000.*.95238
740:           write (31,99002) nx + 2 , alonmin - rloninc , rloninc
741:           write (31,99003) ny + 2 , alatmin - rlatinc , rlatinc
742:           if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
743:             write (32,99007) jx , iy , plon , plat , dsinm/111000. ,    &
744:                            & dsinm/111000.*.95238
745:             write (32,99002) nx + 2 , alonmin - rloninc , rloninc
746:             write (32,99003) ny + 2 , alatmin - rlatinc , rlatinc
747:           end if
748:         else
749:           write (*,*) 'Are you sure your map projection is correct ?'
750:           stop
751:         end if
752:         write (31,99008) 1 , 1000.
753:         month = idate1/100 - (idate1/10000)*100
754:         day = mod(idate1,100)
755:         write (31,99009) inumber , cday(day) , cmonth(month) ,          &
756:                        & idate1/10000
757:         write (31,99010) 1
758:         write (31,99011) 'sst ' , 'surface elevation          '
759:         write (31,'(a)') 'endvars'
760:         close (31)
761:         if ( ssttyp=='OI2ST' .or. ssttyp=='OI2WK' ) then
762:           write (32,99008) 1 , 1000.
763:           write (32,99009) inumber , cday(day) , cmonth(month) ,        &
764:                        & idate1/10000
765:           write (32,99010) 1
766:           write (32,99011) 'ice ' , 'Sea Ice fraction           '
767:           write (32,'(a)') 'endvars'
768:           close (32)
769:         end if
770:       end if
771: 99001 format ('pdef ',i4,1x,i4,1x,'lcc',7(1x,f7.2),1x,2(f7.0,1x))
772: 99002 format ('xdef ',i4,' linear ',f7.2,1x,f7.4)
773: 99003 format ('ydef ',i4,' linear ',f7.2,1x,f7.4)
774: 99004 format ('xdef ',i3,' linear ',f9.4,' ',f9.4)
775: 99005 format ('ydef ',i3,' levels')
776: 99006 format (10F7.2)
777: 99007 format ('pdef ',i4,1x,i4,1x,'eta.u',2(1x,f7.3),2(1x,f9.5))
778: 99008 format ('zdef ',i1,' levels ',f7.2)
779: 99009 format ('tdef ',i4,' linear 00z',a2,a3,i4,' 7dy')
780: 99010 format ('vars ',i1)
781: 99011 format (a4,'0 99 ',a26)
782: !
783:       end subroutine gridml2
784: !
785: !-----------------------------------------------------------------------
786: !
<p><a name=headwk><H3>headwk</H3></a></p> Click <a href="./callingtree/headwk_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where headwk is used.
<hr>
787:       subroutine headwk(wkday)
788:       implicit none
789: !
790: ! Dummy arguments
791: !
792:       integer , intent(out) , dimension(427+1097) :: wkday
793: !
794: ! Local variables
795: !
796:       integer :: i , mday , month , myear
797: !
798:       wkday(1) = 19811029
799:       do i = 2 , 427
800:         wkday(i) = wkday(i-1) + 7
801:         myear = wkday(i)/10000
802:         month = wkday(i)/100 - myear*100
803:         mday = mod(wkday(i),10000) - month*100
804:         if ( month==1 .or. month==3 .or. month==5 .or. month==7 .or.    &
805:            & month==8 .or. month==10 ) then
806:           if ( mday>31 ) then
807:             mday = mday - 31
808:             month = month + 1
809:           end if
810:         else if ( month==12 ) then
811:           if ( mday>31 ) then
812:             mday = mday - 31
813:             month = 1
814:             myear = myear + 1
815:           end if
816:         else if ( month==4 .or. month==6 .or. month==9 .or. month==11 ) &
817:                 & then
818:           if ( mday>30 ) then
819:             mday = mday - 30
820:             month = month + 1
821:           end if
822:         else if ( mod(myear,4)/=0 ) then
823:           if ( mday>28 ) then
824:             mday = mday - 28
825:             month = month + 1
826:           end if
827:         else if ( mod(myear,400)==0 ) then
828:           if ( mday>29 ) then
829:             mday = mday - 29
830:             month = month + 1
831:           end if
832:         else if ( mod(myear,100)==0 ) then
833:           if ( mday>28 ) then
834:             mday = mday - 28
835:             month = month + 1
836:           end if
837:         else if ( mday>29 ) then
838:           mday = mday - 29
839:           month = month + 1
840:         else
841:         end if
842:         wkday(i) = myear*10000 + month*100 + mday
843:       end do
844: !
845:       wkday(428) = 19891231
846:       do i = 429 , 427 + 1097
847:         wkday(i) = wkday(i-1) + 7
848:         myear = wkday(i)/10000
849:         month = wkday(i)/100 - myear*100
850:         mday = mod(wkday(i),10000) - month*100
851:         if ( month==1 .or. month==3 .or. month==5 .or. month==7 .or.    &
852:            & month==8 .or. month==10 ) then
853:           if ( mday>31 ) then
854:             mday = mday - 31
855:             month = month + 1
856:           end if
857:         else if ( month==12 ) then
858:           if ( mday>31 ) then
859:             mday = mday - 31
860:             month = 1
861:             myear = myear + 1
862:           end if
863:         else if ( month==4 .or. month==6 .or. month==9 .or. month==11 ) &
864:                 & then
865:           if ( mday>30 ) then
866:             mday = mday - 30
867:             month = month + 1
868:           end if
869:         else if ( mod(myear,4)/=0 ) then
870:           if ( mday>28 ) then
871:             mday = mday - 28
872:             month = month + 1
873:           end if
874:         else if ( mod(myear,400)==0 ) then
875:           if ( mday>29 ) then
876:             mday = mday - 29
877:             month = month + 1
878:           end if
879:         else if ( mod(myear,100)==0 ) then
880:           if ( mday>28 ) then
881:             mday = mday - 28
882:             month = month + 1
883:           end if
884:         else if ( mday>29 ) then
885:           mday = mday - 29
886:           month = month + 1
887:         else
888:         end if
889:         wkday(i) = myear*10000 + month*100 + mday
890:       end do
891: !
892:       end subroutine headwk
893: !
894: !-----------------------------------------------------------------------
895: !
<p><a name=sst_mn><H3>sst_mn</H3></a></p> Click <a href="./callingtree/sst_mn_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sst_mn is used.
<hr>
896:       subroutine sst_mn(idate,idate0,ilon,jlat,sst,pathaddname)
897:       use <a href="#" TARGET=CENT_PANEL>netcdf</a>
898:       implicit none
899: !
900: ! Dummy arguments
901: !
902:       integer :: idate , idate0 , ilon , jlat
903:       character(256) :: pathaddname
904:       intent (in) idate , idate0 , ilon , jlat , pathaddname
905:       real(4) , dimension(ilon,jlat) :: sst
906:       intent (out) :: sst
907: !
908: ! Local variables
909: !
910:       integer :: i , it , j , month , n , nday , nhour , nyear
911:       logical :: there
912:       character(5) :: varname
913:       integer(2) , dimension(ilon,jlat) :: work
914:       integer :: istatus
915: !
916:       integer , dimension(10) , save :: icount , istart
917:       integer , save :: inet , ivar
918:       real(8) , save :: xadd , xscale
919: !
920: !     This is the latitude, longitude dimension of the grid to be read.
921: !     This corresponds to the lat and lon dimension variables in the
922: !     netCDF file.
923: !
924: !     The data are packed into short integers (INTEGER*2).  The array
925: !     work will be used to hold the packed integers. The array 'sst'
926: !     will contain the unpacked data.
927: !
928: !     DATA ARRAY AND WORK ARRAY
929: !
930:       data varname/'sst'/
931: !
932:       if ( idate==idate0 ) then
933:         inquire (file=pathaddname,exist=there)
934:         if ( .not.there ) then
935:           write (*,*) trim(pathaddname) , ' is not available'
936:           stop
937:         end if
938:         istatus = nf90_open(pathaddname,nf90_nowrite,inet)
939:         if ( istatus/=nf90_noerr ) then
940:           write ( 6,* ) 'Cannot open input file ', trim(pathaddname)
941:           stop 'INPUT FILE OPEN ERROR'
942:         end if
943:         istatus = nf90_inq_varid(inet,varname,ivar)
944:         if ( istatus/=nf90_noerr ) then
945:           write ( 6,* ) 'Cannot find variable ', varname,               &
946:                &        ' in input file ', trim(pathaddname)
947:           stop 'INPUT FILE ERROR'
948:         end if
949:         istatus = nf90_get_att(inet,ivar,'scale_factor',xscale)
950:         istatus = nf90_get_att(inet,ivar,'add_offset',xadd)
951:         istart(1) = 1
952:         istart(2) = 1
953:         icount(1) = ilon
954:         icount(2) = jlat
955:         do n = 4 , 10
956:           istart(n) = 0
957:           icount(n) = 0
958:         end do
959:       end if
960:  
961: !bxq
962:       nyear = idate/1000000
963:       month = idate/10000 - nyear*100
964:       nday = idate/100 - nyear*10000 - month*100
965:       nhour = idate - nyear*1000000 - month*10000 - nday*100
966:  
967:       it = (nyear-1981)*12 + month - 11
968:  
969:       istart(3) = it
970:       icount(3) = 1
971:       istatus = nf90_get_var(inet,ivar,work,istart,icount)
972:       if ( istatus/=nf90_noerr ) then
973:         write ( 6,* ) 'Cannot get ', varname, ' from file'
974:         write ( 6,* ) istart
975:         write ( 6,* ) icount
976:         write ( 6,* ) nf90_strerror(istatus)
977:         stop 'ERROR READ SST'
978:       end if
979: !bxq_
980: !
981:       do j = 1 , jlat
982:         do i = 1 , ilon
983:           if ( work(i,j)==32767 ) then
984:              sst(i,jlat+1-j) = -9999.
985:           else
986:              sst(i,jlat+1-j) = work(i,j)*xscale + xadd
987:           end if
988:         end do
989:       end do
990: !
991:       end subroutine sst_mn
992: !
993: !-----------------------------------------------------------------------
994: !
<p><a name=ice_mn><H3>ice_mn</H3></a></p> Click <a href="./callingtree/ice_mn_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ice_mn is used.
<hr>
995:       subroutine ice_mn(idate,idate0,ilon,jlat,ice,pathaddname)
996:       use <a href="#" TARGET=CENT_PANEL>netcdf</a>
997:       implicit none
998: !
999: ! Dummy arguments
1000: !
1001:       integer :: idate , idate0 , ilon , jlat
1002:       character(256) :: pathaddname
1003:       intent (in) idate , idate0 , ilon , jlat , pathaddname
1004:       real(4) , dimension(ilon,jlat) :: ice
1005:       intent (out) :: ice
1006: !
1007: ! Local variables
1008: !
1009:       integer :: i , it , j , month , n , nday , nhour , nyear
1010:       logical :: there
1011:       character(5) :: varname
1012:       integer(2) , dimension(ilon,jlat) :: work
1013:       integer :: istatus
1014: !
1015:       integer , dimension(10) , save :: icount , istart
1016:       integer , save :: inet , ivar
1017:       real(8) , save :: xadd , xscale
1018: !
1019: !     This is the latitude, longitude dimension of the grid to be read.
1020: !     This corresponds to the lat and lon dimension variables in the
1021: !     netCDF file.
1022: !
1023: !     The data are packed into short integers (INTEGER*2).  The array
1024: !     work will be used to hold the packed integers. The array 'sst'
1025: !     will contain the unpacked data.
1026: !
1027: !     DATA ARRAY AND WORK ARRAY
1028: !
1029:       data varname/'ice'/
1030: !
1031:       if ( idate==idate0 ) then
1032:         inquire (file=pathaddname,exist=there)
1033:         if ( .not.there ) then
1034:           write (*,*) trim(pathaddname) , ' is not available'
1035:           stop
1036:         end if
1037:         istatus = nf90_open(pathaddname,nf90_nowrite,inet)
1038:         if ( istatus/=nf90_noerr ) then
1039:           write ( 6,* ) 'Cannot open input file ', trim(pathaddname)
1040:           stop 'INPUT FILE OPEN ERROR'
1041:         end if
1042:         istatus = nf90_inq_varid(inet,varname,ivar)
1043:         if ( istatus/=nf90_noerr ) then
1044:           write ( 6,* ) 'Cannot find variable ', varname,               &
1045:                &        ' in input file ', trim(pathaddname)
1046:           stop 'INPUT FILE ERROR'
1047:         end if
1048:         istatus = nf90_get_att(inet,ivar,'scale_factor',xscale)
1049:         istatus = nf90_get_att(inet,ivar,'add_offset',xadd)
1050:         istart(1) = 1
1051:         istart(2) = 1
1052:         icount(1) = ilon
1053:         icount(2) = jlat
1054:         do n = 4 , 10
1055:           istart(n) = 0
1056:           icount(n) = 0
1057:         end do
1058:       end if
1059:  
1060: !bxq
1061:       nyear = idate/1000000
1062:       month = idate/10000 - nyear*100
1063:       nday = idate/100 - nyear*10000 - month*100
1064:       nhour = idate - nyear*1000000 - month*10000 - nday*100
1065:  
1066:       it = (nyear-1981)*12 + month - 11
1067:  
1068:       istart(3) = it
1069:       icount(3) = 1
1070:       istatus = nf90_get_var(inet,ivar,work,istart,icount)
1071:       if ( istatus/=nf90_noerr ) then
1072:         write ( 6,* ) 'Cannot get ', varname, ' from file'
1073:         write ( 6,* ) istart
1074:         write ( 6,* ) icount
1075:         write ( 6,* ) nf90_strerror(istatus)
1076:         stop 'ERROR READ SST'
1077:       end if
1078: !bxq_
1079: !
1080:       do j = 1 , jlat
1081:         do i = 1 , ilon
1082:           if ( work(i,j)==32767 ) then
1083:              ice(i,jlat+1-j) = -9999.
1084:           else
1085:              ice(i,jlat+1-j) = work(i,j)*xscale + xadd
1086:           end if
1087:         end do
1088:       end do
1089: !
1090:       end subroutine ice_mn
1091: !
1092: !-----------------------------------------------------------------------
1093: !
<p><a name=sst_wk><H3>sst_wk</H3></a></p> Click <a href="./callingtree/sst_wk_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sst_wk is used.
<hr>
1094:       subroutine sst_wk(idate,idate0,kkk,ilon,jlat,sst,pathaddname)
1095:       use <a href="#" TARGET=CENT_PANEL>netcdf</a>
1096:       implicit none
1097: !
1098: ! Dummy arguments
1099: !
1100:       integer :: idate , idate0 , kkk , ilon , jlat
1101:       character(256) :: pathaddname
1102:       intent (in) idate , idate0 , kkk , ilon , jlat , pathaddname
1103:       real(4) , dimension(ilon,jlat) :: sst
1104:       intent (out) :: sst
1105: !
1106: ! Local variables
1107: !
1108:       integer :: i , it , j , month , n , nday , nhour , nyear
1109:       logical :: there
1110:       character(3) :: varname
1111:       integer :: istatus
1112:       integer(2) , dimension(ilon,jlat) :: work
1113: !
1114:       integer , dimension(10) , save :: icount , istart
1115:       integer , save :: inet , ivar
1116:       real(8) , save :: xadd , xscale
1117: !
1118: !     This is the latitude, longitude dimension of the grid to be read.
1119: !     This corresponds to the lat and lon dimension variables in the
1120: !     netCDF file.
1121: !
1122: !     The data are packed into short integers (INTEGER*2).  The array
1123: !     work will be used to hold the packed integers. The array 'sst'
1124: !     will contain the unpacked data.
1125: !
1126: !     DATA ARRAY AND WORK ARRAY
1127: !
1128:       data varname/'sst'/
1129: !
1130:       if ( idate==idate0 ) then
1131:         inquire (file=pathaddname,exist=there)
1132:         if ( .not.there ) then
1133:           write (*,*) trim(pathaddname) , ' is not available'
1134:           stop
1135:         end if
1136:         istatus = nf90_open(pathaddname,nf90_nowrite,inet)
1137:         if ( istatus/=nf90_noerr ) then
1138:           write ( 6,* ) 'Cannot open input file ', trim(pathaddname)
1139:           stop 'INPUT FILE OPEN ERROR'
1140:         end if
1141:         istatus = nf90_inq_varid(inet,varname,ivar)
1142:         if ( istatus/=nf90_noerr ) then
1143:           write ( 6,* ) 'Cannot find variable ', varname,               &
1144:                &        ' in input file ', trim(pathaddname)
1145:           stop 'INPUT FILE ERROR'
1146:         end if
1147:         istatus = nf90_get_att(inet,ivar,'scale_factor',xscale)
1148:         istatus = nf90_get_att(inet,ivar,'add_offset',xadd)
1149:         istart(1) = 1
1150:         istart(2) = 1
1151:         icount(1) = ilon
1152:         icount(2) = jlat
1153:         do n = 4 , 10
1154:           istart(n) = 0
1155:           icount(n) = 0
1156:         end do
1157:       end if
1158:       if ( idate0<1989123100 .and. idate==1989123100 ) then
1159:         istatus = nf90_close(inet)
1160:         inquire (file=pathaddname,exist=there)
1161:         if ( .not.there ) then
1162:           write (*,*) trim(pathaddname) , ' is not available'
1163:           stop
1164:         end if
1165:         istatus = nf90_open(pathaddname,nf90_nowrite,inet)
1166:         if ( istatus/=nf90_noerr ) then
1167:           write ( 6,* ) 'Cannot open input file ', trim(pathaddname)
1168:           stop 'INPUT FILE OPEN ERROR'
1169:         end if
1170:         istatus = nf90_inq_varid(inet,varname,ivar)
1171:         if ( istatus/=nf90_noerr ) then
1172:           write ( 6,* ) 'Cannot find variable ', varname,               &
1173:                &        ' in input file ', trim(pathaddname)
1174:           stop 'INPUT FILE ERROR'
1175:         end if
1176:         istatus = nf90_get_att(inet,ivar,'scale_factor',xscale)
1177:         istatus = nf90_get_att(inet,ivar,'add_offset',xadd)
1178:         istart(1) = 1
1179:         istart(2) = 1
1180:         icount(1) = ilon
1181:         icount(2) = jlat
1182:         do n = 4 , 10
1183:           istart(n) = 0
1184:           icount(n) = 0
1185:         end do
1186:       end if
1187: !bxq
1188:       nyear = idate/1000000
1189:       month = idate/10000 - nyear*100
1190:       nday = idate/100 - nyear*10000 - month*100
1191:       nhour = idate - nyear*1000000 - month*10000 - nday*100
1192:  
1193:       it = kkk
1194:       if ( kkk>427 ) it = kkk - 427
1195:  
1196:       istart(3) = it
1197:       icount(3) = 1
1198:       istatus = nf90_get_var(inet,ivar,work,istart,icount)
1199:       if ( istatus/=nf90_noerr ) then
1200:         write ( 6,* ) 'Cannot get ', varname, ' from file'
1201:         write ( 6,* ) istart
1202:         write ( 6,* ) icount
1203:         write ( 6,* ) nf90_strerror(istatus)
1204:         stop 'ERROR READ SST'
1205:       end if
1206: !bxq_
1207:       do j = 1 , jlat
1208:         do i = 1 , ilon
1209:           if ( work(i,j)==32767 ) then
1210:              sst(i,jlat+1-j) = -9999.
1211:           else
1212:              sst(i,jlat+1-j) = work(i,j)*xscale + xadd
1213:           end if
1214:         end do
1215:       end do
1216: 
1217:       end subroutine sst_wk
1218: !
1219: !-----------------------------------------------------------------------
1220: !
<p><a name=ice_wk><H3>ice_wk</H3></a></p> Click <a href="./callingtree/ice_wk_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ice_wk is used.
<hr>
1221:       subroutine ice_wk(idate,idate0,kkk,ilon,jlat,ice,pathaddname)
1222:       use <a href="#" TARGET=CENT_PANEL>netcdf</a>
1223:       implicit none
1224: !
1225: ! Dummy arguments
1226: !
1227:       integer :: idate , idate0 , kkk , ilon , jlat
1228:       character(256) :: pathaddname
1229:       intent (in) idate , idate0 , kkk , ilon , jlat , pathaddname
1230:       real(4) , dimension(ilon,jlat) :: ice
1231:       intent (out) :: ice
1232: !
1233: ! Local variables
1234: !
1235:       integer :: i , it , j , month , n , nday , nhour , nyear
1236:       logical :: there
1237:       character(3) :: varname
1238:       integer(2) , dimension(ilon,jlat) :: work
1239:       integer :: istatus
1240: !
1241:       integer , dimension(10) , save :: icount , istart
1242:       integer , save :: inet , ivar
1243:       real(8) , save :: xadd , xscale
1244: !
1245: !     This is the latitude, longitude dimension of the grid to be read.
1246: !     This corresponds to the lat and lon dimension variables in the
1247: !     netCDF file.
1248: !
1249: !     The data are packed into short integers (INTEGER*2).  The array
1250: !     work will be used to hold the packed integers. The array 'sst'
1251: !     will contain the unpacked data.
1252: !
1253: !     DATA ARRAY AND WORK ARRAY
1254: !
1255:       data varname/'ice'/
1256: !
1257:       if ( idate==idate0 ) then
1258:         inquire (file=pathaddname,exist=there)
1259:         if ( .not.there ) then
1260:           write (*,*) trim(pathaddname) , ' is not available'
1261:           stop
1262:         end if
1263:         istatus = nf90_open(pathaddname,nf90_nowrite,inet)
1264:         if ( istatus/=nf90_noerr ) then
1265:           write ( 6,* ) 'Cannot open input file ', trim(pathaddname)
1266:           stop 'INPUT FILE OPEN ERROR'
1267:         end if
1268:         istatus = nf90_inq_varid(inet,varname,ivar)
1269:         if ( istatus/=nf90_noerr ) then
1270:           write ( 6,* ) 'Cannot find variable ', varname,               &
1271:                &        ' in input file ', trim(pathaddname)
1272:           stop 'INPUT FILE ERROR'
1273:         end if
1274:         istatus = nf90_get_att(inet,ivar,'scale_factor',xscale)
1275:         istatus = nf90_get_att(inet,ivar,'add_offset',xadd)
1276:         istart(1) = 1
1277:         istart(2) = 1
1278:         icount(1) = ilon
1279:         icount(2) = jlat
1280:         do n = 4 , 10
1281:           istart(n) = 0
1282:           icount(n) = 0
1283:         end do
1284:       end if
1285:       if ( idate0<1989123100 .and. idate==1989123100 ) then
1286:         istatus = nf90_close(inet)
1287:         inquire (file=pathaddname,exist=there)
1288:         if ( .not.there ) then
1289:           write (*,*) trim(pathaddname) , ' is not available'
1290:           stop
1291:         end if
1292:         istatus = nf90_open(pathaddname,nf90_nowrite,inet)
1293:         if ( istatus/=nf90_noerr ) then
1294:           write ( 6,* ) 'Cannot open input file ', trim(pathaddname)
1295:           stop 'INPUT FILE OPEN ERROR'
1296:         end if
1297:         istatus = nf90_inq_varid(inet,varname,ivar)
1298:         if ( istatus/=nf90_noerr ) then
1299:           write ( 6,* ) 'Cannot find variable ', varname,               &
1300:                &        ' in input file ', trim(pathaddname)
1301:           stop 'INPUT FILE ERROR'
1302:         end if
1303:         istatus = nf90_get_att(inet,ivar,'scale_factor',xscale)
1304:         istatus = nf90_get_att(inet,ivar,'add_offset',xadd)
1305:         istart(1) = 1
1306:         istart(2) = 1
1307:         icount(1) = ilon
1308:         icount(2) = jlat
1309:         do n = 4 , 10
1310:           istart(n) = 0
1311:           icount(n) = 0
1312:         end do
1313:       end if
1314: !bxq
1315:       nyear = idate/1000000
1316:       month = idate/10000 - nyear*100
1317:       nday = idate/100 - nyear*10000 - month*100
1318:       nhour = idate - nyear*1000000 - month*10000 - nday*100
1319:  
1320:       it = kkk
1321:       if ( kkk>427 ) it = kkk - 427
1322:  
1323:       istart(3) = it
1324:       icount(3) = 1
1325:       istatus = nf90_get_var(inet,ivar,work,istart,icount)
1326:       if ( istatus/=nf90_noerr ) then
1327:         write ( 6,* ) 'Cannot get ', varname, ' from file'
1328:         write ( 6,* ) istart
1329:         write ( 6,* ) icount
1330:         write ( 6,* ) nf90_strerror(istatus)
1331:         stop 'ERROR READ SST'
1332:       end if
1333: !bxq_
1334:       do j = 1 , jlat
1335:         do i = 1 , ilon
1336:           if ( work(i,j)==32767 ) then
1337:              ice(i,jlat+1-j) = -9999.
1338:           else
1339:              ice(i,jlat+1-j) = work(i,j)*xscale + xadd
1340:           end if
1341:         end do
1342:       end do
1343: 
1344:       end subroutine ice_wk
1345: !
1346:       end module mod_sst_1deg
</PRE>

<HR>

</BODY>
</HTML>
