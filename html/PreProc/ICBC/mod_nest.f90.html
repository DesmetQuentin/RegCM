<HTML>

<HEAD>
<TITLE>mod_nest.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_nest.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_nest.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_nest><H3>mod_nest</H3></a></p>20:       module mod_nest
21:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
22: 
23:       implicit none
24: 
25:       private
26: 
27:       integer , parameter :: np = 15
28: 
29:       integer :: nrec
30: 
31:       real(4) , allocatable , target , dimension(:,:,:) :: b3
32:       real(4) , allocatable , target , dimension(:,:,:) :: d3
33:       real(4) , allocatable , dimension(:,:) :: b3pd
34:       real(4) , allocatable , dimension(:,:,:) :: z1
35: 
36:       real(4) , allocatable , target , dimension(:,:,:) :: b2
37:       real(4) , allocatable , target , dimension(:,:,:) :: d2
38: 
39:       real(4) , allocatable , dimension(:,:,:) :: c , q , t
40:       real(4) , allocatable , dimension(:,:,:) :: u , v
41:       real(4) , allocatable , dimension(:,:) :: ps
42:       real(4) , allocatable , dimension(:,:) :: ht_in
43:       real(4) , allocatable , dimension(:,:) :: xlat_in , xlon_in
44: 
45:       real(4) , pointer , dimension(:,:,:) :: c3 , h3 , q3 , t3
46:       real(4) , pointer , dimension(:,:,:) :: u3 , v3
47:  
48:       real(4) , pointer , dimension(:,:,:) :: cp , hp , qp , tp
49:       real(4) , pointer , dimension(:,:,:) :: up , vp
50: 
51:       real(4) , dimension(np) :: plev , sigmar
52:       real(4) , allocatable , dimension(:) :: sigf
53:       real(4) , allocatable , dimension(:) :: sig
54: 
55:       character(6) :: iproj_in
56: 
57:       integer :: iy_in , jx_in , kl , iotyp_in , idate0
58: 
59:       real(4) :: clat_in , clon_in , plat_in , plon_in , ptop_in
60: 
61:       public :: get_nest , headnest
62: 
63:       contains
64: 
<p><a name=get_nest><H3>get_nest</H3></a></p> Click <a href="./callingtree/get_nest_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where get_nest is used.
<hr>
65:       subroutine get_nest(idate,ncr)
66:       use <a href="./mod_grid.f90.html#mod_grid" TARGET=CENT_PANEL>mod_grid</a>
67:       use <a href="./mod_date.f90.html#mod_date" TARGET=CENT_PANEL>mod_date</a>
68:       use <a href="./mod_write.f90.html#mod_write" TARGET=CENT_PANEL>mod_write</a>
69:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : cressmcr , cressmdt
70:       use <a href="./mod_vertint.f90.html#mod_vertint" TARGET=CENT_PANEL>mod_vertint</a>
71:       use <a href="./mod_hgt.f90.html#mod_hgt" TARGET=CENT_PANEL>mod_hgt</a>
72:       use <a href="./mod_humid.f90.html#mod_humid" TARGET=CENT_PANEL>mod_humid</a>
73:       use <a href="./mod_mksst.f90.html#mod_mksst" TARGET=CENT_PANEL>mod_mksst</a>
74:       use <a href="./mod_uvrot.f90.html#mod_uvrot" TARGET=CENT_PANEL>mod_uvrot</a>
75:       use <a href="./mod_vectutil.f90.html#mod_vectutil" TARGET=CENT_PANEL>mod_vectutil</a>
76:       implicit none
77: !
78: ! Dummy arguments
79: !
80:       integer :: idate , ncr
81:       intent (in) ncr
82: !
83: ! Local variables
84: !
85:       character(14) :: fillin
86:       character(256) :: inpfile
87:       integer :: i , idatek , j , k , mn0 , mn1 , nd0 , nd1 , nh0 ,     &
88:                & nh1 , nmop , ny0 , ny1 , nyrp
89:       logical :: there
90:       real(4) :: wt
91: !
92:       if (.not. allocated(b2)) then
93:         write (*,*) 'Called get_nest before headnest !'
94:         stop
95:       end if
96: !
97:       if ( idate==idate0 ) then
98:         write (fillin,99001) idate
99:         inpfile = trim(inpglob)//pthsep//'RegCM'//pthsep//fillin
100:         inquire (file=inpfile,exist=there)
101:         if ( .not.there ) then
102:           write (*,*) trim(inpfile), ' is not available'
103:           write (*,*) 'please copy (or link)' , trim(inpfile)
104:           stop
105:         end if
106:         if ( iotyp_in==1 ) then
107:           open (55,file=trim(inpfile),form='unformatted',               &
108:               & recl=iy_in*jx_in*ibyte,access='direct')
109:           nrec = 0
110:         else if ( iotyp_in==2 ) then
111:           open (55,file=trim(inpfile),form='unformatted')
112:           rewind (55)
113:         else
114:         end if
115:       else if ( idate==globidate1 ) then
116:         ny0 = idate0/1000000
117:         mn0 = mod(idate0/10000,100)
118:         nd0 = mod(idate0/100,100)
119:         nh0 = mod(idate0,100)
120:  
121:         ny1 = globidate1/1000000
122:         mn1 = mod(globidate1/10000,100)
123:         nd1 = mod(globidate1/100,100)
124:         nh1 = mod(globidate1,100)
125:  
126:         if ( ny0==ny1 .and. mn0==mn1 ) then
127:           write (fillin,99001) idate0
128:           inpfile = trim(inpglob)//pthsep//'RegCM'//pthsep//fillin
129:           inquire (file=trim(inpfile),exist=there)
130:           if ( .not.there ) then
131:             write (*,*) trim(inpfile), ' is not available'
132:             write (*,*) 'please copy (or link)' , trim(inpfile)
133:             stop
134:           end if
135:           if ( iotyp_in==1 ) then
136:             open (55,file=trim(inpfile),form='unformatted',             &
137:                 & recl=iy_in*jx_in*ibyte,access='direct')
138:             nrec = ((nd1-nd0)*4+(nh1-nh0)/6)*(kl*6+5)
139:           else if ( iotyp_in==2 ) then
140:             open (55,file=trim(inpfile),form='unformatted')
141:             rewind (55)
142:           else
143:           end if
144:         else if ( nd1==1 .and. nh1==0 ) then
145:           if ( (ny1-ny0)*12+(mn1-mn0)==1 ) then
146:             write (fillin,99001) idate0
147:             inpfile = trim(inpglob)//pthsep//'RegCM'//pthsep//fillin
148:             inquire (file=trim(inpfile),exist=there)
149:             if ( .not.there ) then
150:               write (*,*) trim(inpfile), ' is not available'
151:               write (*,*) 'please copy (or link)' , trim(inpfile)
152:               stop
153:             end if
154:             if ( iotyp_in==1 ) then
155:               open (55,file=trim(inpfile),form='unformatted',           &
156:                  &  recl=iy_in*jx_in*ibyte,access='direct')
157:               if ( mn0==1 .or. mn0==3 .or. mn0==5 .or. mn0==7 .or.      &
158:                  & mn0==8 .or. mn0==10 .or. mn0==12 ) then
159:                 nrec = (124-(nd0-1)*4+nh0/6)*(kl*6+5)
160:               else if ( mn0==4 .or. mn0==6 .or. mn0==9 .or. mn0==11 )   &
161:                       & then
162:                 nrec = (120-(nd0-1)*4+nh0/6)*(kl*6+5)
163:               else
164:                 nrec = 112 - (nd0-1)*4 + nh0/6
165:                 if ( mod(ny0,4)==0 ) nrec = nrec + 4
166:                 if ( mod(ny0,100)==0 ) nrec = nrec - 4
167:                 if ( mod(ny0,400)==0 ) nrec = nrec + 4
168:                 nrec = nrec*(kl*6+5)
169:               end if
170:             else if ( iotyp_in==2 ) then
171:               open (55,file=trim(inpfile),form='unformatted')
172:               rewind (55)
173:             else
174:             end if
175:           else
176:             if ( mn1>1 ) then
177:               write (fillin,99001) ny1*1000000 + (mn1-1)*10000 + 100
178:             else
179:               write (fillin,99001) (ny1-1)*1000000 + 120100
180:             end if
181:             inpfile = trim(inpglob)//pthsep//'RegCM'//pthsep//fillin
182:             inquire (file=trim(inpfile),exist=there)
183:             if ( .not.there ) then
184:               write (*,*) trim(inpfile), ' is not available'
185:               write (*,*) 'please copy (or link)' , trim(inpfile)
186:               stop
187:             end if
188:             if ( iotyp_in==1 ) then
189:               open (55,file=trim(inpfile),form='unformatted',           &
190:                   & recl=iy_in*jx_in*ibyte,access='direct')
191:               if ( mn0==1 .or. mn0==3 .or. mn0==5 .or. mn0==7 .or.      &
192:                  & mn0==8 .or. mn0==10 .or. mn0==12 ) then
193:                 nrec = 123*(kl*6+5)
194:               else if ( mn0==4 .or. mn0==6 .or. mn0==9 .or. mn0==11 )   &
195:                       & then
196:                 nrec = 119*(kl*6+5)
197:               else
198:                 nrec = 111
199:                 if ( mod(ny0,4)==0 ) nrec = nrec + 4
200:                 if ( mod(ny0,100)==0 ) nrec = nrec - 4
201:                 if ( mod(ny0,400)==0 ) nrec = nrec + 4
202:                 nrec = nrec*(kl*6+5)
203:               end if
204:             else if ( iotyp_in==2 ) then
205:               open (55,file=trim(inpfile),form='unformatted')
206:               rewind (55)
207:             else
208:             end if
209:           end if
210:         else
211:           write (fillin,99001) ny1*1000000 + mn1*10000 + 100
212:           inpfile = trim(inpglob)//pthsep//'RegCM'//pthsep//fillin
213:           inquire (file=trim(inpfile),exist=there)
214:           if ( .not.there ) then
215:             write (*,*) trim(inpfile), ' is not available'
216:             write (*,*) 'please copy (or link)' , trim(inpfile)
217:             stop
218:           end if
219:           if ( iotyp_in==1 ) then
220:             open (55,file=trim(inpfile),form='unformatted',             &
221:                 & recl=iy_in*jx_in*ibyte,access='direct')
222:             nrec = ((nd1-1)*4+nh1/6-1)*(kl*6+5)
223:           else if ( iotyp_in==2 ) then
224:             open (55,file=trim(inpfile),form='unformatted')
225:             rewind (55)
226:           else
227:           end if
228:         end if
229:       else
230:       end if
231: 
232:       ! write (6,*) 'Open ATM file: ', trim(inpfile)
233:  
234:       if ( iotyp_in==1 ) then
235:         if ( idate/=globidate1 .and. mod(idate,10000)==100 .and.        &
236:            & ncr==1 ) nrec = nrec - (kl*6+5)
237:         idatek = idate
238:         do k = kl , 1 , -1
239:           nrec = nrec + 1
240:           read (55,rec=nrec) ((u(i,j,k),i=1,jx_in),j=1,iy_in)
241:         end do
242:         do k = kl , 1 , -1
243:           nrec = nrec + 1
244:           read (55,rec=nrec) ((v(i,j,k),i=1,jx_in),j=1,iy_in)
245:         end do
246:         nrec = nrec + kl         ! skip omega
247:         do k = kl , 1 , -1
248:           nrec = nrec + 1
249:           read (55,rec=nrec) ((t(i,j,k),i=1,jx_in),j=1,iy_in)
250:         end do
251:         do k = kl , 1 , -1
252:           nrec = nrec + 1
253:           read (55,rec=nrec) ((q(i,j,k),i=1,jx_in),j=1,iy_in)
254:         end do
255:         do k = kl , 1 , -1
256:           nrec = nrec + 1
257:           read (55,rec=nrec) ((c(i,j,k),i=1,jx_in),j=1,iy_in)
258:         end do
259:         nrec = nrec + 1
260:         read (55,rec=nrec) ((ps(i,j),i=1,jx_in),j=1,iy_in)
261:         nrec = nrec + 4
262:       else if ( iotyp_in==2 ) then
263:         if ( idate/=globidate1 .and. mod(idate,10000)==100 .and.        &
264:            & ncr==1 ) rewind (55)
265:  50     continue
266:         read (55) idatek
267:         if ( idatek/=idate ) then
268:           do k = 1 , kl*6 + 5
269:             read (55)
270:           end do
271: !         WRITE(*,*) 'READ IN fields at DATE:',idateK
272:           go to 50
273:         end if
274: !       idate=idateK
275:  
276: !       print*,' IDATE = ',idate
277:         do k = kl , 1 , -1
278:           read (55) ((u(i,j,k),i=1,jx_in),j=1,iy_in)
279:         end do
280:         do k = kl , 1 , -1
281:           read (55) ((v(i,j,k),i=1,jx_in),j=1,iy_in)
282:         end do
283:         do k = kl , 1 , -1
284:           read (55)
285:         end do
286:         do k = kl , 1 , -1
287:           read (55) ((t(i,j,k),i=1,jx_in),j=1,iy_in)
288:         end do
289:         do k = kl , 1 , -1
290:           read (55) ((q(i,j,k),i=1,jx_in),j=1,iy_in)
291:         end do
292:         do k = 1 , kl
293:           read (55) ((c(i,j,k),i=1,jx_in),j=1,iy_in)
294:         end do
295:         read (55) ((ps(i,j),i=1,jx_in),j=1,iy_in)
296:         do k = 1 , 4
297:           read (55)
298:         end do
299:       else
300:       end if
301:       write (*,*) 'READ IN fields at DATE:' , idatek , ' from ' , fillin
302: 
303:       if ( idate/=globidate1 .and. mod(idate,10000)==100 .and. ncr==1 ) then
304:         write (fillin,99001) idate
305:         inpfile = trim(inpglob)//pthsep//'RegCM'//pthsep//fillin
306:         inquire (file=trim(inpfile),exist=there)
307:         if ( .not.there ) then
308:           write (*,*) trim(inpfile), ' is not available'
309:           write (*,*) 'please copy (or link)' , trim(inpfile)
310:           stop
311:         end if
312:         if ( iotyp_in==1 ) then
313:           open (55,file=trim(inpfile),form='unformatted',               &
314:               & recl=iy_in*jx_in*ibyte,access='direct')
315:           nrec = 0
316:         else if ( iotyp_in==2 ) then
317:           open (55,file=trim(inpfile),form='unformatted')
318:           rewind (55)
319:         else
320:         end if
321: !       WRITE(*,*) 'Open ATM file:', trim(inpfile)
322:       end if
323: !
324: !     to calculate Heights on sigma surfaces.
325:       call <a href="./mod_hgt.f90.html#htsig_o" TARGET=CENT_PANEL>htsig_o</a>(t,z1,ps,ht_in,sig,ptop_in,jx_in,iy_in,kl)
326: !
327: !     to interpolate H,U,V,T,Q and QC
328: !     1. For Heights
329:       call <a href="./mod_hgt.f90.html#height_o" TARGET=CENT_PANEL>height_o</a>(hp,z1,t,ps,ht_in,sig,ptop_in,jx_in,iy_in,kl,    &
330:                   & plev,np)
331: !     2. For Zonal and Meridional Winds
332:       call <a href="./mod_vertint.f90.html#intlin_o" TARGET=CENT_PANEL>intlin_o</a>(up,u,ps,sig,ptop_in,jx_in,iy_in,kl,plev,np)
333:       call <a href="./mod_vertint.f90.html#intlin_o" TARGET=CENT_PANEL>intlin_o</a>(vp,v,ps,sig,ptop_in,jx_in,iy_in,kl,plev,np)
334: !     3. For Temperatures
335:       call <a href="./mod_vertint.f90.html#intlog_o" TARGET=CENT_PANEL>intlog_o</a>(tp,t,ps,sig,ptop_in,jx_in,iy_in,kl,plev,np)
336: !     4. For Moisture qva & qca
337:       call <a href="./mod_humid.f90.html#humid1_o" TARGET=CENT_PANEL>humid1_o</a>(t,q,ps,sig,ptop_in,jx_in,iy_in,kl)
338:       call <a href="./mod_vertint.f90.html#intlin_o" TARGET=CENT_PANEL>intlin_o</a>(qp,q,ps,sig,ptop_in,jx_in,iy_in,kl,plev,np)
339:       call <a href="./mod_vertint.f90.html#intlog_o" TARGET=CENT_PANEL>intlog_o</a>(cp,c,ps,sig,ptop_in,jx_in,iy_in,kl,plev,np)
340:       call <a href="./mod_uvrot.f90.html#uvrot4nx" TARGET=CENT_PANEL>uvrot4nx</a>(up,vp,xlon_in,xlat_in,clon_in,clat_in,grdfac,       &
341:              &      jx_in,iy_in,np,plon_in,plat_in,iproj_in)
342: !
343: !     HORIZONTAL INTERPOLATION OF BOTH THE SCALAR AND VECTOR FIELDS
344: !
345:       call <a href="./mod_interp.f90.html#cressmcr" TARGET=CENT_PANEL>cressmcr</a>(b3,b2,xlon,xlat,xlon_in,xlat_in,jx,iy,              &
346:                   & jx_in,iy_in,np,4)
347:       call <a href="./mod_interp.f90.html#cressmdt" TARGET=CENT_PANEL>cressmdt</a>(d3,d2,dlon,dlat,xlon_in,xlat_in,jx,iy,              &
348:                   & jx_in,iy_in,np,2)
349: !
350: !     ROTATE U-V FIELDS AFTER HORIZONTAL INTERPOLATION
351: !
352:       call <a href="./mod_uvrot.f90.html#uvrot4" TARGET=CENT_PANEL>uvrot4</a>(u3,v3,dlon,dlat,clon,clat,grdfac,jx,iy,np,plon,plat,  &
353:                 & iproj)
354: !
355: !     X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
356: !     X X
357: !     V E R T I C A L   I N T E R P O L A T I O N
358: !
359: !     X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
360: !     X X
361: !HH:  CHANGE THE VERTICAL ORDER.
362:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(t3,jx,iy,np)
363:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(q3,jx,iy,np)
364:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(c3,jx,iy,np)
365:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(h3,jx,iy,np)
366:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(u3,jx,iy,np)
367:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(v3,jx,iy,np)
368: !HH:OVER
369: !
370: !     ******           NEW CALCULATION OF P* ON RegCM TOPOGRAPHY.
371:       call <a href="./mod_vertint.f90.html#intgtb" TARGET=CENT_PANEL>intgtb</a>(pa,za,tlayer,topogm,t3,h3,sigmar,jx,iy,np)
372:  
373:       call <a href="./mod_vertint.f90.html#intpsn" TARGET=CENT_PANEL>intpsn</a>(ps4,topogm,pa,za,tlayer,ptop,jx,iy)
374:       call <a href="./mod_vectutil.f90.html#p1p2" TARGET=CENT_PANEL>p1p2</a>(b3pd,ps4,jx,iy)
375: !
376: !     F0    DETERMINE SURFACE TEMPS ON RegCM TOPOGRAPHY.
377: !     INTERPOLATION FROM PRESSURE LEVELS AS IN INTV2
378:       call <a href="./mod_vertint.f90.html#intv3" TARGET=CENT_PANEL>intv3</a>(ts4,t3,ps4,sigmar,ptop,jx,iy,np)
379:  
380:       if ( ssttyp=='EH5RF' .or. ssttyp=='EH5A2' .or.                    &
381:          & ssttyp=='EH5B1' .or. ssttyp=='EHA1B' ) then
382:         call <a href="./mod_mksst.f90.html#mksst3" TARGET=CENT_PANEL>mksst3</a>(ts4,sst1,topogm,xlandu,jx,iy,idate)
383:       else if ( ssttyp/='OI_WK' .and. ssttyp/='OI2WK' ) then
384: !       F1    CALCULATE SSTS FOR DATE FROM OBSERVED SSTS
385: !       PRINT *, 'INPUT DAY FOR SST DATA ACQUISITION:', IDATE
386:         call <a href="./mod_date.f90.html#julian" TARGET=CENT_PANEL>julian</a>(idate,nyrp,nmop,wt)
387: !
388:         if ( ssttyp=='OI2ST' ) then
389:           call <a href="./mod_mksst.f90.html#mkssta" TARGET=CENT_PANEL>mkssta</a>(ts4,sst1,sst2,ice1,ice2,topogm,xlandu,jx,iy,nyrp, &
390:                &      nmop,wt)
391:         else
392:           call <a href="./mod_mksst.f90.html#mksst" TARGET=CENT_PANEL>mksst</a>(ts4,sst1,sst2,topogm,xlandu,jx,iy,nyrp,nmop,wt)
393:         end if
394:       else
395:         if ( ssttyp=='OI2WK' ) then
396:           call <a href="./mod_mksst.f90.html#mksst2a" TARGET=CENT_PANEL>mksst2a</a>(ts4,sst1,sst2,ice1,ice2,topogm,xlandu,jx,iy,    &
397:                &       idate/100)
398:         else
399:           call <a href="./mod_mksst.f90.html#mksst2" TARGET=CENT_PANEL>mksst2</a>(ts4,sst1,sst2,topogm,xlandu,jx,iy,idate/100)
400:         end if
401:       end if
402:  
403: !     F2     DETERMINE P* AND HEIGHT.
404: !
405: !     F3     INTERPOLATE U, V, T, AND Q.
406:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(u4,u3,b3pd,sigma2,sigmar,ptop,jx,iy,kz,np)
407:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(v4,v3,b3pd,sigma2,sigmar,ptop,jx,iy,kz,np)
408: !
409:       call <a href="./mod_vertint.f90.html#intv2" TARGET=CENT_PANEL>intv2</a>(t4,t3,ps4,sigma2,sigmar,ptop,jx,iy,kz,np)
410:  
411:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(q4,q3,ps4,sigma2,sigmar,ptop,jx,iy,kz,np)
412:       call <a href="./mod_humid.f90.html#humid2fv" TARGET=CENT_PANEL>humid2fv</a>(t4,q4,ps4,ptop,sigma2,jx,iy,kz)
413:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(c4,c3,ps4,sigma2,sigmar,ptop,jx,iy,kz,np)
414: !
415: !     F4     DETERMINE H
416:       call <a href="./mod_hgt.f90.html#hydrost" TARGET=CENT_PANEL>hydrost</a>(h4,t4,topogm,ps4,ptop,sigmaf,sigma2,dsigma,jx,iy,kz)
417: !
418: !     G      WRITE AN INITIAL FILE FOR THE RegCM
419:       call <a href="./mod_write.f90.html#writef2" TARGET=CENT_PANEL>writef2</a>(ptop,idate)
420: !
421: 99001 format ('ATM.',i10)
422: !
423:       end subroutine get_nest
424: !
425: !
426: !
<p><a name=headnest><H3>headnest</H3></a></p> Click <a href="./callingtree/headnest_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where headnest is used.
<hr>
427:       subroutine headnest
428:       use <a href="./mod_grid.f90.html#mod_grid" TARGET=CENT_PANEL>mod_grid</a>
429:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a>, only : imxmn , lcross , ldot
430:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : degrad
431:       implicit none
432: !
433: ! Local variables
434: !
435:       real(4) :: dtb , dtc , dto , dtr , dxsp , ptsp , xsign ,          & 
436:             & truelat1 , truelat2
437:       integer :: ibltyp , iboudy , icup , ipptls , k
438:       integer :: ias
439:       logical :: there
440: !
441:       plev(1) = 50.
442:       plev(2) = 70.
443:       plev(3) = 100.
444:       plev(4) = 150.
445:       plev(5) = 200.
446:       plev(6) = 250.
447:       plev(7) = 300.
448:       plev(8) = 400.
449:       plev(9) = 500.
450:       plev(10) = 600.
451:       plev(11) = 700.
452:       plev(12) = 775.
453:       plev(13) = 850.
454:       plev(14) = 925.
455:       plev(15) = 1000.
456:  
457:       do k = 1 , np
458:         sigmar(k) = plev(k)*0.001
459:       end do
460:  
461:       inquire (file=trim(inpglob)//'/RegCM/OUT_HEAD',exist=there)
462:       if ( .not.there ) then
463:         write (*,*) trim(inpglob)//'/RegCM/OUT_HEAD is not available'
464:         write (*,*) 'please copy (or link) the previous output OUT_HEAD'
465:         stop
466:       end if
467: 
468:       open (49,file=trim(inpglob)//'/RegCM/OUT_HEAD',                   &
469:           & form='unformatted',access='direct',recl=24**ibyte)
470:       read (49,rec=1) idate0 , ibltyp , icup , ipptls , iboudy , iy_in ,&
471:                     & jx_in , kl
472:       close (49)
473: 
474:       iy_in = iy_in - 2
475:       jx_in = jx_in - 2
476: 
477: !     Reserve space for I/O
478: 
479:       allocate(sigf(kl+1), stat=ias)
480:       if (ias /= 0) stop 'Allocation Error in headnest: sigf'
481:       allocate(sig(kl), stat=ias)
482:       if (ias /= 0) stop 'Allocation Error in headnest: sig'
483:       allocate(b2(jx_in,iy_in,np*4), stat=ias)
484:       if (ias /= 0) stop 'Allocation Error in headnest: b2'
485:       allocate(d2(jx_in,iy_in,np*2), stat=ias)
486:       if (ias /= 0) stop 'Allocation Error in headnest: d2'
487:       allocate(c(jx_in,iy_in,kl), stat=ias)
488:       if (ias /= 0) stop 'Allocation Error in headnest: c'
489:       allocate(q(jx_in,iy_in,kl), stat=ias)
490:       if (ias /= 0) stop 'Allocation Error in headnest: q'
491:       allocate(t(jx_in,iy_in,kl), stat=ias)
492:       if (ias /= 0) stop 'Allocation Error in headnest: t'
493:       allocate(u(jx_in,iy_in,kl), stat=ias)
494:       if (ias /= 0) stop 'Allocation Error in headnest: u'
495:       allocate(v(jx_in,iy_in,kl), stat=ias)
496:       if (ias /= 0) stop 'Allocation Error in headnest: v'
497:       allocate(ps(jx_in,iy_in), stat=ias)
498:       if (ias /= 0) stop 'Allocation Error in headnest: ps'
499:       allocate(xlat_in(jx_in,iy_in), stat=ias)
500:       if (ias /= 0) stop 'Allocation Error in headnest: xlat_in'
501:       allocate(xlon_in(jx_in,iy_in), stat=ias)
502:       if (ias /= 0) stop 'Allocation Error in headnest: xlon_in'
503:       allocate(ht_in(jx_in,iy_in), stat=ias)
504:       if (ias /= 0) stop 'Allocation Error in headnest: ht_in'
505: 
506:       open (49,file=trim(inpglob)//'/RegCM/OUT_HEAD',form='unformatted',&
507:           & access='direct',recl=iy_in*jx_in*ibyte)
508:       read (49,rec=1) idate0 , ibltyp , icup , ipptls , iboudy , iy_in ,&
509:                     & jx_in , kl , (sigf(k),k=kl+1,1,-1) , dxsp ,       &
510:                     & ptsp , clat_in , clon_in , plat_in , plon_in ,    &
511:                     & iproj_in , dto , dtb , dtr , dtc ,   &
512:                     & iotyp_in , truelat1 , truelat2
513:       ptop_in = ptsp*10.
514:       iy_in = iy_in - 2
515:       jx_in = jx_in - 2
516:       if ( iproj_in=='LAMCON' ) then
517:         if ( clat_in<0. ) then
518:           xsign = -1.       ! SOUTH HEMESPHERE
519:         else
520:           xsign = 1.        ! NORTH HEMESPHERE
521:         end if
522:         if ( abs(truelat1-truelat2)>1.E-1 ) then
523:           grdfac = (log10(cos(truelat1*degrad))                         &
524:                    & -log10(cos(truelat2*degrad)))                      &
525:                    & /(log10(tan((45.0-xsign*truelat1/2.0)*degrad))     &
526:                    & -log10(tan((45.0-xsign*truelat2/2.0)*degrad)))
527:         else
528:           grdfac = xsign*sin(truelat1*degrad)
529:         end if
530:       else if ( iproj_in=='POLSTR' ) then
531:         grdfac = 1.0
532:       else if ( iproj_in=='NORMER' ) then
533:         grdfac = 0.0
534:       else
535:         grdfac = 0.0
536:       end if
537:       read (49,rec=2) ht_in
538:       read (49,rec=6) xlat_in
539:       read (49,rec=7) xlon_in
540:       close (49)
541:  
542:       do k = 1 , kl
543:         sig(k) = 0.5*(sigf(k)+sigf(k+1))
544:       end do
545:  
546:       imxmn = 0
547:       lcross = 0
548:       ldot = 0
549: 
550:       if (allocated(b3)) deallocate(b3)
551:       if (allocated(d3)) deallocate(d3)
552:       if (allocated(b3pd)) deallocate(b3pd)
553:       if (allocated(z1)) deallocate(z1)
554:       allocate(b3(iy_in,jx_in,np*4))
555:       allocate(d3(iy_in,jx_in,np*2))
556:       allocate(b3pd(iy_in,jx_in))
557:       allocate(z1(iy_in,jx_in,kl))
558: 
559: !     Set up pointers
560:  
561:       tp => b2(:,:,1:np)
562:       qp => b2(:,:,np+1:2*np)
563:       cp => b2(:,:,2*np+1:3*np)
564:       hp => b2(:,:,3*np+1:4*np)
565:       up => d2(:,:,1:np)
566:       vp => d2(:,:,np+1:2*np)
567:       t3 => b3(:,:,1:np)
568:       q3 => b3(:,:,np+1:2*np)
569:       c3 => b3(:,:,2*np+1:3*np)
570:       h3 => b3(:,:,3*np+1:4*np)
571:       u3 => d3(:,:,1:np)
572:       v3 => d3(:,:,np+1:2*np)
573: 
574:       end subroutine headnest
575: 
576:       end module mod_nest
</PRE>

<HR>

</BODY>
</HTML>
