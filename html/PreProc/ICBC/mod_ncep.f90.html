<HTML>

<HEAD>
<TITLE>mod_ncep.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_ncep.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_ncep.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_ncep><H3>mod_ncep</H3></a></p>20:       module mod_ncep
21: 
22:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
23: 
24:       implicit none
25: 
26:       private
27: 
28:       integer , parameter :: iii = 1 , jjj = 1
29:       integer , parameter :: klev = 13 , jlat = 73 , ilon = 144
30: 
31:       real(4) , dimension(ilon,jlat) :: psvar
32:       real(4) , dimension(jlat) :: glat
33:       real(4) , dimension(ilon) :: glon
34:       real(4) , dimension(klev) :: sigma1 , sigmar
35: 
36:       real(4) , dimension(ilon,jlat,klev) :: wvar
37: 
38:       real(4) , target , dimension(ilon,jlat,klev*3) :: b2
39:       real(4) , target , dimension(ilon,jlat,klev*2) :: d2
40:       real(4) , allocatable , target , dimension(:,:,:) :: b3
41:       real(4) , allocatable , target , dimension(:,:,:) :: d3
42:       
43:       real(4) , pointer :: u3(:,:,:) , v3(:,:,:)
44:       real(4) , pointer :: h3(:,:,:) , q3(:,:,:) , t3(:,:,:)
45:       real(4) , pointer :: uvar(:,:,:) , vvar(:,:,:)
46:       real(4) , pointer :: hvar(:,:,:) , rhvar(:,:,:) , tvar(:,:,:)
47: 
48:       public :: getncep , getncepw , headernc
49: 
50:       contains
51: 
<p><a name=getncep><H3>getncep</H3></a></p> Click <a href="./callingtree/getncep_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where getncep is used.
<hr>
52:       subroutine getncep(idate)
53:       use <a href="./mod_date.f90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : julian
54:       use <a href="./mod_grid.f90.html#mod_grid" TARGET=CENT_PANEL>mod_grid</a>
55:       use <a href="./mod_write.f90.html#mod_write" TARGET=CENT_PANEL>mod_write</a>
56:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : bilinx2
57:       use <a href="./mod_vertint.f90.html#mod_vertint" TARGET=CENT_PANEL>mod_vertint</a>
58:       use <a href="./mod_hgt.f90.html#mod_hgt" TARGET=CENT_PANEL>mod_hgt</a>
59:       use <a href="./mod_humid.f90.html#mod_humid" TARGET=CENT_PANEL>mod_humid</a>
60:       use <a href="./mod_mksst.f90.html#mod_mksst" TARGET=CENT_PANEL>mod_mksst</a>
61:       use <a href="./mod_uvrot.f90.html#mod_uvrot" TARGET=CENT_PANEL>mod_uvrot</a>
62:       use <a href="./mod_vectutil.f90.html#mod_vectutil" TARGET=CENT_PANEL>mod_vectutil</a>
63:       implicit none
64: !
65: ! Dummy arguments
66: !
67:       integer :: idate
68: !
69: ! Local variables
70: !
71:       integer :: nmop , nyrp
72:       real(4) :: wt
73: 
74: !
75: !     D      BEGIN LOOP OVER NTIMES
76: !
77:       call <a href="./mod_ncep.f90.html#cdc6hour" TARGET=CENT_PANEL>cdc6hour</a>(idate,globidate1)
78: 
79:       write (*,*) 'READ IN fields at DATE:' , idate
80: !
81: !     HORIZONTAL INTERPOLATION OF BOTH THE SCALAR AND VECTOR FIELDS
82: !
83:       call <a href="./mod_interp.f90.html#bilinx2" TARGET=CENT_PANEL>bilinx2</a>(b3,b2,xlon,xlat,glon,glat,ilon,jlat,jx,iy,klev*3)
84:       call <a href="./mod_interp.f90.html#bilinx2" TARGET=CENT_PANEL>bilinx2</a>(d3,d2,dlon,dlat,glon,glat,ilon,jlat,jx,iy,klev*2)
85: !
86: !     ROTATE U-V FIELDS AFTER HORIZONTAL INTERPOLATION
87: !
88:       call <a href="./mod_uvrot.f90.html#uvrot4" TARGET=CENT_PANEL>uvrot4</a>(u3,v3,dlon,dlat,clon,clat,grdfac,jx,iy,klev,plon,plat,&
89:                 & iproj)
90: !
91: !     X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
92: !     X X
93: !     V E R T I C A L   I N T E R P O L A T I O N
94: !
95: !     X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
96: !     X X
97: !HH:  CHANGE THE VERTICAL ORDER.
98:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(t3,jx,iy,klev)
99:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(q3,jx,iy,klev)
100:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(h3,jx,iy,klev)
101:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(u3,jx,iy,klev)
102:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(v3,jx,iy,klev)
103: !HH:OVER
104: !
105: !     ******           NEW CALCULATION OF P* ON RCM TOPOGRAPHY.
106:       call <a href="./mod_vertint.f90.html#intgtb" TARGET=CENT_PANEL>intgtb</a>(pa,za,tlayer,topogm,t3,h3,sigmar,jx,iy,klev)
107:  
108:       call <a href="./mod_vertint.f90.html#intpsn" TARGET=CENT_PANEL>intpsn</a>(ps4,topogm,pa,za,tlayer,ptop,jx,iy)
109:       call <a href="./mod_vectutil.f90.html#p1p2" TARGET=CENT_PANEL>p1p2</a>(b3pd,ps4,jx,iy)
110:  
111: !
112: !     F0  DETERMINE SURFACE TEMPS ON RCM TOPOGRAPHY.
113: !     INTERPOLATION FROM PRESSURE LEVELS AS IN INTV2
114:       call <a href="./mod_vertint.f90.html#intv3" TARGET=CENT_PANEL>intv3</a>(ts4,t3,ps4,sigmar,ptop,jx,iy,klev)
115:  
116:       if ( ssttyp/='OI_WK' .and. ssttyp/='OI2WK' ) then
117: !       F1  CALCULATE SSTS FOR DATE FROM OBSERVED SSTS
118:         print * , 'INPUT DAY FOR SST DATA ACQUISITION:' , idate
119:         call <a href="./mod_date.f90.html#julian" TARGET=CENT_PANEL>julian</a>(idate,nyrp,nmop,wt)
120: !
121:         if ( ssttyp=='OI2ST' ) then
122:           call <a href="./mod_mksst.f90.html#mkssta" TARGET=CENT_PANEL>mkssta</a>(ts4,sst1,sst2,ice1,ice2,topogm,xlandu,jx,iy,nyrp, &
123:                &      nmop,wt)
124:         else
125:           call <a href="./mod_mksst.f90.html#mksst" TARGET=CENT_PANEL>mksst</a>(ts4,sst1,sst2,topogm,xlandu,jx,iy,nyrp,nmop,wt)
126:         end if
127:       else
128:         if ( ssttyp=='OI2WK' ) then
129:           call <a href="./mod_mksst.f90.html#mksst2a" TARGET=CENT_PANEL>mksst2a</a>(ts4,sst1,sst2,ice1,ice2,topogm,xlandu,jx,iy,     &
130:                &       idate/100)
131:         else
132:           call <a href="./mod_mksst.f90.html#mksst2" TARGET=CENT_PANEL>mksst2</a>(ts4,sst1,sst2,topogm,xlandu,jx,iy,idate/100)
133:         end if
134:       end if
135:  
136: !     F2  DETERMINE P* AND HEIGHT.
137: !
138: !     F3  INTERPOLATE U, V, T, AND Q.
139:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(u4,u3,b3pd,sigma2,sigmar,ptop,jx,iy,kz,klev)
140:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(v4,v3,b3pd,sigma2,sigmar,ptop,jx,iy,kz,klev)
141: !
142:       call <a href="./mod_vertint.f90.html#intv2" TARGET=CENT_PANEL>intv2</a>(t4,t3,ps4,sigma2,sigmar,ptop,jx,iy,kz,klev)
143:  
144:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(q4,q3,ps4,sigma2,sigmar,ptop,jx,iy,kz,klev)
145:       call <a href="./mod_humid.f90.html#humid2" TARGET=CENT_PANEL>humid2</a>(t4,q4,ps4,ptop,sigma2,jx,iy,kz)
146: !
147: !     F4  DETERMINE H
148:       call <a href="./mod_hgt.f90.html#hydrost" TARGET=CENT_PANEL>hydrost</a>(h4,t4,topogm,ps4,ptop,sigmaf,sigma2,dsigma,jx,iy,kz)
149: !
150: !     G   WRITE AN INITIAL FILE FOR THE RCM
151:       call <a href="./mod_write.f90.html#writef" TARGET=CENT_PANEL>writef</a>(ptop,idate)
152: !
153:       end subroutine getncep
154: 
<p><a name=cdc6hour><H3>cdc6hour</H3></a></p> Click <a href="./callingtree/cdc6hour_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cdc6hour is used.
<hr>
155:       subroutine cdc6hour(idate,idate0)
156:       use <a href="#" TARGET=CENT_PANEL>netcdf</a>
157:       implicit none
158: !
159: ! Dummy arguments
160: !
161:       integer :: idate , idate0
162:       intent (in) idate , idate0
163: !
164: ! Local variables
165: !
166:       integer :: i , ilev , inet , it , j , kkrec , m , month , nday ,  &
167:                & k , nhour , nlev , nyear , istatus
168:       character(21) :: inname
169:       character(256) :: pathaddname
170:       logical :: there
171: !     character(5) , dimension(7) :: varname
172:       integer(2) , dimension(ilon,jlat,klev) :: work
173:       real(8) :: xadd , xscale
174:       integer , dimension(10) , save :: icount , istart
175:       integer , dimension(7) , save :: inet7
176:       real(8) , dimension(7) , save :: xoff , xscl
177: !
178: !     This is the latitude, longitude dimension of the grid to be read.
179: !     This corresponds to the lat and lon dimension variables in the
180: !     netCDF file.
181: !
182: !     The data are packed into short integers (INTEGER*2).  The array
183: !     work will be used to hold the packed integers.
184: !
185: !     DATA ARRAY AND WORK ARRAY
186: !
187: !     data varname/'air' , 'hgt' , 'rhum' , 'uwnd' , 'vwnd' , 'omega' , &
188: !         &'pres'/
189: !
190: !     Below in the ncopen call is the file name of the netCDF file.
191: !     You may want to add code to read in the file name and the
192: !     variable name.
193: !     OPEN FILE AND GET FILES ID AND VARIABLE ID(S)
194: !
195: !bxq
196:       xadd = 0.0
197:       xscale = 1.0
198:       nyear = idate/1000000
199:       month = idate/10000 - nyear*100
200:       nday = idate/100 - nyear*10000 - month*100
201:       nhour = idate - nyear*1000000 - month*10000 - nday*100
202: !fix  do kkrec=1,7
203:       nlev = 0
204:       do kkrec = 1 , 5
205:         if ( dattyp=='NNRP1' ) then
206:           if ( kkrec==1 .or. kkrec==2 .or. kkrec==4 .or. kkrec==5 )     &
207:              & nlev = klev
208:           if ( kkrec==6 ) nlev = 12
209:           if ( kkrec==3 ) nlev = 8
210:           if ( kkrec==7 ) nlev = 0
211:         else if ( dattyp=='NNRP2' ) then
212:           if ( kkrec<=6 ) nlev = klev
213:           if ( kkrec==7 ) nlev = 0
214:         else
215:         end if
216:         if ( idate==idate0 .or.                                         &
217:            & (mod(idate,100000)==10100 .and. mod(idate,1000000)/=110100)&
218:            & ) then
219:           if ( kkrec==1 ) then
220:             write (inname,99001) nyear , 'air.' , nyear
221:           else if ( kkrec==2 ) then
222:             write (inname,99001) nyear , 'hgt.' , nyear
223:           else if ( kkrec==3 ) then
224:             write (inname,99002) nyear , 'rhum.' , nyear
225:           else if ( kkrec==4 ) then
226:             write (inname,99002) nyear , 'uwnd.' , nyear
227:           else if ( kkrec==5 ) then
228:             write (inname,99002) nyear , 'vwnd.' , nyear
229:           else if ( kkrec==6 ) then
230:             write (inname,99003) nyear , 'omega.' , nyear
231:           else if ( kkrec==7 ) then
232:             write (inname,99004) nyear , 'pres.sfc.' , nyear
233:           else
234:           end if
235:  
236:           if ( dattyp=='NNRP1' ) then
237:             pathaddname = trim(inpglob)//'/NNRP1/'//inname
238:           else if ( dattyp=='NNRP2' ) then
239:             pathaddname = trim(inpglob)//'/NNRP2/'//inname
240:           else
241:           end if
242:           inquire (file=pathaddname,exist=there)
243:           if ( .not.there ) then
244:             print * , pathaddname , ' is not available'
245:             stop
246:           end if
247:           istatus = nf90_open(pathaddname,nf90_nowrite,inet7(kkrec))
248:           istatus = nf90_get_att(inet7(kkrec),5,'scale_factor',         &
249:                  & xscl(kkrec))
250:           istatus = nf90_get_att(inet7(kkrec),5,'add_offset',           &
251:                  & xoff(kkrec))
252:           write (*,*) inet7(kkrec) , pathaddname , xscl(kkrec) ,        &
253:                     & xoff(kkrec)
254:         end if
255:  
256:         it = (nday-1)*4 + nhour/6 + 1
257:         if ( month==2 ) it = it + 31*4
258:         if ( month==3 ) it = it + 59*4
259:         if ( month==4 ) it = it + 90*4
260:         if ( month==5 ) it = it + 120*4
261:         if ( month==6 ) it = it + 151*4
262:         if ( month==7 ) it = it + 181*4
263:         if ( month==8 ) it = it + 212*4
264:         if ( month==9 ) it = it + 243*4
265:         if ( month==10 ) it = it + 273*4
266:         if ( month==11 ) it = it + 304*4
267:         if ( month==12 ) it = it + 334*4
268:         if ( mod(nyear,4)==0 .and. month>2 ) it = it + 4
269:         if ( mod(nyear,100)==0 .and. month>2 ) it = it - 4
270:         if ( mod(nyear,400)==0 .and. month>2 ) it = it + 4
271: !bxq_
272:         do m = 1 , 4
273:           istart(m) = 1
274:         end do
275:         do m = 5 , 10
276:           istart(m) = 0
277:           icount(m) = 0
278:         end do
279:         icount(1) = ilon
280:         icount(2) = jlat
281:         icount(4) = 1460
282:         if ( mod(nyear,4)==0 ) icount(4) = 1464
283:         if ( mod(nyear,100)==0 ) icount(4) = 1460
284:         if ( mod(nyear,400)==0 ) icount(4) = 1464
285:         istart(4) = it
286:         icount(4) = 1
287:         inet = inet7(kkrec)
288:         if ( nlev>0 ) then
289:           icount(3) = nlev
290:           istatus = nf90_get_var(inet,5,work,istart,icount)
291:           xscale = xscl(kkrec)
292:           xadd = xoff(kkrec)
293:           do ilev = 1 , nlev
294:             if ( kkrec==1 ) then
295:               do j = 1 , jlat
296:                 do i = 1 , ilon
297:                   tvar(i,jlat+1-j,14-ilev) = work(i,j,ilev)             &
298:                   & *xscale + xadd
299:                 end do
300:               end do
301:             else if ( kkrec==2 ) then
302:               do j = 1 , jlat
303:                 do i = 1 , ilon
304:                   hvar(i,jlat+1-j,14-ilev) = work(i,j,ilev)             &
305:                   & *xscale + xadd
306:                 end do
307:               end do
308:             else if ( kkrec==3 ) then
309:               do j = 1 , jlat
310:                 do i = 1 , ilon
311:                   rhvar(i,jlat+1-j,14-ilev)                             &
312:                   & = dmin1((work(i,j,ilev)*xscale+xadd)*0.01,1.D0)
313:                 end do
314:               end do
315:             else if ( kkrec==4 ) then
316:               do j = 1 , jlat
317:                 do i = 1 , ilon
318:                   uvar(i,jlat+1-j,14-ilev) = work(i,j,ilev)             &
319:                   & *xscale + xadd
320:                 end do
321:               end do
322:             else if ( kkrec==5 ) then
323:               do j = 1 , jlat
324:                 do i = 1 , ilon
325:                   vvar(i,jlat+1-j,14-ilev) = work(i,j,ilev)             &
326:                   & *xscale + xadd
327:                 end do
328:               end do
329:             else if ( kkrec==6 ) then
330:               do j = 1 , jlat
331:                 do i = 1 , ilon
332:                   wvar(i,jlat+1-j,14-ilev) = work(i,j,ilev)             &
333:                   & *xscale + xadd
334:                 end do
335:               end do
336:             else
337:             end if
338:           end do
339:         else if ( nlev==0 ) then
340:           icount(3) = 1
341:           istatus = nf90_get_var(inet,5,work,istart,icount)
342:           if ( kkrec==7 ) then
343:             do j = 1 , jlat
344:               do i = 1 , ilon
345:                 psvar(i,jlat+1-j) = work(i,j,1)*xscale + xadd
346:               end do
347:             end do
348:           end if
349:         else
350:         end if
351:         if ( dattyp=='NNRP1' ) then
352: !         It's a pity that we have to nudge the values by the following
353: !         way
354:           do k = 5 , 1 , -1
355:             do j = 1 , jlat
356:               do i = 1 , ilon
357:                 rhvar(i,j,k) = rhvar(i,j,k+1)
358:               end do
359:             end do
360:           end do
361:  
362:           do j = 1 , jlat
363:             do i = 1 , ilon
364:               wvar(i,j,1) = 0.0
365:             end do
366:           end do
367:         end if
368:       end do
369: 99001 format (i4,'/',a4,i4,'.nc')
370: 99002 format (i4,'/',a5,i4,'.nc')
371: 99003 format (i4,'/',a6,i4,'.nc')
372: 99004 format (i4,'/',a9,i4,'.nc')
373: !
374:       end subroutine cdc6hour
375: 
<p><a name=getncepw><H3>getncepw</H3></a></p> Click <a href="./callingtree/getncepw_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where getncepw is used.
<hr>
376:       subroutine getncepw(idate)
377:       use <a href="./mod_date.f90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : julian
378:       use <a href="./mod_grid.f90.html#mod_grid" TARGET=CENT_PANEL>mod_grid</a>
379:       use <a href="./mod_write.f90.html#mod_write" TARGET=CENT_PANEL>mod_write</a>
380:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : bilinx2
381:       use <a href="./mod_vertint.f90.html#mod_vertint" TARGET=CENT_PANEL>mod_vertint</a>
382:       use <a href="./mod_hgt.f90.html#mod_hgt" TARGET=CENT_PANEL>mod_hgt</a>
383:       use <a href="./mod_humid.f90.html#mod_humid" TARGET=CENT_PANEL>mod_humid</a>
384:       use <a href="./mod_mksst.f90.html#mod_mksst" TARGET=CENT_PANEL>mod_mksst</a>
385:       use <a href="./mod_uvrot.f90.html#mod_uvrot" TARGET=CENT_PANEL>mod_uvrot</a>
386:       use <a href="./mod_vectutil.f90.html#mod_vectutil" TARGET=CENT_PANEL>mod_vectutil</a>
387:       implicit none
388: !
389: ! Dummy arguments
390: !
391:       integer :: idate
392: !
393: ! Local variables
394: !
395:       integer :: nmop , nyrp
396:       real(4) :: wt
397: 
398: !
399: !     D      BEGIN LOOP OVER NTIMES
400: !
401:       call <a href="./mod_ncep.f90.html#cdc6hour2" TARGET=CENT_PANEL>cdc6hour2</a>(idate,globidate1)
402: 
403:       write (*,*) 'READ IN fields at DATE:' , idate
404: !
405: !     HORIZONTAL INTERPOLATION OF BOTH THE SCALAR AND VECTOR FIELDS
406: !
407:       call <a href="./mod_interp.f90.html#bilinx2" TARGET=CENT_PANEL>bilinx2</a>(b3,b2,xlon,xlat,glon,glat,ilon,jlat,jx,iy,klev*3)
408:       call <a href="./mod_interp.f90.html#bilinx2" TARGET=CENT_PANEL>bilinx2</a>(d3,d2,dlon,dlat,glon,glat,ilon,jlat,jx,iy,klev*2)
409: !
410: !     ROTATE U-V FIELDS AFTER HORIZONTAL INTERPOLATION
411: !
412:       call <a href="./mod_uvrot.f90.html#uvrot4" TARGET=CENT_PANEL>uvrot4</a>(u3,v3,dlon,dlat,clon,clat,grdfac,jx,iy,klev,plon,plat,&
413:                 & iproj)
414: !
415: !     X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
416: !     X X
417: !     V E R T I C A L   I N T E R P O L A T I O N
418: !
419: !     X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
420: !     X X
421: !HH:  CHANGE THE VERTICAL ORDER.
422:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(t3,jx,iy,klev)
423:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(q3,jx,iy,klev)
424:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(h3,jx,iy,klev)
425:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(u3,jx,iy,klev)
426:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(v3,jx,iy,klev)
427: !HH:OVER
428: !
429: !     ******           NEW CALCULATION OF P* ON RCM TOPOGRAPHY.
430:       call <a href="./mod_vertint.f90.html#intgtb" TARGET=CENT_PANEL>intgtb</a>(pa,za,tlayer,topogm,t3,h3,sigmar,jx,iy,klev)
431:  
432:       call <a href="./mod_vertint.f90.html#intpsn" TARGET=CENT_PANEL>intpsn</a>(ps4,topogm,pa,za,tlayer,ptop,jx,iy)
433:       call <a href="./mod_vectutil.f90.html#p1p2" TARGET=CENT_PANEL>p1p2</a>(b3pd,ps4,jx,iy)
434:  
435: !
436: !     F0  DETERMINE SURFACE TEMPS ON RCM TOPOGRAPHY.
437: !     INTERPOLATION FROM PRESSURE LEVELS AS IN INTV2
438:       call <a href="./mod_vertint.f90.html#intv3" TARGET=CENT_PANEL>intv3</a>(ts4,t3,ps4,sigmar,ptop,jx,iy,klev)
439:  
440:       if ( ssttyp/='OI_WK' .and. ssttyp/='OI2WK' ) then
441: !       F1  CALCULATE SSTS FOR DATE FROM OBSERVED SSTS
442:         print * , 'INPUT DAY FOR SST DATA ACQUISITION:' , idate
443:         call <a href="./mod_date.f90.html#julian" TARGET=CENT_PANEL>julian</a>(idate,nyrp,nmop,wt)
444: !
445:         if ( ssttyp=='OI2ST' ) then
446:           call <a href="./mod_mksst.f90.html#mkssta" TARGET=CENT_PANEL>mkssta</a>(ts4,sst1,sst2,ice1,ice2,topogm,xlandu,jx,iy,nyrp, &
447:                &      nmop,wt)
448:         else
449:           call <a href="./mod_mksst.f90.html#mksst" TARGET=CENT_PANEL>mksst</a>(ts4,sst1,sst2,topogm,xlandu,jx,iy,nyrp,nmop,wt)
450:         end if
451:       else
452:         if ( ssttyp=='OI2WK' ) then
453:           call <a href="./mod_mksst.f90.html#mksst2a" TARGET=CENT_PANEL>mksst2a</a>(ts4,sst1,sst2,ice1,ice2,topogm,xlandu,jx,iy,    &
454:                 &      idate/100)
455:         else
456:           call <a href="./mod_mksst.f90.html#mksst2" TARGET=CENT_PANEL>mksst2</a>(ts4,sst1,sst2,topogm,xlandu,jx,iy,idate/100)
457:         end if
458:       end if
459:  
460: !     F2  DETERMINE P* AND HEIGHT.
461: !
462: !     F3  INTERPOLATE U, V, T, AND Q.
463:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(u4,u3,b3pd,sigma2,sigmar,ptop,jx,iy,kz,klev)
464:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(v4,v3,b3pd,sigma2,sigmar,ptop,jx,iy,kz,klev)
465: !
466:       call <a href="./mod_vertint.f90.html#intv2" TARGET=CENT_PANEL>intv2</a>(t4,t3,ps4,sigma2,sigmar,ptop,jx,iy,kz,klev)
467:  
468:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(q4,q3,ps4,sigma2,sigmar,ptop,jx,iy,kz,klev)
469:       call <a href="./mod_humid.f90.html#humid2" TARGET=CENT_PANEL>humid2</a>(t4,q4,ps4,ptop,sigma2,jx,iy,kz)
470: !
471: !     F4  DETERMINE H
472:       call <a href="./mod_hgt.f90.html#hydrost" TARGET=CENT_PANEL>hydrost</a>(h4,t4,topogm,ps4,ptop,sigmaf,sigma2,dsigma,jx,iy,kz)
473: !
474: !     G   WRITE AN INITIAL FILE FOR THE RCM
475:       call <a href="./mod_write.f90.html#writef" TARGET=CENT_PANEL>writef</a>(ptop,idate)
476: !
477:       end subroutine getncepw
478: 
<p><a name=cdc6hour2><H3>cdc6hour2</H3></a></p> Click <a href="./callingtree/cdc6hour2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cdc6hour2 is used.
<hr>
479:       subroutine cdc6hour2(idate,idate0)
480:       use <a href="#" TARGET=CENT_PANEL>netcdf</a>
481:       use <a href="./mod_grid.f90.html#mod_grid" TARGET=CENT_PANEL>mod_grid</a>
482:       implicit none
483: !
484: ! Dummy arguments
485: !
486:       integer :: idate , idate0
487:       intent (in) idate , idate0
488: !
489: ! Local variables
490: !
491:       integer :: i , ii , ilev , inet , it , j , jj , kkrec , m ,       &
492:                & month , nday , nhour , nlev , nyear , istatus
493:       character(24) :: inname
494:       character(256) :: pathaddname
495:       logical :: there
496: !     character(5) , dimension(7) :: varname
497:       integer(2) , dimension(iii,jjj,klev+1) :: work
498:       real(8) :: xadd , xscale
499:       integer , dimension(10) :: icount , istart
500:       integer , dimension(7) :: inet7
501:       real(8) , dimension(7) :: xoff , xscl
502: !
503: !     This is the latitude, longitude dimension of the grid to be read.
504: !     This corresponds to the lat and lon dimension variables in the
505: !     netCDF file.
506: !
507: !     The data are packed into short integers (INTEGER*2).  The array
508: !     work will be used to hold the packed integers.
509: !
510: !     DATA ARRAY AND WORK ARRAY
511: !
512: !     data varname/'air' , 'hgt' , 'rhum' , 'uwnd' , 'vwnd' , 'omega' , &
513: !         &'pres'/
514: !
515:       xadd = 0.0
516:       xscale = 1.0
517:       if ( idate==idate0 ) then
518:         i0 = lon0/2.5 + 1
519:         if ( i0<=0 ) i0 = i0 + ilon
520:         if ( i0>ilon ) i0 = i0 - ilon
521:         i1 = lon1/2.5 + 1
522:         if ( i1<=0 ) i1 = i1 + ilon
523:         if ( i1>ilon ) i1 = i1 - ilon
524:         j0 = lat0/2.5 + 36
525:       end if
526: !
527: !bxq
528:       nyear = idate/1000000
529:       month = idate/10000 - nyear*100
530:       nday = idate/100 - nyear*10000 - month*100
531:       nhour = idate - nyear*1000000 - month*10000 - nday*100
532: !
533: !fix  do kkrec=1,7
534:       nlev = 0
535:       do kkrec = 1 , 5
536:         if ( kkrec<=6 ) nlev = klev
537:         if ( kkrec==7 ) nlev = 0
538:         if ( idate==idate0 .or.                                         &
539:            & (mod(idate,100000)==10100 .and. mod(idate,1000000)/=110100)&
540:            & ) then
541:           if ( kkrec==1 ) then
542:             write (inname,99001) nyear , 'air.WIN.' , nyear
543:           else if ( kkrec==2 ) then
544:             write (inname,99001) nyear , 'hgt.WIN.' , nyear
545:           else if ( kkrec==3 ) then
546:             write (inname,99002) nyear , 'rhum.WIN.' , nyear
547:           else if ( kkrec==4 ) then
548:             write (inname,99002) nyear , 'uwnd.WIN.' , nyear
549:           else if ( kkrec==5 ) then
550:             write (inname,99002) nyear , 'vwnd.WIN.' , nyear
551:           else if ( kkrec==6 ) then
552:             write (inname,99003) nyear , 'omega.WIN.' , nyear
553:           else if ( kkrec==7 ) then
554:             write (inname,99004) nyear , 'pres.sfc.WIN.' , nyear
555:           else
556:           end if
557:  
558:           pathaddname = trim(inpglob)//'/NNRP2/'//inname
559:           inquire (file=pathaddname,exist=there)
560:           if ( .not.there ) then
561:             print * , pathaddname , ' is not available'
562:             stop
563:           end if
564:           istatus = nf90_open(pathaddname,nf90_nowrite,inet7(kkrec))
565:           istatus = nf90_get_att(inet7(kkrec),5,'scale_factor',         &
566:                  &               xscl(kkrec))
567:           istatus = nf90_get_att(inet7(kkrec),5,'add_offset',           &
568:                  &               xoff(kkrec))
569:           write (*,*) inet7(kkrec) , pathaddname , xscl(kkrec) ,        &
570:                     & xoff(kkrec)
571:         end if
572:  
573:         it = (nday-1)*4 + nhour/6 + 1
574:         if ( month==2 ) it = it + 31*4
575:         if ( month==3 ) it = it + 59*4
576:         if ( month==4 ) it = it + 90*4
577:         if ( month==5 ) it = it + 120*4
578:         if ( month==6 ) it = it + 151*4
579:         if ( month==7 ) it = it + 181*4
580:         if ( month==8 ) it = it + 212*4
581:         if ( month==9 ) it = it + 243*4
582:         if ( month==10 ) it = it + 273*4
583:         if ( month==11 ) it = it + 304*4
584:         if ( month==12 ) it = it + 334*4
585:         if ( mod(nyear,4)==0 .and. month>2 ) it = it + 4
586:         if ( mod(nyear,100)==0 .and. month>2 ) it = it - 4
587:         if ( mod(nyear,400)==0 .and. month>2 ) it = it + 4
588: !bxq_
589:         do m = 1 , 4
590:           istart(m) = 1
591:         end do
592:         do m = 5 , 10
593:           istart(m) = 0
594:           icount(m) = 0
595:         end do
596:         icount(1) = iii
597:         icount(2) = jjj
598:         icount(4) = 1460
599:         if ( mod(nyear,4)==0 ) icount(4) = 1464
600:         if ( mod(nyear,100)==0 ) icount(4) = 1460
601:         if ( mod(nyear,400)==0 ) icount(4) = 1464
602:         istart(4) = it
603:         icount(4) = 1
604:         inet = inet7(kkrec)
605:         if ( nlev>0 ) then
606:           icount(3) = nlev + 1
607:           istatus = nf90_get_var(inet,5,work,istart,icount)
608:           xscale = xscl(kkrec)
609:           xadd = xoff(kkrec)
610:           do ilev = 1 , nlev
611:             if ( kkrec==1 ) then
612:               do j = 1 , jjj
613:                 jj = j0 + j
614:                 if ( i0>i1 ) then
615:                   do ii = i0 , ilon
616:                     i = ii - i0 + 1
617:                     tvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
618:                   end do
619:                   do ii = 1 , i1
620:                     i = ii + (ilon-i0) + 1
621:                     tvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
622:                   end do
623:                 else
624:                   do ii = i0 , i1
625:                     i = ii - i0 + 1
626:                     tvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
627:                   end do
628:                 end if
629:               end do
630:  
631:             else if ( kkrec==2 ) then
632:               do j = 1 , jjj
633:                 jj = j0 + j
634:                 if ( i0>i1 ) then
635:                   do ii = i0 , ilon
636:                     i = ii - i0 + 1
637:                     hvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
638:                   end do
639:                   do ii = 1 , i1
640:                     i = ii + (ilon-i0) + 1
641:                     hvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
642:                   end do
643:                 else
644:                   do ii = i0 , i1
645:                     i = ii - i0 + 1
646:                     hvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
647:                   end do
648:                 end if
649:               end do
650:             else if ( kkrec==3 ) then
651:               do j = 1 , jjj
652:                 jj = j0 + j
653:                 if ( i0>i1 ) then
654:                   do ii = i0 , ilon
655:                     i = ii - i0 + 1
656:                     rhvar(ii,jj,ilev) = dmin1((work(i,j,ilev+1)*xscale+ &
657:                                       & xadd)*0.01,1.D0)
658:                   end do
659:                   do ii = 1 , i1
660:                     i = ii + (ilon-i0) + 1
661:                     rhvar(ii,jj,ilev) = dmin1((work(i,j,ilev+1)*xscale+ &
662:                                       & xadd)*0.01,1.D0)
663:                   end do
664:                 else
665:                   do ii = i0 , i1
666:                     i = ii - i0 + 1
667:                     rhvar(ii,jj,ilev) = dmin1((work(i,j,ilev+1)*xscale+ &
668:                                       & xadd)*0.01,1.D0)
669:                   end do
670:                 end if
671:               end do
672:             else if ( kkrec==4 ) then
673:               do j = 1 , jjj
674:                 jj = j0 + j
675:                 if ( i0>i1 ) then
676:                   do ii = i0 , ilon
677:                     i = ii - i0 + 1
678:                     uvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
679:                   end do
680:                   do ii = 1 , i1
681:                     i = ii + (ilon-i0) + 1
682:                     uvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
683:                   end do
684:                 else
685:                   do ii = i0 , i1
686:                     i = ii - i0 + 1
687:                     uvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
688:                   end do
689:                 end if
690:               end do
691:             else if ( kkrec==5 ) then
692:               do j = 1 , jjj
693:                 jj = j0 + j
694:                 if ( i0>i1 ) then
695:                   do ii = i0 , ilon
696:                     i = ii - i0 + 1
697:                     vvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
698:                   end do
699:                   do ii = 1 , i1
700:                     i = ii + (ilon-i0) + 1
701:                     vvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
702:                   end do
703:                 else
704:                   do ii = i0 , i1
705:                     i = ii - i0 + 1
706:                     vvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
707:                   end do
708:                 end if
709:               end do
710:             else if ( kkrec==6 ) then
711:               do j = 1 , jjj
712:                 jj = j0 + j
713:                 if ( i0>i1 ) then
714:                   do ii = i0 , ilon
715:                     i = ii - i0 + 1
716:                     wvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
717:                   end do
718:                   do ii = 1 , i1
719:                     i = ii + (ilon-i0) + 1
720:                     wvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
721:                   end do
722:                 else
723:                   do ii = i0 , i1
724:                     i = ii - i0 + 1
725:                     wvar(ii,jj,ilev) = work(i,j,ilev+1)*xscale + xadd
726:                   end do
727:                 end if
728:               end do
729:             else
730:             end if
731:           end do
732:         else if ( nlev==0 ) then
733:           icount(3) = nlev
734:           istatus = nf90_get_var(inet,5,work,istart,icount)
735:           if ( kkrec==7 ) then
736:             do j = 1 , jjj
737:               jj = j0 + j
738:               if ( i0>i1 ) then
739:                 do ii = i0 , ilon
740:                   i = ii - i0 + 1
741:                   psvar(ii,jj) = work(i,j,1)*xscale + xadd
742:                 end do
743:                 do ii = 1 , i1
744:                   i = ii + (ilon-i0) + 1
745:                   psvar(ii,jj) = work(i,j,1)*xscale + xadd
746:                 end do
747:               else
748:                 do ii = i0 , i1
749:                   i = ii - i0 + 1
750:                   psvar(ii,jj) = work(i,j,1)*xscale + xadd
751:                 end do
752:               end if
753:             end do
754:           end if
755:         else
756:         end if
757:       end do
758: 99001 format (i4,'/',a8,i4,'.nc')
759: 99002 format (i4,'/',a9,i4,'.nc')
760: 99003 format (i4,'/',a10,i4,'.nc')
761: 99004 format (i4,'/',a13,i4,'.nc')
762: !
763:       end subroutine cdc6hour2
764: 
<p><a name=headernc><H3>headernc</H3></a></p> Click <a href="./callingtree/headernc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where headernc is used.
<hr>
765:       subroutine headernc
766:       implicit none
767: !
768: ! Local variables
769: !
770:       integer :: i , j , k , kr
771: !
772: !     X X X X X   SET 1 :PARAMETERS FOR NCEP/NCAR REALALYSIS DATASET X
773: !     X X A1
774: !
775: !     ilon  = NUMBER OF LONGITUDES ON NCEP GRID.
776: !     jlat  = NUMBER OF LATITUDES ON NCEP GRID.
777: !     klev  = NUMBER OF PRESSURE LEVELS IN NCEP DATASET.
778: !
779: !
780:       sigmar(1) = .07
781:       sigmar(2) = .1
782:       sigmar(3) = .15
783:       sigmar(4) = .2
784:       sigmar(5) = .25
785:       sigmar(6) = .3
786:       sigmar(7) = .4
787:       sigmar(8) = .5
788:       sigmar(9) = .6
789:       sigmar(10) = .7
790:       sigmar(11) = .85
791:       sigmar(12) = .925
792:       sigmar(13) = 1.0
793: !
794: !     INITIAL GLOBAL GRID-POINT LONGITUDE & LATITUDE
795: !
796:       do i = 1 , ilon
797:         glon(i) = float(i-1)*2.5
798:       end do
799:       do j = 1 , jlat
800:         glat(j) = -90.0 + float(j-1)*2.5
801:       end do
802: !HH:OVER
803: !     CHANGE ORDER OF VERTICAL INDEXES FOR PRESSURE LEVELS
804: !
805:       do k = 1 , klev
806:         kr = klev - k + 1
807:         sigma1(k) = sigmar(kr)
808:       end do
809:  
810:       allocate(b3(jx,iy,klev*3))
811:       allocate(d3(jx,iy,klev*2))
812: 
813: !     Set up pointers
814: 
815:       u3 => d3(:,:,1:klev)
816:       v3 => d3(:,:,klev+1:2*klev)
817:       t3 => b3(:,:,1:klev)
818:       h3 => b3(:,:,klev+1:2*klev)
819:       q3 => b3(:,:,2*klev+1:3*klev)
820:       uvar => d2(:,:,1:klev)
821:       vvar => d2(:,:,klev+1:2*klev)
822:       tvar => b2(:,:,1:klev)
823:       hvar => b2(:,:,klev+1:2*klev)
824:       rhvar => b2(:,:,2*klev+1:3*klev)
825: 
826:       end subroutine headernc
827: 
828:       end module mod_ncep
</PRE>

<HR>

</BODY>
</HTML>
