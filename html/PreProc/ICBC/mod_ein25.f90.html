<HTML>

<HEAD>
<TITLE>mod_ein25.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_ein25.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_ein25.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_ein25><H3>mod_ein25</H3></a></p>20:       module mod_ein25
21:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
22:       implicit none
23: 
24:       private
25: 
26:       integer , parameter :: klev = 23 , jlat = 73 , ilon = 144
27: 
28:       real(4) , target , dimension(ilon,jlat,klev*3) :: b2
29:       real(4) , target , dimension(ilon,jlat,klev*2) :: d2
30:       real(4) , allocatable , target , dimension(:,:,:) :: b3
31:       real(4) , allocatable , target , dimension(:,:,:) :: d3
32: 
33:       real(4) , pointer :: u3(:,:,:) , v3(:,:,:)
34:       real(4) , pointer :: h3(:,:,:) , q3(:,:,:) , t3(:,:,:)
35:       real(4) , pointer :: uvar(:,:,:) , vvar(:,:,:)
36:       real(4) , pointer :: hvar(:,:,:) , rhvar(:,:,:) , tvar(:,:,:)
37: 
38:       integer(2) , dimension(ilon,jlat,37) :: work
39:       real(4) , dimension(jlat) :: glat
40:       real(4) , dimension(ilon) :: glon
41:       real(4) , dimension(klev) :: sigma1 , sigmar
42: 
43:       public :: getein25 , headerein25
44: 
45:       contains
46: 
<p><a name=getein25><H3>getein25</H3></a></p> Click <a href="./callingtree/getein25_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where getein25 is used.
<hr>
47:       subroutine getein25(idate)
48:       use <a href="./mod_date.f90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : julian
49:       use <a href="./mod_grid.f90.html#mod_grid" TARGET=CENT_PANEL>mod_grid</a>
50:       use <a href="./mod_write.f90.html#mod_write" TARGET=CENT_PANEL>mod_write</a>
51:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : bilinx2
52:       use <a href="./mod_vertint.f90.html#mod_vertint" TARGET=CENT_PANEL>mod_vertint</a>
53:       use <a href="./mod_hgt.f90.html#mod_hgt" TARGET=CENT_PANEL>mod_hgt</a>
54:       use <a href="./mod_humid.f90.html#mod_humid" TARGET=CENT_PANEL>mod_humid</a>
55:       use <a href="./mod_mksst.f90.html#mod_mksst" TARGET=CENT_PANEL>mod_mksst</a>
56:       use <a href="./mod_uvrot.f90.html#mod_uvrot" TARGET=CENT_PANEL>mod_uvrot</a>
57:       use <a href="./mod_vectutil.f90.html#mod_vectutil" TARGET=CENT_PANEL>mod_vectutil</a>
58:       implicit none
59: !
60: ! Dummy arguments
61: !
62:       integer :: idate
63: !
64: ! Local variables
65: !
66:       integer :: nmop , nyrp
67:       real(4) :: wt
68: !
69: !     D      BEGIN LOOP OVER NTIMES
70: !
71:       call <a href="./mod_ein25.f90.html#ein256hour" TARGET=CENT_PANEL>ein256hour</a>(dattyp,idate,globidate1)
72:       write (*,*) 'READ IN fields at DATE:' , idate
73: !
74: !     HORIZONTAL INTERPOLATION OF BOTH THE SCALAR AND VECTOR FIELDS
75: !
76:       call <a href="./mod_interp.f90.html#bilinx2" TARGET=CENT_PANEL>bilinx2</a>(b3,b2,xlon,xlat,glon,glat,ilon,jlat,jx,iy,klev*3)
77:       call <a href="./mod_interp.f90.html#bilinx2" TARGET=CENT_PANEL>bilinx2</a>(d3,d2,dlon,dlat,glon,glat,ilon,jlat,jx,iy,klev*2)
78: !
79: !     ROTATE U-V FIELDS AFTER HORIZONTAL INTERPOLATION
80: !
81:       call <a href="./mod_uvrot.f90.html#uvrot4" TARGET=CENT_PANEL>uvrot4</a>(u3,v3,dlon,dlat,clon,clat,grdfac,jx,iy,klev,plon,plat,&
82:                 & iproj)
83: !
84: !     X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
85: !     X X
86: !     V E R T I C A L   I N T E R P O L A T I O N
87: !
88: !     X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
89: !     X X
90: !HH:  CHANGE THE VERTICAL ORDER.
91:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(t3,jx,iy,klev)
92:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(q3,jx,iy,klev)
93:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(h3,jx,iy,klev)
94:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(u3,jx,iy,klev)
95:       call <a href="./mod_vectutil.f90.html#top2btm" TARGET=CENT_PANEL>top2btm</a>(v3,jx,iy,klev)
96: !HH:OVER
97: !
98: !     ******           NEW CALCULATION OF P* ON RCM TOPOGRAPHY.
99:       call <a href="./mod_vertint.f90.html#intgtb" TARGET=CENT_PANEL>intgtb</a>(pa,za,tlayer,topogm,t3,h3,sigmar,jx,iy,klev)
100:  
101:       call <a href="./mod_vertint.f90.html#intpsn" TARGET=CENT_PANEL>intpsn</a>(ps4,topogm,pa,za,tlayer,ptop,jx,iy)
102:       call <a href="./mod_vectutil.f90.html#p1p2" TARGET=CENT_PANEL>p1p2</a>(b3pd,ps4,jx,iy)
103:  
104: !     CALL HUMID1(T3,Q3,100.,0.0,SIGMA1,JX,IY,klev)
105: !
106: !     F0  DETERMINE SURFACE TEMPS ON RCM TOPOGRAPHY.
107: !     INTERPOLATION FROM PRESSURE LEVELS AS IN INTV2
108:       call <a href="./mod_vertint.f90.html#intv3" TARGET=CENT_PANEL>intv3</a>(ts4,t3,ps4,sigmar,ptop,jx,iy,klev)
109:  
110:       if ( ssttyp/='OI_WK' .and. ssttyp/='OI2WK' ) then
111: !       F1  CALCULATE SSTS FOR DATE FROM OBSERVED SSTS
112:         print * , 'INPUT DAY FOR SST DATA ACQUISITION:' , idate
113:         call <a href="./mod_date.f90.html#julian" TARGET=CENT_PANEL>julian</a>(idate,nyrp,nmop,wt)
114: !
115:         if ( ssttyp=='OI2ST' ) then
116:           call <a href="./mod_mksst.f90.html#mkssta" TARGET=CENT_PANEL>mkssta</a>(ts4,sst1,sst2,ice1,ice2,topogm,xlandu,jx,iy,nyrp, &
117:                 &     nmop,wt)
118:         else
119:           call <a href="./mod_mksst.f90.html#mksst" TARGET=CENT_PANEL>mksst</a>(ts4,sst1,sst2,topogm,xlandu,jx,iy,nyrp,nmop,wt)
120:         end if
121:       else
122:         if ( ssttyp=='OI2WK' ) then
123:           call <a href="./mod_mksst.f90.html#mksst2a" TARGET=CENT_PANEL>mksst2a</a>(ts4,sst1,sst2,ice1,ice2,topogm,xlandu,jx,iy,     &
124:                &       idate/100)
125:         else
126:           call <a href="./mod_mksst.f90.html#mksst2" TARGET=CENT_PANEL>mksst2</a>(ts4,sst1,sst2,topogm,xlandu,jx,iy,idate/100)
127:         end if
128:       end if
129:  
130: !     F3  INTERPOLATE U, V, T, AND Q.
131:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(u4,u3,b3pd,sigma2,sigmar,ptop,jx,iy,kz,klev)
132:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(v4,v3,b3pd,sigma2,sigmar,ptop,jx,iy,kz,klev)
133: !
134:       call <a href="./mod_vertint.f90.html#intv2" TARGET=CENT_PANEL>intv2</a>(t4,t3,ps4,sigma2,sigmar,ptop,jx,iy,kz,klev)
135:  
136:       call <a href="./mod_vertint.f90.html#intv1" TARGET=CENT_PANEL>intv1</a>(q4,q3,ps4,sigma2,sigmar,ptop,jx,iy,kz,klev)
137:       call <a href="./mod_humid.f90.html#humid2" TARGET=CENT_PANEL>humid2</a>(t4,q4,ps4,ptop,sigma2,jx,iy,kz)
138: !
139: !     F4  DETERMINE H
140:       call <a href="./mod_hgt.f90.html#hydrost" TARGET=CENT_PANEL>hydrost</a>(h4,t4,topogm,ps4,ptop,sigmaf,sigma2,dsigma,jx,iy,kz)
141: !
142: !     G   WRITE AN INITIAL FILE FOR THE RCM
143:       call <a href="./mod_write.f90.html#writef" TARGET=CENT_PANEL>writef</a>(ptop,idate)
144: !
145:       end subroutine getein25
146: 
<p><a name=ein256hour><H3>ein256hour</H3></a></p> Click <a href="./callingtree/ein256hour_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ein256hour is used.
<hr>
147:       subroutine ein256hour(dattyp,idate,idate0)
148:       use <a href="#" TARGET=CENT_PANEL>netcdf</a>
149: !
150: ! Dummy arguments
151: !
152:       character(5) :: dattyp
153:       integer :: idate , idate0
154:       intent (in) dattyp , idate , idate0
155: !
156: ! Local variables
157: !
158:       integer :: i , inet , it , j , k , k4 , kkrec , month , nday ,    &
159:                & nhour , nyear , istatus
160:       character(24) :: inname
161:       character(256) :: pathaddname
162:       logical :: there
163: !     character(1) , dimension(5) :: varname
164:       real(8) :: xadd , xscale
165: !
166:       integer , dimension(5,4) , save :: inet6
167:       real(8) , dimension(5,4) , save :: xoff , xscl
168:       integer , dimension(10) , save :: icount , istart
169: !
170: !     This is the latitude, longitude dimension of the grid to be read.
171: !     This corresponds to the lat and lon dimension variables in the
172: !     netCDF file.
173: !
174: !     The data are packed into short integers (INTEGER*2).  The array
175: !     work will be used to hold the packed integers.  The array 'x'
176: !     will contain the unpacked data.
177: !
178: !     DATA ARRAY AND WORK ARRAY
179: !
180: !     data varname/'t' , 'z' , 'r' , 'u' , 'v'/
181: !
182: !     Below in the ncopen call is the file name of the netCDF file.
183: !     You may want to add code to read in the file name and the
184: !     variable name.
185: !     OPEN FILE AND GET FILES ID AND VARIABLE ID(S)
186: !
187: !bxq
188:       if ( idate<1989010100 .or. idate>1998123118 ) then
189:         write (*,*) 'EIN25 datasets is just available from' ,           &
190:                    &' 1989010100 to 1998123118'
191:         stop
192:       end if
193:  
194:       nyear = idate/1000000
195:       month = idate/10000 - nyear*100
196:       nday = idate/100 - nyear*10000 - month*100
197:       nhour = idate - nyear*1000000 - month*10000 - nday*100
198:       if ( idate==idate0 .or.                                           &
199:          & (mod(idate,100000)==10100 .and. mod(idate,1000000)/=110100) )&
200:          & then
201:         do k4 = 1 , 4
202:           do kkrec = 1 , 5
203:             if ( kkrec==1 ) then
204:               if ( k4==1 ) then
205:                 write (inname,99001) nyear , 'air.' , nyear
206:               else if ( k4==2 ) then
207:                 write (inname,99002) nyear , 'air.' , nyear
208:               else if ( k4==3 ) then
209:                 write (inname,99003) nyear , 'air.' , nyear
210:               else if ( k4==4 ) then
211:                 write (inname,99004) nyear , 'air.' , nyear
212:               else
213:               end if
214:             else if ( kkrec==2 ) then
215:               if ( k4==1 ) then
216:                 write (inname,99001) nyear , 'hgt.' , nyear
217:               else if ( k4==2 ) then
218:                 write (inname,99002) nyear , 'hgt.' , nyear
219:               else if ( k4==3 ) then
220:                 write (inname,99003) nyear , 'hgt.' , nyear
221:               else if ( k4==4 ) then
222:                 write (inname,99004) nyear , 'hgt.' , nyear
223:               else
224:               end if
225:             else if ( kkrec==3 ) then
226:               if ( k4==1 ) then
227:                 write (inname,99005) nyear , 'rhum.' , nyear
228:               else if ( k4==2 ) then
229:                 write (inname,99006) nyear , 'rhum.' , nyear
230:               else if ( k4==3 ) then
231:                 write (inname,99007) nyear , 'rhum.' , nyear
232:               else if ( k4==4 ) then
233:                 write (inname,99008) nyear , 'rhum.' , nyear
234:               else
235:               end if
236:             else if ( kkrec==4 ) then
237:               if ( k4==1 ) then
238:                 write (inname,99005) nyear , 'uwnd.' , nyear
239:               else if ( k4==2 ) then
240:                 write (inname,99006) nyear , 'uwnd.' , nyear
241:               else if ( k4==3 ) then
242:                 write (inname,99007) nyear , 'uwnd.' , nyear
243:               else if ( k4==4 ) then
244:                 write (inname,99008) nyear , 'uwnd.' , nyear
245:               else
246:               end if
247:             else if ( kkrec==5 ) then
248:               if ( k4==1 ) then
249:                 write (inname,99005) nyear , 'vwnd.' , nyear
250:               else if ( k4==2 ) then
251:                 write (inname,99006) nyear , 'vwnd.' , nyear
252:               else if ( k4==3 ) then
253:                 write (inname,99007) nyear , 'vwnd.' , nyear
254:               else if ( k4==4 ) then
255:                 write (inname,99008) nyear , 'vwnd.' , nyear
256:               else
257:               end if
258:             else
259:             end if
260:  
261:             pathaddname = trim(inpglob)//pthsep//dattyp//pthsep//inname
262:             inquire (file=pathaddname,exist=there)
263:             if ( .not.there ) then
264:               print * , trim(pathaddname) , ' is not available'
265:               stop
266:             end if
267:             istatus = nf90_open(pathaddname,nf90_nowrite,               &
268:                    & inet6(kkrec,k4))
269:             istatus = nf90_get_att(inet6(kkrec,k4),5,'scale_factor',    &
270:                    & xscl(kkrec,k4))
271:             istatus = nf90_get_att(inet6(kkrec,k4),5,'add_offset',      &
272:                    & xoff(kkrec,k4))
273:             write (*,*) inet6(kkrec,k4) , pathaddname , xscl(kkrec,k4) ,&
274:                       & xoff(kkrec,k4)
275:           end do
276:         end do
277:  
278:       end if
279:  
280:       k4 = nhour/6 + 1
281:       it = nday
282:       if ( month==2 ) it = it + 31
283:       if ( month==3 ) it = it + 59
284:       if ( month==4 ) it = it + 90
285:       if ( month==5 ) it = it + 120
286:       if ( month==6 ) it = it + 151
287:       if ( month==7 ) it = it + 181
288:       if ( month==8 ) it = it + 212
289:       if ( month==9 ) it = it + 243
290:       if ( month==10 ) it = it + 273
291:       if ( month==11 ) it = it + 304
292:       if ( month==12 ) it = it + 334
293:       if ( mod(nyear,4)==0 .and. month>2 ) it = it + 1
294:       if ( mod(nyear,100)==0 .and. month>2 ) it = it - 1
295:       if ( mod(nyear,400)==0 .and. month>2 ) it = it + 1
296:       do k = 1 , 4
297:         istart(k) = 1
298:       end do
299:       do k = 5 , 10
300:         istart(k) = 0
301:         icount(k) = 0
302:       end do
303:       icount(1) = ilon
304:       icount(2) = jlat
305:       icount(3) = 37
306:       icount(4) = 365
307:       if ( mod(nyear,4)==0 ) icount(4) = 366
308:       if ( mod(nyear,100)==0 ) icount(4) = 365
309:       if ( mod(nyear,400)==0 ) icount(4) = 366
310:       istart(4) = it
311:       icount(4) = 1
312: !bxq_
313:       do kkrec = 1 , 5
314:         inet = inet6(kkrec,k4)
315:         istatus = nf90_get_var(inet,5,work,istart,icount)
316:         xscale = xscl(kkrec,k4)
317:         xadd = xoff(kkrec,k4)
318:         if ( kkrec==1 ) then
319:           do j = 1 , jlat
320:             do i = 1 , ilon
321: !             Tvar(i,jlat+1-j,k)=work(i,j,k)*xscale+xadd
322:               tvar(i,jlat+1-j,1) = work(i,j,1)*xscale + xadd
323:               tvar(i,jlat+1-j,2) = work(i,j,2)*xscale + xadd
324:               tvar(i,jlat+1-j,3) = work(i,j,3)*xscale + xadd
325:               tvar(i,jlat+1-j,4) = work(i,j,4)*xscale + xadd
326:               tvar(i,jlat+1-j,5) = work(i,j,5)*xscale + xadd
327:               tvar(i,jlat+1-j,6) = work(i,j,6)*xscale + xadd
328:               tvar(i,jlat+1-j,7) = work(i,j,7)*xscale + xadd
329:               tvar(i,jlat+1-j,8) = work(i,j,8)*xscale + xadd
330:               tvar(i,jlat+1-j,9) = work(i,j,9)*xscale + xadd
331:               tvar(i,jlat+1-j,10) = work(i,j,10)*xscale + xadd
332:               tvar(i,jlat+1-j,11) = work(i,j,11)*xscale + xadd
333:               tvar(i,jlat+1-j,12) = work(i,j,13)*xscale + xadd
334:               tvar(i,jlat+1-j,13) = work(i,j,15)*xscale + xadd
335:               tvar(i,jlat+1-j,14) = work(i,j,17)*xscale + xadd
336:               tvar(i,jlat+1-j,15) = work(i,j,18)*xscale + xadd
337:               tvar(i,jlat+1-j,16) = work(i,j,20)*xscale + xadd
338:               tvar(i,jlat+1-j,17) = work(i,j,22)*xscale + xadd
339:               tvar(i,jlat+1-j,18) = work(i,j,24)*xscale + xadd
340:               tvar(i,jlat+1-j,19) = work(i,j,26)*xscale + xadd
341:               tvar(i,jlat+1-j,20) = work(i,j,28)*xscale + xadd
342:               tvar(i,jlat+1-j,21) = work(i,j,31)*xscale + xadd
343:               tvar(i,jlat+1-j,22) = work(i,j,34)*xscale + xadd
344:               tvar(i,jlat+1-j,23) = work(i,j,37)*xscale + xadd
345:             end do
346:           end do
347:         else if ( kkrec==2 ) then
348:           do j = 1 , jlat
349:             do i = 1 , ilon
350: !             Hvar(i,jlat+1-j,k)=work(i,j,k)*xscale+xadd
351:               hvar(i,jlat+1-j,1) = work(i,j,1)*xscale + xadd
352:               hvar(i,jlat+1-j,2) = work(i,j,2)*xscale + xadd
353:               hvar(i,jlat+1-j,3) = work(i,j,3)*xscale + xadd
354:               hvar(i,jlat+1-j,4) = work(i,j,4)*xscale + xadd
355:               hvar(i,jlat+1-j,5) = work(i,j,5)*xscale + xadd
356:               hvar(i,jlat+1-j,6) = work(i,j,6)*xscale + xadd
357:               hvar(i,jlat+1-j,7) = work(i,j,7)*xscale + xadd
358:               hvar(i,jlat+1-j,8) = work(i,j,8)*xscale + xadd
359:               hvar(i,jlat+1-j,9) = work(i,j,9)*xscale + xadd
360:               hvar(i,jlat+1-j,10) = work(i,j,10)*xscale + xadd
361:               hvar(i,jlat+1-j,11) = work(i,j,11)*xscale + xadd
362:               hvar(i,jlat+1-j,12) = work(i,j,13)*xscale + xadd
363:               hvar(i,jlat+1-j,13) = work(i,j,15)*xscale + xadd
364:               hvar(i,jlat+1-j,14) = work(i,j,17)*xscale + xadd
365:               hvar(i,jlat+1-j,15) = work(i,j,18)*xscale + xadd
366:               hvar(i,jlat+1-j,16) = work(i,j,20)*xscale + xadd
367:               hvar(i,jlat+1-j,17) = work(i,j,22)*xscale + xadd
368:               hvar(i,jlat+1-j,18) = work(i,j,24)*xscale + xadd
369:               hvar(i,jlat+1-j,19) = work(i,j,26)*xscale + xadd
370:               hvar(i,jlat+1-j,20) = work(i,j,28)*xscale + xadd
371:               hvar(i,jlat+1-j,21) = work(i,j,31)*xscale + xadd
372:               hvar(i,jlat+1-j,22) = work(i,j,34)*xscale + xadd
373:               hvar(i,jlat+1-j,23) = work(i,j,37)*xscale + xadd
374:             end do
375:           end do
376:           do k = 1 , klev
377:             do j = 1 , jlat
378:               do i = 1 , ilon
379:                 hvar(i,j,k) = hvar(i,j,k)/9.80616
380:               end do
381:             end do
382:           end do
383:         else if ( kkrec==3 ) then
384:           do j = 1 , jlat
385:             do i = 1 , ilon
386: !             RHvar(i,jlat+1-j,k)=work(i,j,k)*xscale+xadd
387:               rhvar(i,jlat+1-j,1) = work(i,j,1)*xscale + xadd
388:               rhvar(i,jlat+1-j,2) = work(i,j,2)*xscale + xadd
389:               rhvar(i,jlat+1-j,3) = work(i,j,3)*xscale + xadd
390:               rhvar(i,jlat+1-j,4) = work(i,j,4)*xscale + xadd
391:               rhvar(i,jlat+1-j,5) = work(i,j,5)*xscale + xadd
392:               rhvar(i,jlat+1-j,6) = work(i,j,6)*xscale + xadd
393:               rhvar(i,jlat+1-j,7) = work(i,j,7)*xscale + xadd
394:               rhvar(i,jlat+1-j,8) = work(i,j,8)*xscale + xadd
395:               rhvar(i,jlat+1-j,9) = work(i,j,9)*xscale + xadd
396:               rhvar(i,jlat+1-j,10) = work(i,j,10)*xscale + xadd
397:               rhvar(i,jlat+1-j,11) = work(i,j,11)*xscale + xadd
398:               rhvar(i,jlat+1-j,12) = work(i,j,13)*xscale + xadd
399:               rhvar(i,jlat+1-j,13) = work(i,j,15)*xscale + xadd
400:               rhvar(i,jlat+1-j,14) = work(i,j,17)*xscale + xadd
401:               rhvar(i,jlat+1-j,15) = work(i,j,18)*xscale + xadd
402:               rhvar(i,jlat+1-j,16) = work(i,j,20)*xscale + xadd
403:               rhvar(i,jlat+1-j,17) = work(i,j,22)*xscale + xadd
404:               rhvar(i,jlat+1-j,18) = work(i,j,24)*xscale + xadd
405:               rhvar(i,jlat+1-j,19) = work(i,j,26)*xscale + xadd
406:               rhvar(i,jlat+1-j,20) = work(i,j,28)*xscale + xadd
407:               rhvar(i,jlat+1-j,21) = work(i,j,31)*xscale + xadd
408:               rhvar(i,jlat+1-j,22) = work(i,j,34)*xscale + xadd
409:               rhvar(i,jlat+1-j,23) = work(i,j,37)*xscale + xadd
410:             end do
411:           end do
412:           do k = 1 , 23
413:             do j = 1 , jlat
414:               do i = 1 , ilon
415:                 rhvar(i,j,k) = amax1(rhvar(i,j,k)*0.01,0.00)
416:               end do
417:             end do
418:           end do
419:         else if ( kkrec==4 ) then
420:           do j = 1 , jlat
421:             do i = 1 , ilon
422: !             Uvar(i,jlat+1-j,k)=work(i,j,k)*xscale+xadd
423:               uvar(i,jlat+1-j,1) = work(i,j,1)*xscale + xadd
424:               uvar(i,jlat+1-j,2) = work(i,j,2)*xscale + xadd
425:               uvar(i,jlat+1-j,3) = work(i,j,3)*xscale + xadd
426:               uvar(i,jlat+1-j,4) = work(i,j,4)*xscale + xadd
427:               uvar(i,jlat+1-j,5) = work(i,j,5)*xscale + xadd
428:               uvar(i,jlat+1-j,6) = work(i,j,6)*xscale + xadd
429:               uvar(i,jlat+1-j,7) = work(i,j,7)*xscale + xadd
430:               uvar(i,jlat+1-j,8) = work(i,j,8)*xscale + xadd
431:               uvar(i,jlat+1-j,9) = work(i,j,9)*xscale + xadd
432:               uvar(i,jlat+1-j,10) = work(i,j,10)*xscale + xadd
433:               uvar(i,jlat+1-j,11) = work(i,j,11)*xscale + xadd
434:               uvar(i,jlat+1-j,12) = work(i,j,13)*xscale + xadd
435:               uvar(i,jlat+1-j,13) = work(i,j,15)*xscale + xadd
436:               uvar(i,jlat+1-j,14) = work(i,j,17)*xscale + xadd
437:               uvar(i,jlat+1-j,15) = work(i,j,18)*xscale + xadd
438:               uvar(i,jlat+1-j,16) = work(i,j,20)*xscale + xadd
439:               uvar(i,jlat+1-j,17) = work(i,j,22)*xscale + xadd
440:               uvar(i,jlat+1-j,18) = work(i,j,24)*xscale + xadd
441:               uvar(i,jlat+1-j,19) = work(i,j,26)*xscale + xadd
442:               uvar(i,jlat+1-j,20) = work(i,j,28)*xscale + xadd
443:               uvar(i,jlat+1-j,21) = work(i,j,31)*xscale + xadd
444:               uvar(i,jlat+1-j,22) = work(i,j,34)*xscale + xadd
445:               uvar(i,jlat+1-j,23) = work(i,j,37)*xscale + xadd
446:             end do
447:           end do
448:         else if ( kkrec==5 ) then
449:           do j = 1 , jlat
450:             do i = 1 , ilon
451: !             Vvar(i,jlat+1-j,k) =work(i,j,k)*xscale+xadd
452:               vvar(i,jlat+1-j,1) = work(i,j,1)*xscale + xadd
453:               vvar(i,jlat+1-j,2) = work(i,j,2)*xscale + xadd
454:               vvar(i,jlat+1-j,3) = work(i,j,3)*xscale + xadd
455:               vvar(i,jlat+1-j,4) = work(i,j,4)*xscale + xadd
456:               vvar(i,jlat+1-j,5) = work(i,j,5)*xscale + xadd
457:               vvar(i,jlat+1-j,6) = work(i,j,6)*xscale + xadd
458:               vvar(i,jlat+1-j,7) = work(i,j,7)*xscale + xadd
459:               vvar(i,jlat+1-j,8) = work(i,j,8)*xscale + xadd
460:               vvar(i,jlat+1-j,9) = work(i,j,9)*xscale + xadd
461:               vvar(i,jlat+1-j,10) = work(i,j,10)*xscale + xadd
462:               vvar(i,jlat+1-j,11) = work(i,j,11)*xscale + xadd
463:               vvar(i,jlat+1-j,12) = work(i,j,13)*xscale + xadd
464:               vvar(i,jlat+1-j,13) = work(i,j,15)*xscale + xadd
465:               vvar(i,jlat+1-j,14) = work(i,j,17)*xscale + xadd
466:               vvar(i,jlat+1-j,15) = work(i,j,18)*xscale + xadd
467:               vvar(i,jlat+1-j,16) = work(i,j,20)*xscale + xadd
468:               vvar(i,jlat+1-j,17) = work(i,j,22)*xscale + xadd
469:               vvar(i,jlat+1-j,18) = work(i,j,24)*xscale + xadd
470:               vvar(i,jlat+1-j,19) = work(i,j,26)*xscale + xadd
471:               vvar(i,jlat+1-j,20) = work(i,j,28)*xscale + xadd
472:               vvar(i,jlat+1-j,21) = work(i,j,31)*xscale + xadd
473:               vvar(i,jlat+1-j,22) = work(i,j,34)*xscale + xadd
474:               vvar(i,jlat+1-j,23) = work(i,j,37)*xscale + xadd
475:             end do
476:           end do
477:         else
478:         end if
479:       end do
480: 99001 format (i4,'/',a4,i4,'.00.nc')
481: 99002 format (i4,'/',a4,i4,'.06.nc')
482: 99003 format (i4,'/',a4,i4,'.12.nc')
483: 99004 format (i4,'/',a4,i4,'.18.nc')
484: 99005 format (i4,'/',a5,i4,'.00.nc')
485: 99006 format (i4,'/',a5,i4,'.06.nc')
486: 99007 format (i4,'/',a5,i4,'.12.nc')
487: 99008 format (i4,'/',a5,i4,'.18.nc')
488: !
489:       end subroutine ein256hour
490: 
<p><a name=headerein25><H3>headerein25</H3></a></p> Click <a href="./callingtree/headerein25_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where headerein25 is used.
<hr>
491:       subroutine headerein25
492:       implicit none
493: !
494: ! Local variables
495: !
496:       integer :: i , j , k , kr
497: !
498:       sigmar(1) = .001
499:       sigmar(2) = .002
500:       sigmar(3) = .003
501:       sigmar(4) = .005
502:       sigmar(5) = .007
503:       sigmar(6) = .01
504:       sigmar(7) = .02
505:       sigmar(8) = .03
506:       sigmar(9) = .05
507:       sigmar(10) = .07
508:       sigmar(11) = .1
509:       sigmar(12) = .15
510:       sigmar(13) = .2
511:       sigmar(14) = .25
512:       sigmar(15) = .3
513:       sigmar(16) = .4
514:       sigmar(17) = .5
515:       sigmar(18) = .6
516:       sigmar(19) = .7
517:       sigmar(20) = .775
518:       sigmar(21) = .85
519:       sigmar(22) = .925
520:       sigmar(23) = 1.00
521: !
522: !     INITIAL GLOBAL GRID-POINT LONGITUDE & LATITUDE
523: !
524:       do i = 1 , ilon
525:         glon(i) = float(i-1)*2.5
526:       end do
527:       do j = 1 , jlat
528:         glat(j) = -90.0 + float(j-1)*2.5
529:       end do
530: !HH:OVER
531: !     CHANGE ORDER OF VERTICAL INDEXES FOR PRESSURE LEVELS
532: !
533:       do k = 1 , klev
534:         kr = klev - k + 1
535:         sigma1(k) = sigmar(kr)
536:       end do
537:  
538:       allocate(b3(jx,iy,klev*3))
539:       allocate(d3(jx,iy,klev*2))
540: 
541: !     Set up pointers
542: 
543:       u3 => d3(:,:,1:klev)
544:       v3 => d3(:,:,klev+1:2*klev)
545:       t3 => b3(:,:,1:klev)
546:       h3 => b3(:,:,klev+1:2*klev)
547:       q3 => b3(:,:,2*klev+1:3*klev)
548:       uvar => d2(:,:,1:klev)
549:       vvar => d2(:,:,klev+1:2*klev)
550:       tvar => b2(:,:,1:klev)
551:       hvar => b2(:,:,klev+1:2*klev)
552:       rhvar => b2(:,:,2*klev+1:3*klev)
553: !
554:       end subroutine headerein25
555: 
556:       end module mod_ein25
</PRE>

<HR>

</BODY>
</HTML>
