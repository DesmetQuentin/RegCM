<HTML>

<HEAD>
<TITLE>mod_interp.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_interp.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_interp.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_interp><H3>mod_interp</H3></a></p>20:       module mod_interp
21:  
22:       real(4) :: alatmn , alatmx , alonmn , alonmx , glatmn , glatmx ,  &
23:             &    glonmn , glonmx
24:       real(4) :: dlatmax , dlonmax
25:       integer :: imxmn , lcross , ldot
26: 
27:       real(4) , allocatable , dimension(:,:) :: dc1xa , dc1xb , dc1xc , &
28:                                        &        dc1xd , dc1xt
29:       integer , allocatable, dimension(:,:) :: ic1dl , ic1dr , ic1ul ,  &
30:                               &   ic1ur , jc1dl , jc1dr , jc1ul , jc1ur
31:       real(4) , allocatable , dimension(:,:) :: dd1xa , dd1xb , dd1xc , &
32:                                        &        dd1xd , dd1xt
33:       integer , allocatable, dimension(:,:) :: id1dl , id1dr , id1ul ,  &
34:                               &   id1ur , jd1dl , jd1dr , jd1ul , jd1ur
35: 
36:       data imxmn /0/
37:       data lcross /0/
38:       data ldot /0/
39:       contains
40: !
41: !-----------------------------------------------------------------------
42: !
<p><a name=bilinx><H3>bilinx</H3></a></p> Click <a href="./callingtree/bilinx_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where bilinx is used.
<hr>
43:       subroutine bilinx(fin,fout,lono,lato,loni,lati,nloni,nlati,iy,jx, &
44:                       & nflds)
45:       implicit none
46: !
47: ! Dummy arguments
48: !
49:       integer :: iy , jx , nflds , nlati , nloni
50:       real(4) , dimension(nloni,nlati,nflds) :: fin
51:       real(4) , dimension(nlati) :: lati
52:       real(4) , dimension(iy,jx) :: lato , lono
53:       real(4) , dimension(nloni) :: loni
54:       real(4) , dimension(iy,jx,nflds) :: fout
55:       intent (in) fin , iy , jx , lati , lato , loni , lono , nflds ,   &
56:                 & nlati , nloni
57:       intent (out) fout
58: !
59: ! Local variables
60: !
61:       real(4) :: bas , lon360 , p , q , xsum , xind , yind
62:       integer :: i , ip , ipp1 , j , jq , jqp1 , l
63:       logical :: lg
64: !
65: !
66: !     PERFORMING BI-LINEAR INTERPOLATION USING 4 GRID POINTS FROM A
67: !     BIGGER RECTANGULAR GRID TO A GRID DESCRIBED BY XLONS AND XLATS OF
68: !     GRID2. A POINT ON GRID2 IS TRAPPED WITHIN FOUR GRID POINTS ON
69: !     GRID4.THE GRID POINTS ARE ALWAYS TO THE NORTH AND EAST OF THE
70: !     TRAPPED POINT.. THE ALGORITHM COMPUTES THE FRACTIONAL DISTANCES
71: !     IN BOTH X AND Y DIRECTION OF THE TRAPPED GRID POINT AND USES THE
72: !     INFORMATION AS WEIGHTING FACTORS IN THE INTERPOLATION.
73: !     THERE IS ONE LESS ROW AND COLUMN WHEN THE SCALAR FIELDS ARE
74: !     INTERPOLATED BECAUSE XLATS AND XLONS ARE NOT DEFINED FOR
75: !     THE CROSS POINTS IN THE MM4 MODEL.
76: !
77: !     IN(NLONI,NLATI,NFLDS)  IS THE INPUT FIELD ON REGULAR LAT/LON GRID.
78: !     OUT(NLATO,NLONO,NFLDS) IS THE OUTPUT FIELD ON LAMBERT CONFORMAL
79: !     GRID. LONI.....LONGITUDE VALUES IN DEGREES OF THE LAT-LON GRID.
80: !     LATI.....LATITUDE VALUES IN DEGREES OF THE LAT-LON GRID.
81: !     P.........EAST-WEST WEIGHTING FACTOR.
82: !     Q.........NORTH-SOUTH WEIGHTING FACTOR.
83: !     IP........GRID POINT LOCATION IN EAST-WEST OF TRAPPED GRID POINT.
84: !     IQ........GRID POINT LOCATION IN NORTH-SOUTH OF TRAPPED GRID
85: !               POINT.
86: !
87: !     Global dataset ?
88: ! 
89:       lg = .true.
90: !
91: !
92:       do j = 1 , jx
93:         do i = 1 , iy
94:  
95:           yind = (((lato(i,j)-lati(1))/(lati(nlati)-lati(1)))           &
96:                & *float(nlati-1)) + 1.
97:           jq = int(yind)
98:           jq = max0(jq,1)
99:           jqp1 = min0(jq+1,nlati)
100:           q = yind - jq
101:  
102:           lon360 = lono(i,j)
103:           if ( lono(i,j)<0. ) lon360 = lono(i,j) + 360.
104:           xind = (((lon360-loni(1))/(loni(nloni)-loni(1)))              &
105:                & *float(nloni-1)) + 1.
106:           if ( xind<1.0 .and. lg ) then
107:             ip = nloni
108:             ipp1 = 1
109:             p = xind
110:           else if ( (xind-nloni)>0.0 .and. lg ) then
111:             ip = nloni
112:             ipp1 = 1
113:             p = xind - nloni
114:           else
115:             ip = int(xind)
116:             ip = max0(ip,1)
117:             ipp1 = min0(ip+1,nloni)
118:             p = xind - ip
119:           end if
120:  
121:           do l = 1 , nflds
122:             xsum = 0.0
123:             bas = 0.0
124:             if ( fin(ip,jq,l)<-9990.0 .and. fin(ipp1,jq,l)<-9990.0 .and.&
125:                & fin(ipp1,jqp1,l)<-9990.0 .and. fin(ip,jqp1,l)<-9990.0 )&
126:                & then
127:               fout(i,j,l) = -9999.
128:             else
129:               if ( fin(ip,jq,l)>-9990.0 ) then
130:                 xsum = xsum + (1.-q)*(1.-p)*fin(ip,jq,l)
131:                 bas = bas + (1.-q)*(1.-p)
132:               end if
133:               if ( fin(ipp1,jq,l)>-9990.0 ) then
134:                 xsum = xsum + (1.-q)*p*fin(ipp1,jq,l)
135:                 bas = bas + (1.-q)*p
136:               end if
137:               if ( fin(ipp1,jqp1,l)>-9990.0 ) then
138:                 xsum = xsum + q*p*fin(ipp1,jqp1,l)
139:                 bas = bas + q*p
140:               end if
141:               if ( fin(ip,jqp1,l)>-9990.0 ) then
142:                 xsum = xsum + q*(1.-p)*fin(ip,jqp1,l)
143:                 bas = bas + q*(1.-p)
144:               end if
145:               fout(i,j,l) = xsum/bas
146:             end if
147:           end do
148:         end do
149:  
150:       end do
151:  
152:       end subroutine bilinx
153: !
154: !-----------------------------------------------------------------------
155: !
<p><a name=bilinx2><H3>bilinx2</H3></a></p> Click <a href="./callingtree/bilinx2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where bilinx2 is used.
<hr>
156:       subroutine bilinx2(b3,b2,alon,alat,hlon,hlat,nlon,nlat,jx,iy,llev)
157:       implicit none
158: !
159: ! Dummy arguments
160: !
161:       integer :: iy , jx , llev , nlat , nlon
162:       real(4) , dimension(jx,iy) :: alat , alon
163:       real(4) , dimension(nlon,nlat,llev) :: b2
164:       real(4) , dimension(jx,iy,llev) :: b3
165:       real(4) , dimension(nlat) :: hlat
166:       real(4) , dimension(nlon) :: hlon
167:       intent (in) alat , alon , b2 , hlat , hlon , iy , jx , llev ,     &
168:                 & nlat , nlon
169:       intent (out) b3
170: !
171: ! Local variables
172: !
173:       real(4) :: ave , p1 , p2 , q1 , q2
174:       integer :: i , i1 , i2 , ii , j , j1 , j2 , jj , l
175: !
176: !     PERFORMING BI-LINEAR INTERPOLATION USING 4 GRID POINTS FROM A
177: !     BIGGER RECTANGULAR GRID TO A GRID DESCRIBED BY ALON AND ALAT OF
178: !     GRID2. A POINT ON GRID2 IS TRAPPED WITHIN FOUR GRID POINTS ON
179: !     GRID4.THE GRID POINTS ARE ALWAYS TO THE NORTH AND EAST OF THE
180: !     TRAPPED POINT. THE ALGORITHM COMPUTES THE FRACTIONAL DISTANCES IN
181: !     BOTH X AND Y DIRECTION OF THE TRAPPED GRID POINT AND USES THE
182: !     INFORMATION AS WEIGHTING FACTORS IN THE INTERPOLATION.
183: !     THERE IS ONE LESS ROW AND COLUMN WHEN THE SCALAR FIELDS ARE
184: !     INTERPOLATED BECAUSE ALAT AND ALON ARE NOT DEFINED FOR
185: !     THE CROSS POINTS IN THE RegCM MODEL.
186: !
187: !     B2(JX,IX,NLEV) IS THE INPUT FIELD ON REGULAR LAT/LON GRID.
188: !     B3(JX,IX,NLEV) IS THE OUTPUT FIELD ON LAMBERT CONFORMAL GRID.
189: !     HLON......LONGITUDE VALUES IN DEGREES OF THE INTERMEDIATE GRID4.
190: !     HLAT......LATITUDE VALUES IN DEGREES OF THE INTERMEDIATE GRID4.
191: !     P.........EAST-WEST WEIGHTING FACTOR.
192: !     Q.........NORTH-SOUTH WEIGHTING FACTOR.
193: !     IP........GRID POINT LOCATION IN EAST-WEST OF TRAPPED GRID POINT.
194: !     IQ........GRID POINT LOCATION IN NORTH-SOUTH OF TRAPPED GRID
195: !     POINT.
196: !
197:       i1 = 0
198:       i2 = 0
199:       j1 = 0
200:       j2 = 0
201:       q1 = 0.0
202:       q2 = 0.0
203: 
204:       do j = 1 , iy
205:         do i = 1 , jx
206:  
207:           i1 = 1000
208:           do ii = 1 , nlon - 1
209:             if ( alon(i,j)>=hlon(ii) .and. alon(i,j)<hlon(ii+1) ) then
210:               p1 = alon(i,j) - hlon(ii)
211:               p2 = hlon(ii+1) - alon(i,j)
212:               i1 = ii
213:               i2 = ii + 1
214:               go to 20
215:             else if ( alon(i,j)>=hlon(ii)-360 .and. alon(i,j)<hlon(ii+1)&
216:                     & -360. ) then
217:               p1 = alon(i,j) - (hlon(ii)-360.)
218:               p2 = (hlon(ii+1)-360.) - alon(i,j)
219:               i1 = ii
220:               i2 = ii + 1
221:               go to 20
222:             else if ( alon(i,j)>=hlon(ii)+360 .and. alon(i,j)<hlon(ii+1)&
223:                     & +360. ) then
224:               p1 = alon(i,j) - (hlon(ii)+360.)
225:               p2 = (hlon(ii+1)+360.) - alon(i,j)
226:               i1 = ii
227:               i2 = ii + 1
228:               go to 20
229:             else
230:             end if
231:           end do
232:           if ( alon(i,j)>=hlon(nlon) .and. alon(i,j)<hlon(1)+360. ) then
233:             p1 = alon(i,j) - hlon(nlon)
234:             p2 = (hlon(1)+360.) - alon(i,j)
235:             i1 = nlon
236:             i2 = 1
237:           else if ( alon(i,j)>=hlon(nlon)+360 .and. alon(i,j)<hlon(1)   &
238:                   & +720. ) then
239:             p1 = alon(i,j) - (hlon(nlon)+360.)
240:             p2 = (hlon(1)+720.) - alon(i,j)
241:             i1 = nlon
242:             i2 = 1
243:           else if ( alon(i,j)>=hlon(nlon)-360 .and. alon(i,j)<hlon(1) ) &
244:                   & then
245:             p1 = alon(i,j) - (hlon(nlon)-360.)
246:             p2 = hlon(1) - alon(i,j)
247:             i1 = nlon
248:             i2 = 1
249:           else if ( alon(i,j)>=hlon(nlon)-720 .and. alon(i,j)<hlon(1)   &
250:                   & -360. ) then
251:             p1 = alon(i,j) - (hlon(nlon)-720.)
252:             p2 = (hlon(1)-360.) - alon(i,j)
253:             i1 = nlon
254:             i2 = 1
255:           else
256:           end if
257:  20       continue
258:           if ( i1==1000 ) stop 'Could not find the right longitute'
259:           j1 = 1000
260:           do jj = 1 , nlat - 1
261:             if ( alat(i,j)>=hlat(jj) .and. alat(i,j)<hlat(jj+1) ) then
262:               q1 = alat(i,j) - hlat(jj)
263:               q2 = hlat(jj+1) - alat(i,j)
264:               j1 = jj
265:               j2 = jj + 1
266:             else if ( alat(i,j)<hlat(1) ) then
267:               if ( alat(i,j)>=-90. ) then
268:                 q1 = alat(i,j) + 90.
269:                 q2 = hlat(1) - alat(i,j)
270:                 j1 = 0
271:                 j2 = 1
272:               end if
273:             else if ( alat(i,j)>hlat(nlat) ) then
274:               if ( alat(i,j)<=90. ) then
275:                 q1 = alat(i,j) - hlat(nlat)
276:                 q2 = 90. - alat(i,j)
277:                 j1 = nlat
278:                 j2 = nlat + 1
279:               end if
280:             else
281:             end if
282:           end do
283:           if ( j1==1000 ) stop 'Could not find the right latitude'
284:           if ( j1>0 .and. j1<nlat ) then
285:             do l = 1 , llev
286:               b3(i,j,l) = ((b2(i1,j1,l)*p2+b2(i2,j1,l)*p1)*q2+(b2(i1,j2,&
287:                         & l)*p2+b2(i2,j2,l)*p1)*q1)/(p1+p2)/(q1+q2)
288:             end do
289:           else if ( j1==0 ) then
290:             do l = 1 , llev
291:               ave = 0.0
292:               do ii = 1 , nlon
293:                 ave = ave + b2(ii,1,l)
294:               end do
295:               ave = ave/float(nlon)
296:               b3(i,j,l) = ((ave*(p1+p2))*q2+(b2(i1,j2,l)*p2+b2(i2,j2,l)*&
297:                         & p1)*q1)/(p1+p2)/(q1+q2)
298:             end do
299:           else if ( j1==nlat ) then
300:             do l = 1 , llev
301:               ave = 0.0
302:               do ii = 1 , nlon
303:                 ave = ave + b2(ii,nlat,l)
304:               end do
305:               ave = ave/float(nlon)
306:               b3(i,j,l) = ((b2(i1,j1,l)*p2+b2(i2,j1,l)*p1)*q2+(ave*(p1+ &
307:                         & p2))*q1)/(p1+p2)/(q1+q2)
308:             end do
309:           else
310:           end if
311:         end do
312:       end do
313: 
314:       end subroutine bilinx2
315: !
316: !-----------------------------------------------------------------------
317: !
<p><a name=cressmcr><H3>cressmcr</H3></a></p> Click <a href="./callingtree/cressmcr_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cressmcr is used.
<hr>
318:       subroutine cressmcr(b3,b2,alon,alat,glon,glat,jx,iy,nlon,nlat,    &
319:                         & nlev,nf)
320:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : degrad
321:       implicit none
322: !
323: ! Dummy arguments
324: !
325:       integer :: iy , jx , nlat , nlev , nlon , nf
326:       real(4) , dimension(jx,iy) :: alat , alon
327:       real(4) , dimension(jx,iy,nlev*nf) :: b3
328:       real(4) , dimension(nlon,nlat) :: glat , glon
329:       real(4) , dimension(nlon,nlat,nlev*nf) :: b2
330:       intent (in) alat , alon , b2 , glat , glon , iy , jx , nlat ,     &
331:                 & nlev , nlon , nf
332:       intent (out) b3
333: !
334: ! Local variables
335: !
336:       real(4) :: aaa , dist , dista , distb , distc , distd
337:       integer :: i , j , k , l , m , mdl , mdr , mul , mur , n , ndl ,  &
338:                & ndr , nul , nur , kin
339: !
340: !     FIND THE FOUR CLOSEST POINTS TO THE GRID WE WANT TO HAVE VALUE,
341: !     THEN DO THE AVERAGE OF THOSE FOUR POINTS WEIGHTED BY THE DISTANCE.
342: !     THE CLOSEST ONE HAS BIGGEST WEIGHT.
343: !
344: !     B2(JX,IX,NLEV) IS THE INPUT FIELD ON PREVIOUS regular or
345: !     irregular GRID. B3(JX,IX,NLEV) IS THE OUTPUT FIELD ON new
346: !     (regular or irregular) GRID. GLON......LONGITUDE VALUES IN
347: !     DEGREES OF THE INTERMEDIATE GRID4. GLAT......LATITUDE VALUES IN
348: !     DEGREES OF THE INTERMEDIATE GRID4.
349: !
350: !
351: !     Find the Minimum and Maximum of GLON, GLAT, ALON and ALAT
352: !
353:       if ( imxmn==0 ) then
354:         glonmx = maxval(glon)
355:         glonmn = minval(glon)
356:         alonmx = maxval(alon)
357:         alonmn = minval(alon)
358:         glatmx = maxval(glat)
359:         glatmn = minval(glat)
360:         alatmx = maxval(alat)
361:         alatmn = minval(alat)
362:         dlatmax = (glatmx-glatmn)/nlat * 2.
363:         dlonmax = (glonmx-glonmn)/nlon * 2.
364:         write (*,*) 'GLONMN,ALONMN,ALONMX,GLONMX = '
365:         write (*,*) glonmn , alonmn , alonmx , glonmx
366:         write (*,*) 'GLATMN,ALATMN,ALATMX,GLATMX = '
367:         write (*,*) glatmn , alatmn , alatmx , glatmx
368:         imxmn = 1
369:       end if
370: 
371:       if ( lcross==0 ) then
372:         if (.not. allocated(ic1dl)) allocate (ic1dl(jx,iy))
373:         if (.not. allocated(ic1dr)) allocate (ic1dr(jx,iy))
374:         if (.not. allocated(ic1ul)) allocate (ic1ul(jx,iy))
375:         if (.not. allocated(ic1ur)) allocate (ic1ur(jx,iy))
376:         if (.not. allocated(jc1dl)) allocate (jc1dl(jx,iy))
377:         if (.not. allocated(jc1dr)) allocate (jc1dr(jx,iy))
378:         if (.not. allocated(jc1ul)) allocate (jc1ul(jx,iy))
379:         if (.not. allocated(jc1ur)) allocate (jc1ur(jx,iy))
380:         if (.not. allocated(dc1xa)) allocate (dc1xa(jx,iy))
381:         if (.not. allocated(dc1xb)) allocate (dc1xb(jx,iy))
382:         if (.not. allocated(dc1xc)) allocate (dc1xc(jx,iy))
383:         if (.not. allocated(dc1xd)) allocate (dc1xd(jx,iy))
384:         if (.not. allocated(dc1xt)) allocate (dc1xt(jx,iy))
385:         write ( 6,* ) 'FIRST TIME in CRESSMCR'
386:         write ( 6,* ) 'Calculating weights.... (will take long time)'
387:         do j = 1 , iy
388:           do i = 1 , jx
389:  
390:             mur = -1000
391:             nur = -1000
392:             mul = -1000
393:             nul = -1000
394:             mdr = -1000
395:             ndr = -1000
396:             mdl = -1000
397:             ndl = -1000
398:  
399:             dista = 1.E8
400:             distb = 1.E8
401:             distc = 1.E8
402:             distd = 1.E8
403:             do n = 2 , nlat
404:               do m = 2 , nlon
405:                 if ( (glon(m,n)>=alon(i,j) .and.                        &
406:                    &  glon(m,n)-alon(i,j) < dlonmax ) .and.             &
407:                    & (glat(m,n)>=alat(i,j) .and.                        &
408:                    &  glat(m,n)-alat(i,j) < dlatmax ) ) then
409:                   aaa = ((glon(m,n)-alon(i,j)) *                        &
410:                       & cos((glat(m,n)+alat(i,j))*degrad))**2 +         &
411:                       & (glat(m,n)-alat(i,j))**2
412:                   if ( dista>aaa ) then
413:                     dista = aaa
414:                     mur = m
415:                     nur = n
416:                   end if
417:                 end if
418:                 if ( (glon(m,n)<alon(i,j) .and.                         &
419:                    &  alon(i,j)-glon(m,n) < dlonmax ) .and.             &
420:                    & (glat(m,n)>=alat(i,j) .and.                        &
421:                    &  glat(m,n)-alat(i,j) < dlatmax ) ) then
422:                   aaa = ((glon(m,n)-alon(i,j)) *                        &
423:                       & cos((glat(m,n)+alat(i,j))*degrad))**2 +         &
424:                       & (glat(m,n)-alat(i,j))**2
425:                   if ( distb>aaa ) then
426:                     distb = aaa
427:                     mul = m
428:                     nul = n
429:                   end if
430:                 end if
431:                 if ( (glon(m,n)>=alon(i,j) .and.                        &
432:                    &  glon(m,n)-alon(i,j) < dlonmax ) .and.             &
433:                    & (glat(m,n)<alat(i,j) .and.                         &
434:                    &  alat(i,j)-glat(m,n) < dlatmax ) ) then
435:                   aaa = ((glon(m,n)-alon(i,j)) *                        &
436:                       & cos((glat(m,n)+alat(i,j))*degrad))**2 +         &
437:                       & (glat(m,n)-alat(i,j))**2
438:                   if ( distc>aaa ) then
439:                     distc = aaa
440:                     mdr = m
441:                     ndr = n
442:                   end if
443:                 end if
444:                 if ( (glon(m,n)<alon(i,j) .and.                         &
445:                    &  alon(i,j)-glon(m,n) < dlonmax ) .and.             &
446:                    & (glat(m,n)<alat(i,j) .and.                         &
447:                    &  alat(i,j)-glat(m,n) < dlatmax ) ) then
448:                   aaa = ((glon(m,n)-alon(i,j)) *                        &
449:                       & cos((glat(m,n)+alat(i,j))*degrad))**2 +         &
450:                       & (glat(m,n)-alat(i,j))**2
451:                   if ( distd>aaa ) then
452:                     distd = aaa
453:                     mdl = m
454:                     ndl = n
455:                   end if
456:                 end if
457:               end do
458:             end do
459: 
460:             if ( mur < 0. .or. nur < 0. .or. mul < 0. .or. nul < 0. .or.&
461:                  mdr < 0. .or. ndr < 0. .or. mdl < 0. .or. ndl < 0 )    &
462:             then
463:               write ( 6, * ) 'NEST DOMAIN TOO NEAR TO PARENT.'
464:               write ( 6, * ) mur , nur , mdr , ndr
465:               write ( 6, * ) mul , nul , mdl , ndl
466:               write ( 6, * ) i , j
467:               write ( 6, * ) alon(i,j)
468:               write ( 6, * ) alat(i,j)
469:               stop
470:             end if
471: 
472:             dist = amin1(dista,distb,distc,distd)
473:  
474:             ic1ur(i,j) = mur
475:             jc1ur(i,j) = nur
476:             ic1ul(i,j) = mul
477:             jc1ul(i,j) = nul
478:             ic1dr(i,j) = mdr
479:             jc1dr(i,j) = ndr
480:             ic1dl(i,j) = mdl
481:             jc1dl(i,j) = ndl
482:             dc1xt(i,j) = dist
483:             dc1xa(i,j) = dista
484:             dc1xb(i,j) = distb
485:             dc1xc(i,j) = distc
486:             dc1xd(i,j) = distd
487: 
488:             do l = 1 , nf
489:               do k = 1 , nlev
490:                 kin = (l-1)*nlev+k
491:                 if ( dist>0.000001 ) then
492:                   b3(i,j,kin) = (b2(mur,nur,kin)/dista+b2(mul,nul,kin)  &
493:                               & /distb+b2(mdr,ndr,kin)                  &
494:                               & /distc+b2(mdl,ndl,kin)/distd)           &
495:                               & /(1./dista+1./distb+1./distc+1./distd)
496:                 else if ( dist==dista ) then
497:                   b3(i,j,kin) = b2(mur,nur,kin)
498:                 else if ( dist==distb ) then
499:                   b3(i,j,kin) = b2(mul,nul,kin)
500:                 else if ( dist==distc ) then
501:                   b3(i,j,kin) = b2(mdr,ndr,kin)
502:                 else if ( dist==distd ) then
503:                   b3(i,j,kin) = b2(mdl,ndl,kin)
504:                 else
505:                 end if
506:               end do
507:             end do
508:           end do
509:         end do
510:         write ( 6,* ) 'Done.'
511:         lcross = 1
512:       else
513:         do j = 1 , iy
514:           do i = 1 , jx
515:  
516:             mur = ic1ur(i,j)
517:             nur = jc1ur(i,j)
518:             mul = ic1ul(i,j)
519:             nul = jc1ul(i,j)
520:             mdr = ic1dr(i,j)
521:             ndr = jc1dr(i,j)
522:             mdl = ic1dl(i,j)
523:             ndl = jc1dl(i,j)
524:             dist = dc1xt(i,j)
525:             dista = dc1xa(i,j)
526:             distb = dc1xb(i,j)
527:             distc = dc1xc(i,j)
528:             distd = dc1xd(i,j)
529:  
530:             do l = 1 , nf
531:               do k = 1 , nlev
532:                 kin = (l-1)*nlev+k
533:                 if ( dist>0.000001 ) then
534:                   b3(i,j,kin) = (b2(mur,nur,kin)/dista+b2(mul,nul,kin)  &
535:                               & /distb+b2(mdr,ndr,kin)                  &
536:                               & /distc+b2(mdl,ndl,kin)/distd)           &
537:                               & /(1./dista+1./distb+1./distc+1./distd)
538:                 else if ( dist==dista ) then
539:                   b3(i,j,kin) = b2(mur,nur,kin)
540:                 else if ( dist==distb ) then
541:                   b3(i,j,kin) = b2(mul,nul,kin)
542:                 else if ( dist==distc ) then
543:                   b3(i,j,kin) = b2(mdr,ndr,kin)
544:                 else if ( dist==distd ) then
545:                   b3(i,j,kin) = b2(mdl,ndl,kin)
546:                 else
547:                 end if
548:               end do
549:             end do
550:           end do
551:         end do
552:       end if
553:  
554:       end subroutine cressmcr
555: !
556: !-----------------------------------------------------------------------
557: !
<p><a name=cressmdt><H3>cressmdt</H3></a></p> Click <a href="./callingtree/cressmdt_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cressmdt is used.
<hr>
558:       subroutine cressmdt(b3,b2,alon,alat,glon,glat,jx,iy,nlon,nlat,    &
559:                         & nlev,nf)
560:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : degrad
561:       implicit none
562: !
563: ! Dummy arguments
564: !
565:       integer :: iy , jx , nlat , nlev , nlon , nf
566:       real(4) , dimension(jx,iy) :: alat , alon
567:       real(4) , dimension(jx,iy,nlev*nf) :: b3
568:       real(4) , dimension(nlon,nlat) :: glat , glon
569:       real(4) , dimension(nlon,nlat,nlev*nf) :: b2
570:       intent (in) alat , alon , b2 , glat , glon , iy , jx , nlat ,     &
571:                 & nlev , nlon , nf
572:       intent (out) b3
573: !
574: ! Local variables
575: !
576:       real(4) :: aaa , dist , dista , distb , distc , distd
577:       integer :: i , j , k , l , m , mdl , mdr , mul , mur , n , ndl ,  &
578:                & ndr , nul , nur , kin
579: !
580: !     FIND THE FOUR CLOSEST POINTS TO THE GRID WE WANT TO HAVE VALUE,
581: !     THEN DO THE AVERAGE OF THOSE FOUR POINTS WEIGHTED BY THE DISTANCE.
582: !     THE CLOSEST ONE HAS BIGGEST WEIGHT.
583: !
584: !     B2(JX,IX,NLEV) IS THE INPUT FIELD ON PREVIOUS regular or
585: !     irregular GRID. B3(JX,IX,NLEV) IS THE OUTPUT FIELD ON new
586: !     (regular or irregular) GRID. GLON......LONGITUDE VALUES IN
587: !     DEGREES OF THE INTERMEDIATE GRID4. GLAT......LATITUDE VALUES IN
588: !     DEGREES OF THE INTERMEDIATE GRID4.
589: !
590: !     Find the Minimum and Maximum of GLON, GLAT, ALON and ALAT
591: !
592:       if ( imxmn==0 ) then
593:         glonmx = maxval(glon)
594:         glonmn = minval(glon)
595:         alonmx = maxval(alon)
596:         alonmn = minval(alon)
597:         glatmx = maxval(glat)
598:         glatmn = minval(glat)
599:         alatmx = maxval(alat)
600:         alatmn = minval(alat)
601:         dlatmax = (glatmx-glatmn)/nlat * 2.
602:         dlonmax = (glonmx-glonmn)/nlon * 2.
603:         write (*,*) 'GLONMN,ALONMN,ALONMX,GLONMX = '
604:         write (*,*) glonmn , alonmn , alonmx , glonmx
605:         write (*,*) 'GLATMN,ALATMN,ALATMX,GLATMX = '
606:         write (*,*) glatmn , alatmn , alatmx , glatmx
607:         imxmn = 1
608:       end if
609: 
610:       if ( ldot==0 ) then
611:         if (.not. allocated(id1dl)) allocate (id1dl(jx,iy))
612:         if (.not. allocated(id1dr)) allocate (id1dr(jx,iy))
613:         if (.not. allocated(id1ul)) allocate (id1ul(jx,iy))
614:         if (.not. allocated(id1ur)) allocate (id1ur(jx,iy))
615:         if (.not. allocated(jd1dl)) allocate (jd1dl(jx,iy))
616:         if (.not. allocated(jd1dr)) allocate (jd1dr(jx,iy))
617:         if (.not. allocated(jd1ul)) allocate (jd1ul(jx,iy))
618:         if (.not. allocated(jd1ur)) allocate (jd1ur(jx,iy))
619:         if (.not. allocated(dd1xa)) allocate (dd1xa(jx,iy))
620:         if (.not. allocated(dd1xb)) allocate (dd1xb(jx,iy))
621:         if (.not. allocated(dd1xc)) allocate (dd1xc(jx,iy))
622:         if (.not. allocated(dd1xd)) allocate (dd1xd(jx,iy))
623:         if (.not. allocated(dd1xt)) allocate (dd1xt(jx,iy))
624:         write ( 6,* ) 'FIRST TIME in CRESSMDT'
625:         write ( 6,* ) 'Calculating weights.... (will take long time)'
626:         do j = 1 , iy
627:           do i = 1 , jx
628:  
629:             mur = 1000
630:             nur = 1000
631:             mul = 1000
632:             nul = 1000
633:             mdr = 1000
634:             ndr = 1000
635:             mdl = 1000
636:             ndl = 1000
637:  
638:             dista = 1.E8
639:             distb = 1.E8
640:             distc = 1.E8
641:             distd = 1.E8
642:             do n = 2 , nlat
643:               do m = 2 , nlon
644:                 if ( (glon(m,n)>=alon(i,j) .and.                        &
645:                    &  glon(m,n)-alon(i,j) < dlonmax ) .and.             &
646:                    & (glat(m,n)>=alat(i,j) .and.                        &
647:                    &  glat(m,n)-alat(i,j) < dlatmax ) ) then
648:                   aaa = ((glon(m,n)-alon(i,j)) *                        &
649:                       & cos((glat(m,n)+alat(i,j))*degrad))**2 +         &
650:                       & (glat(m,n)-alat(i,j))**2
651:                   if ( dista>aaa ) then
652:                     dista = aaa
653:                     mur = m
654:                     nur = n
655:                   end if
656:                 end if
657:                 if ( (glon(m,n)<alon(i,j) .and.                         &
658:                    &  alon(i,j)-glon(m,n) < dlonmax ) .and.             &
659:                    & (glat(m,n)>=alat(i,j) .and.                        &
660:                    &  glat(m,n)-alat(i,j) < dlatmax ) ) then
661:                   aaa = ((glon(m,n)-alon(i,j)) *                        &
662:                       & cos((glat(m,n)+alat(i,j))*degrad))**2 +         &
663:                       & (glat(m,n)-alat(i,j))**2
664:                   if ( distb>aaa ) then
665:                     distb = aaa
666:                     mul = m
667:                     nul = n
668:                   end if
669:                 end if
670:                 if ( (glon(m,n)>=alon(i,j) .and.                        &
671:                    &  glon(m,n)-alon(i,j) < dlonmax ) .and.             &
672:                    & (glat(m,n)<alat(i,j) .and.                         &
673:                    &  alat(i,j)-glat(m,n) < dlatmax ) ) then
674:                   aaa = ((glon(m,n)-alon(i,j)) *                        &
675:                       & cos((glat(m,n)+alat(i,j))*degrad))**2 +         &
676:                       & (glat(m,n)-alat(i,j))**2
677:                   if ( distc>aaa ) then
678:                     distc = aaa
679:                     mdr = m
680:                     ndr = n
681:                   end if
682:                 end if
683:                 if ( (glon(m,n)<alon(i,j) .and.                         &
684:                    &  alon(i,j)-glon(m,n) < dlonmax ) .and.             &
685:                    & (glat(m,n)<alat(i,j) .and.                         &
686:                    &  alat(i,j)-glat(m,n) < dlatmax ) ) then
687:                   aaa = ((glon(m,n)-alon(i,j)) *                        &
688:                       & cos((glat(m,n)+alat(i,j))*degrad))**2 +         &
689:                       & (glat(m,n)-alat(i,j))**2
690:                   if ( distd>aaa ) then
691:                     distd = aaa
692:                     mdl = m
693:                     ndl = n
694:                   end if
695:                 end if
696:               end do
697:             end do
698: 
699:             if ( mur < 0. .or. nur < 0. .or. mul < 0. .or. nul < 0. .or.&
700:                  mdr < 0. .or. ndr < 0. .or. mdl < 0. .or. ndl < 0 )    &
701:             then
702:               write ( 6, * ) 'NEST DOMAIN TOO NEAR TO PARENT.'
703:               write ( 6, * ) mur , nur , mdr , ndr
704:               write ( 6, * ) mul , nul , mdl , ndl
705:               write ( 6, * ) i , j
706:               write ( 6, * ) alon(i,j)
707:               write ( 6, * ) alat(i,j)
708:               stop
709:             end if
710: 
711:             dist = amin1(dista,distb,distc,distd)
712:  
713:             id1ur(i,j) = mur
714:             jd1ur(i,j) = nur
715:             id1ul(i,j) = mul
716:             jd1ul(i,j) = nul
717:             id1dr(i,j) = mdr
718:             jd1dr(i,j) = ndr
719:             id1dl(i,j) = mdl
720:             jd1dl(i,j) = ndl
721:             dd1xt(i,j) = dist
722:             dd1xa(i,j) = dista
723:             dd1xb(i,j) = distb
724:             dd1xc(i,j) = distc
725:             dd1xd(i,j) = distd
726:             do l = 1 , nf
727:               do k = 1 , nlev
728:                 kin = (l-1)*nlev+k
729:                 if ( dist>0.000001 ) then
730:                   b3(i,j,kin) = (b2(mur,nur,kin)/dista+b2(mul,nul,kin)  &
731:                               & /distb+b2(mdr,ndr,kin)                  &
732:                               & /distc+b2(mdl,ndl,kin)/distd)           &
733:                               & /(1./dista+1./distb+1./distc+1./distd)
734:                 else if ( dist==dista ) then
735:                   b3(i,j,kin) = b2(mur,nur,kin)
736:                 else if ( dist==distb ) then
737:                   b3(i,j,kin) = b2(mul,nul,kin)
738:                 else if ( dist==distc ) then
739:                   b3(i,j,kin) = b2(mdr,ndr,kin)
740:                 else if ( dist==distd ) then
741:                   b3(i,j,kin) = b2(mdl,ndl,kin)
742:                 else
743:                 end if
744:               end do
745:             end do
746:           end do
747:         end do
748:         ldot = 1
749:         write ( 6,* ) 'Done.'
750:       else
751:         do j = 1 , iy
752:           do i = 1 , jx
753:  
754:             mur = id1ur(i,j)
755:             nur = jd1ur(i,j)
756:             mul = id1ul(i,j)
757:             nul = jd1ul(i,j)
758:             mdr = id1dr(i,j)
759:             ndr = jd1dr(i,j)
760:             mdl = id1dl(i,j)
761:             ndl = jd1dl(i,j)
762:             dist = dd1xt(i,j)
763:             dista = dd1xa(i,j)
764:             distb = dd1xb(i,j)
765:             distc = dd1xc(i,j)
766:             distd = dd1xd(i,j)
767:  
768:             do l = 1 , nf
769:               do k = 1 , nlev
770:                 kin = (l-1)*nlev+k
771:                 if ( dist>0.000001 ) then
772:                   b3(i,j,kin) = (b2(mur,nur,kin)/dista+b2(mul,nul,kin)  &
773:                               & /distb+b2(mdr,ndr,kin)                  &
774:                               & /distc+b2(mdl,ndl,kin)/distd)           &
775:                               & /(1./dista+1./distb+1./distc+1./distd)
776:                 else if ( dist==dista ) then
777:                   b3(i,j,kin) = b2(mur,nur,kin)
778:                 else if ( dist==distb ) then
779:                   b3(i,j,kin) = b2(mul,nul,kin)
780:                 else if ( dist==distc ) then
781:                   b3(i,j,kin) = b2(mdr,ndr,kin)
782:                 else if ( dist==distd ) then
783:                   b3(i,j,kin) = b2(mdl,ndl,kin)
784:                 else
785:                 end if
786:               end do
787:             end do
788:           end do
789:         end do
790:       end if
791:  
792:       end subroutine cressmdt
793: !
794:       end module mod_interp
</PRE>

<HR>

</BODY>
</HTML>
