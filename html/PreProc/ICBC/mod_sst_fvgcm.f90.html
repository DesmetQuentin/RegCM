<HTML>

<HEAD>
<TITLE>mod_sst_fvgcm.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_sst_fvgcm.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_sst_fvgcm.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_sst_fvgcm><H3>mod_sst_fvgcm</H3></a></p>20:       module mod_sst_fvgcm
21: 
22:       contains
23: 
<p><a name=sst_fvgcm><H3>sst_fvgcm</H3></a></p> Click <a href="./callingtree/sst_fvgcm_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sst_fvgcm is used.
<hr>
24:       subroutine sst_fvgcm
25: 
26: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
27: ! Comments on dataset sources and location:                          c
28: !                                                                    c
29: ! FVGCM    HadAMH_SST in the original netCDF format.                 c
30: !          for 'RF'          run, from 1959 to 1991, 385 months      c
31: !          for 'A2' and 'B2' run, from 2069 to 2101, 385 months      c
32: !                                                                    c
33: !          ML= 1 is   0.0; ML= 2 is   1.875; => ML=192 is 358.125E   c
34: !          NL= 1 is  90.0; ML= 2 is  88.75 ; => ML=145 is -90.       c
35: !                                                                    c
36: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
37: 
38:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
39:       use <a href="./mod_interp.f90.html#mod_interp" TARGET=CENT_PANEL>mod_interp</a> , only : bilinx
40:       use <a href="./mod_printl.f90.html#mod_printl" TARGET=CENT_PANEL>mod_printl</a>
41: 
42:       implicit none
43: !
44: ! PARAMETER definitions
45: !
46:       integer , parameter :: ilon = 192 , jlat = 145
47: !
48: ! Local variables
49: !
50:       integer :: i , idatef , idateo , it , j , k , ludom , lumax ,     &
51:              &   mrec , nday , nmo , nyear
52:       real(4) , dimension(jlat) :: lati
53:       real(4) , dimension(ilon) :: loni
54:       integer , dimension(20) :: lund
55:       real(4) , dimension(ilon,jlat) :: temp
56:       real(4) , dimension(ilon,jlat) :: sst
57:       integer :: idate , idate0
58:       logical :: there
59:       real(4) , allocatable , dimension(:,:) :: lu , sstmm , xlat , xlon
60:       character(256) :: terfile , sstfile
61: !
62:       allocate(lu(iy,jx))
63:       allocate(sstmm(iy,jx))
64:       allocate(xlat(iy,jx))
65:       allocate(xlon(iy,jx))
66: !
67:       if ( ssttyp=='FV_RF' ) then
68:         inquire (file=trim(inpglob)//'/SST/Sst_1959_1991ref.dat',       &
69:             &    exist=there)
70:         if ( .not.there ) print * ,                                     &
71:             & 'Sst_1959_1991ref.dat is not available under ',           &
72:             & trim(inpglob),'/SST/'
73:         open (11,file=trim(inpglob)//'/SST/Sst_1959_1991ref.dat',       &
74:              &form='unformatted',recl=ilon*jlat*ibyte,access='direct')
75:       else if ( ssttyp=='FV_A2' ) then
76:         inquire (file=trim(inpglob)//'/SST/Sst_2069_2101_A2.dat',       &
77:              &   exist=there)
78:         if ( .not.there ) print * ,                                     &
79:             & 'Sst_2069_2101_A2.dat is not available under ',           &
80:             & trim(inpglob),'/SST/'
81:         open (11,file=trim(inpglob)//'/SST/Sst_2069_2101_A2.dat',       &
82:              &form='unformatted',recl=ilon*jlat*ibyte,access='direct')
83:       else if ( ssttyp=='FV_B2' ) then
84:         inquire (file=trim(inpglob)//'/SST/Sst_2069_2101_B2.dat',       &
85:               &  exist=there)
86:         if ( .not.there ) print * ,                                     &
87:              & 'Sst_2069_2101_B2.dat is not available under ',          &
88:              & trim(inpglob),'/SST/'
89:         open (11,file=trim(inpglob)//'/SST/Sst_2069_2101_B2.dat',       &
90:              &form='unformatted',recl=ilon*jlat*ibyte,access='direct')
91:       else
92:         write (*,*) 'PLEASE SET right SSTTYP in regcm.in'
93:         write (*,*) 'Supported types are FV_RF FV_A2 FV_B2'
94:         stop
95:       end if
96:       write (sstfile,99001) trim(dirglob), pthsep, trim(domname) ,      &
97:         &  '_SST.RCM'
98:       open (21,file=sstfile,form='unformatted',status='replace')
99:  
100: !     ******    ON WHAT RegCM GRID ARE SST DESIRED?
101:       write (terfile,99001)                                             &
102:         & trim(dirter), pthsep, trim(domname) , '.INFO'
103:       open (10,file=terfile,form='unformatted',recl=iy*jx*ibyte,        &
104:          &  access='direct',status='unknown',err=100)
105:       idate = globidate1/10000
106:       if ( idate-(idate/100)*100==1 ) then
107:         idate = idate - 89
108:       else
109:         idate = idate - 1
110:       end if
111:       idateo = idate
112:       idate0 = idateo*10000 + 100
113:       idate = globidate2/10000
114:       if ( idate-(idate/100)*100==12 ) then
115:         idate = idate + 89
116:       else
117:         idate = idate + 1
118:       end if
119:       idatef = idate
120:       print * , globidate1 , globidate2 , idateo , idatef
121:       write (sstfile,99001) trim(dirglob), pthsep, trim(domname) ,      &
122:           &  '_RCM_SST.dat'
123:       open (25,file=sstfile,status='unknown',form='unformatted',        &
124:           & recl=iy*jx*ibyte,access='direct')
125:       if ( igrads==1 ) then
126:         write (sstfile,99001) trim(dirglob), pthsep, trim(domname) ,    &
127:          &   '_RCM_SST.ctl'
128:         open (31,file=sstfile,status='replace')
129:         write (31,'(a,a,a)') 'dset ^',trim(domname),'_RCM_SST.dat'
130:       end if
131:       call <a href="./mod_sst_fvgcm.f90.html#gridmlf" TARGET=CENT_PANEL>gridmlf</a>(xlon,xlat,lu,iy,jx,idateo,idatef)
132:       mrec = 0
133:  
134: !     ******    SET UP LONGITUDES AND LATITUDES FOR SST DATA
135:       do i = 1 , ilon
136:         loni(i) = float(i-1)*1.875
137:       end do
138:       do j = 1 , jlat
139:         lati(j) = -90. + 1.25*float(j-1)
140:       end do
141:  
142: !     **  REF  SST DATA, 1.875x1.1.25, AVAILABLE FROM 16/1/1959 TO
143: !     16/1/1991 ** A2&B2 SST DATA, 1.875x1.1.25, AVAILABLE FROM
144: !     16/1/2069 TO 16/1/2101
145:       idate = idateo
146:       do while ( idate<=idatef )
147:         nyear = idate/100
148:         nmo = idate - nyear*100
149:         nday = 16
150:         write (*,*) idate*10000 + 100 , idate0
151: !       IF(IDATE*10000+100.EQ.IDATE0) CALL SST_MN(SSTTYP)
152:         if ( ssttyp=='FV_RF' ) then
153:           it = (nyear-1959)*12 + nmo
154:         else
155:           it = (nyear-2069)*12 + nmo
156:         end if
157:         read (11,rec=it) temp
158:         do j = 1 , jlat
159:           do i = 1 , ilon
160: !           if(temp(I,NLAT+1-J).gt.-9000.0.and.
161: !           &         temp(I,NLAT+1-J).lt.10000.0) then
162: !           SST2(I,J)=temp(I,NLAT+1-J)
163:             if ( temp(i,j)>-9000.0 .and. temp(i,j)<10000.0 ) then
164:               sst(i,j) = temp(i,j)
165:             else
166:               sst(i,j) = -9999.
167:             end if
168:           end do
169:         end do
170:  
171: !       ******           PRINT OUT DATA AS A CHECK
172:         if ( nmo==1 ) call <a href="./mod_printl.f90.html#printl" TARGET=CENT_PANEL>printl</a>(sst,ilon,jlat)
173:  
174:         call <a href="./aerosol.f90.html#bilinx" TARGET=CENT_PANEL>bilinx</a>(sst,sstmm,xlon,xlat,loni,lati,ilon,jlat,iy,jx,1)
175:         print * , 'XLON,XLAT,SST=' , xlon(1,1) , xlat(1,1) , sstmm(1,1)
176:  
177:         do j = 1 , jx
178:           do i = 1 , iy
179:             if ( sstmm(i,j)<-5000. .and.                                &
180:                & (lu(i,j)>13.5 .and. lu(i,j)<15.5) ) then
181:               do k = 1 , 20
182:                 lund(k) = 0.0
183:               end do
184:               lund(nint(lu(i-1,j-1))) = lund(nint(lu(i-1,j-1))) + 2
185:               lund(nint(lu(i-1,j))) = lund(nint(lu(i-1,j))) + 3
186:               lund(nint(lu(i-1,j+1))) = lund(nint(lu(i-1,j+1))) + 2
187:               lund(nint(lu(i,j-1))) = lund(nint(lu(i,j-1))) + 3
188:               lund(nint(lu(i,j+1))) = lund(nint(lu(i,j+1))) + 3
189:               lund(nint(lu(i+1,j-1))) = lund(nint(lu(i+1,j-1))) + 2
190:               lund(nint(lu(i+1,j))) = lund(nint(lu(i+1,j))) + 3
191:               lund(nint(lu(i+1,j+1))) = lund(nint(lu(i+1,j+1))) + 2
192:               ludom = 18
193:               lumax = 0
194:               do k = 1 , 20
195:                 if ( k<=13 .or. k>=16 ) then
196:                   if ( lund(k)>lumax ) then
197:                     ludom = k
198:                     lumax = lund(k)
199:                   end if
200:                 end if
201:               end do
202:               lu(i,j) = float(ludom)
203:               print * , ludom , sstmm(i,j)
204:             end if
205:             if ( sstmm(i,j)>-100. ) then
206:               sstmm(i,j) = sstmm(i,j)
207:             else
208:               sstmm(i,j) = -9999.
209:             end if
210:           end do
211:         end do
212:  
213: !       ******           WRITE OUT SST DATA ON MM4 GRID
214:         write (21) nday , nmo , nyear , sstmm
215:         print * , 'WRITING OUT MM4 SST DATA:' , nmo , nyear
216:         idate = idate + 1
217:         if ( nmo==12 ) idate = idate + 88
218:         mrec = mrec + 1
219:         write (25,rec=mrec) ((sstmm(i,j),j=1,jx),i=1,iy)
220:       end do
221:       write (10,rec=4) ((lu(i,j),j=1,jx),i=1,iy)
222:  
223:       deallocate(lu)
224:       deallocate(sstmm)
225:       deallocate(xlat)
226:       deallocate(xlon)
227: 
228:       return
229: 
230: !     4810 PRINT *,'ERROR OPENING GISST FILE'
231: !     STOP '4810 IN PROGRAM RDSST'
232:  100  continue
233:       print * , 'ERROR OPENING DOMAIN HEADER FILE'
234:       stop '4830 IN PROGRAM RDSST'
235: 
236: 99001 format (a,a,a,a)
237:       end subroutine sst_fvgcm
238: !
239: !-----------------------------------------------------------------------
240: !
<p><a name=gridmlf><H3>gridmlf</H3></a></p> Click <a href="./callingtree/gridmlf_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where gridmlf is used.
<hr>
241:       subroutine gridmlf(xlon,xlat,lu,iy,jx,idate1,idate2)
242:       implicit none
243: !
244: ! Dummy arguments
245: !
246:       integer :: idate1 , idate2 , iy , jx
247:       real(4) , dimension(iy,jx) :: lu , xlat , xlon
248:       intent (in) idate1 , idate2 , iy , jx
249:       intent (out) lu
250:       intent (out) xlat , xlon
251: !
252: ! Local variables
253: !
254:       real(4) :: alatmax , alatmin , alonmax , alonmin , centeri ,      &
255:             & centerj , clat , clon , dsinm , grdfac , plat , plon ,    &
256:             & ptop , rlatinc , rloninc, trl, trh
257:       character(3) , dimension(12) :: cmonth
258:       integer :: i , ibigend , igrads ,  iyy , j , jxx , k , kz ,       &
259:                & month , nx , ny , period
260:       character(6) :: iproj
261:       real(4) , dimension(30) :: sigmaf
262: !
263:       data cmonth/'jan' , 'feb' , 'mar' , 'apr' , 'may' , 'jun' ,       &
264:          & 'jul' , 'aug' , 'sep' , 'oct' , 'nov' , 'dec'/
265: !
266:       alatmin = 999999.
267:       alatmax = -999999.
268:       alonmin = 999999.
269:       alonmax = -999999.
270:       nx = 0
271:       ny = 0
272:       read (10,rec=1) iyy , jxx , kz , dsinm , clat , clon , plat ,     &
273:                     & plon , grdfac , iproj , (sigmaf(k),k=1,kz+1) ,    &
274:                     & ptop , igrads , ibigend , trl , trh
275:       if ( iyy/=iy .or. jxx/=jx ) then
276:         write (*,*) 'IY,JX,IYY,JXX' , iy , jx , iyy , jxx
277:         stop
278:       end if
279:       read (10,rec=4) ((lu(i,j),j=1,jx),i=1,iy)
280:       read (10,rec=5) ((xlat(i,j),j=1,jx),i=1,iy)
281:       read (10,rec=6) ((xlon(i,j),j=1,jx),i=1,iy)
282: !
283:       if ( igrads==1 ) then
284:         write (31,'(a)') 'title SST fields for RegCM domain'
285:         if ( ibigend==1 ) then
286:           write (31,'(a)') 'options big_endian'
287:         else
288:           write (31,'(a)') 'options little_endian'
289:         end if
290:         write (31,'(a)') 'undef -9999.'
291:         if ( iproj=='LAMCON' .or. iproj=='ROTMER' ) then
292:           do j = 1 , jx
293:             if ( xlat(1,j)<alatmin ) alatmin = xlat(1,j)
294:             if ( xlat(iy,j)>alatmax ) alatmax = xlat(iy,j)
295:           end do
296:           do i = 1 , iy
297:             do j = 1 , jx
298:               if ( clon>=0.0 ) then
299:                 if ( xlon(i,j)>=0.0 ) then
300:                   alonmin = amin1(alonmin,xlon(i,j))
301:                   alonmax = amax1(alonmax,xlon(i,j))
302:                 else if ( abs(clon-xlon(i,j))<abs(clon-(xlon(i,j)+360.))&
303:                         & ) then
304:                   alonmin = amin1(alonmin,xlon(i,j))
305:                   alonmax = amax1(alonmax,xlon(i,j))
306:                 else
307:                   alonmin = amin1(alonmin,xlon(i,j)+360.)
308:                   alonmax = amax1(alonmax,xlon(i,j)+360.)
309:                 end if
310:               else if ( xlon(i,j)<0.0 ) then
311:                 alonmin = amin1(alonmin,xlon(i,j))
312:                 alonmax = amax1(alonmax,xlon(i,j))
313:               else if ( abs(clon-xlon(i,j))<abs(clon-(xlon(i,j)-360.)) )&
314:                       & then
315:                 alonmin = amin1(alonmin,xlon(i,j))
316:                 alonmax = amax1(alonmax,xlon(i,j))
317:               else
318:                 alonmin = amin1(alonmin,xlon(i,j)-360.)
319:                 alonmax = amax1(alonmax,xlon(i,j)-360.)
320:               end if
321:             end do
322:           end do
323:           rlatinc = dsinm*0.001/111./2.
324:           rloninc = dsinm*0.001/111./2.
325:           ny = 2 + nint(abs(alatmax-alatmin)/rlatinc)
326:           nx = 1 + nint(abs((alonmax-alonmin)/rloninc))
327:  
328:           centerj = jx/2.
329:           centeri = iy/2.
330:         end if
331:         if ( iproj=='LAMCON' ) then        ! Lambert projection
332:           write (31,99001) jx , iy , clat , clon , centerj , centeri ,  &
333:                          & trl , trh , clon , dsinm , dsinm
334:           write (31,99002) nx + 2 , alonmin - rloninc , rloninc
335:           write (31,99003) ny + 2 , alatmin - rlatinc , rlatinc
336:         else if ( iproj=='POLSTR' ) then   !
337:         else if ( iproj=='NORMER' ) then
338:           write (31,99004) jx , xlon(1,1) , xlon(1,2) - xlon(1,1)
339:           write (31,99005) iy
340:           write (31,99006) (xlat(i,1),i=1,iy)
341:         else if ( iproj=='ROTMER' ) then
342:           write (*,*) 'Note that rotated Mercartor (ROTMER)' ,          &
343:                      &' projections are not supported by GrADS.'
344:           write (*,*) '  Although not exact, the eta.u projection' ,    &
345:                      &' in GrADS is somewhat similar.'
346:           write (*,*) ' FERRET, however, does support this projection.'
347:           write (31,99007) jx , iy , plon , plat , dsinm/111000. ,      &
348:                          & dsinm/111000.*.95238
349:           write (31,99002) nx + 2 , alonmin - rloninc , rloninc
350:           write (31,99003) ny + 2 , alatmin - rlatinc , rlatinc
351:         else
352:           write (*,*) 'Are you sure your map projection is correct ?'
353:           stop
354:         end if
355:         write (31,99008) 1 , 1000.
356:         month = idate1 - (idate1/100)*100
357:         period = (idate2/100-idate1/100)*12 + (idate2-(idate2/100)*100) &
358:                & - (idate1-(idate1/100)*100) + 1
359:         write (31,99009) period , cmonth(month) , idate1/100
360:         write (31,99010) 1
361:         write (31,99011) 'sst ' , 'surface elevation          '
362:         write (31,'(a)') 'endvars'
363:         close (31)
364:       end if
365: 99001 format ('pdef ',i4,1x,i4,1x,'lcc',7(1x,f7.2),1x,2(f7.0,1x))
366: 99002 format ('xdef ',i4,' linear ',f7.2,1x,f7.4)
367: 99003 format ('ydef ',i4,' linear ',f7.2,1x,f7.4)
368: 99004 format ('xdef ',i3,' linear ',f9.4,' ',f9.4)
369: 99005 format ('ydef ',i3,' levels')
370: 99006 format (10F7.2)
371: 99007 format ('pdef ',i4,1x,i4,1x,'eta.u',2(1x,f7.3),2(1x,f9.5))
372: 99008 format ('zdef ',i1,' levels ',f7.2)
373: 99009 format ('tdef ',i4,' linear 00z16',a3,i4,' 1mo')
374: 99010 format ('vars ',i1)
375: 99011 format (a4,'0 99 ',a26)
376: !
377:       end subroutine gridmlf
378: 
379:       end module mod_sst_fvgcm
</PRE>

<HR>

</BODY>
</HTML>
