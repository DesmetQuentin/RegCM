<HTML>

<HEAD>
<TITLE>initclm.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>initclm.F90</H1>
<HR>
<H2 ALIGN=CENTER>initclm.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
20: #ifdef MPP1
21: #ifdef CLM
<p><a name=initclm><H3>initclm</H3></a></p> Click <a href="./callingtree/initclm_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where initclm is used.
<hr>
22:       subroutine initclm(instep)
23: 
24: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
25: !
26: ! Routine for initializing clm3 in regcm3
27: !
28: ! written by Jason Bell 6/2004 for clm2. Updated by J.Bell 4/2005.
29: ! Modified by: Ahmed Tawfik 8/2009
30: !
31: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
32: ! ==========================================
33: ! Possible atmospheric input fields to clm:
34: ! ==========================================
35: ! Name     Description                              Required/Optional
36: ! -----------------------------------------------------------------------------
37: ! TBOT     temperature (K)                          Required
38: ! WIND     wind:sqrt(u**2+v**2) (m/s)               Required
39: ! QBOT     specific humidity (kg/kg)                Required
40: ! Tdew     dewpoint temperature (K)                 Alternative to Q
41: ! RH       relative humidity (percent)              Alternative to Q
42: ! ZBOT     reference height (m)                     optional
43: ! PSRF     surface pressure (Pa)                    optional
44: ! FSDS     total incident solar radiation (W/m**2)  Required
45: ! FSDSdir  direct incident solar radiation (W/m**2) optional (replaces FSDS)
46: ! FSDSdif  diffuse incident solar rad (W/m**2)      optional (replaces FSDS)
47: !clm2 start
48: ! FSDSsdir  direct incident solar radiation (W/m**2) optional (replaces FSDSdir)
49: ! FSDSsdif  diffuse incident solar rad (W/m**2)      optional (replaces FSDSdif)
50: ! FSDSldir  direct incident solar radiation (W/m**2) optional (replaces FSDSdir)
51: ! FSDSldif  diffuse incident solar rad (W/m**2)      optional (replaces FSDSdif)
52: !clm2 end
53: ! FLDS     incident longwave radiation (W/m**2)     optional
54: ! PRECTmms total precipitation (mm H2O / sec)       Required
55: ! PRECCmms convective precipitation (mm H2O / sec)  optional (replaces PRECT)
56: ! PRECLmms large-scale precipitation (mm H2O / sec) optional (replaces PRECT)
57:  
58:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
59: !
60:       use <a href="#" TARGET=CENT_PANEL>initializeMod</a>
61:       use <a href="#" TARGET=CENT_PANEL>shr_orb_mod</a>
<p><a name=only : r8><H3>only : r8</H3></a></p> Click <a href="./callingtree/only : r8_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where only : r8 is used.
<hr>
62:       use shr_kind_mod,  only : r8 => <a href="#" TARGET=CENT_PANEL>shr_kind_r8</a>
63:       use <a href="#" TARGET=CENT_PANEL>clm_varpar</a>,    only : lsmlon , lsmlat
64:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a>,    only : landmask , landfrac , satbrt_clm
65:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a>,    only : r2cimask , init_tgb , r2coutfrq
66:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a>,    only : clm2bats_veg , ht_rcm
67:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a>,    only : clm_fracveg
68:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a>,    only : slmo
69:       use <a href="#" TARGET=CENT_PANEL>atmdrvMod</a>
70:       use <a href="#" TARGET=CENT_PANEL>spmdMod</a>,       only : masterproc, iam, spmd_init
71:       use <a href="./clmlib/program_offMod.F90.html#program_offmod" TARGET=CENT_PANEL>program_offMod</a>
72:       use <a href="#" TARGET=CENT_PANEL>clm_comp</a> 
73:       use <a href="#" TARGET=CENT_PANEL>clmtype</a>
74:       use <a href="#" TARGET=CENT_PANEL>perf_mod</a>
75: !
76:       use <a href="#" TARGET=CENT_PANEL>mpi</a>
77:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a>
78:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a>
79:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a>
80:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a>
81:       use <a href="./mod_clm.F90.html#mod_clm" TARGET=CENT_PANEL>mod_clm</a>
82:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a>
83:       use <a href="./mod_mppio.F90.html#mod_mppio" TARGET=CENT_PANEL>mod_mppio</a>
84:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a>
85:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
86:       use <a href="./mod_pbldim.F90.html#mod_pbldim" TARGET=CENT_PANEL>mod_pbldim</a>
87:       use <a href="./mod_slice.F90.html#mod_slice" TARGET=CENT_PANEL>mod_slice</a>
88: ! 
89:       implicit none
90: !
91: ! Dummy arguments
92: !
93:       integer :: instep
94:       intent (out) instep
95: !
96: ! Local variables
97: !
98:       integer :: ci , cj , i , ii , j , je , jj , js , n , ierr
99:       real(8) , dimension(jxp,iy) :: r2cflwd , r2cpsb , r2cqb ,         &
100:                 & r2crnc , r2crnnc , r2csoll , r2csolld , r2csols ,     &
101:                 & r2csolsd , r2ctb , r2cuxb , r2cvxb , r2cxlat ,        &
102:                 & r2cxlatd , r2cxlon , r2cxlond , r2czga
103:       real(r8) , dimension(jxp*iy) :: work_in
104:       real(r8) , dimension(jx*iy) :: work_out
105: !
106: !----------------------------------------------------------------------
107: !     About the dimension ordering:
108: !     regcm: ix=lat,jx=lon, arrays are lat by lon
109: !     clm: i=lon, j=lat, arrays are lon by lat
110: !----------------------------------------------------------------------
111: !
112: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
113: !     Initialize run control variables for clm
114: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
115: 
116:       if ( ifrest ) then         !abt added all these indices
117:         r2cnsrest = 1
118:       else
119:         r2cnsrest = 0
120:       end if
121: !     land surface timestep
122:       r2cdtime = abatm
123: !     start date and time
124:       r2cstart_ymd = idate1/100
125:       r2cstart_tod = mod(idate1,100)
126: !     stop date and time
127:       r2cstop_ymd = idate2/100
128:       r2cstop_tod = mod(idate2,100)
129: !     calendar type (GREGORIAN not available in regcm)
130:       r2cclndr = 'NO_LEAP'
131: !     don't write to NCAR Mass Store
132:       r2cmss_irt = 0
133: !     clm output frequency
134:       r2coutfrq = clmfrq
135: !     radiation calculation frequency
136: !     regcm: radfrq is in minutes
137: !     clm: irad is (+) iterations or (-) hours
138: !     clm: hours gets converted to seconds then divided by dtime
139:       r2cirad = (radfrq*60/r2cdtime)
140: !     write output
141:       if ( ifbat ) then
142:         r2cwrtdia = .true.
143:       else
144:         r2cwrtdia = .false.
145:       end if
146: !     Set grid spacing resolution
147:       r2cdx = dx
148: !     Set gridcell area
149:       r2carea = (dx/1000)*(dx/1000)
150: !     Set landmask method
151:       r2cimask = imask
152: !     Set elevation and BATS landuse type (abt added)
153:       if ( .not.allocated(ht_rcm) ) allocate(ht_rcm(iy,jx))
154:       if ( .not.allocated(satbrt_clm) ) allocate(satbrt_clm(iy,jx))
155:       if ( .not.allocated(init_tgb) ) allocate(init_tgb(iy,jx))
156:       if ( .not.allocated(clm2bats_veg) ) allocate(clm2bats_veg(jx,iy))
157:       if ( .not.allocated(clm_fracveg) ) allocate(clm_fracveg(iy,jx))
158:       if ( myid==0 ) then
159:         do j = 1 , jx
160:           do i = 1 , iy
161:             ht_rcm(i,j) = ht_io(i,j)
162:             satbrt_clm(i,j) = satbrt_io(i,j)
163:             init_tgb(i,j) = ts0_io(i,j)
164:             clm_fracveg(i,j) = 0
165:           end do
166:         end do
167:       end if
168: 
169: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
170: !     End of clm run control variable initialization
171: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
172:  
173: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
174: !     Initialize clm input variables:
175: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
176: !
177: !     Assign regcm values to the passed variables
178: !     Flip lat and lon for clm
179: !     regcm writes uneven # of j values to arrays. for now fix by
180: !     copying neighboring values
181:  
182: !     Some vars have not been init'd yet
183:       if ( .not. ifrest ) then
184: !       Rainfall
185:         pptc(:,:) = 0.0
186:         pptnc(:,:) = 0.0
187: !       Radiation
188:         sols2d(:,:) = 0.0
189:         soll2d(:,:) = 0.0
190:         solsd2d(:,:) = 0.0
191:         solld2d(:,:) = 0.0
192:         flwd2d(:,:) = 0.0
193: !       Albedo
194: !       Set initial albedos to clm dry soil values for mid-colored soils
195:         aldirs2d(:,:) = 0.16
196:         aldirl2d(:,:) = 0.32
197:         aldifs2d(:,:) = 0.16
198:         aldifl2d(:,:) = 0.32
199:       end if
200:  
201:       do j = 1 , jxp
202:  
203: !       clm3 currently works on all iy,jx instead of 2-ilx and 2-jlx so
204: !       copy neighboring values for now
205: 
206:         do i = 1 , iy
207:  
208: !         10/05 treat all variables identically. Copy i=2 to i=1 and
209: !         i=ilx to i=iy. For myid = 0, copy j=2 to j=1. For myid =
210: !         nproc-1, copy j=jendx to j=jxp.
211: 
212:           if ( myid==0 .and. j==1 ) then
213:             cj = 2
214:           else if ( myid==(nproc-1) .and. j==jxp ) then
215:             cj = jxp - 1
216:           else
217:             cj = j
218:           end if
219:           if ( i==1 ) then
220:             ci = 2
221:           else if ( i==iy ) then
222:             ci = iy - 1
223:           else
224:             ci = i
225:           end if
226:  
227: !         xlat,xlon in degrees
228:           r2cxlatd(j,i) = xlat(ci,cj)
229:           r2cxlond(j,i) = xlong(ci,cj)
230: !         xlat,xlon in radians
231:           r2cxlat(j,i) = xlat(ci,cj)*degrad
232:           r2cxlon(j,i) = xlong(ci,cj)*degrad
233:  
234:           if ( .not.ifrest ) then
235: !           T(K) at bottom layer
236:             r2ctb(j,i) = tb3d(ci,kz,cj)
237: !           Specific Humidity
238:             r2cqb(j,i) = qvb3d(ci,kz,cj)/(1.+qvb3d(ci,kz,cj))
239: !           Reference Height (m)
240: !           abt               r2czga(j,i) = za3d(ci,kz,cj)
241:             r2czga(j,i) = za(ci,kz,cj)
242: !           Surface winds
243:             r2cuxb(j,i) = ubx3d(ci,kz,cj)
244:             r2cvxb(j,i) = vbx3d(ci,kz,cj)
245: !           Surface Pressure in Pa from hPa
246:             r2cpsb(j,i) = (psb(ci,cj)+ptop)*1000.
247: !
248:             r2crnc(j,i) = pptc(ci,cj)
249:             r2crnnc(j,i) = pptnc(ci,cj)
250:             r2csols(j,i) = sols2d(ci,cj)
251:             r2csoll(j,i) = soll2d(ci,cj)
252:             r2csolsd(j,i) = solsd2d(ci,cj)
253:             r2csolld(j,i) = solld2d(ci,cj)
254:             r2cflwd(j,i) = flwd2d(ci,cj)
255:  
256:           end if
257:  
258:         end do
259:       end do
260:  
261:  
262: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
263: !c
264: !c    1. Copy 2d (jxp,iy) arrays to 1d work_in (jx*iy) array.
265: !c    2. Gather jxp values of each nproc work_in array and fill
266: !c    work_out(jx*iy) array.
267: !c    3. Copy 1d work_out array to 2d (jx,iy) array for passing
268: !c    to clm.
269: !c
270: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
271: 
272:       if ( .not.ifrest ) then
273: !       TGB
274:         ii = 1
275:         do j = 1 , jxp
276:           do i = 1 , iy
277:             work_in(ii) = r2ctb(j,i)
278:             ii = ii + 1
279:           end do
280:         end do
281:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
282:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
283:                          & ierr)
284:         ii = 1
285:         do j = 1 , jx
286:           do i = 1 , iy
287:             r2ctb_all(j,i) = work_out(ii)
288:             ii = ii + 1
289:           end do
290:         end do
291: !       QB
292:         ii = 1
293:         do j = 1 , jxp
294:           do i = 1 , iy
295:             work_in(ii) = r2cqb(j,i)
296:             ii = ii + 1
297:           end do
298:         end do
299:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
300:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
301:                          & ierr)
302:         ii = 1
303:         do j = 1 , jx
304:           do i = 1 , iy
305:             r2cqb_all(j,i) = work_out(ii)
306:             ii = ii + 1
307:           end do
308:         end do
309: !       ZGA
310:         ii = 1
311:         do j = 1 , jxp
312:           do i = 1 , iy
313:             work_in(ii) = r2czga(j,i)
314:             ii = ii + 1
315:           end do
316:         end do
317:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
318:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
319:                          & ierr)
320:         ii = 1
321:         do j = 1 , jx
322:           do i = 1 , iy
323:             r2czga_all(j,i) = work_out(ii)
324:             ii = ii + 1
325:           end do
326:         end do
327: !       PSB
328:         ii = 1
329:         do j = 1 , jxp
330:           do i = 1 , iy
331:             work_in(ii) = r2cpsb(j,i)
332:             ii = ii + 1
333:           end do
334:         end do
335:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
336:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
337:                          & ierr)
338:         ii = 1
339:         do j = 1 , jx
340:           do i = 1 , iy
341:             r2cpsb_all(j,i) = work_out(ii)
342:             ii = ii + 1
343:           end do
344:         end do
345: !       UXB
346:         ii = 1
347:         do j = 1 , jxp
348:           do i = 1 , iy
349:             work_in(ii) = r2cuxb(j,i)
350:             ii = ii + 1
351:           end do
352:         end do
353:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
354:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
355:                          & ierr)
356:         ii = 1
357:         do j = 1 , jx
358:           do i = 1 , iy
359:             r2cuxb_all(j,i) = work_out(ii)
360:             ii = ii + 1
361:           end do
362:         end do
363: !       VXB
364:         ii = 1
365:         do j = 1 , jxp
366:           do i = 1 , iy
367:             work_in(ii) = r2cvxb(j,i)
368:             ii = ii + 1
369:           end do
370:         end do
371:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
372:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
373:                          & ierr)
374:         ii = 1
375:         do j = 1 , jx
376:           do i = 1 , iy
377:             r2cvxb_all(j,i) = work_out(ii)
378:             ii = ii + 1
379:           end do
380:         end do
381: !       RNC
382:         ii = 1
383:         do j = 1 , jxp
384:           do i = 1 , iy
385:             work_in(ii) = r2crnc(j,i)
386:             ii = ii + 1
387:           end do
388:         end do
389:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
390:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
391:                          & ierr)
392:         ii = 1
393:         do j = 1 , jx
394:           do i = 1 , iy
395:             r2crnc_all(j,i) = work_out(ii)
396:             ii = ii + 1
397:           end do
398:         end do
399: !       RNNC
400:         ii = 1
401:         do j = 1 , jxp
402:           do i = 1 , iy
403:             work_in(ii) = r2crnnc(j,i)
404:             ii = ii + 1
405:           end do
406:         end do
407:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
408:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
409:                          & ierr)
410:         ii = 1
411:         do j = 1 , jx
412:           do i = 1 , iy
413:             r2crnnc_all(j,i) = work_out(ii)
414:             ii = ii + 1
415:           end do
416:         end do
417: !       SOLS
418:         ii = 1
419:         do j = 1 , jxp
420:           do i = 1 , iy
421:             work_in(ii) = r2csols(j,i)
422:             ii = ii + 1
423:           end do
424:         end do
425:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
426:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
427:                          & ierr)
428:         ii = 1
429:         do j = 1 , jx
430:           do i = 1 , iy
431:             r2csols_all(j,i) = work_out(ii)
432:             ii = ii + 1
433:           end do
434:         end do
435: !       SOLL
436:         ii = 1
437:         do j = 1 , jxp
438:           do i = 1 , iy
439:             work_in(ii) = r2csoll(j,i)
440:             ii = ii + 1
441:           end do
442:         end do
443:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
444:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
445:                          & ierr)
446:         ii = 1
447:         do j = 1 , jx
448:           do i = 1 , iy
449:             r2csoll_all(j,i) = work_out(ii)
450:             ii = ii + 1
451:           end do
452:         end do
453: !       SOLSD
454:         ii = 1
455:         do j = 1 , jxp
456:           do i = 1 , iy
457:             work_in(ii) = r2csolsd(j,i)
458:             ii = ii + 1
459:           end do
460:         end do
461:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
462:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
463:                          & ierr)
464:         ii = 1
465:         do j = 1 , jx
466:           do i = 1 , iy
467:             r2csolsd_all(j,i) = work_out(ii)
468:             ii = ii + 1
469:           end do
470:         end do
471: !       SOLLD
472:         ii = 1
473:         do j = 1 , jxp
474:           do i = 1 , iy
475:             work_in(ii) = r2csolld(j,i)
476:             ii = ii + 1
477:           end do
478:         end do
479:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
480:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
481:                          & ierr)
482:         ii = 1
483:         do j = 1 , jx
484:           do i = 1 , iy
485:             r2csolld_all(j,i) = work_out(ii)
486:             ii = ii + 1
487:           end do
488:         end do
489: !       LONGWAVE RAD.
490:         ii = 1
491:         do j = 1 , jxp
492:           do i = 1 , iy
493:             work_in(ii) = r2cflwd(j,i)
494:             ii = ii + 1
495:           end do
496:         end do
497:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,&
498:                          & jxp*iy,mpi_double_precision,mpi_comm_world,  &
499:                          & ierr)
500:         ii = 1
501:         do j = 1 , jx
502:           do i = 1 , iy
503:             r2cflwd_all(j,i) = work_out(ii)
504:             ii = ii + 1
505:           end do
506:         end do
507:  
508:       end if  ! if not restart
509:  
510:  
511: !     XLAT in radians
512:       ii = 1
513:       do j = 1 , jxp
514:         do i = 1 , iy
515:           work_in(ii) = r2cxlat(j,i)
516:           ii = ii + 1
517:         end do
518:       end do
519:       call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,  &
520:                        & jxp*iy,mpi_double_precision,mpi_comm_world,    &
521:                        & ierr)
522:       ii = 1
523:       do j = 1 , jx
524:         do i = 1 , iy
525:           r2cxlat_all(j,i) = work_out(ii)
526:           ii = ii + 1
527:         end do
528:       end do
529: !     XLON in radians
530:       ii = 1
531:       do j = 1 , jxp
532:         do i = 1 , iy
533:           work_in(ii) = r2cxlon(j,i)
534:           ii = ii + 1
535:         end do
536:       end do
537:       call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,  &
538:                        & jxp*iy,mpi_double_precision,mpi_comm_world,    &
539:                        & ierr)
540:       ii = 1
541:       do j = 1 , jx
542:         do i = 1 , iy
543:           r2cxlon_all(j,i) = work_out(ii)
544:           ii = ii + 1
545:         end do
546:       end do
547: !     XLAT in degrees
548:       ii = 1
549:       do j = 1 , jxp
550:         do i = 1 , iy
551:           work_in(ii) = r2cxlatd(j,i)
552:           ii = ii + 1
553:         end do
554:       end do
555:       call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,  &
556:                        & jxp*iy,mpi_double_precision,mpi_comm_world,    &
557:                        & ierr)
558:       ii = 1
559:       do j = 1 , jx
560:         do i = 1 , iy
561:           r2cxlatd_all(j,i) = work_out(ii)
562:           ii = ii + 1
563:         end do
564:       end do
565: !     XLON in degrees
566:       ii = 1
567:       do j = 1 , jxp
568:         do i = 1 , iy
569:           work_in(ii) = r2cxlond(j,i)
570:           ii = ii + 1
571:         end do
572:       end do
573:       call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(work_in,jxp*iy,mpi_double_precision,work_out,  &
574:                        & jxp*iy,mpi_double_precision,mpi_comm_world,    &
575:                        & ierr)
576:       ii = 1
577:       do j = 1 , jx
578:         do i = 1 , iy
579:           r2cxlond_all(j,i) = work_out(ii)
580:           ii = ii + 1
581:         end do
582:       end do
583:  
584: !     Set grid edges
585:       r2cedgen = r2cxlatd_all(1,1)
586:       r2cedges = r2cxlatd_all(1,1)
587:       r2cedgee = r2cxlond_all(1,1)
588:       r2cedgew = r2cxlond_all(1,1)
589:  
590: !     clm vars are (lon x lat), regcm (lat x lon)
591:       do j = 1 , jx
592:         do i = 1 , iy
593:           r2cedgen = dmax1(r2cxlatd_all(j,i),r2cedgen)
594:           r2cedges = dmin1(r2cxlatd_all(j,i),r2cedges)
595:           r2cedgee = dmax1(r2cxlond_all(j,i),r2cedgee)
596:           r2cedgew = dmin1(r2cxlond_all(j,i),r2cedgew)
597:         end do
598:       end do
599:  
600: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
601: !     End Initialization of atm variables:
602: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
603:  
604: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
605: !     Get orbital parameters for use in initialize_
606: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
607:       r2cnstep = ktau
608:  
609:       lsmlon = jx   !abt changed clm_varpar_init also
610:       lsmlat = iy
611:  
612: !!!!! Program_off initializes MPI,timing,and surface variables
613:  
614:       call <a href="./clmlib/program_offMod.F90.html#program_off" TARGET=CENT_PANEL>program_off</a>(r2ceccen,r2cobliqr,r2clambm0,r2cmvelpp)
615:       call <a href="#" TARGET=CENT_PANEL>clm_init0</a>()
616:       call <a href="#" TARGET=CENT_PANEL>clm_init1</a>()
617:       call <a href="#" TARGET=CENT_PANEL>clm_init2</a>()
618:  
619: ! -----------------------------------------------------------------
620: ! Initialize "external" atmospheric forcing for CLM
621: ! -----------------------------------------------------------------
622:  
623: ! Read atmospheric forcing dataset one time to obtain the longitudes
624: ! and latitudes of the atmospheric dataset, as well as the edges. When
625: ! coupled to atm model, these are input variables. If no
626: ! atmospheric data files are provided, model uses dummy atmospheric
627: ! forcing and sets atmospheric grid to land grid.
628:  
629:       if ( masterproc ) write (6,*)                                     &
630:                                   &'Attempting to make atmospheric grid'
631:       call <a href="#" TARGET=CENT_PANEL>rcmdrv_init</a>()
632:       if ( masterproc ) write (6,*) 'Successfully make atmospheric grid'
633:  
634: !jlb  12/05: orbital params calc'd in solar1_clm called from init.f and
635: !     tend.f Initializes grid and surface variables (e.g.veg type, soil
636: !     text....)
637:       call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(landmask,size(landmask),mpi_integer,0,             &
638:                    & mpi_comm_world,ierr)
639:  
640:       call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(landfrac,size(landfrac),mpi_real,0,mpi_comm_world, &
641:                    & ierr)
642:  
643: !     Initialize radiation and atmosphere variables
644:       if ( .not.ifrest ) then
645:         instep = ktau
646:         call <a href="#" TARGET=CENT_PANEL>rcmdrv</a>()
647:       end if !end ifrest test
648:  
649: !     Initialize ocld2d now that clm has determined the land sea mask
650: !     Initialize accumulation variables at zero
651:  
652:       js = (jxp*myid) + 1
653:       je = jxp*(myid+1)
654:       jj = 0
655:       do j = js , je
656:         jj = jj + 1
657:         do i = 1 , iy - 1
658:  
659:           if ( .not.ifrest ) then
660:             do n = 1 , nnsg
661:               ocld2d(n,i,jj) = dble(landmask(j,i))
662:               tgb2d(n,i,jj) = tgb(i,jj)
663:               taf2d(n,i,jj) = tgb(i,jj)
664:               tlef2d(n,i,jj) = tgb(i,jj)
665:               dew2d(n,i,jj) = 0.
666:               sag2d(n,i,jj) = 0.
667:               scv2d(n,i,jj) = dmax1(snowc(n,i,jj),0.D0)
668:               sice2d(n,i,jj) = 0.
669:               fsw2d(i,jj) = 0.
670:               flw2d(i,jj) = 0.
671:               sabv2d(i,jj) = 0.
672:               sol2d(i,jj) = 0.
673:               gwet2d(n,i,jj) = 0.5
674:               fswa2d(i,jj) = 0.
675:               flwa2d(i,jj) = 0.
676:               sena2d(n,i,jj) = 0.
677:               evpa2d(n,i,jj) = 0.
678:               prca2d(i,jj) = 0.
679:               prnca2d(i,jj) = 0.
680:               rnos2d(n,i,jj) = 0.
681:               rno2d(n,i,jj) = 0.
682:               svga2d(i,jj) = 0.
683:               sina2d(i,jj) = 0.
684:               ircp2d(n,i,jj) = 0.
685:             end do
686:           end if !end ifrest test
687:  
688:           if ( landfrac(j,i)/=1. .and. landfrac(j,i)/=0. )              &
689:              &    landmask(j,i) = 3.
690: 
691:           ! Set some clm land surface/vegetation variables to the ones
692:           ! used in RegCM.  Make sure all are consistent  
693: 
694:           satbrt(i,jj) = clm2bats_veg(j,i)
695:           if ( clm2bats_veg(j,i).eq.0 ) satbrt(i,jj) = 15
696:           do n = 1 , nnsg
697:             satbrt1(n,i,jj) = clm2bats_veg(j,i)
698:             if ( clm2bats_veg(j,i).eq.0 ) satbrt1(n,i,jj) = 15
699:           end do
700:           if ( satbrt(i,jj).gt.13.9 .and. satbrt(i,jj).lt.15.1 ) then
701:             veg2d(i,jj)  = 0
702:             do n = 1 , nnsg
703:               veg2d1(n,i,jj)  = 0
704:             end do
705:           else
706:             veg2d(i,jj) = satbrt(i,jj)
707:             do n = 1 , nnsg
708:               veg2d1(n,i,jj)  = satbrt(i,jj)
709:             end do
710:           end if
711: !          svegfrac2d(i,jj) = clm_fracveg(i,j) 
712:           do n = 1 , nnsg
713:             if ( veg2d(i,jj).eq.0 .and. ocld2d(n,i,jj).eq.1 ) then
714:               veg2d(i,jj)     =  2
715:               veg2d1(n,i,jj)  =  2
716:               satbrt1(n,i,jj) =  2
717:               satbrt(i,jj)    =  2
718:             end if
719:           end do
720:           if ( landfrac(j,i).ne.1 .and. landfrac(j,i).ne.0 ) then
721:             landmask(j,i) = 3
722:           endif
723:         end do
724:       end do
725:  
726: !     deallocate some variables used in CLM initialization only
727:       if ( allocated(ht_rcm) ) deallocate(ht_rcm)
728:       if ( allocated(satbrt_clm) ) deallocate(satbrt_clm)
729:       if ( allocated(init_tgb) ) deallocate(init_tgb)
730:       if ( allocated(clm2bats_veg) ) deallocate(clm2bats_veg)
731:       if ( allocated(clm_fracveg) ) deallocate(clm_fracveg)
732:  
733:       end subroutine initclm
734: 
735: #endif
736: #endif
</PRE>

<HR>

</BODY>
</HTML>
