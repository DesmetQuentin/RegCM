<HTML>

<HEAD>
<TITLE>spstep.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>spstep.F90</H1>
<HR>
<H2 ALIGN=CENTER>spstep.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=spstep><H3>spstep</H3></a></p> Click <a href="./callingtree/spstep_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spstep is used.
<hr>
20:       subroutine spstep(hbar,dx2,dtau,m)
21: !
22:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
23:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
24:       use <a href="./mod_bxq.F90.html#mod_bxq" TARGET=CENT_PANEL>mod_bxq</a>
25: #ifdef MPP1
26: #ifndef IBM
27:       use <a href="#" TARGET=CENT_PANEL>mpi</a>
28: #else
29:       include 'mpif.h'
30: #endif
31: #endif
32:       implicit none
33: !
34: ! Dummy arguments
35: !
36:       real(8) :: dx2
37:       real(8) , dimension(nsplit) :: dtau , hbar
38:       integer , dimension(nsplit) :: m
39:       intent (in) dtau , dx2 , hbar , m
40: !
41: ! Local variables
42: !
43:       real(8) :: dtau2 , fac
44:       integer :: i , j , m2 , n , n0 , n1 , n2 , ns , nw
45: #ifdef MPP1
46:       integer :: ierr
47:       real(8) , dimension(iy*2) :: wkrecv , wksend
48: #endif
49: !
50:       do n = 1 , nsplit
51: #ifdef MPP1
52:         do j = 1 , jendl
53:           do i = 1 , iy
54:             ddsum(i,j,n) = 0.
55:             dhsum(i,j,n) = 0.
56:           end do
57:         end do
58: #else
59:         do j = 1 , jx
60:           do i = 1 , iy
61:             ddsum(i,j,n) = 0.
62:             dhsum(i,j,n) = 0.
63:           end do
64:         end do
65: #endif
66:       end do
67: !
68:       do ns = 1 , nsplit
69: !
70:         n0 = 1
71:         n1 = 2
72:         n2 = n0
73:         m2 = m(ns)*2
74:         dtau2 = dtau(ns)*2.
75: !
76: !**     below follows madala(1987)
77: !c      do 101 j=1,jlx
78: !c      do 101 i=1,ilx
79: !       deld, delh: 1,ilx on cross grid
80: !c      deld(i,j,ns,n1) = deld(i,j,ns,n0)
81: !c      delh(i,j,ns,n1) = delh(i,j,ns,n0)
82: !c101   continue
83: !
84: #ifdef MPP1
85:         do j = 1 , jendx
86:           do i = 1 , iym1
87: !           deld, delh: 1,ilx on cross grid
88:             ddsum(i,j,ns) = deld(i,j,ns,n0)
89:             dhsum(i,j,ns) = delh(i,j,ns,n0)
90:           end do
91:         end do
92: #else
93:         do j = 1 , jxm1
94:           do i = 1 , iym1
95: !           deld, delh: 1,ilx on cross grid
96:             ddsum(i,j,ns) = deld(i,j,ns,n0)
97:             dhsum(i,j,ns) = delh(i,j,ns,n0)
98:           end do
99:         end do
100: #endif
101: !
102: !**     first step, use forward scheme
103: !=======================================================================
104: !
105: !**     compute gradient of delh;  output = (work1,work2)
106: !
107: #ifdef MPP1
108:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(delh(1,jxp,ns,n0),iy,mpi_real8,               &
109:                         & ieast,1,delh(1,0,ns,n0),iy,                   &
110:                         & mpi_real8,iwest,1,mpi_comm_world,             &
111:                         & mpi_status_ignore,ierr)
112:         do j = jbegin , jendx
113:           do i = 2 , iym1
114:             fac = dx2*msfx(i,j)
115:             work(i,j,1) = (delh(i,j,ns,n0)+delh(i-1,j,ns,n0)-delh(i,j-1,&
116:                         & ns,n0)-delh(i-1,j-1,ns,n0))/fac
117:             work(i,j,2) = (delh(i,j,ns,n0)+delh(i,j-1,ns,n0)-delh(i-1,j,&
118:                         & ns,n0)-delh(i-1,j-1,ns,n0))/fac
119:           end do
120:         end do
121: #else
122:         do j = 2 , jxm1
123:           do i = 2 , iym1
124:             fac = dx2*msfx(i,j)
125:             work(i,j,1) = (delh(i,j,ns,n0)+delh(i-1,j,ns,n0)-delh(i,j-1,&
126:                         & ns,n0)-delh(i-1,j-1,ns,n0))/fac
127:             work(i,j,2) = (delh(i,j,ns,n0)+delh(i,j-1,ns,n0)-delh(i-1,j,&
128:                         & ns,n0)-delh(i-1,j-1,ns,n0))/fac
129:           end do
130:         end do
131: #endif
132: !
133: !=======================================================================
134:         do nw = 1 , 2
135: #ifdef MPP1
136:           do j = jbegin , jendx
137:             do i = 2 , iym1
138: !             work: 2,ilx on dot grid
139:               work(i,j,nw) = work(i,j,nw)*psdot(i,j)
140:             end do
141:           end do
142: #else
143:           do j = 2 , jxm1
144:             do i = 2 , iym1
145: !             work: 2,ilx on dot grid
146:               work(i,j,nw) = work(i,j,nw)*psdot(i,j)
147:             end do
148:           end do
149: #endif
150:         end do
151: !=======================================================================
152: !
153: !**     compute divergence z from u and v
154: !       ( u must be pstar * u ; similarly for v )
155: !       ( note: map scale factors have been inverted in model (init) )
156: !
157: #ifdef MPP1
158:         do j = jbegin , jendx
159:           do i = 2 , iym1
160:             uu(i,j) = work(i,j,1)*msfd(i,j)
161:             vv(i,j) = work(i,j,2)*msfd(i,j)
162:           end do
163:         end do
164: #else
165:         do j = 2 , jxm1
166:           do i = 2 , iym1
167:             uu(i,j) = work(i,j,1)*msfd(i,j)
168:             vv(i,j) = work(i,j,2)*msfd(i,j)
169:           end do
170:         end do
171: #endif
172: !
173: #ifdef MPP1
174:         do i = 1 , iy
175:           wksend(i) = uu(i,1)
176:           wksend(i+iy) = vv(i,1)
177:         end do
178:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(wksend(1),2*iy,mpi_real8,iwest,2,             &
179:                         & wkrecv(1),2*iy,mpi_real8,ieast,2,             &
180:                         & mpi_comm_world,mpi_status_ignore,ierr)
181:         do i = 1 , iy
182:           uu(i,jxp+1) = wkrecv(i)
183:           vv(i,jxp+1) = wkrecv(i+iy)
184:         end do
185: !
186:         do j = jbegin , jendm
187:           do i = 2 , iym2
188:             fac = dx2*msfx(i,j)*msfx(i,j)
189:             work(i,j,3) = (-uu(i+1,j)+uu(i+1,j+1)-uu(i,j)+uu(i,j+1)     &
190:                         & +vv(i+1,j)+vv(i+1,j+1)-vv(i,j)-vv(i,j+1))/fac
191:           end do
192:         end do
193: #else
194:         do j = 2 , jxm2
195:           do i = 2 , iym2
196:             fac = dx2*msfx(i,j)*msfx(i,j)
197:             work(i,j,3) = (-uu(i+1,j)+uu(i+1,j+1)-uu(i,j)+uu(i,j+1)     &
198:                         & +vv(i+1,j)+vv(i+1,j+1)-vv(i,j)-vv(i,j+1))/fac
199:           end do
200:         end do
201: #endif
202: !
203: !=======================================================================
204: !
205: #ifdef MPP1
206:         do j = jbegin , jendm
207:           do i = 2 , iym2
208: !           work3: 2,iym2 on cross grid
209:             deld(i,j,ns,n1) = deld(i,j,ns,n0) - dtau(ns)*work(i,j,3)    &
210:                             & + deld(i,j,ns,3)/m2
211:             delh(i,j,ns,n1) = delh(i,j,ns,n0) - dtau(ns)*hbar(ns)       &
212:                             & *deld(i,j,ns,n0)/psa(i,j) + delh(i,j,ns,3)&
213:                             & /m2
214:           end do
215:         end do
216: #else
217:         do j = 2 , jxm2
218:           do i = 2 , iym2
219: !           work3: 2,iym2 on cross grid
220:             deld(i,j,ns,n1) = deld(i,j,ns,n0) - dtau(ns)*work(i,j,3)    &
221:                             & + deld(i,j,ns,3)/m2
222:             delh(i,j,ns,n1) = delh(i,j,ns,n0) - dtau(ns)*hbar(ns)       &
223:                             & *deld(i,j,ns,n0)/psa(i,j) + delh(i,j,ns,3)&
224:                             & /m2
225:           end do
226:         end do
227: #endif
228:  
229: !**     not in madala(1987)
230:         fac = (m(ns)-1.)/m(ns)
231:         do i = 2 , iym2
232: #ifdef MPP1
233:           if ( myid.eq.0 ) delh(i,1,ns,n1) = delh(i,1,ns,n0)*fac
234:           if ( myid.eq.nproc-1 ) delh(i,jendx,ns,n1)                    &
235:              & = delh(i,jendx,ns,n0)*fac
236: #else
237:           delh(i,1,ns,n1) = delh(i,1,ns,n0)*fac
238:           delh(i,jxm1,ns,n1) = delh(i,jxm1,ns,n0)*fac
239: #endif
240:         end do
241: #ifdef MPP1
242:         do j = 1 , jendx
243:           delh(1,j,ns,n1) = delh(1,j,ns,n0)*fac
244:           delh(iym1,j,ns,n1) = delh(iym1,j,ns,n0)*fac
245:         end do
246: #else
247:         do j = 1 , jxm1
248:           delh(1,j,ns,n1) = delh(1,j,ns,n0)*fac
249:           delh(iym1,j,ns,n1) = delh(iym1,j,ns,n0)*fac
250:         end do
251: #endif
252: !
253: #ifdef MPP1
254:         do j = 1 , jendx
255:           do i = 1 , iym1
256:             ddsum(i,j,ns) = ddsum(i,j,ns) + deld(i,j,ns,n1)
257:             dhsum(i,j,ns) = dhsum(i,j,ns) + delh(i,j,ns,n1)
258:           end do
259:         end do
260: #else
261:         do j = 1 , jxm1
262:           do i = 1 , iym1
263:             ddsum(i,j,ns) = ddsum(i,j,ns) + deld(i,j,ns,n1)
264:             dhsum(i,j,ns) = dhsum(i,j,ns) + delh(i,j,ns,n1)
265:           end do
266:         end do
267: #endif
268: !
269: !**     subsequent steps, use leapfrog scheme
270:         do n = 2 , m2
271: !=======================================================================
272: !
273: !**       compute gradient of delh;  output = (work1,work2)
274: !
275: #ifdef MPP1
276:           call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(delh(1,jxp,ns,n1),iy,mpi_real8,             &
277:                           & ieast,1,delh(1,0,ns,n1),iy,                 &
278:                           & mpi_real8,iwest,1,mpi_comm_world,           &
279:                           & mpi_status_ignore,ierr)
280:           do j = jbegin , jendx
281:             do i = 2 , iym1
282:               fac = dx2*msfx(i,j)
283:               work(i,j,1) = (delh(i,j,ns,n1)+delh(i-1,j,ns,n1)-delh(i,j-&
284:                           & 1,ns,n1)-delh(i-1,j-1,ns,n1))/fac
285:               work(i,j,2) = (delh(i,j,ns,n1)+delh(i,j-1,ns,n1)-delh(i-1,&
286:                           & j,ns,n1)-delh(i-1,j-1,ns,n1))/fac
287:             end do
288:           end do
289: #else
290:           do j = 2 , jxm1
291:             do i = 2 , iym1
292:               fac = dx2*msfx(i,j)
293:               work(i,j,1) = (delh(i,j,ns,n1)+delh(i-1,j,ns,n1)-delh(i,j-&
294:                           & 1,ns,n1)-delh(i-1,j-1,ns,n1))/fac
295:               work(i,j,2) = (delh(i,j,ns,n1)+delh(i,j-1,ns,n1)-delh(i-1,&
296:                           & j,ns,n1)-delh(i-1,j-1,ns,n1))/fac
297:             end do
298:           end do
299: #endif
300: !=======================================================================
301: !
302:           do nw = 1 , 2
303: #ifdef MPP1
304:             do j = jbegin , jendx
305:               do i = 2 , iym1
306:                 work(i,j,nw) = work(i,j,nw)*psdot(i,j)
307:               end do
308:             end do
309: #else
310:             do j = 2 , jxm1
311:               do i = 2 , iym1
312:                 work(i,j,nw) = work(i,j,nw)*psdot(i,j)
313:               end do
314:             end do
315: #endif
316:           end do
317: !=======================================================================
318: !
319: !**       compute divergence z from u and v
320: !         ( u must be pstar * u ; similarly for v )
321: !         ( note: map scale factors have been inverted in model (init) )
322: !
323: #ifdef MPP1
324:           do j = jbegin , jendx
325:             do i = 2 , iym1
326:               uu(i,j) = work(i,j,1)*msfd(i,j)
327:               vv(i,j) = work(i,j,2)*msfd(i,j)
328:             end do
329:           end do
330: #else
331:           do j = 2 , jxm1
332:             do i = 2 , iym1
333:               uu(i,j) = work(i,j,1)*msfd(i,j)
334:               vv(i,j) = work(i,j,2)*msfd(i,j)
335:             end do
336:           end do
337: #endif
338: !
339: #ifdef MPP1
340:           do i = 1 , iy
341:             wksend(i) = uu(i,1)
342:             wksend(i+iy) = vv(i,1)
343:           end do
344:           call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(wksend(1),2*iy,mpi_real8,iwest,2,           &
345:                           & wkrecv(1),2*iy,mpi_real8,ieast,2,           &
346:                           & mpi_comm_world,mpi_status_ignore,ierr)
347:           do i = 1 , iy
348:             uu(i,jxp+1) = wkrecv(i)
349:             vv(i,jxp+1) = wkrecv(i+iy)
350:           end do
351: !
352:           do j = jbegin , jendm
353:             do i = 2 , iym2
354:               fac = dx2*msfx(i,j)*msfx(i,j)
355:               work(i,j,3) = (-uu(i+1,j)+uu(i+1,j+1)-uu(i,j)+uu(i,j+1)   &
356:                           & +vv(i+1,j)+vv(i+1,j+1)-vv(i,j)-vv(i,j+1))   &
357:                           & /fac
358:             end do
359:           end do
360: #else
361:           do j = 2 , jxm2
362:             do i = 2 , iym2
363:               fac = dx2*msfx(i,j)*msfx(i,j)
364:               work(i,j,3) = (-uu(i+1,j)+uu(i+1,j+1)-uu(i,j)+uu(i,j+1)   &
365:                           & +vv(i+1,j)+vv(i+1,j+1)-vv(i,j)-vv(i,j+1))   &
366:                           & /fac
367:             end do
368:           end do
369: #endif
370: !
371: !=======================================================================
372: !
373: #ifdef MPP1
374:           do j = jbegin , jendm
375:             do i = 2 , iym2
376:               deld(i,j,ns,n2) = deld(i,j,ns,n0) - dtau2*work(i,j,3)     &
377:                               & + deld(i,j,ns,3)/m(ns)
378:               delh(i,j,ns,n2) = delh(i,j,ns,n0) - dtau2*hbar(ns)        &
379:                               & *deld(i,j,ns,n1)/psa(i,j)               &
380:                               & + delh(i,j,ns,3)/m(ns)
381:             end do
382:           end do
383: #else
384:           do j = 2 , jxm2
385:             do i = 2 , iym2
386:               deld(i,j,ns,n2) = deld(i,j,ns,n0) - dtau2*work(i,j,3)     &
387:                               & + deld(i,j,ns,3)/m(ns)
388:               delh(i,j,ns,n2) = delh(i,j,ns,n0) - dtau2*hbar(ns)        &
389:                               & *deld(i,j,ns,n1)/psa(i,j)               &
390:                               & + delh(i,j,ns,3)/m(ns)
391:             end do
392:           end do
393: #endif
394: !
395: !**       not in madala(1987)
396:           do i = 2 , iym2
397: #ifdef MPP1
398:             if ( myid.eq.0 ) delh(i,1,ns,n2) = 2.*delh(i,1,ns,n1)       &
399:                & - delh(i,1,ns,n0)
400:             if ( myid.eq.nproc-1 ) delh(i,jendx,ns,n2)                  &
401:                & = 2.*delh(i,jendx,ns,n1) - delh(i,jendx,ns,n0)
402: #else
403:             delh(i,1,ns,n2) = 2.*delh(i,1,ns,n1) - delh(i,1,ns,n0)
404:             delh(i,jxm1,ns,n2) = 2.*delh(i,jxm1,ns,n1) - delh(i,jxm1,ns,n0)
405: #endif
406:           end do
407: #ifdef MPP1
408:           do j = 1 , jendx
409:             delh(1,j,ns,n2) = 2.*delh(1,j,ns,n1) - delh(1,j,ns,n0)
410:             delh(iym1,j,ns,n2) = 2.*delh(iym1,j,ns,n1) - delh(iym1,j,ns,n0)
411:           end do
412: #else
413:           do j = 1 , jxm1
414:             delh(1,j,ns,n2) = 2.*delh(1,j,ns,n1) - delh(1,j,ns,n0)
415:             delh(iym1,j,ns,n2) = 2.*delh(iym1,j,ns,n1) - delh(iym1,j,ns,n0)
416:           end do
417: #endif
418: !
419: #ifdef MPP1
420:           do j = 1 , jendx
421:             do i = 1 , iym1
422:               ddsum(i,j,ns) = ddsum(i,j,ns) + deld(i,j,ns,n2)
423:               dhsum(i,j,ns) = dhsum(i,j,ns) + delh(i,j,ns,n2)
424:             end do
425:           end do
426: #else
427:           do j = 1 , jxm1
428:             do i = 1 , iym1
429:               ddsum(i,j,ns) = ddsum(i,j,ns) + deld(i,j,ns,n2)
430:               dhsum(i,j,ns) = dhsum(i,j,ns) + delh(i,j,ns,n2)
431:             end do
432:           end do
433: #endif
434: !
435:           n0 = n1
436:           n1 = n2
437:           n2 = n0
438:         end do
439: !
440:       end do
441: !
442:       end subroutine spstep
</PRE>

<HR>

</BODY>
</HTML>
