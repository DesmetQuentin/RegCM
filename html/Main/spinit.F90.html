<HTML>

<HEAD>
<TITLE>spinit.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>spinit.F90</H1>
<HR>
<H2 ALIGN=CENTER>spinit.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public Licens for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=spinit><H3>spinit</H3></a></p> Click <a href="./callingtree/spinit_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spinit is used.
<hr>
20:       subroutine spinit(sigma,kv1)
21: !
22: !** compute vertical modes.
23: !
24:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
25:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : dt , dtau , dx2
26:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a>
27:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : r8pt
28:       use <a href="./mod_iunits.f90.html#mod_iunits" TARGET=CENT_PANEL>mod_iunits</a>
29:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a>
30:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
31:       use <a href="./mod_split.F90.html#mod_split" TARGET=CENT_PANEL>mod_split</a>
32:       use <a href="./mod_bxq.F90.html#mod_bxq" TARGET=CENT_PANEL>mod_bxq</a>
33:       use <a href="./mod_tmpsav.F90.html#mod_tmpsav" TARGET=CENT_PANEL>mod_tmpsav</a>
34:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : jyear , jyear0 , ktau
35:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgas
36:       use <a href="./mod_vmodes.F90.html#mod_vmodes" TARGET=CENT_PANEL>mod_vmodes</a> , only : vmodes
37: #ifdef MPP1
38:       use <a href="./mod_mppio.F90.html#mod_mppio" TARGET=CENT_PANEL>mod_mppio</a>
39: #ifndef IBM
40:       use <a href="#" TARGET=CENT_PANEL>mpi</a>
41: #else
42:       include 'mpif.h'
43: #endif
44: #endif
45:       implicit none
46: !
47: ! Dummy arguments
48: !
49:       integer :: kv1
50:       real(8) , dimension(kv1) :: sigma
51: !
52: ! Local variables
53: !
54:       real(8) :: eps , eps1 , fac , pdlog
55:       integer :: i , ijlx , j , k , l , n , ns
56:       logical :: lstand
57: #ifdef MPP1
58:       integer :: ierr
59: #endif
60: !
61: !     lstand = .true. if standard atmosphere t to be used (ignore input
62: !     tbarh and ps in that case).  otherwise, ps and tbarh must
63: !     be defined on input.  note that in either case, r8pt must
64: !     also be defined on input (common block named cvert).
65: !
66: !
67: !     ******dtau = time steps(in sec)for modes in split explicit is
68: !     ******specified in namelist as array dtsplit
69: !
70: !**   zero new arrays
71: 
72:       dstor = 0.0
73:       hstor = 0.0
74: !
75: !**   compute m.
76:       do ns = 1 , nsplit
77:         m(ns) = nint(dt/dtau(ns))
78:         if ( jyear.ne.jyear0 .or. ktau.ne.0 ) m(ns)                     &
79:            & = nint(.5*dt/dtau(ns))
80:       end do
81: #ifdef MPP1
82:       if ( myid.eq.0 ) print * , 'dt, dtau = ' , dt , dtau
83: #else
84:       print * , 'dt, dtau = ' , dt , dtau
85: #endif
86: !
87: !**   compute ps and tbarh for use in vmodes.
88:       ps = 0.
89:       do k = 1 , kz
90:         tbarh(k) = 0.
91:       end do
92: #ifdef MPP1
93:       ijlx = iym1*jendx
94:       do j = 1 , jendx
95:         do i = 1 , iym1
96:           ps = ps + psa(i,j)/ijlx
97:         end do
98:       end do
99: #else
100:       ijlx = iym1*jxm1
101:       do j = 1 , jxm1
102:         do i = 1 , iym1
103:           ps = ps + psa(i,j)/ijlx
104:         end do
105:       end do
106: #endif
107:       do k = 1 , kz
108: #ifdef MPP1
109:         do j = 1 , jendx
110:           do i = 1 , iym1
111:             tbarh(k) = tbarh(k) + ta(i,k,j)/(psa(i,j)*ijlx)
112:           end do
113:         end do
114: #else
115:         do j = 1 , jxm1
116:           do i = 1 , iym1
117:             tbarh(k) = tbarh(k) + ta(i,k,j)/(psa(i,j)*ijlx)
118:           end do
119:         end do
120: #endif
121:       end do
122: !
123: !**   compute vertical modes.
124:       lstand = .true.
125:       if ( jyear.ne.jyear0 .or. ktau.ne.0 ) lstand = .true.
126:       call <a href="./mod_vmodes.F90.html#vmodes" TARGET=CENT_PANEL>vmodes</a>(lstand,sigma,kv1)
127: !
128: !**   subract a4 from a for use in computing am.
129:       do l = 1 , kz
130:         do k = 1 , kz
131:           a(k,l) = a(k,l) - a4(k,l)
132:         end do
133:       end do
134: !
135: !**   compute am and an.
136:       do n = 1 , nsplit
137:         an(n) = 0.
138:         do l = 1 , kz
139:           an(n) = an(n) + dsigma(l)*zmatx(l,n)
140:         end do
141:         do k = 1 , kz
142:           am(k,n) = 0.
143:           tau(n,k) = 0.
144:         end do
145:         do l = 1 , kz
146:           do k = 1 , kz
147:             am(k,n) = am(k,n) + a(k,l)*zmatx(l,n)
148:             tau(n,k) = tau(n,k) + rgas*zmatxr(n,l)*hydros(l,k)
149:           end do
150:         end do
151: !
152:         do k = 1 , kzp1
153:           varpa1(n,k) = 0.
154:         end do
155:         do l = 1 , kz
156:           do k = 1 , kzp1
157:             varpa1(n,k) = varpa1(n,k) + rgas*zmatxr(n,l)*hydroc(l,k)
158:           end do
159:         end do
160:       end do
161: !
162: !**   multiply am, an and zmatx by factor.
163:       do l = 1 , nsplit
164:         fac = 2.*dt/(2.*dble(m(l))+1.)
165:         if ( jyear.ne.jyear0 .or. ktau.ne.0 )                           &
166:            & fac = dt/(2.*dble(m(l))+1.)
167: #ifdef MPP1
168:         if ( myid.eq.0 ) print * , 'm, fac = ' , m(l) , fac
169: #else
170:         print * , 'm, fac = ' , m(l) , fac
171: #endif
172:         an(l) = an(l)*fac
173:         do k = 1 , kz
174:           zmatx(k,l) = zmatx(k,l)*fac
175:           am(k,l) = am(k,l)*fac
176:         end do
177:       end do
178: !
179:       if ( ifrest ) then
180: #ifdef MPP1
181:         if ( myid.eq.0 ) then
182:           read (iutrs) dstor_io
183:           read (iutrs) hstor_io
184:           read (iutrs) uj1 , uj2 , ujlx , ujl
185:           read (iutrs) ui1_io , ui2_io , uilx_io , uil_io
186:           read (iutrs) vj1 , vj2 , vjlx , vjl
187:           read (iutrs) vi1_io , vi2_io , vilx_io , vil_io
188:           do j = 1 , jx
189:             do n = 1 , nsplit
190:               do i = 1 , iy
191:                 sav_0d(i,n,j) = dstor_io(i,j,n)
192:                 sav_0d(i,n+nsplit,j) = hstor_io(i,j,n)
193:               end do
194:             end do
195:           end do
196:           do j = 1 , jx
197:             do k = 1 , kz
198:               sav_6(k,1,j) = ui1_io(k,j)
199:               sav_6(k,2,j) = ui2_io(k,j)
200:               sav_6(k,3,j) = uilx_io(k,j)
201:               sav_6(k,4,j) = uil_io(k,j)
202:               sav_6(k,5,j) = vi1_io(k,j)
203:               sav_6(k,6,j) = vi2_io(k,j)
204:               sav_6(k,7,j) = vilx_io(k,j)
205:               sav_6(k,8,j) = vil_io(k,j)
206:             end do
207:           end do
208:         end if
209:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0d(1,1,1),iy*nsplit*2*jxp,mpi_real8,       &
210:                        & sav0d(1,1,1), iy*nsplit*2*jxp,mpi_real8,       &
211:                        & 0,mpi_comm_world,ierr)
212:         do j = 1 , jendl
213:           do n = 1 , nsplit
214:             do i = 1 , iy
215:               dstor(i,j,n) = sav0d(i,n,j)
216:               hstor(i,j,n) = sav0d(i,n+nsplit,j)
217:             end do
218:           end do
219:         end do
220:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_6(1,1,1),kz*8*jxp,mpi_real8,               &
221:                        & sav6(1,1,1),kz*8*jxp,mpi_real8,0,              &
222:                        & mpi_comm_world,ierr)
223:         do j = 1 , jendl
224:           do k = 1 , kz
225:             ui1(k,j) = sav6(k,1,j)
226:             ui2(k,j) = sav6(k,2,j)
227:             uilx(k,j) = sav6(k,3,j)
228:             uil(k,j) = sav6(k,4,j)
229:             vi1(k,j) = sav6(k,5,j)
230:             vi2(k,j) = sav6(k,6,j)
231:             vilx(k,j) = sav6(k,7,j)
232:             vil(k,j) = sav6(k,8,j)
233:           end do
234:         end do
235:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(uj1,iy*kz,mpi_real8,0,mpi_comm_world,ierr)
236:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(uj2,iy*kz,mpi_real8,0,mpi_comm_world,ierr)
237:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(vj1,iy*kz,mpi_real8,0,mpi_comm_world,ierr)
238:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(vj2,iy*kz,mpi_real8,0,mpi_comm_world,ierr)
239:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ujlx,iy*kz,mpi_real8,0,mpi_comm_world,ierr)
240:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ujl,iy*kz,mpi_real8,0,mpi_comm_world,ierr)
241:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(vjlx,iy*kz,mpi_real8,0,mpi_comm_world,ierr)
242:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(vjl,iy*kz,mpi_real8,0,mpi_comm_world,ierr)
243:         if ( myid.ne.nproc-1 ) then
244:           do k = 1 , kz
245:             var1snd(k,1) = ui1(k,jxp)
246:             var1snd(k,2) = vi1(k,jxp)
247:             var1snd(k,3) = ui2(k,jxp)
248:             var1snd(k,4) = vi2(k,jxp)
249:             var1snd(k,5) = uilx(k,jxp)
250:             var1snd(k,6) = vilx(k,jxp)
251:             var1snd(k,7) = uil(k,jxp)
252:             var1snd(k,8) = vil(k,jxp)
253:           end do
254:         end if
255:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(var1snd(1,1),kz*8,mpi_real8,ieast,            &
256:                         & 1,var1rcv(1,1),kz*8,mpi_real8,                &
257:                         & iwest,1,mpi_comm_world,mpi_status_ignore,ierr)
258:         if ( myid.ne.0 ) then
259:           do k = 1 , kz
260:             ui1(k,0) = var1rcv(k,1)
261:             vi1(k,0) = var1rcv(k,2)
262:             ui2(k,0) = var1rcv(k,3)
263:             vi2(k,0) = var1rcv(k,4)
264:             uilx(k,0) = var1rcv(k,5)
265:             vilx(k,0) = var1rcv(k,6)
266:             uil(k,0) = var1rcv(k,7)
267:             vil(k,0) = var1rcv(k,8)
268:           end do
269:         end if
270:         if ( myid.ne.0 ) then
271:           do k = 1 , kz
272:             var1snd(k,1) = ui1(k,1)
273:             var1snd(k,2) = vi1(k,1)
274:             var1snd(k,3) = ui2(k,1)
275:             var1snd(k,4) = vi2(k,1)
276:             var1snd(k,5) = uilx(k,1)
277:             var1snd(k,6) = vilx(k,1)
278:             var1snd(k,7) = uil(k,1)
279:             var1snd(k,8) = vil(k,1)
280:           end do
281:         end if
282:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(var1snd(1,1),kz*8,mpi_real8,iwest,            &
283:                         & 2,var1rcv(1,1),kz*8,mpi_real8,                &
284:                         & ieast,2,mpi_comm_world,mpi_status_ignore,ierr)
285:         if ( myid.ne.nproc-1 ) then
286:           do k = 1 , kz
287:             ui1(k,jxp+1) = var1rcv(k,1)
288:             vi1(k,jxp+1) = var1rcv(k,2)
289:             ui2(k,jxp+1) = var1rcv(k,3)
290:             vi2(k,jxp+1) = var1rcv(k,4)
291:             uilx(k,jxp+1) = var1rcv(k,5)
292:             vilx(k,jxp+1) = var1rcv(k,6)
293:             uil(k,jxp+1) = var1rcv(k,7)
294:             vil(k,jxp+1) = var1rcv(k,8)
295:           end do
296:         end if
297: #else
298:         read (iutrs) dstor
299:         read (iutrs) hstor
300:         read (iutrs) uj1 , uj2 , ujlx , ujl
301:         read (iutrs) ui1 , ui2 , uilx , uil
302:         read (iutrs) vj1 , vj2 , vjlx , vjl
303:         read (iutrs) vi1 , vi2 , vilx , vil
304: #endif
305:       else
306: !
307: !=======================================================================
308: !******* divergence manipulations (0)
309: !
310: !**     compute divergence z from u and v
311: !       ( u must be pstar * u ; similarly for v )
312: !       ( note: map scale factors have been inverted in model (init) )
313: !
314:         do k = 1 , kz
315: #ifdef MPP1
316:           do j = 1 , jendl
317:             do i = 1 , iy
318:               uuu(i,k,j) = ub(i,k,j)*msfd(i,j)
319:               vvv(i,k,j) = vb(i,k,j)*msfd(i,j)
320:             end do
321:           end do
322: #else
323:           do j = 1 , jx
324:             do i = 1 , iy
325:               uuu(i,k,j) = ub(i,k,j)*msfd(i,j)
326:               vvv(i,k,j) = vb(i,k,j)*msfd(i,j)
327:             end do
328:           end do
329: #endif
330:         end do
331: #ifdef MPP1
332:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(uuu(1,1,1),iy*kz,mpi_real8,iwest,2,           &
333:                         & uuu(1,1,jxp+1),iy*kz,mpi_real8,               &
334:                         & ieast,2,mpi_comm_world,mpi_status_ignore,ierr)
335:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(vvv(1,1,1),iy*kz,mpi_real8,iwest,2,           &
336:                         & vvv(1,1,jxp+1),iy*kz,mpi_real8,               &
337:                         & ieast,2,mpi_comm_world,mpi_status_ignore,ierr)
338: #endif
339: !
340:         do l = 1 , nsplit
341: #ifdef MPP1
342:           do j = 1 , jendl
343:             do i = 1 , iy
344:               dstor(i,j,l) = 0.
345:             end do
346:           end do
347: #else
348:           do j = 1 , jx
349:             do i = 1 , iy
350:               dstor(i,j,l) = 0.
351:             end do
352:           end do
353: #endif
354:         end do
355:         do l = 1 , nsplit
356:           do k = 1 , kz
357: #ifdef MPP1
358:             do j = 1 , jendx
359:               do i = 1 , iym1
360:                 fac = dx2*msfx(i,j)*msfx(i,j)
361:                 dstor(i,j,l) = dstor(i,j,l) + zmatxr(l,k)               &
362:                              & *(-uuu(i+1,k,j)+uuu(i+1,k,j+1)-uuu(i,k,j)&
363:                              & +uuu(i,k,j+1)+vvv(i+1,k,j)+vvv(i+1,k,j+1)&
364:                              & -vvv(i,k,j)-vvv(i,k,j+1))/fac
365:               end do
366:             end do
367: #else
368:             do j = 1 , jxm1
369:               do i = 1 , iym1
370:                 fac = dx2*msfx(i,j)*msfx(i,j)
371:                 dstor(i,j,l) = dstor(i,j,l) + zmatxr(l,k)               &
372:                              & *(-uuu(i+1,k,j)+uuu(i+1,k,j+1)-uuu(i,k,j)&
373:                              & +uuu(i,k,j+1)+vvv(i+1,k,j)+vvv(i+1,k,j+1)&
374:                              & -vvv(i,k,j)-vvv(i,k,j+1))/fac
375:               end do
376:             end do
377: #endif
378:           end do
379:         end do
380: !
381: !=======================================================================
382: !
383: !******* geopotential manipulations
384:         do l = 1 , nsplit
385:           pdlog = varpa1(l,kzp1)*dlog(sigmah(kzp1)*pd+r8pt)
386:           eps1 = varpa1(l,kzp1)*sigmah(kzp1)/(sigmah(kzp1)*pd+r8pt)
387: #ifdef MPP1
388:           do j = 1 , jendx
389:             do i = 1 , iym1
390:               eps = eps1*(psb(i,j)-pd)
391:               hstor(i,j,l) = pdlog + eps
392:             end do
393:           end do
394: #else
395:           do j = 1 , jxm1
396:             do i = 1 , iym1
397:               eps = eps1*(psb(i,j)-pd)
398:               hstor(i,j,l) = pdlog + eps
399:             end do
400:           end do
401: #endif
402:           do k = 1 , kz
403:             pdlog = varpa1(l,k)*dlog(sigmah(k)*pd+r8pt)
404:             eps1 = varpa1(l,k)*sigmah(k)/(sigmah(k)*pd+r8pt)
405: #ifdef MPP1
406:             do j = 1 , jendx
407:               do i = 1 , iym1
408:                 eps = eps1*(psb(i,j)-pd)
409:                 hstor(i,j,l) = hstor(i,j,l) + pdlog + tau(l,k)*tb(i,k,j)&
410:                              & /psb(i,j) + eps
411:               end do
412:             end do
413: #else
414:             do j = 1 , jxm1
415:               do i = 1 , iym1
416:                 eps = eps1*(psb(i,j)-pd)
417:                 hstor(i,j,l) = hstor(i,j,l) + pdlog + tau(l,k)*tb(i,k,j)&
418:                              & /psb(i,j) + eps
419:               end do
420:             end do
421: #endif
422:           end do
423:         end do
424:       end if
425: !
426:       end subroutine spinit
</PRE>

<HR>

</BODY>
</HTML>
