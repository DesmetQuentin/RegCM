<HTML>

<HEAD>
<TITLE>albedoclm.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>albedoclm.F90</H1>
<HR>
<H2 ALIGN=CENTER>albedoclm.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=albedoclm><H3>albedoclm</H3></a></p> Click <a href="./callingtree/albedoclm_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where albedoclm is used.
<hr>
20:       subroutine albedoclm(j,iemiss)
21:  
22:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
23:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a> , only : albvs , albvl  , aldirs , aldirl , ssw1d ,   &
24:                   & aldifs , aldifl , czen , sice1d , emiss1d , coszrs ,&
25:                   & ldoc1d , tgb1d , lveg  , ts1d , scv1d , sag1d , wt , &
26:                   & scvk , veg1d , emiss2d , albvgs , albvgl , kolsol , &
27:                   & depuv , solour, ocld2d , aldirs2d, aldirl2d, aldifs2d, &
28:                   & aldifl2d
29:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : tzero
30:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a>,     only : landfrac
31:       implicit none
32: !
33: ! Dummy arguments
34: !
35:       integer :: iemiss , j
36:       intent (in) iemiss , j
37: !
38: ! Local variables
39: !
40:       real(8) :: age , albg , albgl , albgld , albgs , albgsd , albl ,  &
41:                & albld , albs , albsd , albzn , alwet , cf1 , cff ,     &
42:                & conn , cons , czeta , czf , dfalbl , dfalbs , dralbl , &
43:                & dralbs , fsol1 , fsol2 , sfac , sical0 , sical1 , sl , &
44:                & sl2 , sli , snal0 , snal1 , tdiff , tdiffs , wet , x
45:       real(8) , dimension(nnsg) :: albvl_s , albvs_s , aldifl_s ,       &
46:                                  & aldifs_s , aldirl_s , aldirs_s
47:       real(8) :: fseas
48:       integer :: kolour , n , i, jj
49: !
50: !     Albedo calculates fragmented albedos (direct and diffuse) in
51: !     wavelength regions split at 0.7um.
52: !
53: !     CM hands albedos to radiation package which computes
54: !     fsw1d(i) = net solar absorbed over full grid square
55: !     sabveg(i) = vegetation absorbed (full solar spectrum)
56: !     solis(i) = shortwave  solar incident
57: !
58: !     Here these are calculated at the end of albedo - they use only
59: !     direct albedos for now
60: !
61: !     in both versions :  lftemp uses sabveg
62: !     tgrund uses sabveg & fsw1d(i) to get
63: !     ground absorbed solar
64: !     photosynthesis uses solis - see subrouts
65: !     stomat and co2 (carbon)
66: !
67: !     For sea, sea-ice veg albedos are not set
68: !     these albedos are not treated as arrays here
69: !
70: !     (depuv/10.0)= the ratio of upper soil layer to total
71: !     root depth; used to compute "wet" for soil albedo
72: !
73: !     =================================================================
74: !     1. set initial parameters
75: !     =================================================================
76:       fseas(x) = dmax1(0.D0,1.D0-0.0016D0*dmax1(298.D0-x,0.D0)**2)
77: !
78: !     1.1 constants
79: !
80: !     Solar flux partitioned at wavelength of 0.7micr
81:       fsol1 = 0.5D0
82:       fsol2 = 0.5D0
83: !     Short and long wave albedo for new snow
84:       snal0 = 0.95D0
85:       snal1 = 0.65D0
86: !     Short and long wave albedo for sea ice
87:       sical0 = 0.6D0
88:       sical1 = 0.4D0
89:  
90: !
91: !     In depth, wt is frac of grid square covered by snow;
92: !     depends on average snow depth, vegetation, etc.
93: !
94:       call <a href="./depth.f90.html#depth" TARGET=CENT_PANEL>depth</a>
95:  
96: !     1.2 set pointers
97: !     ***************************************************
98: !     *    set n"x"k params here  in ccm but not needed *
99: !     ***************************************************
100: !
101: !     1.3  set default vegetation and albedo
102: !     do loop 50 in ccm not used here )
103:  
104:       do i = 2 , iym1
105:         czen(i) = dmax1(coszrs(i),0.D0)
106:         czeta = czen(i)
107:         do n = 1 , nnsg
108:           albgs = 0.0D0
109:           albgl = 0.0D0
110:           albgsd = 0.0D0
111:           albgld = 0.0D0
112:           albs = 0.0D0
113:           albl = 0.0D0
114:           albsd = 0.0D0
115:           albld = 0.0D0
116:  
117:           albvs_s(n) = 0.0D0
118:           albvl_s(n) = 0.0D0
119:           ldoc1d(n,i) = ocld2d(n,i,j)
120:  
121: !================================================================
122: !         2.   get albedo over land
123: !================================================================
124: !         can't use pointer "nalbk" here because not set - use nldock
125: !         instead tgb1d(i) used instead of tbelow
126: !
127: #ifdef SEAICE
128:           if ( ldoc1d(n,i).gt.1.5 ) then
129:             tdiffs=ts1d(n,i)-tzero
130:             tdiff=dmax1(tdiffs,0.d0)
131:             tdiffs=dmin1(tdiff,20.d0)
132:             albgl=sical1-1.1e-2*tdiffs
133:             albgs=sical0-2.45e-2*tdiffs
134:             albg=fsol1*albgs+fsol2*albgl
135:             albgsd=albgs
136:             albgld=albgl
137:           else if ( ldoc1d(n,i).gt.0.1D0 .and.                          &
138:            &       sice1d(n,i).eq.0.D0 ) then
139: #else
140:            if ( ldoc1d(n,i).gt.0.1D0 .and. sice1d(n,i).eq.0.D0 ) then
141: #endif
142:             sfac = 1.D0 - fseas(tgb1d(n,i))
143:  
144: !           **********  ccm tests here on land mask for veg and soils
145:  
146:  
147: !c          data *** reduces albedo at low temps !!!!!should respond to
148: !c          moisture too the following card inactivated (commented out)
149: !c          (pat, 27 oct 86)
150:  
151: !           veg1d(i)=vegc(lveg(i))-seasf(lveg(i))*sfac
152:             albs = albvgs(lveg(n,i))
153:             albl = albvgl(lveg(n,i))
154:  
155: !----------------------------------------------------------------------
156:             if ( (lveg(n,i).lt.12) .or. (lveg(n,i).gt.15) ) then
157:  
158: !             2.1  bare soil albedos
159: !             (soil albedo depends on moisture)
160:               kolour = kolsol(lveg(n,i))
161:               wet = ssw1d(n,i)/depuv(lveg(n,i))
162:               alwet = dmax1((11.D0-40.D0*wet),0.D0)*0.01D0
163:               alwet = dmin1(alwet,solour(kolour))
164:               albg = solour(kolour) + alwet
165: !             if((lveg(n,i).eq.8)) albg=0.40      !Laura, cambiato il
166: !             DESERTO
167:               albgs = albg
168:               albgl = 2.D0*albg
169: !             **********            higher nir albedos
170: !             **********              set diffuse albedo
171:               albgld = albgl
172:               albgsd = albgs
173:               albsd = albs
174:               albld = albl
175:  
176: !             Dec. 15   albzn=0.85+1./(1.+10.*czen(i))
177: !             Dec. 12, 2008
178:               albzn = 1.0D0
179: !             Dec. 15, 2008
180:  
181: !             **********            leafless hardwood canopy: no or
182: !             inverse zen dep
183:               if ( lveg(n,i).eq.5 .and. sfac.lt.0.1 ) albzn = 1.
184: !             **********            multiply by zenith angle correction
185:               albs = albs*albzn
186:               albl = albl*albzn
187:  
188: !             **********            albedo over vegetation after zenith
189: !             angle corr
190:               albvs_s(n) = albs
191:               albvl_s(n) = albl
192:  
193:             else if ( lveg(n,i).eq.12 ) then
194:  
195: !             2.2   permanent ice sheet
196:               albgs = 0.8D0
197:               albgsd = 0.8D0
198:               albgl = 0.55D0
199:               albgld = 0.55D0
200:             else
201:  
202: !             2.3  inland water, swamps, rice paddies etc.
203:               albg = 0.05D0/(czeta+0.15D0)
204:               albgs = albg
205:               albgsd = albg
206:               albgl = albg
207:               albgld = albg
208:             end if
209:  
210:           else if ( sice1d(n,i).gt.0.D0 ) then
211: !====================================================================
212: !           3.  get albedo over sea ice
213: !====================================================================
214: !           **********          albedo depends on wave-length and ts.
215: !           the ts **********          dependence accounts for melt
216: !           water puddles.
217:             tdiffs = ts1d(n,i) - tzero
218:             tdiff = dmax1(tdiffs,0.D0)
219:             tdiffs = dmin1(tdiff,20.D0)
220:             albgl = sical1 - 1.1E-2*tdiffs
221:             albgs = sical0 - 2.45E-2*tdiffs
222:             albg = fsol1*albgs + fsol2*albgl
223:             albgsd = albgs
224:             albgld = albgl
225:           else
226:           end if
227: ! ===================================================================
228: !         4.  correct for snow cover
229: ! ===================================================================
230:           if ( scv1d(n,i).gt.0.0D0 ) then
231: !           **********            snow albedo depends on  snow-age,
232: !           zenith angle, **********            and thickness of snow
233:  
234: !           **********            zenith angle set in zenitm
235: !           **********            snow albedoes for visible and ir
236: !           solar rad **********            visible albedo depends on
237: !           snow age **********            age gives reduction of
238: !           visible rad snow albedo **********              due to age
239:             cons = 0.2D0
240:             conn = 0.5D0
241:             age = (1.D0-1.D0/(1.D0+sag1d(n,i)))
242: !           **********            sl helps control albedo zenith
243: !           dependence
244:             sl = 2.0D0
245:             sli = 1.D0/sl
246:             sl2 = 2.D0*sl
247: !           **********            snal0= new snow albedo for vis rad,
248: !           sol zen le 6 **********            snal1= new snow albedo
249: !           for long-wave rad
250:             dfalbs = snal0*(1.D0-cons*age)
251: !           **********            czf corrects albedo of new snow for
252: !           solar zenith
253:             cf1 = ((1.D0+sli)/(1.D0+sl2*czen(i))-sli)
254:             cff = dmax1(cf1,0.D0)
255:             czf = 0.4D0*cff*(1.D0-dfalbs)
256:             dralbs = dfalbs + czf
257:             dfalbl = snal1*(1.D0-conn*age)
258:             czf = 0.4D0*cff*(1.D0-dfalbl)
259:             dralbl = dfalbl + czf
260:  
261:             if ( veg1d(n,i).gt.0.001D0 ) then
262: !             **********            effective albedo over vegetation
263: !             with snow
264:               albl = (1.D0-wt(n,i))*albl + dralbl*wt(n,i)
265:               albld = (1.D0-wt(n,i))*albld + dfalbl*wt(n,i)
266:               albs = (1.D0-wt(n,i))*albs + dralbs*wt(n,i)
267:               albsd = (1.D0-wt(n,i))*albsd + dfalbs*wt(n,i)
268:             end if
269:  
270: !----------------------------------------------------------------------
271: !           4.1  compute albedo for snow on bare ground
272: !----------------------------------------------------------------------
273:             albgs = (1.D0-scvk(n,i))*albgs + dralbs*scvk(n,i)
274:             albgl = (1.D0-scvk(n,i))*albgl + dralbl*scvk(n,i)
275:             albgsd = (1.D0-scvk(n,i))*albgsd + dfalbs*scvk(n,i)
276:             albgld = (1.D0-scvk(n,i))*albgld + dfalbl*scvk(n,i)
277:           end if
278:  
279: !=====================================================================
280: !         5.  albedo over open ocean
281: !=====================================================================
282:           if ( ldoc1d(n,i).eq.0.D0 ) then
283: !           *********   ocean albedo depends on zenith angle
284:             if ( czeta.ge.0.0D0 ) then
285: !             **********   albedo independent of wavelength
286:               albg = 0.05D0/(czeta+0.15D0)
287:               albgs = albg
288:               albgl = albg
289:               albgsd = 0.08D0
290:               albgld = 0.08D0
291:             end if
292:           end if
293:  
294: !
295: !         ***************not part of albedo in the ccm ****************
296: !
297:           aldirs_s(n) = (1.D0-veg1d(n,i))*albgs + veg1d(n,i)*albs
298:           aldirl_s(n) = (1.D0-veg1d(n,i))*albgl + veg1d(n,i)*albl
299:           aldifs_s(n) = (1.D0-veg1d(n,i))*albgsd + veg1d(n,i)*albsd
300:           aldifl_s(n) = (1.D0-veg1d(n,i))*albgld + veg1d(n,i)*albld
301:         end do
302:         albvs(i) = albvs_s(1)
303:         albvl(i) = albvl_s(1)
304:         aldirs(i) = aldirs_s(1)
305:         aldirl(i) = aldirl_s(1)
306:         aldifs(i) = aldifs_s(1)
307:         aldifl(i) = aldifl_s(1)
308:         if ( iemiss.eq.1 ) emiss1d(i) = emiss2d(1,i,j)
309:         do n = 2 , nnsg
310:           albvs(i) = albvs(i) + albvs_s(n)
311:           albvl(i) = albvl(i) + albvl_s(n)
312:           aldirs(i) = aldirs(i) + aldirs_s(n)
313:           aldirl(i) = aldirl(i) + aldirl_s(n)
314:           aldifs(i) = aldifs(i) + aldifs_s(n)
315:           aldifl(i) = aldifl(i) + aldifl_s(n)
316:           if ( iemiss.eq.1 ) emiss1d(i) = emiss1d(i) + emiss2d(n,i,j)
317:         end do
318:         albvs(i) = albvs(i)/dble(nnsg)
319:         albvl(i) = albvl(i)/dble(nnsg)
320:         aldirs(i) = aldirs(i)/dble(nnsg)
321:         aldirl(i) = aldirl(i)/dble(nnsg)
322:         aldifs(i) = aldifs(i)/dble(nnsg)
323:         aldifl(i) = aldifl(i)/dble(nnsg)
324:         if ( iemiss.eq.1 ) emiss1d(i) = emiss1d(i)/dble(nnsg)
325:  
326: !       ******   fsw1d(i),sabveg(i),solis(i) computed in colmod (radcsw)
327: 
328: !       ****** Section Below added for albedo to be corrected by CLM
329: !       ****** calculated albedo.  NOTE: for cosz<=0 CLM assigns albedo
330: !       ****** to be equal to 1 which can cause a FPE.  To avoid this
331: !       ****** use albedo calculated with BATS method when albedo=1
332: #ifdef MPP1
333:         jj = j+(jxp*myid)
334: #else
335:         jj = j
336: #endif
337:         if(ocld2d(1,i,j)>=1 .and. aldirs2d(i,j)/=1.) then
338:            aldirs(i) = aldirs2d(i,j)*landfrac(jj,i) + aldirs(i)*(1-landfrac(jj,i))
339:            aldirl(i) = aldirl2d(i,j)*landfrac(jj,i) + aldirl(i)*(1-landfrac(jj,i))
340:            aldifs(i) = aldifs2d(i,j)*landfrac(jj,i) + aldifs(i)*(1-landfrac(jj,i))
341:            aldifl(i) = aldifl2d(i,j)*landfrac(jj,i) + aldifl(i)*(1-landfrac(jj,i))
342:            albvs(i)  = aldirs2d(i,j)*landfrac(jj,i) + albvs(i) *(1-landfrac(jj,i))
343:            albvl(i)  = aldirl2d(i,j)*landfrac(jj,i) + albvl(i) *(1-landfrac(jj,i)) 
344:         end if
345: 
346: 
347: 
348:  
349:       end do   ! end of i loop
350:   
351:       end subroutine albedoclm
</PRE>

<HR>

</BODY>
</HTML>
