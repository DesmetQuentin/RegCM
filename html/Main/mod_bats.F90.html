<HTML>

<HEAD>
<TITLE>mod_bats.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_bats.F90</H1>
<HR>
<H2 ALIGN=CENTER>mod_bats.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_bats><H3>mod_bats</H3></a></p>20:       module mod_bats
21: 
22:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
23:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : dtbat , dtmin
24:       use <a href="./mod_bats_param.F90.html#mod_bats_param" TARGET=CENT_PANEL>mod_bats_param</a>
25: 
26:       implicit none
27:       real(8) , allocatable , target , dimension(:,:,:) :: spacebs1d
28:       real(8) , allocatable , target , dimension(:,:) :: spaceb1d
29:       private :: spacebs1d , spaceb1d
30: !
31:       real(8) , pointer , dimension(:,:) :: p1d0 , qs1d0 , ts1d0
32: !
33:       real(8) , pointer , dimension(:,:) :: delq1d , delt1d , drag1d ,  &
34:            & emiss_1d , evpr1d , gwet1d , ircp1d , ldew1d , ldoc1d ,    &
35:            & p1d , pbp1d , prcp1d , q2m_1d , qg1d , qs1d , resp1d ,     &
36:            & rhs1d , rno1d , rnos1d , rsw1d , sag1d , scv1d , sent1d ,  &
37:            & sice1d , ssw1d , t2m_1d , taf1d , tg1d , tgb1d , tlef1d ,  &
38:            & ts1d , tsw1d , u10m1d , v10m1d , veg1d , z1d
39: !
40:       real(8) , pointer , dimension(:,:) :: bfc , bsw , evmx0 , fdry ,  &
41:            & fwet , gwmx0 , gwmx1 , gwmx2 , porsl , relfc , rnet ,      &
42:            & texrat , vegt , wiltr , wt , xkmx
43: !
44:       real(8) , pointer , dimension(:,:) :: aarea , cdr , cdrn , cdrx , &
45:            & cf , cgrnd , cgrndl , cgrnds , clead , densi , efpr , eg , &
46:            & etr , etrrun , evaps , evapw , fevpg , flnet , flneto ,    &
47:            & fseng , htvp , ps , pw , qice , qsatl , rhosw , ribd ,     &
48:            & rlai , rpp , scrat , scvk , sdrop , seasb , sigf , sm ,    &
49:            & tm , uaf , vspda , wata , watr , watt , watu , wta , xlai ,&
50:            & xlsai , xrun , z1 , z1log
51: !
52:       real(8) , pointer , dimension(:,:) :: cn1 , rgr , wta0 , wtaq0 ,  &
53:            & wtg , wtg0 , wtg2 , wtga , wtgaq , wtgl , wtglq , wtgq ,   &
54:            & wtgq0 , wtl0 , wtlh , wtlq , wtlq0 , wtshi , wtsqi , df
55: !
56:       integer , allocatable , dimension(:,:) :: imelt , lveg
57: !
58:       real(8) :: difrat
59: !
60:       integer :: ilat , ihis , mhis , ncase
61: !
62:       real(8) , pointer , dimension(:) :: flw1d , fsw1d , us1d , vs1d
63:       real(8) , pointer , dimension(:) :: czen , sola , vpdd
64:       real(8) , pointer , dimension(:) :: ems
65:       real(8) , pointer , dimension(:) :: albdif , albdir , albvl ,     &
66:                                & albvs , albvsd , aldifl , aldifs ,     &
67:                                & aldirl , aldirs , emiss1d , fracd ,    &
68:                                & sabveg , solis , solvd , solvs , albvld
69: !
70:       real(8) , allocatable , dimension(:) :: coszrs
71: !
72:       real(8) , allocatable, dimension(:,:) :: flw2d , flwa2d , flwd2d ,&
73:                                     & flwda2d , fsw2d , fswa2d , pptc , &
74:                                     & pptnc , prca2d , prnca2d ,        &
75:                                     & sabv2d , sdelqk2d , sdeltk2d ,    &
76:                                     & sfracb2d , sfracs2d , sfracv2d ,  &
77:                                     & sina2d , sinc2d , sol2d ,         &
78:                                     & solvd2d , solvs2d , ssw2da ,      &
79:                                     & svegfrac2d , svga2d , veg2d
80: !
81:       real(8) , allocatable, dimension(:,:,:) :: col2d , dew2d ,        &
82:            & emiss2d , evpa2d , gwet2d , ircp2d , ocld2d , rno2d ,      &
83:            & rnos2d , sag2d , scv2d , sena2d , sice2d , srw2d , ssw2d , &
84:            & swt2d , taf2d , text2d , tg2d , tgb2d , tlef2d , veg2d1
85:       real(8) ,allocatable, dimension(:,:,:) :: ht1 , satbrt1
86: !
87:       real(4) , pointer , dimension(:,:) :: drag_o , evpa_o , flwa_o ,  &
88:                                      & flwd_o , fswa_o , prcv_o ,       &
89:                                      & psmn_o , ps_o , q2m_o , rnos_o , &
90:                                      & rsw_o , scv_o , sena_o , sina_o ,&
91:                                      & ssw_o , t2mn_o , t2mx_o , t2m_o ,&
92:                                      & tgmn_o , tgmx_o , tg_o , tlef_o ,&
93:                                      & tpr_o , u10m_o , v10m_o ,        &
94:                                      & w10x_o , zpbl_o
95: !
96:       real(4) , pointer , dimension(:,:,:) :: drag_s , evpa_s , prcv_s ,&
97:            & ps_s , q2m_s , rnos_s , rsw_s , scv_s , sena_s , ssw_s ,   &
98:            & t2m_s , tg_s , tlef_s , tpr_s , u10m_s , v10m_s
99: !
100:       real(4) , target , allocatable, dimension(:,:,:) :: fbat
101:       real(4) , target ,allocatable, dimension(:,:,:,:) :: fsub
102: !
103: #ifdef MPP1
104: #ifdef CLM
105:       real(8) , allocatable , target , dimension(:,:,:) :: spaceclm
106:       private :: spaceclm
107:       ! Direct solar rad incident on surface (<0.7)
108:       real(8) , pointer , dimension(:,:) :: sols2d
109:       ! Direct solar rad incident on surface (>=0.7)
110:       real(8) , pointer , dimension(:,:) :: soll2d
111:       ! Diffuse solar rad incident on surface (<0.7)
112:       real(8) , pointer , dimension(:,:) :: solsd2d
113:       ! Diffuse solar rad incident on surface (>=0.7)
114:       real(8) , pointer , dimension(:,:) :: solld2d
115:       real(8) , pointer , dimension(:,:) :: aldirs2d
116:       real(8) , pointer , dimension(:,:) :: aldirl2d
117:       real(8) , pointer , dimension(:,:) :: aldifs2d
118:       real(8) , pointer , dimension(:,:) :: aldifl2d
119:       real(8) , pointer , dimension(:,:) :: coszrs2d
120:       real(8) , pointer , dimension(:,:) :: rs2d
121:       real(8) , pointer , dimension(:,:) :: ra2d
122:       ! 2 meter specific humidity
123:       real(8) , pointer , dimension(:,:) :: q2d
124: #endif
125: #endif
126: 
127: #ifdef DCSST
128:       ! dtskin is difference between skin tem and bulk sst
129:       real(8) , allocatable , dimension(:,:) :: deltas , tdeltas ,      &
130:                            &                    dtskin
131:       logical , allocatable , dimension(:,:) :: firstcall
132: #endif
133: 
134:       contains
135: 
<p><a name=allocate_mod_bats><H3>allocate_mod_bats</H3></a></p> Click <a href="./callingtree/allocate_mod_bats_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where allocate_mod_bats is used.
<hr>
136:        subroutine allocate_mod_bats 
137:        implicit none
138: #ifdef MPP1
139:         allocate(flw2d(iym1,jxp)) 
140:         allocate(flwa2d(iym1,jxp))
141:         allocate(flwd2d(iym1,jxp))
142:         allocate(flwda2d(iym1,jxp))
143:         allocate(fsw2d(iym1,jxp))
144:         allocate(fswa2d(iym1,jxp))
145:         allocate(pptc(iym1,jxp))  
146:         allocate(pptnc(iym1,jxp))
147:         allocate(prca2d(iym1,jxp))
148:         allocate(prnca2d(iym1,jxp))
149:         allocate(sabv2d(iym1,jxp))
150:         allocate(sdelqk2d(iym1,jxp))
151:         allocate(sdeltk2d(iym1,jxp))
152:         allocate(sfracb2d (iym1,jxp))
153:         allocate(sfracs2d(iym1,jxp))
154:         allocate(sfracv2d(iym1,jxp))
155:         allocate(sina2d(iym1,jxp))
156:         allocate(sinc2d(iym1,jxp))
157:         allocate(sol2d(iym1,jxp))
158:         allocate(solvd2d(iym1,jxp))
159:         allocate(solvs2d(iym1,jxp))
160:         allocate(ssw2da(iym1,jxp))
161:         allocate(svegfrac2d(iym1,jxp))
162:         allocate(svga2d(iym1,jxp))
163:         allocate(veg2d(iym1,jxp))
164:         allocate(col2d(nnsg,iym1,jxp))
165:         allocate(dew2d(nnsg,iym1,jxp))
166:         allocate(emiss2d(nnsg,iym1,jxp))
167:         allocate(evpa2d(nnsg,iym1,jxp))
168:         allocate(gwet2d(nnsg,iym1,jxp))
169:         allocate(ircp2d(nnsg,iym1,jxp))
170:         allocate(ocld2d(nnsg,iym1,jxp))
171:         allocate(rno2d(nnsg,iym1,jxp))
172:         allocate(rnos2d(nnsg,iym1,jxp))
173:         allocate(sag2d(nnsg,iym1,jxp))
174:         allocate(scv2d(nnsg,iym1,jxp))
175:         allocate(sena2d(nnsg,iym1,jxp))
176:         allocate(sice2d(nnsg,iym1,jxp))
177:         allocate(srw2d(nnsg,iym1,jxp))
178:         allocate(ssw2d(nnsg,iym1,jxp))
179:         allocate(swt2d(nnsg,iym1,jxp))
180:         allocate(taf2d(nnsg,iym1,jxp))
181:         allocate(text2d(nnsg,iym1,jxp))
182:         allocate(tg2d(nnsg,iym1,jxp))
183:         allocate(tgb2d(nnsg,iym1,jxp))
184:         allocate(tlef2d(nnsg,iym1,jxp))
185:         allocate(veg2d1(nnsg,iym1,jxp))
186:         allocate(ht1(nnsg,iy,jxp))
187:         allocate(satbrt1(nnsg,iy,jxp))
188:         allocate(fbat(jxp,iym2,numbat))
189:         allocate(fsub(nnsg,jxp,iym2,numsub))
190: #ifdef CLM
191:         allocate(spaceclm(iym1,jxp,12))
192:         sols2d   => spaceclm(:,:,1)
193:         soll2d   => spaceclm(:,:,2)
194:         solsd2d  => spaceclm(:,:,3)
195:         solld2d  => spaceclm(:,:,4)
196:         aldirs2d => spaceclm(:,:,5)
197:         aldirl2d => spaceclm(:,:,6)
198:         aldifs2d => spaceclm(:,:,7)
199:         aldifl2d => spaceclm(:,:,8)
200:         coszrs2d => spaceclm(:,:,9)
201:         rs2d     => spaceclm(:,:,10)
202:         ra2d     => spaceclm(:,:,11)
203:         q2d      => spaceclm(:,:,12)
204: #endif
205: #ifdef DCSST
206:         allocate(deltas(iy,jxp))
207:         allocate(tdeltas(iy,jxp))
208:         allocate(dtskin(iy,jxp))
209:         allocate(firstcall(iy,jxp))
210: #endif
211: #else
212:         allocate(flw2d(iym1,jxm1)) 
213:         allocate(flwa2d(iym1,jxm1))
214:         allocate(flwd2d(iym1,jxm1))
215:         allocate(flwda2d(iym1,jxm1))
216:         allocate(fsw2d(iym1,jxm1))
217:         allocate(fswa2d(iym1,jxm1))
218:         allocate(pptc(iym1,jxm1))  
219:         allocate(pptnc(iym1,jxm1))
220:         allocate(prca2d(iym1,jxm1))
221:         allocate(prnca2d(iym1,jxm1))
222:         allocate(sabv2d(iym1,jxm1))
223:         allocate(sdelqk2d(iym1,jxm1))
224:         allocate(sdeltk2d(iym1,jxm1))
225:         allocate(sfracb2d (iym1,jxm1))
226:         allocate(sfracs2d(iym1,jxm1))
227:         allocate(sfracv2d(iym1,jxm1))
228:         allocate(sina2d(iym1,jxm1))
229:         allocate(sinc2d(iym1,jxm1))
230:         allocate(sol2d(iym1,jxm1))
231:         allocate(solvd2d(iym1,jxm1))
232:         allocate(solvs2d(iym1,jxm1))
233:         allocate(ssw2da(iym1,jxm1))
234:         allocate(svegfrac2d(iym1,jxm1))
235:         allocate(svga2d(iym1,jxm1))
236:         allocate(veg2d(iym1,jxm1))
237:         allocate(col2d(nnsg,iym1,jxm1))
238:         allocate(dew2d(nnsg,iym1,jxm1))
239:         allocate(emiss2d(nnsg,iym1,jxm1))
240:         allocate(evpa2d(nnsg,iym1,jxm1))
241:         allocate(gwet2d(nnsg,iym1,jxm1))
242:         allocate(ircp2d(nnsg,iym1,jxm1))
243:         allocate(ocld2d(nnsg,iym1,jxm1))
244:         allocate(rno2d(nnsg,iym1,jxm1))
245:         allocate(rnos2d(nnsg,iym1,jxm1))
246:         allocate(sag2d(nnsg,iym1,jxm1))
247:         allocate(scv2d(nnsg,iym1,jxm1))
248:         allocate(sena2d(nnsg,iym1,jxm1))
249:         allocate(sice2d(nnsg,iym1,jxm1))
250:         allocate(srw2d(nnsg,iym1,jxm1))
251:         allocate(ssw2d(nnsg,iym1,jxm1))
252:         allocate(swt2d(nnsg,iym1,jxm1))
253:         allocate(taf2d(nnsg,iym1,jxm1))
254:         allocate(text2d(nnsg,iym1,jxm1))
255:         allocate(tg2d(nnsg,iym1,jxm1))
256:         allocate(tgb2d(nnsg,iym1,jxm1))
257:         allocate(tlef2d(nnsg,iym1,jxm1))
258:         allocate(veg2d1(nnsg,iym1,jxm1))
259:         allocate(ht1(nnsg,iy,jx))
260:         allocate(satbrt1(nnsg,iy,jx))
261:         allocate(fbat(jxm2,iym2,numbat))
262:         allocate(fsub(nnsg,jxm2,iym2,numsub))
263: #ifdef DCSST
264:         allocate(deltas(iy,jx))
265:         allocate(tdeltas(iy,jx))
266:         allocate(dtskin(iy,jx))
267:         allocate(firstcall(iy,jx))
268: #endif
269: #endif
270:         allocate(spacebs1d(nnsg,iym1,123))
271:         p1d0     => spacebs1d(:,:,1)
272:         qs1d0    => spacebs1d(:,:,2)
273:         ts1d0    => spacebs1d(:,:,3)
274:         delq1d   => spacebs1d(:,:,4)
275:         delt1d   => spacebs1d(:,:,5)
276:         drag1d   => spacebs1d(:,:,6)
277:         emiss_1d => spacebs1d(:,:,7)
278:         evpr1d   => spacebs1d(:,:,8)
279:         gwet1d   => spacebs1d(:,:,9)
280:         ircp1d   => spacebs1d(:,:,10)
281:         ldew1d   => spacebs1d(:,:,11)
282:         ldoc1d   => spacebs1d(:,:,12)
283:         p1d      => spacebs1d(:,:,13)
284:         pbp1d    => spacebs1d(:,:,14)
285:         prcp1d   => spacebs1d(:,:,15)
286:         q2m_1d   => spacebs1d(:,:,16)
287:         qg1d     => spacebs1d(:,:,17)
288:         qs1d     => spacebs1d(:,:,18)
289:         resp1d   => spacebs1d(:,:,19)
290:         rhs1d    => spacebs1d(:,:,20)
291:         rno1d    => spacebs1d(:,:,21)
292:         rnos1d   => spacebs1d(:,:,22)
293:         rsw1d    => spacebs1d(:,:,23)
294:         sag1d    => spacebs1d(:,:,24)
295:         scv1d    => spacebs1d(:,:,25)
296:         sent1d   => spacebs1d(:,:,26)
297:         sice1d   => spacebs1d(:,:,27)
298:         ssw1d    => spacebs1d(:,:,28)
299:         t2m_1d   => spacebs1d(:,:,29)
300:         taf1d    => spacebs1d(:,:,30)
301:         tg1d     => spacebs1d(:,:,31)
302:         tgb1d    => spacebs1d(:,:,32)
303:         tlef1d   => spacebs1d(:,:,33)
304:         ts1d     => spacebs1d(:,:,34)
305:         tsw1d    => spacebs1d(:,:,35)
306:         u10m1d   => spacebs1d(:,:,36)
307:         v10m1d   => spacebs1d(:,:,37)
308:         veg1d    => spacebs1d(:,:,38)
309:         z1d      => spacebs1d(:,:,39)
310:         bfc      => spacebs1d(:,:,40)
311:         bsw      => spacebs1d(:,:,41)
312:         evmx0    => spacebs1d(:,:,42)
313:         fdry     => spacebs1d(:,:,43)
314:         fwet     => spacebs1d(:,:,44)
315:         gwmx0    => spacebs1d(:,:,45)
316:         gwmx1    => spacebs1d(:,:,46)
317:         gwmx2    => spacebs1d(:,:,47)
318:         porsl    => spacebs1d(:,:,48)
319:         relfc    => spacebs1d(:,:,49)
320:         rnet     => spacebs1d(:,:,50)
321:         texrat   => spacebs1d(:,:,51)
322:         vegt     => spacebs1d(:,:,52)
323:         wiltr    => spacebs1d(:,:,53)
324:         wt       => spacebs1d(:,:,54)
325:         xkmx     => spacebs1d(:,:,55)
326:         aarea    => spacebs1d(:,:,56)
327:         cdr      => spacebs1d(:,:,57)
328:         cdrn     => spacebs1d(:,:,58)
329:         cdrx     => spacebs1d(:,:,59)
330:         cf       => spacebs1d(:,:,60)
331:         cgrnd    => spacebs1d(:,:,61)
332:         cgrndl   => spacebs1d(:,:,62)
333:         cgrnds   => spacebs1d(:,:,63)
334:         clead    => spacebs1d(:,:,64)
335:         densi    => spacebs1d(:,:,65)
336:         efpr     => spacebs1d(:,:,66)
337:         eg       => spacebs1d(:,:,67)
338:         etr      => spacebs1d(:,:,68)
339:         etrrun   => spacebs1d(:,:,69)
340:         evaps    => spacebs1d(:,:,70)
341:         evapw    => spacebs1d(:,:,71)
342:         fevpg    => spacebs1d(:,:,72)
343:         flnet    => spacebs1d(:,:,73)
344:         flneto   => spacebs1d(:,:,74)
345:         fseng    => spacebs1d(:,:,75)
346:         htvp     => spacebs1d(:,:,76)
347:         ps       => spacebs1d(:,:,77)
348:         pw       => spacebs1d(:,:,78)
349:         qice     => spacebs1d(:,:,79)
350:         qsatl    => spacebs1d(:,:,80)
351:         rhosw    => spacebs1d(:,:,81)
352:         ribd     => spacebs1d(:,:,82)
353:         rlai     => spacebs1d(:,:,83)
354:         rpp      => spacebs1d(:,:,84)
355:         scrat    => spacebs1d(:,:,85)
356:         scvk     => spacebs1d(:,:,86)
357:         sdrop    => spacebs1d(:,:,87)
358:         seasb    => spacebs1d(:,:,88)
359:         sigf     => spacebs1d(:,:,89)
360:         sm       => spacebs1d(:,:,90)
361:         tm       => spacebs1d(:,:,91)
362:         uaf      => spacebs1d(:,:,92)
363:         vspda    => spacebs1d(:,:,93)
364:         wata     => spacebs1d(:,:,94)
365:         watr     => spacebs1d(:,:,95)
366:         watt     => spacebs1d(:,:,96)
367:         watu     => spacebs1d(:,:,97)
368:         wta      => spacebs1d(:,:,98)
369:         xlai     => spacebs1d(:,:,99)
370:         xlsai    => spacebs1d(:,:,100)
371:         xrun     => spacebs1d(:,:,101)
372:         z1       => spacebs1d(:,:,102)
373:         z1log    => spacebs1d(:,:,103)
374:         cn1      => spacebs1d(:,:,104)
375:         df       => spacebs1d(:,:,105)
376:         rgr      => spacebs1d(:,:,106)
377:         wta0     => spacebs1d(:,:,107)
378:         wtaq0    => spacebs1d(:,:,108)
379:         wtg      => spacebs1d(:,:,109)
380:         wtg0     => spacebs1d(:,:,110)
381:         wtg2     => spacebs1d(:,:,111)
382:         wtga     => spacebs1d(:,:,112)
383:         wtgaq    => spacebs1d(:,:,113)
384:         wtgl     => spacebs1d(:,:,114)
385:         wtglq    => spacebs1d(:,:,115)
386:         wtgq     => spacebs1d(:,:,116)
387:         wtgq0    => spacebs1d(:,:,117)
388:         wtl0     => spacebs1d(:,:,118)
389:         wtlh     => spacebs1d(:,:,119)
390:         wtlq     => spacebs1d(:,:,120)
391:         wtlq0    => spacebs1d(:,:,121)
392:         wtshi    => spacebs1d(:,:,122)
393:         wtsqi    => spacebs1d(:,:,123)
394:         allocate(imelt(nnsg,iym1))
395:         allocate(lveg(nnsg,iym1))
396:         allocate(spaceb1d(iym1,24))
397:         flw1d   => spaceb1d(:,1)
398:         fsw1d   => spaceb1d(:,2)
399:         us1d    => spaceb1d(:,3)
400:         vs1d    => spaceb1d(:,4)
401:         czen    => spaceb1d(:,5)
402:         sola    => spaceb1d(:,6)
403:         vpdd    => spaceb1d(:,7)
404:         ems     => spaceb1d(:,8)
405:         albdif  => spaceb1d(:,9)
406:         albdir  => spaceb1d(:,10)
407:         albvl   => spaceb1d(:,11)
408:         albvld  => spaceb1d(:,12)
409:         albvs   => spaceb1d(:,13)
410:         albvsd  => spaceb1d(:,14)
411:         aldifl  => spaceb1d(:,15)
412:         aldifs  => spaceb1d(:,16)
413:         aldirl  => spaceb1d(:,17)
414:         aldirs  => spaceb1d(:,18)
415:         emiss1d => spaceb1d(:,19)
416:         fracd   => spaceb1d(:,20)
417:         sabveg  => spaceb1d(:,21)
418:         solis   => spaceb1d(:,22)
419:         solvd   => spaceb1d(:,23)
420:         solvs   => spaceb1d(:,24)
421:         allocate(coszrs(iy))
422:         u10m_o => fbat(:,:,1)
423:         v10m_o => fbat(:,:,2)
424:         drag_o => fbat(:,:,3)
425:         tg_o   => fbat(:,:,4)
426:         tlef_o => fbat(:,:,5)
427:         t2m_o  => fbat(:,:,6)
428:         q2m_o  => fbat(:,:,7)
429:         ssw_o  => fbat(:,:,8)
430:         rsw_o  => fbat(:,:,9)
431:         tpr_o  => fbat(:,:,10)
432:         evpa_o => fbat(:,:,11)
433:         rnos_o => fbat(:,:,12)
434:         scv_o  => fbat(:,:,13)
435:         sena_o => fbat(:,:,14)
436:         flwa_o => fbat(:,:,15)
437:         fswa_o => fbat(:,:,16)
438:         flwd_o => fbat(:,:,17)
439:         sina_o => fbat(:,:,18)
440:         prcv_o => fbat(:,:,19)
441:         ps_o   => fbat(:,:,20)
442:         zpbl_o => fbat(:,:,21)
443:         tgmx_o => fbat(:,:,22)
444:         tgmn_o => fbat(:,:,23)
445:         t2mx_o => fbat(:,:,24)
446:         t2mn_o => fbat(:,:,25)
447:         w10x_o => fbat(:,:,26)
448:         psmn_o => fbat(:,:,27)
449:         u10m_s => fsub(:,:,:,1)
450:         v10m_s => fsub(:,:,:,2)
451:         drag_s => fsub(:,:,:,3)
452:         tg_s   => fsub(:,:,:,4)
453:         tlef_s => fsub(:,:,:,5)
454:         t2m_s  => fsub(:,:,:,6)
455:         q2m_s  => fsub(:,:,:,7)
456:         ssw_s  => fsub(:,:,:,8)
457:         rsw_s  => fsub(:,:,:,9)
458:         tpr_s  => fsub(:,:,:,10)
459:         evpa_s => fsub(:,:,:,11)
460:         rnos_s => fsub(:,:,:,12)
461:         scv_s  => fsub(:,:,:,13)
462:         sena_s => fsub(:,:,:,14)
463:         prcv_s => fsub(:,:,:,15)
464:         ps_s   => fsub(:,:,:,16)
465: #ifdef DCSST
466:         firstcall(:,:) = .false.
467: #endif
468: !
469:        end subroutine allocate_mod_bats 
470: !
471: !
472: !
<p><a name=interf><H3>interf</H3></a></p> Click <a href="./callingtree/interf_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where interf is used.
<hr>
473:       subroutine interf(ivers,j,k,istart,iend,ng)
474: 
475: ! ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
476: !
477: !  this subroutine interfaces mm42d and bats variables
478: !
479: !  ivers = 1 ,   regcm2d --> bats
480: !  ivers = 2 ,   bats --> regcm2d
481: !
482:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a> , only : iocnflx , kbats
483:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : r8pt
484:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a> , only : psb , hfx , qfx , ht , zpbl , uvdrag ,      &
485:                   &         snowc , tgbb , tga , tgb
486:       use <a href="./mod_pbldim.F90.html#mod_pbldim" TARGET=CENT_PANEL>mod_pbldim</a> , only : thx3d , za
487:       use <a href="./mod_slice.F90.html#mod_slice" TARGET=CENT_PANEL>mod_slice</a> , only : ubx3d , vbx3d , qvb3d
488:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : tau1 , zlnd , zoce , zsno , rgti ,     &
489:                   &              rgas , tzero , lh0 , lh1 , lsvp1 ,     &
490:                   &              lsvp2 , ep2 , lrate
491:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : jyear , jyear0 , jyearr , ntime , ktau ,    &
492:                   &         ktaur
493:       implicit none
494: !
495: ! Dummy arguments
496: !
497:       integer , intent (in) :: ivers , j , k , istart , iend , ng
498: !
499: ! Local variables
500: !
501:       real(8) :: amxtem , facb , facs , fact , factuv , facv , fracb ,  &
502:                & fracs , fracv , hl , mmpd , rh0 , satvp , sfac ,       &
503:                & solvt , wpm2
504:       integer :: i , n , nnn
505:       real(4) :: real_4
506: !
507: !     ******    fbat contains nummap+1 fields to be written out to
508: !     iutbat ******    fields are written out in following order:
509: !     1.  anemon west  wind (41)
510: !     2.  anemom south wind (42)
511: !     3.  drag- surface stress, in si (48)
512: !     4.  ground temp (4)
513: !     5.  temp of foliage (7)
514: !     6.  anemom temp (5)
515: !     7.  anemom spec. humidity (15)
516: !     8.  upper layer soil water (26)
517: !     9.  root zone soil water (25)
518: !     10.  accum precip (19)
519: !     11.  accum evap (39)
520: !     12.  accum surf runoff (12)
521: !     13.  snow depth in mm h2o (30)
522: !     14.  accum sensible heat (40)
523: !     15.  accum net ir (38)
524: !     16.  accum net solar abs (37)
525: !     17.  accum downward ir
526: !     18.  accum solar incident at surface
527: !     19.  convective precipitation
528: !     20.  surface pressure
529: !     21.  pbl height
530:  
531:       if ( ivers.eq.1 ) then ! regcm2d --> bats
532: 
533:         do i = istart, iend
534:           do n = 1 , ng
535:             p1d0(n,i) = (psb(i,j)+r8pt)*1000.
536:             z1d(n,i) = za(i,k,j)
537:             ts1d0(n,i) = thx3d(i,k,j)
538:             qs1d0(n,i) = qvb3d(i,k,j)/(1.+qvb3d(i,k,j))
539:             qs1d(n,i) = qs1d0(n,i)
540:  
541:             hl = lh0 - lh1*(ts1d0(n,i)-tzero)
542:             satvp = lsvp1*dexp(lsvp2*hl*(1./tzero-1./ts1d0(n,i)))
543:             rh0 = dmax1(qs1d0(n,i)/(ep2*satvp/(p1d0(n,i)*0.01-satvp)), &
544:                 & 0.D0)
545:  
546:             ts1d(n,i) = ts1d0(n,i) - lrate*rgti*(ht1(n,i,j)-ht(i,j))
547:             p1d(n,i) = p1d0(n,i)*(ts1d(n,i)/ts1d0(n,i))
548:  
549:             hl = lh0 - lh1*(ts1d(n,i)-tzero)
550:             satvp = lsvp1*dexp(lsvp2*hl*(1./tzero-1./ts1d(n,i)))
551:             qs1d(n,i) = dmax1(rh0*ep2*satvp/(p1d(n,i)*0.01-satvp),0.D0)
552:  
553:             tg1d(n,i) = tg2d(n,i,j)
554:             rhs1d(n,i) = p1d(n,i)/(rgas*ts1d(n,i))
555:             prcp1d(n,i) = pptnc(i,j) + pptc(i,j)
556: !
557: !           quantities stored on 2d surface array for bats use only
558: !
559:             tgb1d(n,i) = tgb2d(n,i,j)
560:             taf1d(n,i) = taf2d(n,i,j)
561:             tlef1d(n,i) = tlef2d(n,i,j)
562:             tsw1d(n,i) = swt2d(n,i,j)
563:             rsw1d(n,i) = srw2d(n,i,j)
564:             ssw1d(n,i) = ssw2d(n,i,j)
565:             ldew1d(n,i) = dew2d(n,i,j)
566:             sag1d(n,i) = sag2d(n,i,j)
567:             scv1d(n,i) = scv2d(n,i,j)
568:             sice1d(n,i) = sice2d(n,i,j)
569:             gwet1d(n,i) = gwet2d(n,i,j)
570:             sent1d(n,i) = hfx(i,j)
571:             evpr1d(n,i) = qfx(i,j)
572:             ldoc1d(n,i) = ocld2d(n,i,j)
573:             ircp1d(n,i) = ircp2d(n,i,j)
574:             lveg(n,i) = nint(veg2d1(n,i,j))
575:             amxtem = dmax1(298.-tgb1d(n,i),0.D0)
576:             sfac = 1. - dmax1(0.D0,1.-0.0016*amxtem**2)
577:             if ( lveg(n,i).eq.0 ) then
578:               veg1d(n,i) = 0.
579:             else
580:               veg1d(n,i) = vegc(lveg(n,i)) - seasf(lveg(n,i))*sfac
581:             end if
582:             emiss_1d(n,i) = emiss2d(n,i,j)
583:           end do
584:  
585:           rh0 = 0.0D0
586:           do n = 1 , ng
587:             rh0 = rh0 + (qs1d(n,i)-qs1d0(n,i))
588:           end do
589:           rh0 = rh0/ng
590:           do n = 1 , ng
591:             qs1d(n,i) = dmax1(qs1d(n,i)-rh0,0.0D0)
592:           end do
593:  
594:           us1d(i) = ubx3d(i,k,j)
595:           vs1d(i) = vbx3d(i,k,j)
596:           fsw1d(i) = fsw2d(i,j)
597:           flw1d(i) = flw2d(i,j)
598:           solis(i) = sol2d(i,j)
599:           sabveg(i) = sabv2d(i,j)
600:           solvt = solvd2d(i,j) + solvs2d(i,j)
601:           if ( solvt.gt.0.0 ) then
602:             fracd(i) = solvd2d(i,j)/solvt
603:           else
604:             fracd(i) = 0.2
605:           end if
606:           czen(i) = dmax1(coszrs(i),0.D0)
607:         end do
608:  
609:       else if ( ivers.eq.2 ) then ! bats --> regcm2d
610:  
611:         do i = istart, iend
612:           uvdrag(i,j) = 0.0
613:           hfx(i,j) = 0.0
614:           qfx(i,j) = 0.0
615:           tgb(i,j) = 0.0
616:           tga(i,j) = 0.0
617:           tgbb(i,j) = 0.0
618: !chem2
619:           ssw2da(i,j) = 0.0
620:           sdeltk2d(i,j) = 0.0
621:           sdelqk2d(i,j) = 0.0
622:           sfracv2d(i,j) = 0.0
623:           sfracb2d(i,j) = 0.0
624:           sfracs2d(i,j) = 0.0
625:           svegfrac2d(i,j) = 0.0
626: !chem2_
627:           do n = 1 , ng
628:             uvdrag(i,j) = uvdrag(i,j) + drag1d(n,i)
629:             hfx(i,j) = hfx(i,j) + sent1d(n,i)
630:             qfx(i,j) = qfx(i,j) + evpr1d(n,i)
631:             tgb(i,j) = tgb(i,j) + tg1d(n,i)
632:             tga(i,j) = tga(i,j) + tg1d(n,i)
633: !chem2
634:             ssw2da(i,j) = ssw2da(i,j) + ssw1d(n,i)
635:             sdeltk2d(i,j) = sdeltk2d(i,j) + delt1d(n,i)
636:             sdelqk2d(i,j) = sdelqk2d(i,j) + delq1d(n,i)
637:             sfracv2d(i,j) = sfracv2d(i,j) + sigf(n,i)
638:             sfracb2d(i,j) = sfracb2d(i,j) + (1.-veg1d(n,i))             &
639:                           & *(1.-scvk(n,i))
640:             sfracs2d(i,j) = sfracs2d(i,j) + veg1d(n,i)*wt(n,i)          &
641:                           & + (1.-veg1d(n,i))*scvk(n,i)
642:             svegfrac2d(i,j) = svegfrac2d(i,j) + veg1d(n,i)
643: !chem2_
644:             if ( iocnflx.eq.1 .or.                                      &
645:                & (iocnflx.eq.2 .and. ocld2d(n,i,j).ge.0.5) ) then
646:               tgbb(i,j) = tgbb(i,j)                                     &
647:                         & + ((1.-veg1d(n,i))*tg1d(n,i)**4+veg1d(n,i)    &
648:                         & *tlef1d(n,i)**4)**0.25
649:             else
650:               tgbb(i,j) = tgbb(i,j) + tg1d(n,i)
651:             end if
652:             if ( ocld2d(n,i,j).lt.0.5 ) then
653:               ssw1d(n,i) = -1.E34
654:               rsw1d(n,i) = -1.E34
655:               tsw1d(n,i) = -1.E34
656:               rno1d(n,i) = -1.E34
657:               rnos1d(n,i) = -1.E34
658:               scv1d(n,i) = -1.E34
659:             end if
660:           end do
661:           uvdrag(i,j) = uvdrag(i,j)/float(ng)
662:           hfx(i,j) = hfx(i,j)/float(ng)
663:           qfx(i,j) = qfx(i,j)/float(ng)
664:           tgb(i,j) = tgb(i,j)/float(ng)
665:           tga(i,j) = tga(i,j)/float(ng)
666:           tgbb(i,j) = tgbb(i,j)/float(ng)
667: !chem2
668:           ssw2da(i,j) = ssw2da(i,j)/float(ng)
669:           sdeltk2d(i,j) = sdeltk2d(i,j)/float(ng)
670:           sdelqk2d(i,j) = sdelqk2d(i,j)/float(ng)
671:           sfracv2d(i,j) = sfracv2d(i,j)/float(ng)
672:           sfracb2d(i,j) = sfracb2d(i,j)/float(ng)
673:           sfracs2d(i,j) = sfracs2d(i,j)/float(ng)
674:           svegfrac2d(i,j) = svegfrac2d(i,j)/float(ng)
675: !chem2_
676:           do n = 1 , ng
677:             snowc(n,i,j) = scv1d(n,i)
678:             tg2d(n,i,j) = tg1d(n,i)
679:             tgb2d(n,i,j) = tgb1d(n,i)
680:             taf2d(n,i,j) = taf1d(n,i)
681:             tlef2d(n,i,j) = tlef1d(n,i)
682:             swt2d(n,i,j) = tsw1d(n,i)
683:             srw2d(n,i,j) = rsw1d(n,i)
684:             ssw2d(n,i,j) = ssw1d(n,i)
685:             dew2d(n,i,j) = ldew1d(n,i)
686:             sag2d(n,i,j) = sag1d(n,i)
687:             scv2d(n,i,j) = scv1d(n,i)
688:             sice2d(n,i,j) = sice1d(n,i)
689:             gwet2d(n,i,j) = gwet1d(n,i)
690:             ocld2d(n,i,j) = ldoc1d(n,i)
691:             ircp2d(n,i,j) = ircp1d(n,i)
692:             evpa2d(n,i,j) = evpa2d(n,i,j) + dtbat*evpr1d(n,i)
693:             sena2d(n,i,j) = sena2d(n,i,j) + dtbat*sent1d(n,i)
694:             if ( rnos2d(n,i,j).gt.-1.E10 .and. rnos1d(n,i).gt.-1.E10 )  &
695:                & then
696:               rnos2d(n,i,j) = rnos2d(n,i,j) + rnos1d(n,i)/tau1*dtbat
697:             else
698:               rnos2d(n,i,j) = -1.E34
699:             end if
700:             if ( rno2d(n,i,j).gt.-1.E10 .and. rnos1d(n,i)               &
701:                & .gt.-1.E10 .and. rno1d(n,i).gt.-1.E10 ) then
702:               rno2d(n,i,j) = rno2d(n,i,j) + (rno1d(n,i)-rnos1d(n,i))    &
703:                            & /tau1*dtbat
704:             else
705:               rno2d(n,i,j) = -1.E34
706:             end if
707:           end do
708: !
709: !         quantities stored on 2d surface array for bats use only
710: !
711:           prca2d(i,j) = prca2d(i,j) + dtbat*pptc(i,j)
712:           prnca2d(i,j) = prnca2d(i,j) + dtbat*pptnc(i,j)
713:           if ( prnca2d(i,j) < 1E-30 ) prnca2d(i,j) = 0.0
714:           if ( prca2d(i,j) < 1E-30 ) prca2d(i,j) = 0.0
715:           flwa2d(i,j) = flwa2d(i,j) + dtbat*flw1d(i)
716:           flwda2d(i,j) = flwda2d(i,j) + dtbat*flwd2d(i,j)
717:           fswa2d(i,j) = fswa2d(i,j) + dtbat*fsw1d(i)
718:           svga2d(i,j) = svga2d(i,j) + dtbat*sabveg(i)
719:           sina2d(i,j) = sina2d(i,j) + dtbat*sinc2d(i,j)
720:           pptnc(i,j) = 0.
721:           pptc(i,j) = 0.
722:         end do
723: 
724:         do i = istart, iend
725: #ifdef MPP1
726:           u10m_o(j,i-1) = 0.0
727:           v10m_o(j,i-1) = 0.0
728:           tg_o(j,i-1) = 0.0
729:           t2m_o(j,i-1) = 0.0
730:           do n = 1 , ng
731:             if ( ocld2d(n,i,j).ge.0.5 ) then
732:               fracv = sigf(n,i)
733:               fracb = (1.-veg1d(n,i))*(1.-scvk(n,i))
734:               fracs = veg1d(n,i)*wt(n,i) + (1.-veg1d(n,i))*scvk(n,i)
735:               facv = dlog(z1(n,i)/2.)/dlog(z1(n,i)/rough(lveg(n,i)))
736:               facb = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zlnd)
737:               facs = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zsno)
738:               fact = fracv*facv + fracb*facb + fracs*facs
739:               facv = dlog(z1(n,i)/10.)/dlog(z1(n,i)/rough(lveg(n,i)))
740:               facb = dlog(z1(n,i)/10.)/dlog(z1(n,i)/zlnd)
741:               facs = dlog(z1(n,i)/10.)/dlog(z1(n,i)/zsno)
742:               factuv = fracv*facv + fracb*facb + fracs*facs
743:               u10m1d(n,i) = us1d(i)*(1.-factuv)
744:               v10m1d(n,i) = vs1d(i)*(1.-factuv)
745:               t2m_1d(n,i) = ts1d(n,i) - delt1d(n,i)*fact
746:             else if ( iocnflx.eq.1 ) then
747:               fact = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zoce)
748:               factuv = dlog(z1(n,i)/10.)/dlog(z1(n,i)/zoce)
749:               u10m1d(n,i) = us1d(i)*(1.-factuv)
750:               v10m1d(n,i) = vs1d(i)*(1.-factuv)
751:               t2m_1d(n,i) = ts1d(n,i) - delt1d(n,i)*fact
752:             else
753:             end if
754:             tg_s(n,j,i-1) = tg1d(n,i)
755:             u10m_s(n,j,i-1) = u10m1d(n,i)
756:             v10m_s(n,j,i-1) = v10m1d(n,i)
757:             t2m_s(n,j,i-1) = t2m_1d(n,i)
758:  
759:             u10m_o(j,i-1) = u10m_o(j,i-1) + u10m1d(n,i)
760:             v10m_o(j,i-1) = v10m_o(j,i-1) + v10m1d(n,i)
761:             t2m_o(j,i-1) = t2m_o(j,i-1) + t2m_1d(n,i)
762:             tg_o(j,i-1) = tg_o(j,i-1) + tg1d(n,i)
763:           end do
764:           u10m_o(j,i-1) = u10m_o(j,i-1)/float(ng)
765:           v10m_o(j,i-1) = v10m_o(j,i-1)/float(ng)
766:           t2m_o(j,i-1) = t2m_o(j,i-1)/float(ng)
767:           tg_o(j,i-1) = tg_o(j,i-1)/float(ng)
768:  
769:           tgmx_o(j,i-1) = amax1(tgmx_o(j,i-1),tg_o(j,i-1))
770:           tgmn_o(j,i-1) = amin1(tgmn_o(j,i-1),tg_o(j,i-1))
771:           t2mx_o(j,i-1) = amax1(t2mx_o(j,i-1),t2m_o(j,i-1))
772:           t2mn_o(j,i-1) = amin1(t2mn_o(j,i-1),t2m_o(j,i-1))
773:           w10x_o(j,i-1) = amax1(w10x_o(j,i-1),sqrt(u10m_o(j,i-1)**2+    &
774:                         & v10m_o(j,i-1)**2))
775:           real_4 = (psb(i,j)+r8pt)*10.
776:           psmn_o(j,i-1) = amin1(psmn_o(j,i-1),real_4)
777: #else
778:           u10m_o(j-1,i-1) = 0.0
779:           v10m_o(j-1,i-1) = 0.0
780:           tg_o(j-1,i-1) = 0.0
781:           t2m_o(j-1,i-1) = 0.0
782:           do n = 1 , ng
783:             if ( ocld2d(n,i,j).ge.0.5 ) then
784:               fracv = sigf(n,i)
785:               fracb = (1.-veg1d(n,i))*(1.-scvk(n,i))
786:               fracs = veg1d(n,i)*wt(n,i) + (1.-veg1d(n,i))*scvk(n,i)
787:               facv = dlog(z1(n,i)/2.)/dlog(z1(n,i)/rough(lveg(n,i)))
788:               facb = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zlnd)
789:               facs = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zsno)
790:               fact = fracv*facv + fracb*facb + fracs*facs
791:               facv = dlog(z1(n,i)/10.)/dlog(z1(n,i)/rough(lveg(n,i)))
792:               facb = dlog(z1(n,i)/10.)/dlog(z1(n,i)/zlnd)
793:               facs = dlog(z1(n,i)/10.)/dlog(z1(n,i)/zsno)
794:               factuv = fracv*facv + fracb*facb + fracs*facs
795:               u10m1d(n,i) = us1d(i)*(1.-factuv)
796:               v10m1d(n,i) = vs1d(i)*(1.-factuv)
797:               t2m_1d(n,i) = ts1d(n,i) - delt1d(n,i)*fact
798:             else if ( iocnflx.eq.1 ) then
799:               fact = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zoce)
800:               factuv = dlog(z1(n,i)/10.)/dlog(z1(n,i)/zoce)
801:               u10m1d(n,i) = us1d(i)*(1.-factuv)
802:               v10m1d(n,i) = vs1d(i)*(1.-factuv)
803:               t2m_1d(n,i) = ts1d(n,i) - delt1d(n,i)*fact
804:             else
805:             end if
806:             tg_s(n,j-1,i-1) = tg1d(n,i)
807:             u10m_s(n,j-1,i-1) = u10m1d(n,i)
808:             v10m_s(n,j-1,i-1) = v10m1d(n,i)
809:             t2m_s(n,j-1,i-1) = t2m_1d(n,i)
810: 
811:             u10m_o(j-1,i-1) = u10m_o(j-1,i-1) + u10m1d(n,i)
812:             v10m_o(j-1,i-1) = v10m_o(j-1,i-1) + v10m1d(n,i)
813:             t2m_o(j-1,i-1) = t2m_o(j-1,i-1) + t2m_1d(n,i)
814:             tg_o(j-1,i-1) = tg_o(j-1,i-1) + tg1d(n,i)
815:           end do
816:           u10m_o(j-1,i-1) = u10m_o(j-1,i-1)/float(ng)
817:           v10m_o(j-1,i-1) = v10m_o(j-1,i-1)/float(ng)
818:           t2m_o(j-1,i-1) = t2m_o(j-1,i-1)/float(ng)
819:           tg_o(j-1,i-1) = tg_o(j-1,i-1)/float(ng)
820:           tgmx_o(j-1,i-1) = amax1(tgmx_o(j-1,i-1),tg_o(j-1,i-1))
821:           tgmn_o(j-1,i-1) = amin1(tgmn_o(j-1,i-1),tg_o(j-1,i-1))
822:           t2mx_o(j-1,i-1) = amax1(t2mx_o(j-1,i-1),t2m_o(j-1,i-1))
823:           t2mn_o(j-1,i-1) = amin1(t2mn_o(j-1,i-1),t2m_o(j-1,i-1))
824:           w10x_o(j-1,i-1) = amax1(w10x_o(j-1,i-1),sqrt(u10m_o(j-1,i-1)**&
825:                           & 2+v10m_o(j-1,i-1)**2))
826:           real_4 = (psb(i,j)+r8pt)*10.
827:           psmn_o(j-1,i-1) = amin1(psmn_o(j-1,i-1),real_4)
828: #endif
829:         end do
830: 
831:         if ( mod(ntime+nint(dtmin*60.),kbats).eq.0 .or.                 &
832:            & (jyear.eq.jyearr .and. ktau.eq.ktaur) ) then
833:           if ( jyear.eq.jyear0 .and. ktau.le.1 ) then
834:             mmpd = 86400./dtbat
835:             wpm2 = 1./dtbat
836:           else if ( jyear.eq.jyear0 .and. dble(ktau*dtmin)              &
837:                   & .le.batfrq*60.+0.01 ) then
838:             mmpd = 24./(batfrq-dtmin/60.)
839:             wpm2 = 1./((batfrq-dtmin/60.)*3600.)
840:           else
841:             mmpd = 24./batfrq
842:             wpm2 = 1./(batfrq*3600.)
843:           end if
844:           do i = istart, iend
845: #ifdef MPP1
846:             drag_o(j,i-1) = 0.0
847:             q2m_o(j,i-1) = 0.0
848:             evpa_o(j,i-1) = 0.0
849:             sena_o(j,i-1) = 0.0
850:             do n = 1 , ng
851:               if ( ocld2d(n,i,j).ge.0.5 ) then
852:                 fracv = sigf(n,i)
853:                 fracb = (1.-veg1d(n,i))*(1.-scvk(n,i))
854:                 fracs = veg1d(n,i)*wt(n,i) + (1.-veg1d(n,i))*scvk(n,i)
855:                 facv = dlog(z1(n,i)/2.)/dlog(z1(n,i)/rough(lveg(n,i)))
856:                 facb = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zlnd)
857:                 facs = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zsno)
858:                 fact = fracv*facv + fracb*facb + fracs*facs
859:                 q2m_1d(n,i) = qs1d(n,i) - delq1d(n,i)*fact
860:               else if ( iocnflx.eq.1 ) then
861:                 fact = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zoce)
862:                 q2m_1d(n,i) = qs1d(n,i) - delq1d(n,i)*fact
863:               else
864:               end if
865:               q2m_s(n,j,i-1) = q2m_1d(n,i)
866:               drag_s(n,j,i-1) = drag1d(n,i)
867:               evpa_s(n,j,i-1) = evpa2d(n,i,j)*mmpd
868:               sena_s(n,j,i-1) = sena2d(n,i,j)*wpm2
869:               tpr_s(n,j,i-1) = (prnca2d(i,j)+prca2d(i,j))*mmpd
870:               prcv_s(n,j,i-1) = prca2d(i,j)*mmpd
871:               ps_s(n,j,i-1) = p1d(n,i)*0.01
872:  
873:               q2m_o(j,i-1) = q2m_o(j,i-1) + q2m_1d(n,i)
874:               drag_o(j,i-1) = drag_o(j,i-1) + drag1d(n,i)
875:               evpa_o(j,i-1) = evpa_o(j,i-1) + evpa2d(n,i,j)
876:               sena_o(j,i-1) = sena_o(j,i-1) + sena2d(n,i,j)
877:             end do
878:             tpr_o(j,i-1) = (prnca2d(i,j)+prca2d(i,j))*mmpd
879:             q2m_o(j,i-1) = q2m_o(j,i-1)/float(ng)
880:             drag_o(j,i-1) = drag_o(j,i-1)/float(ng)
881:             evpa_o(j,i-1) = evpa_o(j,i-1)/float(ng)*mmpd
882:             sena_o(j,i-1) = sena_o(j,i-1)/float(ng)*wpm2
883:             flwa_o(j,i-1) = flwa2d(i,j)*wpm2
884:             fswa_o(j,i-1) = fswa2d(i,j)*wpm2
885:             flwd_o(j,i-1) = flwda2d(i,j)*wpm2
886:             sina_o(j,i-1) = sina2d(i,j)*wpm2
887:             prcv_o(j,i-1) = prca2d(i,j)*mmpd
888:             ps_o(j,i-1) = (psb(i,j)+r8pt)*10.
889:             zpbl_o(j,i-1) = zpbl(i,j)
890:  
891:             tlef_o(j,i-1) = 0.0
892:             ssw_o(j,i-1) = 0.0
893:             rsw_o(j,i-1) = 0.0
894:             rnos_o(j,i-1) = 0.0
895:             scv_o(j,i-1) = 0.0
896:             nnn = 0
897:             do n = 1 , ng
898:               if ( ocld2d(n,i,j).ge.0.5 ) then
899:                 tlef_o(j,i-1) = tlef_o(j,i-1) + tlef1d(n,i)
900:                 ssw_o(j,i-1) = ssw_o(j,i-1) + ssw1d(n,i)
901:                 rsw_o(j,i-1) = rsw_o(j,i-1) + rsw1d(n,i)
902:                 rnos_o(j,i-1) = rnos_o(j,i-1) + rnos2d(n,i,j)
903:                 scv_o(j,i-1) = scv_o(j,i-1) + scv1d(n,i)
904:                 tlef_s(n,j,i-1) = tlef1d(n,i)
905:                 ssw_s(n,j,i-1) = ssw1d(n,i)
906:                 rsw_s(n,j,i-1) = rsw1d(n,i)
907:                 rnos_s(n,j,i-1) = rnos2d(n,i,j)*mmpd
908:                 scv_s(n,j,i-1) = scv1d(n,i)
909:                 nnn = nnn + 1
910:               else
911:                 tlef_s(n,j,i-1) = -1.E34
912:                 ssw_s(n,j,i-1) = -1.E34
913:                 rsw_s(n,j,i-1) = -1.E34
914:                 rnos_s(n,j,i-1) = -1.E34
915:                 scv_s(n,j,i-1) = -1.E34
916:               end if
917:             end do
918:             if ( nnn.ge.max0(ng/2,1) ) then
919:               tlef_o(j,i-1) = tlef_o(j,i-1)/float(nnn)
920:               ssw_o(j,i-1) = ssw_o(j,i-1)/float(nnn)
921:               rsw_o(j,i-1) = rsw_o(j,i-1)/float(nnn)
922:               rnos_o(j,i-1) = rnos_o(j,i-1)/float(nnn)*mmpd
923:               scv_o(j,i-1) = scv_o(j,i-1)/float(nnn)
924:             else
925:               tlef_o(j,i-1) = -1.E34
926:               ssw_o(j,i-1) = -1.E34
927:               rsw_o(j,i-1) = -1.E34
928:               rnos_o(j,i-1) = -1.E34
929:               scv_o(j,i-1) = -1.E34
930:             end if
931: #else
932:             drag_o(j-1,i-1) = 0.0
933:             q2m_o(j-1,i-1) = 0.0
934:             evpa_o(j-1,i-1) = 0.0
935:             sena_o(j-1,i-1) = 0.0
936:             do n = 1 , ng
937:               if ( ocld2d(n,i,j).ge.0.5 ) then
938:                 fracv = sigf(n,i)
939:                 fracb = (1.-veg1d(n,i))*(1.-scvk(n,i))
940:                 fracs = veg1d(n,i)*wt(n,i) + (1.-veg1d(n,i))*scvk(n,i)
941:                 facv = dlog(z1(n,i)/2.)/dlog(z1(n,i)/rough(lveg(n,i)))
942:                 facb = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zlnd)
943:                 facs = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zsno)
944:                 fact = fracv*facv + fracb*facb + fracs*facs
945:                 q2m_1d(n,i) = qs1d(n,i) - delq1d(n,i)*fact
946:               else if ( iocnflx.eq.1 ) then
947:                 fact = dlog(z1(n,i)/2.)/dlog(z1(n,i)/zoce)
948:                 q2m_1d(n,i) = qs1d(n,i) - delq1d(n,i)*fact
949:               else
950:               end if
951:               q2m_s(n,j-1,i-1) = q2m_1d(n,i)
952:               drag_s(n,j-1,i-1) = drag1d(n,i)
953:               evpa_s(n,j-1,i-1) = evpa2d(n,i,j)*mmpd
954:               sena_s(n,j-1,i-1) = sena2d(n,i,j)*wpm2
955:               tpr_s(n,j-1,i-1) = (prnca2d(i,j)+prca2d(i,j))*mmpd
956:               prcv_s(n,j-1,i-1) = prca2d(i,j)*mmpd
957:               ps_s(n,j-1,i-1) = p1d(n,i)*0.01
958: 
959:               q2m_o(j-1,i-1) = q2m_o(j-1,i-1) + q2m_1d(n,i)
960:               drag_o(j-1,i-1) = drag_o(j-1,i-1) + drag1d(n,i)
961:               evpa_o(j-1,i-1) = evpa_o(j-1,i-1) + evpa2d(n,i,j)
962:               sena_o(j-1,i-1) = sena_o(j-1,i-1) + sena2d(n,i,j)
963:             end do
964:             tpr_o(j-1,i-1) = (prnca2d(i,j)+prca2d(i,j))*mmpd
965:             q2m_o(j-1,i-1) = q2m_o(j-1,i-1)/float(ng)
966:             drag_o(j-1,i-1) = drag_o(j-1,i-1)/float(ng)
967:             evpa_o(j-1,i-1) = evpa_o(j-1,i-1)/float(ng)*mmpd
968:             sena_o(j-1,i-1) = sena_o(j-1,i-1)/float(ng)*wpm2
969:             flwa_o(j-1,i-1) = flwa2d(i,j)*wpm2
970:             fswa_o(j-1,i-1) = fswa2d(i,j)*wpm2
971:             flwd_o(j-1,i-1) = flwda2d(i,j)*wpm2
972:             sina_o(j-1,i-1) = sina2d(i,j)*wpm2
973:             prcv_o(j-1,i-1) = prca2d(i,j)*mmpd
974:             ps_o(j-1,i-1) = (psb(i,j)+r8pt)*10.
975:             zpbl_o(j-1,i-1) = zpbl(i,j)
976: 
977:             tlef_o(j-1,i-1) = 0.0
978:             ssw_o(j-1,i-1) = 0.0
979:             rsw_o(j-1,i-1) = 0.0
980:             rnos_o(j-1,i-1) = 0.0
981:             scv_o(j-1,i-1) = 0.0
982:             nnn = 0
983:             do n = 1 , ng
984:               if ( ocld2d(n,i,j).ge.0.5 ) then
985:                 tlef_o(j-1,i-1) = tlef_o(j-1,i-1) + tlef1d(n,i)
986:                 ssw_o(j-1,i-1) = ssw_o(j-1,i-1) + ssw1d(n,i)
987:                 rsw_o(j-1,i-1) = rsw_o(j-1,i-1) + rsw1d(n,i)
988:                 rnos_o(j-1,i-1) = rnos_o(j-1,i-1) + rnos2d(n,i,j)
989:                 scv_o(j-1,i-1) = scv_o(j-1,i-1) + scv1d(n,i)
990:                 tlef_s(n,j-1,i-1) = tlef1d(n,i)
991:                 ssw_s(n,j-1,i-1) = ssw1d(n,i)
992:                 rsw_s(n,j-1,i-1) = rsw1d(n,i)
993:                 rnos_s(n,j-1,i-1) = rnos2d(n,i,j)*mmpd
994:                 scv_s(n,j-1,i-1) = scv1d(n,i)
995:                 nnn = nnn + 1
996:               else
997:                 tlef_s(n,j-1,i-1) = -1.E34
998:                 ssw_s(n,j-1,i-1) = -1.E34
999:                 rsw_s(n,j-1,i-1) = -1.E34
1000:                 rnos_s(n,j-1,i-1) = -1.E34
1001:                 scv_s(n,j-1,i-1) = -1.E34
1002:               end if
1003:             end do
1004:             if ( nnn.ge.max0(ng/2,1) ) then
1005:               tlef_o(j-1,i-1) = tlef_o(j-1,i-1)/float(nnn)
1006:               ssw_o(j-1,i-1) = ssw_o(j-1,i-1)/float(nnn)
1007:               rsw_o(j-1,i-1) = rsw_o(j-1,i-1)/float(nnn)
1008:               rnos_o(j-1,i-1) = rnos_o(j-1,i-1)/float(nnn)*mmpd
1009:               scv_o(j-1,i-1) = scv_o(j-1,i-1)/float(nnn)
1010:             else
1011:               tlef_o(j-1,i-1) = -1.E34
1012:               ssw_o(j-1,i-1) = -1.E34
1013:               rsw_o(j-1,i-1) = -1.E34
1014:               rnos_o(j-1,i-1) = -1.E34
1015:               scv_o(j-1,i-1) = -1.E34
1016:             end if
1017: #endif
1018:  
1019: !           ******    reset accumulation arrays to zero
1020:             do n = 1 , ng
1021:               evpa2d(n,i,j) = 0.
1022:               rnos2d(n,i,j) = 0.
1023:               sena2d(n,i,j) = 0.
1024:             end do
1025:             prnca2d(i,j) = 0.
1026:             prca2d(i,j) = 0.
1027:             flwa2d(i,j) = 0.
1028:             flwda2d(i,j) = 0.
1029:             fswa2d(i,j) = 0.
1030:             svga2d(i,j) = 0.
1031:             sina2d(i,j) = 0.
1032:           end do
1033:         end if
1034: !
1035:       else ! end ivers test
1036:       end if
1037: !
1038:       end subroutine interf
1039: !
1040: !     provides leaf and stem area parameters;
1041: !     depends on climate through subsoil temperatures.
1042: !
<p><a name=vcover><H3>vcover</H3></a></p> Click <a href="./callingtree/vcover_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vcover is used.
<hr>
1043:       subroutine vcover
1044: !:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
1045:  
1046:       implicit none
1047: !
1048: ! Local variables
1049: !
1050:       integer :: n , i
1051: !
1052:       do i = 2 , iym1
1053:         do n = 1 , nnsg
1054:           if ( ldoc1d(n,i).gt.0.5 ) then
1055:             if ( sigf(n,i).gt.0.001 ) seasb(n,i)                        &
1056:                & = dmax1(0.D0,1.-0.0016*dmax1(298.-tgb1d(n,i),0.D0)**2)
1057:           end if
1058:         end do
1059:       end do
1060:  
1061:       do i = 2 , iym1
1062:         do n = 1 , nnsg
1063:           if ( ldoc1d(n,i).gt.0.5 ) then
1064:             if ( sigf(n,i).gt.0.001 ) then
1065:               xlai(n,i) = xla(lveg(n,i))
1066:               xlai(n,i) = xlai(n,i) + (xlai0(lveg(n,i))-xlai(n,i))      &
1067:                          & *(1.-seasb(n,i))
1068:               rlai(n,i) = xlai(n,i) + sai(lveg(n,i))
1069:               xlsai(n,i) = xlai(n,i) + sai(lveg(n,i))
1070:               vegt(n,i) = sigf(n,i)*xlsai(n,i)
1071:             end if
1072:           end if
1073:         end do
1074:       end do
1075: !
1076:       end subroutine vcover
1077: !
1078: !
1079: !     this subroutine provides root function in terms of maximum
1080: !     transpiration rate plants can sustain depending on soil moisture.
1081: !
1082: !     trsmx0 is a prescribed constant (kg/m**2/s).
1083: !     trsmx is the maximum transpiration rate,
1084: !        including a low temperature correction (=seasb)
1085: !        and a correction for fractional vegetation (=sigf).
1086: !
1087: !     rotf is ratio of moisture extracton from top to total when
1088: !           fully saturated
1089: !     rootf is ratio of roots in upper soil layer
1090: !                    to roots in root soil layer
1091: !     bsw is the b param in clapp and hornberger
1092: !
1093: !     "wlt  " are ratios factors controlling the saturation
1094: !                 cf wilting (see ewing paper)
1095: !     wlttb (total) & wltub (upper) become 1 at the wilting point
1096: !     (eqn 14 in ewing paper) n.b. etrc=etrmx in ewing paper
1097: !
1098: !     etrc= max poss transpiration given the soil moisture distributions
1099: !     efpr = the relative contribution of upper soil layer to
1100: !     evapotranspiration - need soil moist. budget (subrout water)
1101: !
<p><a name=root><H3>root</H3></a></p> Click <a href="./callingtree/root_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where root is used.
<hr>
1102:       subroutine root
1103:       use <a href="./mod_ictp01.F90.html#mod_ictp01" TARGET=CENT_PANEL>mod_ictp01</a>
1104:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : trsmx0
1105:       implicit none
1106: !
1107: ! Local variables
1108: !
1109:       real(8) :: bneg , rotf , trsmx , wlttb , wltub , wmli
1110:       integer :: n , i
1111: !
1112:       do i = 2 , iym1
1113:         do n = 1 , nnsg
1114:           if ( ldoc1d(n,i).gt.0.5 ) then
1115:             if ( sigf(n,i).gt.0.001 ) then
1116: !             trsmx = trsmx0*sigf(n,i)*seasb(n,i)
1117:               trsmx = trsmx0*sigf(n,i)
1118:               rotf = rootf(lveg(n,i))
1119:               bneg = -bsw(n,i)
1120:               wmli = 1./(wiltr(n,i)**bneg-1.)
1121:               wlttb = (watr(n,i)**bneg-1.)*wmli
1122:               wltub = (watu(n,i)**bneg-1.)*wmli
1123:               wlttb = dmin1(wlttb,1.D0)
1124:               wltub = dmin1(wltub,1.D0)
1125:               etrc(n,i) = trsmx*(1.-(1.-rotf)*wlttb-rotf*wltub)
1126:               efpr(n,i) = trsmx*rotf*(1.-wltub)
1127:               if ( etrc(n,i).lt.1.E-12 ) then
1128:                 etrc(n,i) = 1.E-12
1129:                 efpr(n,i) = 1.0
1130:               else
1131:                 efpr(n,i) = efpr(n,i)/etrc(n,i)
1132:               end if
1133:             end if
1134:           end if
1135:         end do
1136:       end do
1137: !
1138:       end subroutine root
1139: !
1140: !              update soil moisture and runoff
1141: !
1142: !     new algorithms for three soil layers (dickinson & kennedy 8-88)
1143: !     calculate fluxes through air, surface layer, and root layer faces
1144: !
1145: !          b = b of clapp and hornberger
1146: !       est0 = soil water flux, out top
1147: !      gwatr = net input of water to the soil surface
1148: !       ircp = leaf interception
1149: !     wflux1 = soil water flux, 10 cm
1150: !     wflux2 = soil water flux, 1 m
1151: !     rsubss = soil water flux by grav. drainage thru 10 cm interface
1152: !     rsubsr = soil water flux by grav. drainage thru 1 m interface
1153: !     rsubst = soil water flux by grav. drainage thru 10 m interface
1154: !       rsur = surface runoff
1155: !     rno1d(n,i) = total runoff (mm/day)
1156: !     rnos1d(n,i) = surface runoff (mm/day)
1157: !
1158: !     xkmxr and wflux1 determine flow thru upper/root soil interface
1159: !     evmxt, xkmx1, and xkmx2 determine flow thru lower interfaces
1160: !
1161: !     veg type 10 "irrigated crop" is irrigated through reducing
1162: !          the runoff (rsur), i.e., by adding a negative number
1163: !          if the land isn't at least 60% saturated.
1164: !     veg type 13 and 14 are water covered (lake, swamp, rice paddy);
1165: !          negative runoff keeps this land saturated.
1166: !
<p><a name=water><H3>water</H3></a></p> Click <a href="./callingtree/water_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where water is used.
<hr>
1167:       subroutine water
1168: !
1169:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : drain , tau1 , csoilc , tzero
1170:       implicit none
1171: !
1172: ! Local variables
1173: !
1174:       real(8) :: b , bfac , bfac2 , delwat , est0 , evmax , evmxr ,     &
1175:                & evmxt , rap , vakb , wtg2c , xxkb
1176:       real(8) , dimension(nnsg,iym1) :: gwatr , rnof , rsubsr ,         &
1177:            & rsubss , rsubst , rsur , wflux1 , wflux2 , wfluxc , xkmx1 ,&
1178:            & xkmx2 , xkmxr
1179:       integer :: n , i
1180: !
1181: !***********************************************************************
1182: !
1183:  
1184: !=======================================================================
1185: !     1.   define soil water fluxes
1186: !=======================================================================
1187: !
1188:       do i = 2 , iym1
1189:         do n = 1 , nnsg
1190:           if ( ldoc1d(n,i).gt.0.5 .and. ldoc1d(n,i).lt.1.5 ) then
1191: !
1192: !           1.1  reduce infiltration for frozen ground
1193: !
1194:             if ( tgb1d(n,i).gt.tzero ) then
1195:               xkmxr(n,i) = xkmx(n,i)
1196:             else
1197:               xkmxr(n,i) = 0.
1198:             end if
1199: !
1200: !           1.11 permafrost or ice sheet
1201: !
1202:             if ( lveg(n,i).eq.9 .or. lveg(n,i).eq.12 ) then
1203:               xkmx1(n,i) = 0.
1204:               xkmx2(n,i) = 0.
1205:             else
1206:               xkmx1(n,i) = xkmx(n,i)
1207:               xkmx2(n,i) = drain
1208:             end if
1209: !
1210: !           1.2  diffusive fluxes
1211: !
1212:             evmxr = evmx0(n,i)*xkmxr(n,i)/xkmx(n,i)
1213:             evmxt = evmx0(n,i)*xkmx1(n,i)/xkmx(n,i)
1214:             b = bsw(n,i)
1215:             bfac = watr(n,i)**(3.+bfc(n,i))*watu(n,i)**(b-bfc(n,i)-1)
1216:             bfac2 = watt(n,i)**(2.+bfc(n,i))*watr(n,i)**(b-bfc(n,i))
1217:             wfluxc(n,i) = evmxr*(depuv(lveg(n,i))/deprv(lveg(n,i)))     &
1218:                          & **0.4*bfac
1219:             wflux1(n,i) = wfluxc(n,i)*watr(n,i)
1220:             wflux2(n,i) = evmxt*(depuv(lveg(n,i))/deprv(lveg(n,i)))     &
1221:                          & **0.5*bfac2*(watt(n,i)-watr(n,i))
1222: !
1223: !           1.3  gravitational drainage
1224: !
1225:             rsubss(n,i) = xkmxr(n,i)*watr(n,i)**(b+0.5)*watu(n,i)       &
1226:                          & **(b+2.5)
1227:             rsubsr(n,i) = xkmx1(n,i)*watt(n,i)**(b+0.5)*watr(n,i)       &
1228:                          & **(b+2.5)
1229:             rsubst(n,i) = xkmx2(n,i)*watt(n,i)**(2.*b+3.)
1230: !
1231: !           1.32 bog or water
1232: !
1233:             if ( (lveg(n,i).ge.13) .and. (lveg(n,i).le.15) ) then
1234:               rsubst(n,i) = 0.0
1235:               rsubss(n,i) = 0.0
1236:               rsubsr(n,i) = 0.0
1237:             end if
1238: !
1239: !           1.4  fluxes through internal surfaces
1240: !
1241:             wflux1(n,i) = wflux1(n,i) - rsubss(n,i)
1242:             wflux2(n,i) = wflux2(n,i) - rsubsr(n,i)
1243:           end if
1244:         end do
1245:       end do
1246: !
1247: !     1.5  net flux at air interface
1248: !
1249:       do i = 2 , iym1
1250:         do n = 1 , nnsg
1251:           if ( ldoc1d(n,i).gt.0.5 .and. ldoc1d(n,i).lt.1.5 ) then
1252:             gwatr(n,i) = pw(n,i) - evapw(n,i) + sm(n,i)                 &
1253:                         & + etrrun(n,i)/dtbat
1254: !
1255: !=======================================================================
1256: !           2.   define runoff terms
1257: !=======================================================================
1258: !
1259: !           2.1  surface runoff
1260: !
1261:             wata(n,i) = 0.5*(watu(n,i)+watr(n,i))
1262: !
1263: !           2.11 increase surface runoff over frozen ground
1264: !
1265:             if ( tg1d(n,i).lt.tzero ) then
1266:               rsur(n,i) = dmin1(1.D0,wata(n,i)**1)*                     &
1267:                          & dmax1(0.D0,gwatr(n,i))
1268:             else
1269:               rsur(n,i) = dmin1(1.D0,wata(n,i)**4)                      &
1270:                          & *dmax1(0.D0,gwatr(n,i))
1271:             end if
1272: !
1273: !           2.12 irrigate cropland
1274: !
1275:             if ( lveg(n,i).eq.10 .and. watr(n,i).lt.relfc(n,i) )        &
1276:                & rsur(n,i) = rsur(n,i) + (rsw1d(n,i)-relfc(n,i)*        &
1277:                &             gwmx1(n,i))/dtbat
1278: !
1279: !           2.13 saturate swamp or rice paddy
1280: !
1281:             if ( (lveg(n,i).ge.13) .and. (lveg(n,i).lt.16) )            &
1282:                & rsur(n,i) = rsur(n,i) + dmin1(0.D0,(rsw1d(n,i)-        &
1283:                &             gwmx1(n,i))/dtbat)
1284: !
1285: !           2.2  total runoff
1286: !
1287:             rnof(n,i) = rsur(n,i) + rsubst(n,i)
1288: !
1289: !=======================================================================
1290: !           3.   increment soil moisture
1291: !=======================================================================
1292: !
1293: !           3.1  update top layer with implicit treatment
1294: !           of flux from below
1295: !
1296:             ssw1d(n,i) = ssw1d(n,i) + dtbat*(gwatr(n,i)-efpr(n,i)*      &
1297:                         & etr(n,i)-rsur(n,i)+wflux1(n,i))
1298:             ssw1d(n,i) = ssw1d(n,i)/(1.+wfluxc(n,i)*dtbat/gwmx0(n,i))
1299: !
1300: !           3.2  update root zone
1301: !
1302:             rsw1d(n,i) = rsw1d(n,i) + dtbat*(gwatr(n,i)-etr(n,i)-       &
1303:                         & rsur(n,i)+wflux2(n,i))
1304: !
1305: !           3.3  update total water
1306: !
1307:             tsw1d(n,i) = tsw1d(n,i) + dtbat*(gwatr(n,i)-etr(n,i)-       &
1308:                         & rnof(n,i))
1309:           end if
1310:         end do
1311:       end do
1312: !
1313:       do i = 2 , iym1
1314:         do n = 1 , nnsg
1315:           if ( ldoc1d(n,i).gt.0.5 .and. ldoc1d(n,i).lt.1.5 ) then
1316: !
1317: !=======================================================================
1318: !           4.   check whether soil water exceeds maximum capacity or
1319: !           becomes negative (should rarely or never happen)
1320: !=======================================================================
1321: !
1322: !           4.1  surface water assumed to move downward into soil
1323: !
1324:             if ( ssw1d(n,i).gt.gwmx0(n,i) ) ssw1d(n,i) = gwmx0(n,i)
1325: !
1326: !           4.2  excess root layer water assumed to move downward
1327: !
1328:             if ( rsw1d(n,i).gt.gwmx1(n,i) ) rsw1d(n,i) = gwmx1(n,i)
1329: !
1330: !           4.3  excess total water assumed to go to subsurface runoff
1331: !
1332:             if ( tsw1d(n,i).gt.gwmx2(n,i) ) then
1333:               delwat = tsw1d(n,i) - gwmx2(n,i)
1334:               tsw1d(n,i) = gwmx2(n,i)
1335:               rsubst(n,i) = rsubst(n,i) + delwat/dtbat
1336:             end if
1337: !
1338: !           4.4  check for negative water in top layer
1339: !
1340:             if ( ssw1d(n,i).le.1.E-2 ) ssw1d(n,i) = 1.E-2
1341: !
1342: !=======================================================================
1343: !           5.   accumulate leaf interception
1344: !=======================================================================
1345: !
1346:             ircp1d(n,i) = ircp1d(n,i) + sigf(n,i)*(dtbat*               &
1347:                          & prcp1d(n,i)) - (sdrop(n,i)+etrrun(n,i))
1348: !
1349: !=======================================================================
1350: !           6.   evaluate runoff (incremented in ccm)
1351: !=======================================================================
1352: !
1353: !*          update total runoff
1354: !
1355:             rnof(n,i) = rsur(n,i) + rsubst(n,i)
1356:             rno1d(n,i) = rnof(n,i)*tau1
1357:             rnos1d(n,i) = rsur(n,i)*tau1
1358:           else                       ! ocean or sea ice
1359:             rnof(n,i) = 0.
1360:             rno1d(n,i) = 0.
1361:             rnos1d(n,i) = 0.
1362:           end if
1363:         end do
1364:       end do
1365: !
1366: !=======================================================================
1367: !     7.   calculate potential evaporation and use mod_to determine
1368: !     wetness factor, allowing for snow being saturated
1369: !=======================================================================
1370: !
1371:       do i = 2 , iym1
1372:         do n = 1 , nnsg
1373:           if ( ldoc1d(n,i).gt.0.5 .and. ldoc1d(n,i).lt.1.5 ) then
1374:             xxkb = dmin1(rough(lveg(n,i)),1.D0)
1375:             vakb = (1.-sigf(n,i))*vspda(n,i) + sigf(n,i)                &
1376:                  & *(xxkb*uaf(n,i)+(1.-xxkb)*vspda(n,i))
1377:             wtg2c = (1.-sigf(n,i))*cdrx(n,i)*vakb
1378:             rap = rhs1d(n,i)*(csoilc*uaf(n,i)*sigf(n,i)*(qg1d(n,i)+     &
1379:                 & delq1d(n,i)-qs1d(n,i))+wtg2c*(qg1d(n,i)-qs1d(n,i)))
1380:             bfac = watr(n,i)**(3.+bfc(n,i))*watu(n,i)                   &
1381:                  & **(bsw(n,i)-bfc(n,i)-1)
1382:             est0 = evmx0(n,i)*bfac*watu(n,i)
1383:             evmax = dmax1(est0,0.D0)
1384:             gwet1d(n,i) = dmin1(1.D0,evmax/dmax1(1.D-14,rap))
1385:             gwet1d(n,i) = scvk(n,i) + gwet1d(n,i)*(1.0-scvk(n,i))
1386:           end if
1387:         end do
1388:       end do
1389: !
1390:       end subroutine water
1391: ! 
1392: !     update snow cover and snow age
1393: !
1394: !     three-part if block:
1395: !       if snow cover < 0, then snow cover and snow age = 0
1396: !       if antarctica, snow age = 0 (katabatic winds keep snow fresh)
1397: !       if elsewhere, snow age follows given formulae
1398: !
1399: !        ps = snow precipitation rate
1400: !     evaps = moisture flux from ground to atmosphere
1401: !        sm = snow melt rate
1402: !     sdrop = snow fallen from vegetation
1403: !
1404: !     aging of snow consists of three factors:
1405: !           age1: snow crystal growth
1406: !           age2: surface melting
1407: !           age3: accumulation  of other particles, soot, etc., which
1408: !                      is small in southern hemisphere
1409: !
<p><a name=snow><H3>snow</H3></a></p> Click <a href="./callingtree/snow_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where snow is used.
<hr>
1410:       subroutine snow
1411: !
1412:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : dtbat
1413:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : tzero
1414:       implicit none
1415: !
1416: ! Local variables
1417: !
1418:       real(8) :: age1 , age2 , age3 , arg , arg2 , dela , dela0 , dels ,&
1419:                & sge , tage
1420:       integer :: n , i
1421:       real(8) , dimension(nnsg,iym1) :: sold
1422: !
1423:       age3 = 0.3
1424:  
1425: !=======================================================================
1426: !     1.   partition soil evaporation and precipitation
1427: !     between water and snow
1428: !=======================================================================
1429:       do i = 2 , iym1
1430:         do n = 1 , nnsg
1431:           if ( ldoc1d(n,i).gt.0.5 ) then
1432:  
1433:             evapw(n,i) = fevpg(n,i)
1434:             evaps(n,i) = scvk(n,i)*evapw(n,i)
1435:             if ( ldoc1d(n,i).gt.1.5 ) evaps(n,i) = fevpg(n,i)
1436:             evapw(n,i) = (1.-scvk(n,i))*evapw(n,i)
1437: !
1438: !           ******                tm  is temperature of precipitation
1439:             if ( tm(n,i).ge.tzero ) then
1440:               pw(n,i) = prcp1d(n,i)*(1.-sigf(n,i))
1441:               ps(n,i) = 0.0
1442:             else
1443: !             ******                snowing
1444:               pw(n,i) = 0.0
1445:               ps(n,i) = prcp1d(n,i)*(1.-sigf(n,i))
1446:             end if
1447:           end if
1448:         end do
1449:       end do
1450: !
1451: !=======================================================================
1452: !     2.   update snow cover
1453: !=======================================================================
1454:       do i = 2 , iym1
1455:         do n = 1 , nnsg
1456:           if ( ldoc1d(n,i).gt.0.5 ) then
1457:             sold(n,i) = scv1d(n,i)
1458:             scv1d(n,i) = scv1d(n,i) + dtbat                             &
1459:                         & *(ps(n,i)-evaps(n,i)-sm(n,i)) + sdrop(n,i)
1460:             scv1d(n,i) = dmax1(scv1d(n,i),0.D0)
1461:             sag1d(n,i) = dmax1(sag1d(n,i),0.D0)
1462:  
1463: !           ******           snow cover except for antarctica
1464: !=======================================================================
1465: !           3.   increment non-dimensional "age" of snow;
1466: !           10 mm snow restores surface to that of new snow.
1467: !=======================================================================
1468:             if ( scv1d(n,i).gt.0. ) then
1469:               arg = 5.E3*(1./tzero-1./tg1d(n,i))
1470:               age1 = dexp(arg)
1471:               arg2 = dmin1(0.D0,10.*arg)
1472:               age2 = dexp(arg2)
1473:               tage = age1 + age2 + age3
1474:               dela0 = 1.E-6*dtbat
1475:               dela = dela0*tage
1476:               dels = 0.1*dmax1(0.D0,scv1d(n,i)-sold(n,i))
1477:               sge = (sag1d(n,i)+dela)*(1.0-dels)
1478:               sag1d(n,i) = dmax1(0.D0,sge)
1479:             end if
1480:  
1481: !           ******           antarctica
1482:             if ( scv1d(n,i).gt.800. ) sag1d(n,i) = 0.
1483:           end if
1484:         end do
1485:       end do
1486:  
1487:       end subroutine snow
1488:       end module mod_bats
</PRE>

<HR>

</BODY>
</HTML>
