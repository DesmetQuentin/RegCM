<HTML>

<HEAD>
<TITLE>mod_dynparam.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_dynparam.F90</H1>
<HR>
<H2 ALIGN=CENTER>mod_dynparam.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: !
<p><a name=mod_dynparam><H3>mod_dynparam</H3></a></p>20:       module mod_dynparam
21: 
22:       implicit none
23: !
24: ! PARAMETER definitions
25: !
26:       integer , parameter :: ipunit = 255
27: !
28: !################### GRID DIMENSION ####################################
29: !
30: 
31: ! Point in Y (latitude) direction
32: 
33:       integer :: iy
34: 
35: ! Point in X (longitude) direction
36: 
37:       integer :: jx
38: 
39: ! Point in vertical
40: 
41:       integer :: kz
42: 
43: ! Sub grid decomposition
44: 
45:       integer :: nsg
46: 
47: ! Projection
48: !
49: ! One in : 'LAMCON', Lambert conformal
50: !          'POLSTR', Polar stereographic
51: !          'NORMER', Normal  Mercator (ROTMER w/ plat = clat
52: !          'ROTMER', Rotated Mercator
53: !
54:       character(6) :: iproj
55: 
56: ! Grid point horizontal resolution in km
57: 
58:       real(4) :: ds
59: 
60: ! Pressure of model top in cbar
61: 
62:       real(4) :: ptop
63: 
64: ! Central latitude  of model domain in degrees, north hem. is positive
65: 
66:       real(4) :: clat
67: 
68: ! Central longitude of model domain in degrees, west is negative
69: 
70:       real(4) :: clon
71: 
72: ! Pole latitude (only for rotated Mercator Proj, else set = clat)
73: 
74:       real(4) :: plat
75: 
76: ! Pole longitude (only for rotated Mercator Proj, else set = clon)
77: 
78:       real(4) :: plon
79: 
80: ! Lambert true latitude (low latitude side)
81: 
82:       real(4) :: truelatl
83: 
84: ! Lambert true latitude (high latitude side)
85: 
86:       real(4) :: truelath
87: 
88: !###################### I/O control flag ###############################
89: 
90: ! Create GrADS CTL files
91: 
92:       integer :: igrads
93: 
94: ! Machine endianess. LEAVE IT UNTOUCHED IF WANT TO EXCHANGE I/O FILES
95: 
96:       integer :: ibigend
97: 
98: ! Number of bytes in reclen. Usually 4
99: 
100:       integer :: ibyte
101: 
102: ! Type of output files. Usually 1 (direct access). Set to 2 for sequantial
103: ! foles with time listing interleave.
104: 
105:       integer ::iotyp
106: 
107: ! Set amount of printout (still unused, sorry)
108: 
109:       integer :: debug_level
110: 
111: !###################### I/O control flag ###############################
112: 
113: ! Buffer Zone Depth
114: ! nspgx-1,nspgd-1 represent the number of cross/dot point slices
115: ! on the boundary sponge or relaxation boundary conditions.
116: !
117:       integer :: nspgx
118:       integer :: nspgd
119: 
120: ! Number od split exp modes
121: 
122:       integer :: nsplit
123: 
124: ! Number of lake points for lake model
125: 
126:       integer :: lkpts
127: 
128: ! Type of global analysis datasets used in Pre processing
129: !
130: ! One in: ECMWF,ERA40,ERAIN,EIN75,EIN15,EIM25,ERAHI,NNRP1,NNRP2,
131: !         NRP2W,GFS11,FVGCM,FNEST,EH5OM
132: !
133:       character(5) :: dattyp
134: 
135: ! Type of Sea Surface Temperature used
136: !
137: ! One in: GISST,OISST,OI2ST,OI_WK,OI2WK,FV_RF,FV_A2,FV_B2,EH5RF,
138: !         EH5A2,EH5B1,EHA1B,ERSST,ERSKT
139: !
140:       character(5) :: ssttyp
141: 
142: ! SO4 Control Flag
143: 
144:       logical :: ehso4
145: 
146: ! Land Surface Legend type
147: !
148: ! One in : BATS,USGS
149: 
150:       character(4) :: lsmtyp
151:       integer :: nveg
152: 
153: ! Aerosol dataset used
154: !
155: ! One in : AER00D0 -> Neither aerosol, nor dust used
156: !          AER01D0 -> Biomass, SO2 + BC + OC, no dust
157: !          AER10D0 -> Anthropogenic, SO2 + BC + OC, no dust
158: !          AER11D0 -> Anthropogenic+Biomass, SO2 + BC + OC, no dust
159: !          AER00D1 -> No aerosol, with dust
160: !          AER01D1 -> Biomass, SO2 + BC + OC, with dust
161: !          AER10D1 -> Anthropogenic, SO2 + BC + OC, with dust
162: !          AER11D1 -> Anthropogenic+Biomass, SO2 + BC + OC, with dust
163: 
164:       character(7) :: aertyp
165: 
166: ! Tracer parameters: number of tracers and bins number for dust
167: 
168:       integer :: ntr
169:       integer :: nbin
170: 
171: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
172: ! End of configureation. Below this point things are
173: !    calculated from above or should be considered as fixed
174: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
175: 
176:       integer :: iym1
177:       integer :: iym2
178:       integer :: iym3
179:       integer :: jxp1
180:       integer :: jxm1
181:       integer :: jxm2
182:       integer :: kzm1
183:       integer :: kzm2
184:       integer :: kzp1
185:       integer :: kzp2
186:       integer :: kzp3
187:       integer :: kzp4
188:       integer :: iysg
189:       integer :: jxsg
190:       integer :: iym1sg
191:       integer :: jxm1sg
192:       integer :: iym2sg
193:       integer :: jxm2sg
194:       integer :: nnsg
195:       integer :: nspgv
196:       integer :: nspgp
197: 
198: #ifdef MPP1
199: !####################### MPI parameters ################################
200: 
201:       integer :: nproc
202:       integer :: myid
203:       integer :: jxp
204:       integer :: jxpsg
205:       integer :: iwest , ieast , isouth , inorth
206:       integer :: jbegin , ibegin
207:       integer :: jendl , iendl
208:       integer :: jendx , iendx
209:       integer :: jendm , iendm
210: 
211: !####################### MPI parameters ################################
212: #endif
213: 
214: ! Surface minimum H2O percent to be considered water
215: 
216:       real(4) :: h2opct
217: 
218: ! Resolution of the global terrain and landuse data be used
219: !
220: !     Use 60, for  1  degree resolution
221: !         30, for 30 minutes resolution
222: !         10, for 10 minutes resolution
223: !          5, for  5 minutes resolution
224: !          3, for  3 minutes resolution
225: !          2, for  2 minutes resolution
226: 
227:       integer :: ntypec
228: 
229: ! Same for subgrid (Used only if nsg > 1)
230: 
231:       integer :: ntypec_s
232: 
233: ! Interpolation Control flag.
234: !
235: !     true  -> Perform cressman-type objective analysis
236: !     false -> 16-point overlapping parabolic interpolation
237: 
238:       logical :: ifanal
239: 
240: ! Smoothing Control flag
241: !
242: !     true  -> Perform extra smoothing in boundaries
243: 
244:       logical :: smthbdy
245: 
246: ! Great Lakes levels adjustment Control Flag (Set true only if US EC)
247: !
248: !     true  -> Adjust Great Lakes Levels according to obs
249: 
250:       logical :: lakadj
251: 
252: ! I/O format
253: !
254: !     1 => direct access binary
255: !     2 => netcdf
256: 
257:       integer :: itype_in
258: !     integer :: itype_out
259: 
260: ! Fudging for landuse and texture for grid and subgrid
261: 
262:       logical :: fudge_lnd
263:       logical :: fudge_lnd_s
264:       logical :: fudge_tex
265:       logical :: fudge_tex_s
266: 
267: ! Number of Soil texture categories, leave it to 17
268: 
269:       integer :: ntex
270: 
271: ! Terrain output files
272: 
273:       character(64) :: domname
274: 
275: ! Global Begin and End date for Input Pre processing
276: 
277:       integer :: globidate1 ! BEGIN
278:       integer :: globidate2 ! END
279: 
280: ! Fixed dimensions
281: 
282:       integer , dimension(289276) :: mdatez
283: 
284:       integer , parameter :: numbat = 21 + 6
285:       integer , parameter :: numsub = 16
286:       integer , parameter :: nrad2d = 21
287:       integer , parameter :: nrad3d = 5
288: 
289:       character(1), parameter :: pthsep = '/'
290: 
291: ! Paths
292: 
293:       character(256) :: dirter , inpter
294:       character(256) :: dirglob , inpglob
295:       character(256) :: dirout
296: #ifdef CLM
297:       character(256) :: dirclm
298: #endif
299: 
300: ! Model output control parameters
301: 
302:       logical :: ifsave
303:       real(8) :: savfrq
304: 
305:       logical :: iftape
306:       real(8) :: tapfrq
307: 
308:       logical :: ifrad
309:       real(8) :: radisp
310: 
311:       logical :: ifbat
312:       logical :: ifsub
313:       real(8) :: batfrq
314: 
315:       logical :: ifprt
316:       real(8) :: prtfrq
317:       integer :: kxout , jxsex
318: 
319:       logical :: ifchem
320:       real(8) :: chemfrq
321: 
322:       contains
323: 
<p><a name=initparam><H3>initparam</H3></a></p> Click <a href="./callingtree/initparam_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where initparam is used.
<hr>
324:       subroutine initparam(filename, ierr)
325:         implicit none
326:         character (len=*) , intent(in) :: filename
327:         integer , intent(out) :: ierr
328: 
329:         namelist /geoparam/ iproj , ds , ptop , clat , clon , plat ,    &
330:                      & plon , truelatl, truelath
331:         namelist /terrainparam/ domname , itype_in , ntypec , ntypec_s ,&
332:                      &  ifanal , smthbdy , lakadj , fudge_lnd ,         &
333:                      & fudge_lnd_s , fudge_tex , fudge_tex_s , ntex ,   &
334:                      & h2opct , dirter , inpter
335:         namelist /dimparam/ iy , jx , kz , nsg
336:         namelist /ioparam/ igrads , ibigend , ibyte , iotyp
337:         namelist /debugparam/ debug_level
338:         namelist /boundaryparam/ nspgx , nspgd
339:         namelist /modesparam/ nsplit
340:         namelist /lakemodparam/ lkpts
341:         namelist /globdatparam/ dattyp , ssttyp , ehso4 , globidate1 ,  &
342:                      & globidate2 , dirglob , inpglob
343:         namelist /lsmparam/ lsmtyp
344:         namelist /aerosolparam/ aertyp , ntr, nbin
345: 
346:         open(ipunit, file=filename, status='old', &
347:                      action='read', err=100)
348: !
349:         read(ipunit, dimparam, err=101)
350: 
351: !       Setup all convenience dimensions
352: 
353:         iym1 = iy - 1
354:         iym2 = iy - 2
355:         iym3 = iy - 3
356:         jxp1 = jx + 1
357:         jxm1 = jx - 1
358:         jxm2 = jx - 2
359:         kzm1 = kz - 1
360:         kzm2 = kz - 2
361:         kzp1 = kz + 1
362:         kzp2 = kz + 2
363:         kzp3 = kz + 3
364:         kzp4 = kz + 4
365:         iysg = iy * nsg
366:         jxsg = jx * nsg
367:         iym1sg = (iy-1) * nsg
368:         jxm1sg = (jx-1) * nsg
369:         iym2sg = (iy-2) * nsg
370:         jxm2sg = (jx-2) * nsg
371:         nnsg = nsg*nsg
372: 
373:         read(ipunit, geoparam, err=102)
374: 
375:         ! Defaults to have SAME behaviour of V3 if not specified
376:         inpter  = '../DATA'
377:         inpglob = '../DATA'
378:         dirter  = '../../Input'
379:         dirglob = '../../Input'
380: 
381:         read(ipunit, terrainparam, err=103)
382: 
383:         ! Set convenient defaults for I/O parameters
384:         iotyp   = 1
385:         ibigend = 1
386:         read(ipunit, ioparam, err=104)
387:         read(ipunit, debugparam, err=105)
388:         read(ipunit, boundaryparam, err=106)
389: 
390:         nspgv = (nspgd+nspgx)*8 + 8
391:         nspgp = nspgx*4
392: 
393:         read(ipunit, modesparam, err=107)
394:         read(ipunit, lakemodparam, err=108)
395:         read(ipunit, globdatparam, err=109)
396:         read(ipunit, lsmparam, err=110)
397: 
398:         if (lsmtyp == 'BATS') then
399:           nveg = 20
400:         else if (lsmtyp == 'USGS') then
401:           nveg = 25
402:         else
403:           write ( 6 , * ) 'Unknown LSM data type. Use BATS or USGS'
404:           stop
405:         end if
406: 
407:         read(ipunit, aerosolparam, err=111)
408: 
409:         ierr = 0
410:         return
411: 
412:   100   write ( 6, * ) 'Cannot read namelist file ', trim(filename)
413:         ierr = 1 
414:         return 
415:   101   write ( 6, * ) 'Cannot read namelist stanza: dimparam       ',  &
416:             & trim(filename)
417:         ierr = 1
418:         return
419:   102   write ( 6, * ) 'Cannot read namelist stanza: geoparam       ',  &
420:             & trim(filename)
421:         ierr = 1
422:         return
423:   103   write ( 6, * ) 'Cannot read namelist stanza: terrainparam   ',  &
424:             & trim(filename)
425:         ierr = 1
426:         return
427:   104   write ( 6, * ) 'Cannot read namelist stanza: ioparam        ',  &
428:             & trim(filename)
429:         ierr = 1
430:         return
431:   105   write ( 6, * ) 'Cannot read namelist stanza: debugparam     ',  &
432:             & trim(filename)
433:         ierr = 1
434:         return
435:   106   write ( 6, * ) 'Cannot read namelist stanza: boundaryparam  ',  &
436:             & trim(filename)
437:         ierr = 1
438:         return
439:   107   write ( 6, * ) 'Cannot read namelist stanza: modesparam     ',  &
440:             & trim(filename)
441:         ierr = 1
442:         return
443:   108   write ( 6, * ) 'Cannot read namelist stanza: lakemodparam   ',  &
444:             & trim(filename)
445:         ierr = 1
446:         return
447:   109   write ( 6, * ) 'Cannot read namelist stanza: globdatparam   ',  &
448:             & trim(filename)
449:         ierr = 1
450:         return
451:   110   write ( 6, * ) 'Cannot read namelist stanza: lsmparam       ',  &
452:             & trim(filename)
453:         ierr = 1
454:         return
455:   111   write ( 6, * ) 'Cannot read namelist stanza: aereosolparam  ',  &
456:             & trim(filename)
457:         ierr = 1
458: 
459:       end subroutine
460: 
<p><a name=init_outparam><H3>init_outparam</H3></a></p> Click <a href="./callingtree/init_outparam_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where init_outparam is used.
<hr>
461:       subroutine init_outparam
462:         implicit none
463: 
464:         integer :: ierr
465: 
466:         namelist /outparam/ ifsave , savfrq , iftape , tapfrq ,         &
467:               &     ifrad , radisp , ifbat , ifsub ,  batfrq ,          &
468:               &     ifprt , prtfrq , kxout , jxsex , ifchem , chemfrq
469: 
470:         read(ipunit, outparam, err=100)
471:         return
472: 
473:   100   write ( 6, * ) 'Cannot read namelist stanza: outparam'
474:         ierr = 1
475: 
476:       end subroutine init_outparam
477: 
478: #ifdef MPP1
<p><a name=set_nproc><H3>set_nproc</H3></a></p> Click <a href="./callingtree/set_nproc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where set_nproc is used.
<hr>
479:       subroutine set_nproc(ncpu)
480:         implicit none
481:         integer , intent(in) :: ncpu
482:         nproc = ncpu 
483:         jxp   =  jx/nproc
484:         jxpsg  = jxp * nsg
485:       end subroutine set_nproc
486: 
<p><a name=broadcast_params><H3>broadcast_params</H3></a></p> Click <a href="./callingtree/broadcast_params_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where broadcast_params is used.
<hr>
487:       subroutine broadcast_params
488: 
489:         use <a href="#" TARGET=CENT_PANEL>mpi</a>
490:         implicit none
491: 
492:         integer :: ierr
493: 
494:         call <a href="#" TARGET=CENT_PANEL>mpi_barrier</a>(mpi_comm_world,ierr)
495: 
496:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(iy,1,mpi_integer,0,mpi_comm_world,ierr)
497:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(jx,1,mpi_integer,0,mpi_comm_world,ierr)
498:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(kz,1,mpi_integer,0,mpi_comm_world,ierr)
499:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(nsg,1,mpi_integer,0,mpi_comm_world,ierr)
500: 
501:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(iproj,6,mpi_character,0,mpi_comm_world,ierr)
502:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ds,1,mpi_real8,0,mpi_comm_world,ierr)
503:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ptop,1,mpi_real8,0,mpi_comm_world,ierr)
504:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(clat,1,mpi_real8,0,mpi_comm_world,ierr)
505:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(clon,1,mpi_real8,0,mpi_comm_world,ierr)
506:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(plat,1,mpi_real8,0,mpi_comm_world,ierr)
507:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(plon,1,mpi_real8,0,mpi_comm_world,ierr)
508:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(truelatl,1,mpi_real8,0,mpi_comm_world,ierr)
509:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(truelath,1,mpi_real8,0,mpi_comm_world,ierr)
510: 
511:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(domname,64,mpi_character,0,mpi_comm_world,ierr)
512:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(nveg,1,mpi_integer,0,mpi_comm_world,ierr)
513: 
514:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(igrads,1,mpi_integer,0,mpi_comm_world,ierr)
515:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ibigend,1,mpi_integer,0,mpi_comm_world,ierr)
516:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ibyte,1,mpi_integer,0,mpi_comm_world,ierr)
517:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(iotyp,1,mpi_integer,0,mpi_comm_world,ierr)
518: 
519:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(debug_level,1,mpi_integer,0,mpi_comm_world,ierr)
520: 
521:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(nspgx,1,mpi_integer,0,mpi_comm_world,ierr)
522:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(nspgd,1,mpi_integer,0,mpi_comm_world,ierr)
523: 
524:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(nsplit,1,mpi_integer,0,mpi_comm_world,ierr)
525: 
526:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(lkpts,1,mpi_integer,0,mpi_comm_world,ierr)
527: 
528:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(lsmtyp,4,mpi_character,0,mpi_comm_world,ierr)
529:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ehso4,1,mpi_logical,0,mpi_comm_world,ierr)
530: 
531:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(aertyp,7,mpi_character,0,mpi_comm_world,ierr)
532:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ntr,1,mpi_integer,0,mpi_comm_world,ierr)
533:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(nbin,1,mpi_integer,0,mpi_comm_world,ierr)
534: 
535: !       Setup all convenience dimensions
536: 
537:         if ( myid/= 0) then
538:           iym1 = iy - 1
539:           iym2 = iy - 2
540:           iym3 = iy - 3
541:           jxp1 = jx + 1
542:           jxm1 = jx - 1
543:           jxm2 = jx - 2
544:           kzm1 = kz - 1
545:           kzm2 = kz - 2
546:           kzp1 = kz + 1
547:           kzp2 = kz + 2
548:           kzp3 = kz + 3
549:           kzp4 = kz + 4
550:           iysg = iy * nsg
551:           jxsg = jx * nsg
552:           iym1sg = (iy-1) * nsg
553:           jxm1sg = (jx-1) * nsg
554:           iym2sg = (iy-2) * nsg
555:           jxm2sg = (jx-2) * nsg
556:           nnsg = nsg*nsg
557:         end if
558: 
559:         call <a href="#" TARGET=CENT_PANEL>mpi_barrier</a>(mpi_comm_world,ierr)
560: 
561:       end subroutine broadcast_params
562: #endif
563: 
564:       end module mod_dynparam
</PRE>

<HR>

</BODY>
</HTML>
