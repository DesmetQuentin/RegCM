<HTML>

<HEAD>
<TITLE>diffu.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>diffu.F90</H1>
<HR>
<H2 ALIGN=CENTER>diffu.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=diffu_u><H3>diffu_u</H3></a></p> Click <a href="./callingtree/diffu_u_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where diffu_u is used.
<hr>
20:       subroutine diffu_u(ften,xkc,c203,j,ind)
21: !                                                                     c
22: !     this subroutine computes the diffusion term for decoupled       c
23: !     variable on constant sigma surface.                             c
24: !                                                                     c
25: !     ften    : tendency for variable ubd3d                           c
26: !                                                                     c
27: !     ubd3d   : coupled variable at time t-1                          c
28: !                                                                     c
29: !     xkc     : horizontal diffusion coefficient                      c
30: !                                                                     c
31: !     msfd    : map scale factor at the points where ubd3d is defined c
32: !                                                                     c
33: !     scr     : dummy array used for working space                    c
34: !                                                                     c
35: !     c203    : 1./(dx*dx), defined in 'param'                        c
36: !                                                                     c
37: !     j       : j'th slice of variable ubd3d                          c
38: !                                                                     c
39: !     iend    : = iym2 for cross-point variables                      c
40: !               = iym1  for dot-point   variables                      c
41: !                                                                     c
42: !     jend    : = jxm2 for cross-point variables                      c
43: !               = jlx  for dot-point   variables                      c
44: !                                                                     c
45: !     ind = 1 : ubd3d is already multiplied by map scale factor (msfd)c
46: !         = 0 : ubd3d is "not"   multiplied by msfd                   c
47: !                                                                     c
48: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
49:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
50:       use <a href="./mod_slice.F90.html#mod_slice" TARGET=CENT_PANEL>mod_slice</a>
51:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
52:       implicit none
53: !
54: ! Dummy arguments
55: !
56:       real(8) :: c203
57:       integer :: ind , j
58:       real(8) , dimension(iy,kz) :: ften , xkc
59:       intent (in) c203 , ind , j , xkc
60:       intent (inout) ften
61: !
62: ! Local variables
63: !
64:       integer :: i , k
65: !
66: !---------------------------------------------------------------------
67: !
68: #ifdef MPP1
69:       if ( (myid.eq.0 .and. j.eq.2) .or.                                &
70:          & (myid.eq.nproc-1 .and. j.eq.jendx) ) then
71: #else
72:       if (j.eq.2 .or. j.eq.jxm1) then
73: #endif
74: !
75: !......second-order scheme for east or west boundary:
76:         do k = 1 , kz
77:           do i = 2 , iym1
78:             if ( ind.eq.0 ) then
79:               ften(i,k) = ften(i,k) + xkc(i,k)                          &
80:                         & *c203*(ubd3d(i,k,j+1)+ubd3d(i,k,j-1)          &
81:                         & +ubd3d(i+1,k,j)+ubd3d(i-1,k,j)-4.*ubd3d(i,k,j)&
82:                         & )*pdotb(i,j)
83:             else
84:               ften(i,k) = ften(i,k) + xkc(i,k)                          &
85:                         & *c203*(ubd3d(i,k,j+1)/msfd(i,j+1)             &
86:                         & +ubd3d(i,k,j-1)/msfd(i,j-1)+ubd3d(i+1,k,j)    &
87:                         & /msfd(i+1,j)+ubd3d(i-1,k,j)/msfd(i-1,j)       &
88:                         & -4.*ubd3d(i,k,j)/msfd(i,j))*pdotb(i,j)
89:             end if
90:           end do
91:         end do
92: !
93:       else
94: !
95: !.....fourth-order scheme for interior:
96:         do k = 1 , kz
97:           do i = 3 , iym1 - 1
98:             if ( ind.eq.0 ) then
99:               ften(i,k) = ften(i,k) - xkc(i,k)                          &
100:                         & *c203*(ubd3d(i,k,j+2)+ubd3d(i,k,j-2)          &
101:                         & +ubd3d(i+2,k,j)+ubd3d(i-2,k,j)                &
102:                         & -4.*(ubd3d(i,k,j+1)+ubd3d(i,k,j-1)            &
103:                         & +ubd3d(i+1,k,j)+ubd3d(i-1,k,j))               &
104:                         & +12.*ubd3d(i,k,j))*pdotb(i,j)
105:             else
106:               ften(i,k) = ften(i,k) - xkc(i,k)                          &
107:                         & *c203*(ubd3d(i,k,j+2)/msfd(i,j+2)             &
108:                         & +ubd3d(i,k,j-2)/msfd(i,j-2)+ubd3d(i+2,k,j)    &
109:                         & /msfd(i+2,j)+ubd3d(i-2,k,j)/msfd(i-2,j)       &
110:                         & -4.*(ubd3d(i,k,j+1)/msfd(i,j+1)+ubd3d(i,k,j-1)&
111:                         & /msfd(i,j-1)+ubd3d(i+1,k,j)/msfd(i+1,j)       &
112:                         & +ubd3d(i-1,k,j)/msfd(i-1,j))+12.*ubd3d(i,k,j) &
113:                         & /msfd(i,j))*pdotb(i,j)
114:             end if
115:           end do
116:         end do
117: !......second-order scheme for north and south boundaries:
118:         do i = 2 , iym1 , iym1 - 2
119:           do k = 1 , kz
120:             if ( ind.eq.0 ) then
121:               ften(i,k) = ften(i,k) + xkc(i,k)                          &
122:                         & *c203*(ubd3d(i,k,j+1)+ubd3d(i,k,j-1)          &
123:                         & +ubd3d(i+1,k,j)+ubd3d(i-1,k,j)-4.*ubd3d(i,k,j)&
124:                         & )*pdotb(i,j)
125:             else
126:               ften(i,k) = ften(i,k) + xkc(i,k)                          &
127:                         & *c203*(ubd3d(i,k,j+1)/msfd(i,j+1)             &
128:                         & +ubd3d(i,k,j-1)/msfd(i,j-1)+ubd3d(i+1,k,j)    &
129:                         & /msfd(i+1,j)+ubd3d(i-1,k,j)/msfd(i-1,j)       &
130:                         & -4.*ubd3d(i,k,j)/msfd(i,j))*pdotb(i,j)
131:             end if
132:           end do
133:         end do
134: !
135:       end if
136: !
137:       end subroutine diffu_u
138: !
139: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
<p><a name=diffu_v><H3>diffu_v</H3></a></p> Click <a href="./callingtree/diffu_v_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where diffu_v is used.
<hr>
140:       subroutine diffu_v(ften,xkc,c203,j,ind)
141: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
142: !                                                                     c
143: !     this subroutine computes the diffusion term for decoupled       c
144: !     variable on constant sigma surface.                             c
145: !                                                                     c
146: !     ften    : tendency for variable vbd3d                           c
147: !                                                                     c
148: !     vbd3d   : coupled variable at time t-1                          c
149: !                                                                     c
150: !     xkc     : horizontal diffusion coefficient                      c
151: !                                                                     c
152: !     msfd    : map scale factor at the points where vbd3d is defined c
153: !                                                                     c
154: !     scr     : dummy array used for working space                    c
155: !                                                                     c
156: !     c203    : 1./(dx*dx), defined in 'param'                        c
157: !                                                                     c
158: !     j       : j'th slice of variable vbd3d                          c
159: !                                                                     c
160: !     iend    : = iym2 for cross-point variables                      c
161: !               = iym1  for dot-point   variables                      c
162: !                                                                     c
163: !     jend    : = jxm2 for cross-point variables                      c
164: !               = jlx  for dot-point   variables                      c
165: !                                                                     c
166: !     ind = 1 : vbd3d is already multiplied by map scale factor (msfd)c
167: !         = 0 : vbd3d is "not"   multiplied by msfd                   c
168: !                                                                     c
169: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
170:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
171:       use <a href="./mod_slice.F90.html#mod_slice" TARGET=CENT_PANEL>mod_slice</a>
172:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
173:       implicit none
174: !
175: ! Dummy arguments
176: !
177:       real(8) :: c203
178:       integer :: ind , j
179:       real(8) , dimension(iy,kz) :: ften , xkc
180:       intent (in) c203 , ind , j , xkc
181:       intent (inout) ften
182: !
183: ! Local variables
184: !
185:       integer :: i , k
186: !
187: !---------------------------------------------------------------------
188: !
189: #ifdef MPP1
190:       if ( (myid.eq.0 .and. j.eq.2) .or.                                &
191:          & (myid.eq.nproc-1 .and. j.eq.jendx) ) then
192: #else
193:       if (j.eq.2 .or. j.eq.jxm1) then
194: #endif
195: !
196: !......second-order scheme for east or west boundary:
197:         do k = 1 , kz
198:           do i = 2 , iym1
199:             if ( ind.eq.0 ) then
200:               ften(i,k) = ften(i,k) + xkc(i,k)                          &
201:                         & *c203*(vbd3d(i,k,j+1)+vbd3d(i,k,j-1)          &
202:                         & +vbd3d(i+1,k,j)+vbd3d(i-1,k,j)-4.*vbd3d(i,k,j)&
203:                         & )*pdotb(i,j)
204:             else
205:               ften(i,k) = ften(i,k) + xkc(i,k)                          &
206:                         & *c203*(vbd3d(i,k,j+1)/msfd(i,j+1)             &
207:                         & +vbd3d(i,k,j-1)/msfd(i,j-1)+vbd3d(i+1,k,j)    &
208:                         & /msfd(i+1,j)+vbd3d(i-1,k,j)/msfd(i-1,j)       &
209:                         & -4.*vbd3d(i,k,j)/msfd(i,j))*pdotb(i,j)
210:             end if
211:           end do
212:         end do
213: !
214:       else
215: !
216: !.....fourth-order scheme for interior:
217:         do k = 1 , kz
218:           do i = 3 , iym1 - 1
219:             if ( ind.eq.0 ) then
220:               ften(i,k) = ften(i,k) - xkc(i,k)                          &
221:                         & *c203*(vbd3d(i,k,j+2)+vbd3d(i,k,j-2)          &
222:                         & +vbd3d(i+2,k,j)+vbd3d(i-2,k,j)                &
223:                         & -4.*(vbd3d(i,k,j+1)+vbd3d(i,k,j-1)            &
224:                         & +vbd3d(i+1,k,j)+vbd3d(i-1,k,j))               &
225:                         & +12.*vbd3d(i,k,j))*pdotb(i,j)
226:             else
227:               ften(i,k) = ften(i,k) - xkc(i,k)                          &
228:                         & *c203*(vbd3d(i,k,j+2)/msfd(i,j+2)             &
229:                         & +vbd3d(i,k,j-2)/msfd(i,j-2)+vbd3d(i+2,k,j)    &
230:                         & /msfd(i+2,j)+vbd3d(i-2,k,j)/msfd(i-2,j)       &
231:                         & -4.*(vbd3d(i,k,j+1)/msfd(i,j+1)+vbd3d(i,k,j-1)&
232:                         & /msfd(i,j-1)+vbd3d(i+1,k,j)/msfd(i+1,j)       &
233:                         & +vbd3d(i-1,k,j)/msfd(i-1,j))+12.*vbd3d(i,k,j) &
234:                         & /msfd(i,j))*pdotb(i,j)
235:             end if
236:           end do
237:         end do
238: !......second-order scheme for north and south boundaries:
239:         do i = 2 , iym1 , iym1 - 2
240:           do k = 1 , kz
241:             if ( ind.eq.0 ) then
242:               ften(i,k) = ften(i,k) + xkc(i,k)                          &
243:                         & *c203*(vbd3d(i,k,j+1)+vbd3d(i,k,j-1)          &
244:                         & +vbd3d(i+1,k,j)+vbd3d(i-1,k,j)-4.*vbd3d(i,k,j)&
245:                         & )*pdotb(i,j)
246:             else
247:               ften(i,k) = ften(i,k) + xkc(i,k)                          &
248:                         & *c203*(vbd3d(i,k,j+1)/msfd(i,j+1)             &
249:                         & +vbd3d(i,k,j-1)/msfd(i,j-1)+vbd3d(i+1,k,j)    &
250:                         & /msfd(i+1,j)+vbd3d(i-1,k,j)/msfd(i-1,j)       &
251:                         & -4.*vbd3d(i,k,j)/msfd(i,j))*pdotb(i,j)
252:             end if
253:           end do
254:         end do
255: !
256:       end if
257: !
258:       end subroutine diffu_v
</PRE>

<HR>

</BODY>
</HTML>
