<HTML>

<HEAD>
<TITLE>hadv.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>hadv.F90</H1>
<HR>
<H2 ALIGN=CENTER>hadv.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=hadv_t><H3>hadv_t</H3></a></p> Click <a href="./callingtree/hadv_t_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where hadv_t is used.
<hr>
20:       subroutine hadv_t(ften,dxx,j,ind)
21: 
22: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
23: !                                                                     c
24: !     this subroutine computes the horizontal flux-divergence terms.  c
25: !     second-order difference is used.                                c
26: !                                                                     c
27: !     ften   : is the tendency for variable 'f'.                      c
28: !                                                                     c
29: !     ua, va : are p*u and p*v.                                       c
30: !                                                                     c
31: !     msfx   : is the map scale factor.                               c
32: !                                                                     c
33: !     dxx    : is the horizontal distance.                            c
34: !              = dx4  for ind=1.                                      c
35: !              = dx   for ind=2.                                      c
36: !              = dx16 for ind=3.                                      c
37: !                                                                     c
38: !     j      : is the j'th slice of f anf ften.                       c
39: !                                                                     c
40: !     ind = 1 : for t and qv.                                         c
41: !         = 2 : for qc and qr.                                        c
42: !         = 3 : for u and v.                                          c
43: !                                                                     c
44: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
45: 
46:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
47:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
48:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
49:       implicit none
50: !
51: ! Dummy arguments
52: !
53:       real(8) :: dxx
54:       integer :: ind , j
55:       real(8) , dimension(iy,kz) :: ften
56:       intent (in) dxx , ind , j
57:       intent (inout) ften
58: !
59: ! Local variables
60: !
61:       real(8) :: fact1 , fact2 , fx1 , fx2 , fy1 , fy2 , uavg1 , uavg2 ,&
62:                & ucmona , ucmonb , ucmonc , vavg1 , vavg2 , vcmona ,    &
63:                & vcmonb , vcmonc
64:       integer :: i , idx , idxm1 , idxp1 , jdx , jdxm1 , jdxp1 , k
65: !
66: !----------------------------------------------------------------------
67: !
68:       if ( ind.eq.1 ) then
69: !
70: !-----for t and qv:
71: !
72:         do k = 1 , kz
73:           do i = 2 , iym2
74:             ften(i,k) = ften(i,k)                                       &
75:                       & - ((ua(i+1,k,j+1)+ua(i,k,j+1))*(t(i,k,j+1)      &
76:                       & +t(i,k,j))-(ua(i+1,k,j)+ua(i,k,j))              &
77:                       & *(t(i,k,j)+t(i,k,j-1))                          &
78:                       & +(va(i+1,k,j+1)+va(i+1,k,j))                    &
79:                       & *(t(i+1,k,j)+t(i,k,j))-(va(i,k,j+1)+va(i,k,j))  &
80:                       & *(t(i-1,k,j)+t(i,k,j)))                         &
81:                       & /(dxx*msfx(i,j)*msfx(i,j))
82:           end do
83:         end do
84: !
85:       else if ( ind.eq.2 ) then
86: !
87: !       implement a "relaxed" upstream scheme
88: !
89: !hy     fact1=0.75
90:         fact1 = 0.60
91:         fact2 = 1. - fact1
92: !
93: !-----for qc and qr:
94: !       up-wind values of qc and qr are used.
95: !
96:         do k = 1 , kz
97:           do i = 2 , iym2
98:             uavg2 = 0.5*(ua(i+1,k,j+1)+ua(i,k,j+1))
99:             uavg1 = 0.5*(ua(i+1,k,j)+ua(i,k,j))
100:             if ( uavg2.ge.0. ) then
101:               fx2 = fact1*t(i,k,j) + fact2*t(i,k,j+1)
102:             else
103:               fx2 = fact1*t(i,k,j+1) + fact2*t(i,k,j)
104:             end if
105:             if ( uavg1.ge.0. ) then
106:               fx1 = fact1*t(i,k,j-1) + fact2*t(i,k,j)
107:             else
108:               fx1 = fact1*t(i,k,j) + fact2*t(i,k,j-1)
109:             end if
110:             vavg2 = 0.5*(va(i+1,k,j+1)+va(i+1,k,j))
111:             vavg1 = 0.5*(va(i,k,j+1)+va(i,k,j))
112:             if ( vavg2.ge.0. ) then
113:               fy2 = fact1*t(i,k,j) + fact2*t(i+1,k,j)
114:             else
115:               fy2 = fact1*t(i+1,k,j) + fact2*t(i,k,j)
116:             end if
117:             if ( vavg1.ge.0. ) then
118:               fy1 = fact1*t(i-1,k,j) + fact2*t(i,k,j)
119:             else
120:               fy1 = fact1*t(i,k,j) + fact2*t(i-1,k,j)
121:             end if
122:             ften(i,k) = ften(i,k)                                       &
123:                       & - (uavg2*fx2-uavg1*fx1+vavg2*fy2-vavg1*fy1)     &
124:                       & /(dxx*msfx(i,j)*msfx(i,j))
125:           end do
126:         end do
127: !
128:       else if ( ind.eq.3 ) then
129: !
130: !-----for u and v:
131: !
132:         jdx = j
133:         jdxp1 = j + 1
134:         jdxm1 = j - 1
135: #ifdef MPP1
136:         if ( myid.eq.0 ) jdxm1 = max0(jdxm1,2)
137:         if ( myid.eq.nproc-1 ) jdxp1 = min0(jdxp1,jendl-1)
138: #else
139:         jdxp1 = min0(jdxp1,jxm1)
140:         jdxm1 = max0(jdxm1,2)
141: #endif
142: !
143:         do k = 1 , kz
144:           do i = 2 , iym1
145:             idx = i
146:             idxp1 = i + 1
147:             idxp1 = min0(idxp1,iym1)
148:             idxm1 = i - 1
149:             idxm1 = max0(idxm1,2)
150:             ucmona = ua(idxp1,k,jdx) + 2.*ua(idx,k,jdx)                 &
151:                    & + ua(idxm1,k,jdx)
152:             vcmona = va(idx,k,jdxp1) + 2.*va(idx,k,jdx)                 &
153:                    & + va(idx,k,jdxm1)
154:             ucmonb = ua(idxp1,k,jdxp1) + 2.*ua(idx,k,jdxp1)             &
155:                    & + ua(idxm1,k,jdxp1) + ucmona
156:             vcmonb = va(idxp1,k,jdxp1) + 2.*va(idxp1,k,jdx)             &
157:                    & + va(idxp1,k,jdxm1) + vcmona
158:             ucmonc = ua(idxp1,k,jdxm1) + 2.*ua(idx,k,jdxm1)             &
159:                    & + ua(idxm1,k,jdxm1) + ucmona
160:             vcmonc = va(idxm1,k,jdxp1) + 2.*va(idxm1,k,jdx)             &
161:                    & + va(idxm1,k,jdxm1) + vcmona
162:             ften(i,k) = ften(i,k)                                       &
163:                       & - ((t(i,k,j+1)+t(i,k,j))*ucmonb-(t(i,k,j)       &
164:                       & +t(i,k,j-1))*ucmonc+(t(i+1,k,j)+t(i,k,j))       &
165:                       & *vcmonb-(t(i,k,j)+t(i-1,k,j))*vcmonc)           &
166:                       & /(dxx*msfx(i,j)*msfx(i,j))
167:           end do
168:         end do
169: !
170:       else
171:       end if
172: !
173:       end subroutine hadv_t
174: !
175: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
176: !
<p><a name=hadv_u><H3>hadv_u</H3></a></p> Click <a href="./callingtree/hadv_u_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where hadv_u is used.
<hr>
177:       subroutine hadv_u(ften,dxx,j,ind)
178: 
179: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
180: !                                                                     c
181: !     this subroutine computes the horizontal flux-divergence terms.  c
182: !     second-order difference is used.                                c
183: !                                                                     c
184: !     ften   : is the tendency for variable 'f'.                      c
185: !                                                                     c
186: !     ua, va : are p*u and p*v.                                       c
187: !                                                                     c
188: !     msfd   : is the map scale factor.                               c
189: !                                                                     c
190: !     dxx    : is the horizontal distance.                            c
191: !              = dx4  for ind=1.                                      c
192: !              = dx   for ind=2.                                      c
193: !              = dx16 for ind=3.                                      c
194: !                                                                     c
195: !     j      : is the j'th slice of f anf ften.                       c
196: !                                                                     c
197: !     ind = 1 : for t and qv.                                         c
198: !         = 2 : for qc and qr.                                        c
199: !         = 3 : for u and v.                                          c
200: !                                                                     c
201: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
202: 
203:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
204:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
205:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
206:       implicit none
207: !
208: ! Dummy arguments
209: !
210:       real(8) :: dxx
211:       integer :: ind , j
212:       real(8) , dimension(iy,kz) :: ften
213:       intent (in) dxx , ind , j
214:       intent (inout) ften
215: !
216: ! Local variables
217: !
218:       real(8) :: fact1 , fact2 , fx1 , fx2 , fy1 , fy2 , uavg1 , uavg2 ,&
219:                & ucmona , ucmonb , ucmonc , vavg1 , vavg2 , vcmona ,    &
220:                & vcmonb , vcmonc
221:       integer :: i , idx , idxm1 , idxp1 , jdx , jdxm1 , jdxp1 , k
222: !
223: !----------------------------------------------------------------------
224: !
225:       if ( ind.eq.1 ) then
226: !
227: !-----for t and qv:
228: !
229:         do k = 1 , kz
230:           do i = 2 , iym2
231:             ften(i,k) = ften(i,k)                                       &
232:                       & - ((ua(i+1,k,j+1)+ua(i,k,j+1))*(u(i,k,j+1)      &
233:                       & +u(i,k,j))-(ua(i+1,k,j)+ua(i,k,j))              &
234:                       & *(u(i,k,j)+u(i,k,j-1))                          &
235:                       & +(va(i+1,k,j+1)+va(i+1,k,j))                    &
236:                       & *(u(i+1,k,j)+u(i,k,j))-(va(i,k,j+1)+va(i,k,j))  &
237:                       & *(u(i-1,k,j)+u(i,k,j)))                         &
238:                       & /(dxx*msfd(i,j)*msfd(i,j))
239:           end do
240:         end do
241: !
242:       else if ( ind.eq.2 ) then
243: !
244: !       implement a "relaxed" upstream scheme
245: !
246: !hy     fact1=0.75
247:         fact1 = 0.60
248:         fact2 = 1. - fact1
249: !
250: !-----for qc and qr:
251: !       up-wind values of qc and qr are used.
252: !
253:         do k = 1 , kz
254:           do i = 2 , iym2
255:             uavg2 = 0.5*(ua(i+1,k,j+1)+ua(i,k,j+1))
256:             uavg1 = 0.5*(ua(i+1,k,j)+ua(i,k,j))
257:             if ( uavg2.ge.0. ) then
258:               fx2 = fact1*u(i,k,j) + fact2*u(i,k,j+1)
259:             else
260:               fx2 = fact1*u(i,k,j+1) + fact2*u(i,k,j)
261:             end if
262:             if ( uavg1.ge.0. ) then
263:               fx1 = fact1*u(i,k,j-1) + fact2*u(i,k,j)
264:             else
265:               fx1 = fact1*u(i,k,j) + fact2*u(i,k,j-1)
266:             end if
267:             vavg2 = 0.5*(va(i+1,k,j+1)+va(i+1,k,j))
268:             vavg1 = 0.5*(va(i,k,j+1)+va(i,k,j))
269:             if ( vavg2.ge.0. ) then
270:               fy2 = fact1*u(i,k,j) + fact2*u(i+1,k,j)
271:             else
272:               fy2 = fact1*u(i+1,k,j) + fact2*u(i,k,j)
273:             end if
274:             if ( vavg1.ge.0. ) then
275:               fy1 = fact1*u(i-1,k,j) + fact2*u(i,k,j)
276:             else
277:               fy1 = fact1*u(i,k,j) + fact2*u(i-1,k,j)
278:             end if
279:             ften(i,k) = ften(i,k)                                       &
280:                       & - (uavg2*fx2-uavg1*fx1+vavg2*fy2-vavg1*fy1)     &
281:                       & /(dxx*msfd(i,j)*msfd(i,j))
282:           end do
283:         end do
284: !
285:       else if ( ind.eq.3 ) then
286: !
287: !-----for u and v:
288: !
289:         jdx = j
290:         jdxp1 = j + 1
291:         jdxm1 = j - 1
292: #ifdef MPP1
293:         if ( myid.eq.0 ) jdxm1 = max0(jdxm1,2)
294:         if ( myid.eq.nproc-1 ) jdxp1 = min0(jdxp1,jendl-1)
295: #else
296:         jdxp1 = min0(jdxp1,jxm1)
297:         jdxm1 = max0(jdxm1,2)
298: #endif
299: !
300:         do k = 1 , kz
301:           do i = 2 , iym1
302:             idx = i
303:             idxp1 = i + 1
304:             idxp1 = min0(idxp1,iym1)
305:             idxm1 = i - 1
306:             idxm1 = max0(idxm1,2)
307:             ucmona = ua(idxp1,k,jdx) + 2.*ua(idx,k,jdx)                 &
308:                    & + ua(idxm1,k,jdx)
309:             vcmona = va(idx,k,jdxp1) + 2.*va(idx,k,jdx)                 &
310:                    & + va(idx,k,jdxm1)
311:             ucmonb = ua(idxp1,k,jdxp1) + 2.*ua(idx,k,jdxp1)             &
312:                    & + ua(idxm1,k,jdxp1) + ucmona
313:             vcmonb = va(idxp1,k,jdxp1) + 2.*va(idxp1,k,jdx)             &
314:                    & + va(idxp1,k,jdxm1) + vcmona
315:             ucmonc = ua(idxp1,k,jdxm1) + 2.*ua(idx,k,jdxm1)             &
316:                    & + ua(idxm1,k,jdxm1) + ucmona
317:             vcmonc = va(idxm1,k,jdxp1) + 2.*va(idxm1,k,jdx)             &
318:                    & + va(idxm1,k,jdxm1) + vcmona
319:             ften(i,k) = ften(i,k)                                       &
320:                       & - ((u(i,k,j+1)+u(i,k,j))*ucmonb-(u(i,k,j)       &
321:                       & +u(i,k,j-1))*ucmonc+(u(i+1,k,j)+u(i,k,j))       &
322:                       & *vcmonb-(u(i,k,j)+u(i-1,k,j))*vcmonc)           &
323:                       & /(dxx*msfd(i,j)*msfd(i,j))
324:           end do
325:         end do
326: !
327:       else
328:       end if
329: !
330:       end subroutine hadv_u
331: !
332: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
333: !
<p><a name=hadv_v><H3>hadv_v</H3></a></p> Click <a href="./callingtree/hadv_v_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where hadv_v is used.
<hr>
334:       subroutine hadv_v(ften,dxx,j,ind)
335: 
336: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
337: !                                                                     c
338: !     this subroutine computes the horizontal flux-divergence terms.  c
339: !     second-order difference is used.                                c
340: !                                                                     c
341: !     ften   : is the tendency for variable 'f'.                      c
342: !                                                                     c
343: !     ua, va : are p*u and p*v.                                       c
344: !                                                                     c
345: !     msfd   : is the map scale factor.                               c
346: !                                                                     c
347: !     dxx    : is the horizontal distance.                            c
348: !              = dx4  for ind=1.                                      c
349: !              = dx   for ind=2.                                      c
350: !              = dx16 for ind=3.                                      c
351: !                                                                     c
352: !     j      : is the j'th slice of f anf ften.                       c
353: !                                                                     c
354: !     ind = 1 : for t and qv.                                         c
355: !         = 2 : for qc and qr.                                        c
356: !         = 3 : for u and v.                                          c
357: !                                                                     c
358: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
359: 
360:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
361:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
362:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
363:       implicit none
364: !
365: ! Dummy arguments
366: !
367:       real(8) :: dxx
368:       integer :: ind , j
369:       real(8) , dimension(iy,kz) :: ften
370:       intent (in) dxx , ind , j
371:       intent (inout) ften
372: !
373: ! Local variables
374: !
375:       real(8) :: fact1 , fact2 , fx1 , fx2 , fy1 , fy2 , uavg1 , uavg2 ,&
376:                & ucmona , ucmonb , ucmonc , vavg1 , vavg2 , vcmona ,    &
377:                & vcmonb , vcmonc
378:       integer :: i , idx , idxm1 , idxp1 , jdx , jdxm1 , jdxp1 , k
379: !
380: !----------------------------------------------------------------------
381: !
382:       if ( ind.eq.1 ) then
383: !
384: !-----for t and qv:
385: !
386:         do k = 1 , kz
387:           do i = 2 , iym2
388:             ften(i,k) = ften(i,k)                                       &
389:                       & - ((ua(i+1,k,j+1)+ua(i,k,j+1))*(v(i,k,j+1)      &
390:                       & +v(i,k,j))-(ua(i+1,k,j)+ua(i,k,j))              &
391:                       & *(v(i,k,j)+v(i,k,j-1))                          &
392:                       & +(va(i+1,k,j+1)+va(i+1,k,j))                    &
393:                       & *(v(i+1,k,j)+v(i,k,j))-(va(i,k,j+1)+va(i,k,j))  &
394:                       & *(v(i-1,k,j)+v(i,k,j)))                         &
395:                       & /(dxx*msfd(i,j)*msfd(i,j))
396:           end do
397:         end do
398: !
399:       else if ( ind.eq.2 ) then
400: !
401: !       implement a "relaxed" upstream scheme
402: !
403: !hy     fact1=0.75
404:         fact1 = 0.60
405:         fact2 = 1. - fact1
406: !
407: !-----for qc and qr:
408: !       up-wind values of qc and qr are used.
409: !
410:         do k = 1 , kz
411:           do i = 2 , iym2
412:             uavg2 = 0.5*(ua(i+1,k,j+1)+ua(i,k,j+1))
413:             uavg1 = 0.5*(ua(i+1,k,j)+ua(i,k,j))
414:             if ( uavg2.ge.0. ) then
415:               fx2 = fact1*v(i,k,j) + fact2*v(i,k,j+1)
416:             else
417:               fx2 = fact1*v(i,k,j+1) + fact2*v(i,k,j)
418:             end if
419:             if ( uavg1.ge.0. ) then
420:               fx1 = fact1*v(i,k,j-1) + fact2*v(i,k,j)
421:             else
422:               fx1 = fact1*v(i,k,j) + fact2*v(i,k,j-1)
423:             end if
424:             vavg2 = 0.5*(va(i+1,k,j+1)+va(i+1,k,j))
425:             vavg1 = 0.5*(va(i,k,j+1)+va(i,k,j))
426:             if ( vavg2.ge.0. ) then
427:               fy2 = fact1*v(i,k,j) + fact2*v(i+1,k,j)
428:             else
429:               fy2 = fact1*v(i+1,k,j) + fact2*v(i,k,j)
430:             end if
431:             if ( vavg1.ge.0. ) then
432:               fy1 = fact1*v(i-1,k,j) + fact2*v(i,k,j)
433:             else
434:               fy1 = fact1*v(i,k,j) + fact2*v(i-1,k,j)
435:             end if
436:             ften(i,k) = ften(i,k)                                       &
437:                       & - (uavg2*fx2-uavg1*fx1+vavg2*fy2-vavg1*fy1)     &
438:                       & /(dxx*msfd(i,j)*msfd(i,j))
439:           end do
440:         end do
441: !
442:       else if ( ind.eq.3 ) then
443: !
444: !-----for u and v:
445: !
446:         jdx = j
447:         jdxp1 = j + 1
448:         jdxm1 = j - 1
449: #ifdef MPP1
450:         if ( myid.eq.0 ) jdxm1 = max0(jdxm1,2)
451:         if ( myid.eq.nproc-1 ) jdxp1 = min0(jdxp1,jendl-1)
452: #else
453:         jdxp1 = min0(jdxp1,jxm1)
454:         jdxm1 = max0(jdxm1,2)
455: #endif
456: !
457:         do k = 1 , kz
458:           do i = 2 , iym1
459:             idx = i
460:             idxp1 = i + 1
461:             idxp1 = min0(idxp1,iym1)
462:             idxm1 = i - 1
463:             idxm1 = max0(idxm1,2)
464:             ucmona = ua(idxp1,k,jdx) + 2.*ua(idx,k,jdx)                 &
465:                    & + ua(idxm1,k,jdx)
466:             vcmona = va(idx,k,jdxp1) + 2.*va(idx,k,jdx)                 &
467:                    & + va(idx,k,jdxm1)
468:             ucmonb = ua(idxp1,k,jdxp1) + 2.*ua(idx,k,jdxp1)             &
469:                    & + ua(idxm1,k,jdxp1) + ucmona
470:             vcmonb = va(idxp1,k,jdxp1) + 2.*va(idxp1,k,jdx)             &
471:                    & + va(idxp1,k,jdxm1) + vcmona
472:             ucmonc = ua(idxp1,k,jdxm1) + 2.*ua(idx,k,jdxm1)             &
473:                    & + ua(idxm1,k,jdxm1) + ucmona
474:             vcmonc = va(idxm1,k,jdxp1) + 2.*va(idxm1,k,jdx)             &
475:                    & + va(idxm1,k,jdxm1) + vcmona
476:             ften(i,k) = ften(i,k)                                       &
477:                       & - ((v(i,k,j+1)+v(i,k,j))*ucmonb-(v(i,k,j)       &
478:                       & +v(i,k,j-1))*ucmonc+(v(i+1,k,j)+v(i,k,j))       &
479:                       & *vcmonb-(v(i,k,j)+v(i-1,k,j))*vcmonc)           &
480:                       & /(dxx*msfd(i,j)*msfd(i,j))
481:           end do
482:         end do
483: !
484:       else
485:       end if
486: !
487:       end subroutine hadv_v
488: !
489: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
490: !
<p><a name=hadvqv><H3>hadvqv</H3></a></p> Click <a href="./callingtree/hadvqv_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where hadvqv is used.
<hr>
491:       subroutine hadvqv(ften,dxx,j,ind)
492: 
493: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
494: !                                                                     c
495: !     this subroutine computes the horizontal flux-divergence terms.  c
496: !     second-order difference is used.                                c
497: !                                                                     c
498: !     ften   : is the tendency for variable 'f'.                      c
499: !                                                                     c
500: !     ua, va : are p*u and p*v.                                       c
501: !                                                                     c
502: !     msfx   : is the map scale factor.                               c
503: !                                                                     c
504: !     dxx    : is the horizontal distance.                            c
505: !              = dx4  for ind=1.                                      c
506: !              = dx   for ind=2.                                      c
507: !              = dx16 for ind=3.                                      c
508: !                                                                     c
509: !     j      : is the j'th slice of f anf ften.                       c
510: !                                                                     c
511: !     ind = 1 : for t and qv.                                         c
512: !         = 2 : for qc and qr.                                        c
513: !         = 3 : for u and v.                                          c
514: !                                                                     c
515: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
516: 
517:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
518:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
519:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
520:       implicit none
521: !
522: ! Dummy arguments
523: !
524:       real(8) :: dxx
525:       integer :: ind , j
526:       real(8) , dimension(iy,kz) :: ften
527:       intent (in) dxx , ind , j
528:       intent (inout) ften
529: !
530: ! Local variables
531: !
532:       real(8) :: fact1 , fact2 , fx1 , fx2 , fy1 , fy2 , uavg1 , uavg2 ,&
533:                & ucmona , ucmonb , ucmonc , vavg1 , vavg2 , vcmona ,    &
534:                & vcmonb , vcmonc
535:       integer :: i , idx , idxm1 , idxp1 , jdx , jdxm1 , jdxp1 , k
536: !
537: !----------------------------------------------------------------------
538: !
539:       if ( ind.eq.1 ) then
540: !
541: !-----for t and qv:
542: !
543:         do k = 1 , kz
544:           do i = 2 , iym2
545:             ften(i,k) = ften(i,k)                                       &
546:                       & - ((ua(i+1,k,j+1)+ua(i,k,j+1))*(qv(i,k,j+1)     &
547:                       & +qv(i,k,j))-(ua(i+1,k,j)+ua(i,k,j))             &
548:                       & *(qv(i,k,j)+qv(i,k,j-1))                        &
549:                       & +(va(i+1,k,j+1)+va(i+1,k,j))                    &
550:                       & *(qv(i+1,k,j)+qv(i,k,j))-(va(i,k,j+1)+va(i,k,j))&
551:                       & *(qv(i-1,k,j)+qv(i,k,j)))                       &
552:                       & /(dxx*msfx(i,j)*msfx(i,j))
553:           end do
554:         end do
555: !
556:       else if ( ind.eq.2 ) then
557: !
558: !       implement a "relaxed" upstream scheme
559: !
560: !hy     fact1=0.75
561:         fact1 = 0.60
562:         fact2 = 1. - fact1
563: !
564: !-----for qc and qr:
565: !       up-wind values of qc and qr are used.
566: !
567:         do k = 1 , kz
568:           do i = 2 , iym2
569:             uavg2 = 0.5*(ua(i+1,k,j+1)+ua(i,k,j+1))
570:             uavg1 = 0.5*(ua(i+1,k,j)+ua(i,k,j))
571:             if ( uavg2.ge.0. ) then
572:               fx2 = fact1*qv(i,k,j) + fact2*qv(i,k,j+1)
573:             else
574:               fx2 = fact1*qv(i,k,j+1) + fact2*qv(i,k,j)
575:             end if
576:             if ( uavg1.ge.0. ) then
577:               fx1 = fact1*qv(i,k,j-1) + fact2*qv(i,k,j)
578:             else
579:               fx1 = fact1*qv(i,k,j) + fact2*qv(i,k,j-1)
580:             end if
581:             vavg2 = 0.5*(va(i+1,k,j+1)+va(i+1,k,j))
582:             vavg1 = 0.5*(va(i,k,j+1)+va(i,k,j))
583:             if ( vavg2.ge.0. ) then
584:               fy2 = fact1*qv(i,k,j) + fact2*qv(i+1,k,j)
585:             else
586:               fy2 = fact1*qv(i+1,k,j) + fact2*qv(i,k,j)
587:             end if
588:             if ( vavg1.ge.0. ) then
589:               fy1 = fact1*qv(i-1,k,j) + fact2*qv(i,k,j)
590:             else
591:               fy1 = fact1*qv(i,k,j) + fact2*qv(i-1,k,j)
592:             end if
593:             ften(i,k) = ften(i,k)                                       &
594:                       & - (uavg2*fx2-uavg1*fx1+vavg2*fy2-vavg1*fy1)     &
595:                       & /(dxx*msfx(i,j)*msfx(i,j))
596:           end do
597:         end do
598: !
599:       else if ( ind.eq.3 ) then
600: !
601: !-----for u and v:
602: !
603:         jdx = j
604:         jdxp1 = j + 1
605:         jdxm1 = j - 1
606: #ifdef MPP1
607:         if ( myid.eq.0 ) jdxm1 = max0(jdxm1,2)
608:         if ( myid.eq.nproc-1 ) jdxp1 = min0(jdxp1,jendl-1)
609: #else
610:         jdxp1 = min0(jdxp1,jxm1)
611:         jdxm1 = max0(jdxm1,2)
612: #endif
613: !
614:         do k = 1 , kz
615:           do i = 2 , iym1
616:             idx = i
617:             idxp1 = i + 1
618:             idxp1 = min0(idxp1,iym1)
619:             idxm1 = i - 1
620:             idxm1 = max0(idxm1,2)
621:             ucmona = ua(idxp1,k,jdx) + 2.*ua(idx,k,jdx)                 &
622:                    & + ua(idxm1,k,jdx)
623:             vcmona = va(idx,k,jdxp1) + 2.*va(idx,k,jdx)                 &
624:                    & + va(idx,k,jdxm1)
625:             ucmonb = ua(idxp1,k,jdxp1) + 2.*ua(idx,k,jdxp1)             &
626:                    & + ua(idxm1,k,jdxp1) + ucmona
627:             vcmonb = va(idxp1,k,jdxp1) + 2.*va(idxp1,k,jdx)             &
628:                    & + va(idxp1,k,jdxm1) + vcmona
629:             ucmonc = ua(idxp1,k,jdxm1) + 2.*ua(idx,k,jdxm1)             &
630:                    & + ua(idxm1,k,jdxm1) + ucmona
631:             vcmonc = va(idxm1,k,jdxp1) + 2.*va(idxm1,k,jdx)             &
632:                    & + va(idxm1,k,jdxm1) + vcmona
633:             ften(i,k) = ften(i,k)                                       &
634:                       & - ((qv(i,k,j+1)+qv(i,k,j))*ucmonb-(qv(i,k,j)    &
635:                       & +qv(i,k,j-1))*ucmonc+(qv(i+1,k,j)+qv(i,k,j))    &
636:                       & *vcmonb-(qv(i,k,j)+qv(i-1,k,j))*vcmonc)         &
637:                       & /(dxx*msfx(i,j)*msfx(i,j))
638:           end do
639:         end do
640: !
641:       else
642:       end if
643: !
644:       end subroutine hadvqv
645: !
646: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
647: !
<p><a name=hadvqc><H3>hadvqc</H3></a></p> Click <a href="./callingtree/hadvqc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where hadvqc is used.
<hr>
648:       subroutine hadvqc(ften,dxx,j,ind)
649: 
650: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
651: !                                                                     c
652: !     this subroutine computes the horizontal flux-divergence terms.  c
653: !     second-order difference is used.                                c
654: !                                                                     c
655: !     ften   : is the tendency for variable 'f'.                      c
656: !                                                                     c
657: !     ua, va : are p*u and p*v.                                       c
658: !                                                                     c
659: !     msfx   : is the map scale factor.                               c
660: !                                                                     c
661: !     dxx    : is the horizontal distance.                            c
662: !              = dx4  for ind=1.                                      c
663: !              = dx   for ind=2.                                      c
664: !              = dx16 for ind=3.                                      c
665: !                                                                     c
666: !     j      : is the j'th slice of f anf ften.                       c
667: !                                                                     c
668: !     ind = 1 : for t and qv.                                         c
669: !         = 2 : for qc and qr.                                        c
670: !         = 3 : for u and v.                                          c
671: !                                                                     c
672: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
673: 
674:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
675:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
676:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
677:       implicit none
678: !
679: ! Dummy arguments
680: !
681:       real(8) :: dxx
682:       integer :: ind , j
683:       real(8) , dimension(iy,kz) :: ften
684:       intent (in) dxx , ind , j
685:       intent (inout) ften
686: !
687: ! Local variables
688: !
689:       real(8) :: fact1 , fact2 , fx1 , fx2 , fy1 , fy2 , uavg1 , uavg2 ,&
690:                & ucmona , ucmonb , ucmonc , vavg1 , vavg2 , vcmona ,    &
691:                & vcmonb , vcmonc
692:       integer :: i , idx , idxm1 , idxp1 , jdx , jdxm1 , jdxp1 , k
693: !
694: !----------------------------------------------------------------------
695: !
696:       if ( ind.eq.1 ) then
697: !
698: !-----for t and qv:
699: !
700:         do k = 1 , kz
701:           do i = 2 , iym2
702:             ften(i,k) = ften(i,k)                                       &
703:                       & - ((ua(i+1,k,j+1)+ua(i,k,j+1))*(qc(i,k,j+1)     &
704:                       & +qc(i,k,j))-(ua(i+1,k,j)+ua(i,k,j))             &
705:                       & *(qc(i,k,j)+qc(i,k,j-1))                        &
706:                       & +(va(i+1,k,j+1)+va(i+1,k,j))                    &
707:                       & *(qc(i+1,k,j)+qc(i,k,j))-(va(i,k,j+1)+va(i,k,j))&
708:                       & *(qc(i-1,k,j)+qc(i,k,j)))                       &
709:                       & /(dxx*msfx(i,j)*msfx(i,j))
710:           end do
711:         end do
712: !
713:       else if ( ind.eq.2 ) then
714: !
715: !       implement a "relaxed" upstream scheme
716: !
717: !hy     fact1=0.75
718:         fact1 = 0.60
719:         fact2 = 1. - fact1
720: !
721: !-----for qc and qr:
722: !       up-wind values of qc and qr are used.
723: !
724:         do k = 1 , kz
725:           do i = 2 , iym2
726:             uavg2 = 0.5*(ua(i+1,k,j+1)+ua(i,k,j+1))
727:             uavg1 = 0.5*(ua(i+1,k,j)+ua(i,k,j))
728:             if ( uavg2.ge.0. ) then
729:               fx2 = fact1*qc(i,k,j) + fact2*qc(i,k,j+1)
730:             else
731:               fx2 = fact1*qc(i,k,j+1) + fact2*qc(i,k,j)
732:             end if
733:             if ( uavg1.ge.0. ) then
734:               fx1 = fact1*qc(i,k,j-1) + fact2*qc(i,k,j)
735:             else
736:               fx1 = fact1*qc(i,k,j) + fact2*qc(i,k,j-1)
737:             end if
738:             vavg2 = 0.5*(va(i+1,k,j+1)+va(i+1,k,j))
739:             vavg1 = 0.5*(va(i,k,j+1)+va(i,k,j))
740:             if ( vavg2.ge.0. ) then
741:               fy2 = fact1*qc(i,k,j) + fact2*qc(i+1,k,j)
742:             else
743:               fy2 = fact1*qc(i+1,k,j) + fact2*qc(i,k,j)
744:             end if
745:             if ( vavg1.ge.0. ) then
746:               fy1 = fact1*qc(i-1,k,j) + fact2*qc(i,k,j)
747:             else
748:               fy1 = fact1*qc(i,k,j) + fact2*qc(i-1,k,j)
749:             end if
750:             ften(i,k) = ften(i,k)                                       &
751:                       & - (uavg2*fx2-uavg1*fx1+vavg2*fy2-vavg1*fy1)     &
752:                       & /(dxx*msfx(i,j)*msfx(i,j))
753:           end do
754:         end do
755: !
756:       else if ( ind.eq.3 ) then
757: !
758: !-----for u and v:
759: !
760:         jdx = j
761:         jdxp1 = j + 1
762:         jdxm1 = j - 1
763: #ifdef MPP1
764:         if ( myid.eq.0 ) jdxm1 = max0(jdxm1,2)
765:         if ( myid.eq.nproc-1 ) jdxp1 = min0(jdxp1,jendl-1)
766: #else
767:         jdxp1 = min0(jdxp1,jxm1)
768:         jdxm1 = max0(jdxm1,2)
769: #endif
770: !
771:         do k = 1 , kz
772:           do i = 2 , iym1
773:             idx = i
774:             idxp1 = i + 1
775:             idxp1 = min0(idxp1,iym1)
776:             idxm1 = i - 1
777:             idxm1 = max0(idxm1,2)
778:             ucmona = ua(idxp1,k,jdx) + 2.*ua(idx,k,jdx)                 &
779:                    & + ua(idxm1,k,jdx)
780:             vcmona = va(idx,k,jdxp1) + 2.*va(idx,k,jdx)                 &
781:                    & + va(idx,k,jdxm1)
782:             ucmonb = ua(idxp1,k,jdxp1) + 2.*ua(idx,k,jdxp1)             &
783:                    & + ua(idxm1,k,jdxp1) + ucmona
784:             vcmonb = va(idxp1,k,jdxp1) + 2.*va(idxp1,k,jdx)             &
785:                    & + va(idxp1,k,jdxm1) + vcmona
786:             ucmonc = ua(idxp1,k,jdxm1) + 2.*ua(idx,k,jdxm1)             &
787:                    & + ua(idxm1,k,jdxm1) + ucmona
788:             vcmonc = va(idxm1,k,jdxp1) + 2.*va(idxm1,k,jdx)             &
789:                    & + va(idxm1,k,jdxm1) + vcmona
790:             ften(i,k) = ften(i,k)                                       &
791:                       & - ((qc(i,k,j+1)+qc(i,k,j))*ucmonb-(qc(i,k,j)    &
792:                       & +qc(i,k,j-1))*ucmonc+(qc(i+1,k,j)+qc(i,k,j))    &
793:                       & *vcmonb-(qc(i,k,j)+qc(i-1,k,j))*vcmonc)         &
794:                       & /(dxx*msfx(i,j)*msfx(i,j))
795:           end do
796:         end do
797: !
798:       else
799:       end if
800: !
801:       end subroutine hadvqc
802: !
803: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
804: !
<p><a name=hadvch><H3>hadvch</H3></a></p> Click <a href="./callingtree/hadvch_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where hadvch is used.
<hr>
805:       subroutine hadvch(ften,dxx,n,j,ind)
806: 
807: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
808: !                                                                     c
809: !     this subroutine computes the horizontal flux-divergence terms.  c
810: !     second-order difference is used.                                c
811: !                                                                     c
812: !     ften   : is the tendency for variable 'f'.                      c
813: !                                                                     c
814: !     ua, va : are p*u and p*v.                                       c
815: !                                                                     c
816: !     msfx   : is the map scale factor.                               c
817: !                                                                     c
818: !     dxx    : is the horizontal distance.                            c
819: !              = dx4  for ind=1.                                      c
820: !              = dx   for ind=2.                                      c
821: !              = dx16 for ind=3.                                      c
822: !                                                                     c
823: !     j      : is the j'th slice of f anf ften.                       c
824: !                                                                     c
825: !     ind = 1 : for t and qv.                                         c
826: !         = 2 : for qc and qr.                                        c
827: !         = 3 : for u and v.                                          c
828: !                                                                     c
829: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
830: 
831:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
832:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
833:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
834:       implicit none
835: !
836: ! Dummy arguments
837: !
838:       real(8) :: dxx
839:       integer :: ind , j , n
840:       real(8) , dimension(iy,kz) :: ften
841:       intent (in) dxx , ind , j , n
842:       intent (inout) ften
843: !
844: ! Local variables
845: !
846:       real(8) :: fact1 , fact2 , fx1 , fx2 , fy1 , fy2 , uavg1 , uavg2 ,&
847:                & ucmona , ucmonb , ucmonc , vavg1 , vavg2 , vcmona ,    &
848:                & vcmonb , vcmonc
849:       integer :: i , idx , idxm1 , idxp1 , jdx , jdxm1 , jdxp1 , k
850: !
851: !----------------------------------------------------------------------
852: !
853:       if ( ind.eq.1 ) then
854: !
855: !-----for t and qv:
856: !
857:         do k = 1 , kz
858:           do i = 2 , iym2
859:             ften(i,k) = ften(i,k)                                       &
860:                       & - ((ua(i+1,k,j+1)+ua(i,k,j+1))*(chi(i,k,j+1,n)  &
861:                       & +chi(i,k,j,n))-(ua(i+1,k,j)+ua(i,k,j))          &
862:                       & *(chi(i,k,j,n)+chi(i,k,j-1,n))                  &
863:                       & +(va(i+1,k,j+1)+va(i+1,k,j))                    &
864:                       & *(chi(i+1,k,j,n)+chi(i,k,j,n))                  &
865:                       & -(va(i,k,j+1)+va(i,k,j))                        &
866:                       & *(chi(i-1,k,j,n)+chi(i,k,j,n)))                 &
867:                       & /(dxx*msfx(i,j)*msfx(i,j))
868:           end do
869:         end do
870: !
871:       else if ( ind.eq.2 ) then
872: !
873: !       implement a "relaxed" upstream scheme
874: !
875: !hy     fact1=0.75
876:         fact1 = 0.60
877:         fact2 = 1. - fact1
878: !
879: !-----for qc and qr:
880: !       up-wind values of qc and qr are used.
881: !
882:         do k = 1 , kz
883:           do i = 2 , iym2
884:             uavg2 = 0.5*(ua(i+1,k,j+1)+ua(i,k,j+1))
885:             uavg1 = 0.5*(ua(i+1,k,j)+ua(i,k,j))
886:             if ( uavg2.ge.0. ) then
887:               fx2 = fact1*chi(i,k,j,n) + fact2*chi(i,k,j+1,n)
888:             else
889:               fx2 = fact1*chi(i,k,j+1,n) + fact2*chi(i,k,j,n)
890:             end if
891:             if ( uavg1.ge.0. ) then
892:               fx1 = fact1*chi(i,k,j-1,n) + fact2*chi(i,k,j,n)
893:             else
894:               fx1 = fact1*chi(i,k,j,n) + fact2*chi(i,k,j-1,n)
895:             end if
896:             vavg2 = 0.5*(va(i+1,k,j+1)+va(i+1,k,j))
897:             vavg1 = 0.5*(va(i,k,j+1)+va(i,k,j))
898:             if ( vavg2.ge.0. ) then
899:               fy2 = fact1*chi(i,k,j,n) + fact2*chi(i+1,k,j,n)
900:             else
901:               fy2 = fact1*chi(i+1,k,j,n) + fact2*chi(i,k,j,n)
902:             end if
903:             if ( vavg1.ge.0. ) then
904:               fy1 = fact1*chi(i-1,k,j,n) + fact2*chi(i,k,j,n)
905:             else
906:               fy1 = fact1*chi(i,k,j,n) + fact2*chi(i-1,k,j,n)
907:             end if
908:             ften(i,k) = ften(i,k)                                       &
909:                       & - (uavg2*fx2-uavg1*fx1+vavg2*fy2-vavg1*fy1)     &
910:                       & /(dxx*msfx(i,j)*msfx(i,j))
911:           end do
912:         end do
913: !
914:       else if ( ind.eq.3 ) then
915: !
916: !-----for u and v:
917: !
918:         jdx = j
919:         jdxp1 = j + 1
920:         jdxm1 = j - 1
921: #ifdef MPP1
922:         if ( myid.eq.0 ) jdxm1 = max0(jdxm1,2)
923:         if ( myid.eq.nproc-1 ) jdxp1 = min0(jdxp1,jendl-1)
924: #else
925:         jdxp1 = min0(jdxp1,jxm1)
926:         jdxm1 = max0(jdxm1,2)
927: #endif
928: !
929:         do k = 1 , kz
930:           do i = 2 , iym1
931:             idx = i
932:             idxp1 = i + 1
933:             idxp1 = min0(idxp1,iym1)
934:             idxm1 = i - 1
935:             idxm1 = max0(idxm1,2)
936:             ucmona = ua(idxp1,k,jdx) + 2.*ua(idx,k,jdx)                 &
937:                    & + ua(idxm1,k,jdx)
938:             vcmona = va(idx,k,jdxp1) + 2.*va(idx,k,jdx)                 &
939:                    & + va(idx,k,jdxm1)
940:             ucmonb = ua(idxp1,k,jdxp1) + 2.*ua(idx,k,jdxp1)             &
941:                    & + ua(idxm1,k,jdxp1) + ucmona
942:             vcmonb = va(idxp1,k,jdxp1) + 2.*va(idxp1,k,jdx)             &
943:                    & + va(idxp1,k,jdxm1) + vcmona
944:             ucmonc = ua(idxp1,k,jdxm1) + 2.*ua(idx,k,jdxm1)             &
945:                    & + ua(idxm1,k,jdxm1) + ucmona
946:             vcmonc = va(idxm1,k,jdxp1) + 2.*va(idxm1,k,jdx)             &
947:                    & + va(idxm1,k,jdxm1) + vcmona
948:             ften(i,k) = ften(i,k)                                       &
949:                       & - ((chi(i,k,j+1,n)+chi(i,k,j,n))*ucmonb-        &
950:                       & (chi(i,k,j,n)+chi(i,k,j-1,n))                   &
951:                       & *ucmonc+(chi(i+1,k,j,n)+chi(i,k,j,n))           &
952:                       & *vcmonb-(chi(i,k,j,n)+chi(i-1,k,j,n))*vcmonc)   &
953:                       & /(dxx*msfx(i,j)*msfx(i,j))
954:           end do
955:         end do
956: !
957:       else
958:       end if
959: !
960:       end subroutine hadvch
</PRE>

<HR>

</BODY>
</HTML>
