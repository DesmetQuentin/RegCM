<HTML>

<HEAD>
<TITLE>albedov.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>albedov.F90</H1>
<HR>
<H2 ALIGN=CENTER>albedov.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=albedov><H3>albedov</H3></a></p> Click <a href="./callingtree/albedov_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where albedov is used.
<hr>
20:       subroutine albedov(j,iemiss)
21:  
22:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
23:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a> , only : albvs , albvl , aldirs , aldirl , ssw1d ,   &
24:                   & aldifs , aldifl , czen , sice1d , emiss1d , coszrs ,&
25:                   & ldoc1d , tgb1d , lveg , ts1d , scv1d , sag1d , wt , &
26:                   & scvk , veg1d , emiss2d , albvgs , albvgl , kolsol , &
27:                   & depuv , solour
28:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : tzero
29:       implicit none
30: !
31: ! Dummy arguments
32: !
33:       integer :: iemiss , j
34:       intent (in) iemiss , j
35: !
36: ! Local variables
37: !
38:       real(8) :: age , albg , albgl , albgld , albgs , albgsd , albl ,  &
39:                & albld , albs , albsd , albzn , alwet , cf1 , cff ,     &
40:                & conn , cons , czeta , czf , dfalbl , dfalbs , dralbl , &
41:                & dralbs , fsol1 , fsol2 , sfac , sical0 , sical1 , sl , &
42:                & sl2 , sli , snal0 , snal1 , tdiff , tdiffs , wet , x
43:       real(8) , dimension(nnsg) :: albvl_s , albvs_s , aldifl_s ,       &
44:                                  & aldifs_s , aldirl_s , aldirs_s
45:       real(8) :: fseas
46:       integer :: kolour , n , i
47: !
48: !     Albedo calculates fragmented albedos (direct and diffuse) in
49: !     wavelength regions split at 0.7um.
50: !
51: !     CM hands albedos to radiation package which computes
52: !     fsw1d(i) = net solar absorbed over full grid square
53: !     sabveg(i) = vegetation absorbed (full solar spectrum)
54: !     solis(i) = shortwave  solar incident
55: !
56: !     Here these are calculated at the end of albedo - they use only
57: !     direct albedos for now
58: !
59: !     in both versions :  lftemp uses sabveg
60: !     tgrund uses sabveg & fsw1d(i) to get
61: !     ground absorbed solar
62: !     photosynthesis uses solis - see subrouts
63: !     stomat and co2 (carbon)
64: !
65: !     For sea, sea-ice veg albedos are not set
66: !     these albedos are not treated as arrays here
67: !
68: !     (depuv/10.0)= the ratio of upper soil layer to total
69: !     root depth; used to compute "wet" for soil albedo
70: !
71: !     =================================================================
72: !     1. set initial parameters
73: !     =================================================================
74:       fseas(x) = dmax1(0.D0,1.D0-0.0016D0*dmax1(298.D0-x,0.D0)**2)
75: !
76: !     1.1 constants
77: !
78: !     Solar flux partitioned at wavelength of 0.7micr
79:       fsol1 = 0.5D0
80:       fsol2 = 0.5D0
81: !     Short and long wave albedo for new snow
82:       snal0 = 0.95D0
83:       snal1 = 0.65D0
84: !     Short and long wave albedo for sea ice
85:       sical0 = 0.6D0
86:       sical1 = 0.4D0
87:  
88: !
89: !     In depth, wt is frac of grid square covered by snow;
90: !     depends on average snow depth, vegetation, etc.
91: !
92:       call <a href="./depth.f90.html#depth" TARGET=CENT_PANEL>depth</a>
93:  
94: !     1.2 set pointers
95: !     ***************************************************
96: !     *    set n"x"k params here  in ccm but not needed *
97: !     ***************************************************
98: !
99: !     1.3  set default vegetation and albedo
100: !     do loop 50 in ccm not used here )
101:  
102:       do i = 2 , iym1
103:         czen(i) = dmax1(coszrs(i),0.D0)
104:         czeta = czen(i)
105:         do n = 1 , nnsg
106:           albgs = 0.0D0
107:           albgl = 0.0D0
108:           albgsd = 0.0D0
109:           albgld = 0.0D0
110:           albs = 0.0D0
111:           albl = 0.0D0
112:           albsd = 0.0D0
113:           albld = 0.0D0
114:  
115:           albvs_s(n) = 0.0D0
116:           albvl_s(n) = 0.0D0
117:  
118: !================================================================
119: !         2.   get albedo over land
120: !================================================================
121: !         can't use pointer "nalbk" here because not set - use nldock
122: !         instead tgb1d(i) used instead of tbelow
123: !
124: #ifdef SEAICE
125:           if ( ldoc1d(n,i).gt.1.5 ) then
126:             tdiffs=ts1d(n,i)-tzero
127:             tdiff=dmax1(tdiffs,0.d0)
128:             tdiffs=dmin1(tdiff,20.d0)
129:             albgl=sical1-1.1e-2*tdiffs
130:             albgs=sical0-2.45e-2*tdiffs
131:             albg=fsol1*albgs+fsol2*albgl
132:             albgsd=albgs
133:             albgld=albgl
134:           else if ( ldoc1d(n,i).gt.0.1D0 .and.                          &
135:            &       sice1d(n,i).eq.0.D0 ) then
136: #else
137:            if ( ldoc1d(n,i).gt.0.1D0 .and. sice1d(n,i).eq.0.D0 ) then
138: #endif
139:             sfac = 1.D0 - fseas(tgb1d(n,i))
140:  
141: !           **********  ccm tests here on land mask for veg and soils
142:  
143:  
144: !c          data *** reduces albedo at low temps !!!!!should respond to
145: !c          moisture too the following card inactivated (commented out)
146: !c          (pat, 27 oct 86)
147:  
148: !           veg1d(i)=vegc(lveg(i))-seasf(lveg(i))*sfac
149:             albs = albvgs(lveg(n,i))
150:             albl = albvgl(lveg(n,i))
151:  
152: !----------------------------------------------------------------------
153:             if ( (lveg(n,i).lt.12) .or. (lveg(n,i).gt.15) ) then
154:  
155: !             2.1  bare soil albedos
156: !             (soil albedo depends on moisture)
157:               kolour = kolsol(lveg(n,i))
158:               wet = ssw1d(n,i)/depuv(lveg(n,i))
159:               alwet = dmax1((11.D0-40.D0*wet),0.D0)*0.01D0
160:               alwet = dmin1(alwet,solour(kolour))
161:               albg = solour(kolour) + alwet
162: !             if((lveg(n,i).eq.8)) albg=0.40      !Laura, cambiato il
163: !             DESERTO
164:               albgs = albg
165:               albgl = 2.D0*albg
166: !             **********            higher nir albedos
167: !             **********              set diffuse albedo
168:               albgld = albgl
169:               albgsd = albgs
170:               albsd = albs
171:               albld = albl
172:  
173: !             Dec. 15   albzn=0.85+1./(1.+10.*czen(i))
174: !             Dec. 12, 2008
175:               albzn = 1.0D0
176: !             Dec. 15, 2008
177:  
178: !             **********            leafless hardwood canopy: no or
179: !             inverse zen dep
180:               if ( lveg(n,i).eq.5 .and. sfac.lt.0.1 ) albzn = 1.
181: !             **********            multiply by zenith angle correction
182:               albs = albs*albzn
183:               albl = albl*albzn
184:  
185: !             **********            albedo over vegetation after zenith
186: !             angle corr
187:               albvs_s(n) = albs
188:               albvl_s(n) = albl
189:  
190:             else if ( lveg(n,i).eq.12 ) then
191:  
192: !             2.2   permanent ice sheet
193:               albgs = 0.8D0
194:               albgsd = 0.8D0
195:               albgl = 0.55D0
196:               albgld = 0.55D0
197:             else
198:  
199: !             2.3  inland water, swamps, rice paddies etc.
200:               albg = 0.05D0/(czeta+0.15D0)
201:               albgs = albg
202:               albgsd = albg
203:               albgl = albg
204:               albgld = albg
205:             end if
206:  
207:           else if ( sice1d(n,i).gt.0.D0 ) then
208: !====================================================================
209: !           3.  get albedo over sea ice
210: !====================================================================
211: !           **********          albedo depends on wave-length and ts.
212: !           the ts **********          dependence accounts for melt
213: !           water puddles.
214:             tdiffs = ts1d(n,i) - tzero
215:             tdiff = dmax1(tdiffs,0.D0)
216:             tdiffs = dmin1(tdiff,20.D0)
217:             albgl = sical1 - 1.1E-2*tdiffs
218:             albgs = sical0 - 2.45E-2*tdiffs
219:             albg = fsol1*albgs + fsol2*albgl
220:             albgsd = albgs
221:             albgld = albgl
222:           else
223:           end if
224: ! ===================================================================
225: !         4.  correct for snow cover
226: ! ===================================================================
227:           if ( scv1d(n,i).gt.0.0D0 ) then
228: !           **********            snow albedo depends on  snow-age,
229: !           zenith angle, **********            and thickness of snow
230:  
231: !           **********            zenith angle set in zenitm
232: !           **********            snow albedoes for visible and ir
233: !           solar rad **********            visible albedo depends on
234: !           snow age **********            age gives reduction of
235: !           visible rad snow albedo **********              due to age
236:             cons = 0.2D0
237:             conn = 0.5D0
238:             age = (1.D0-1.D0/(1.D0+sag1d(n,i)))
239: !           **********            sl helps control albedo zenith
240: !           dependence
241:             sl = 2.0D0
242:             sli = 1.D0/sl
243:             sl2 = 2.D0*sl
244: !           **********            snal0= new snow albedo for vis rad,
245: !           sol zen le 6 **********            snal1= new snow albedo
246: !           for long-wave rad
247:             dfalbs = snal0*(1.D0-cons*age)
248: !           **********            czf corrects albedo of new snow for
249: !           solar zenith
250:             cf1 = ((1.D0+sli)/(1.D0+sl2*czen(i))-sli)
251:             cff = dmax1(cf1,0.D0)
252:             czf = 0.4D0*cff*(1.D0-dfalbs)
253:             dralbs = dfalbs + czf
254:             dfalbl = snal1*(1.D0-conn*age)
255:             czf = 0.4D0*cff*(1.D0-dfalbl)
256:             dralbl = dfalbl + czf
257:  
258:             if ( veg1d(n,i).gt.0.001D0 ) then
259: !             **********            effective albedo over vegetation
260: !             with snow
261:               albl = (1.D0-wt(n,i))*albl + dralbl*wt(n,i)
262:               albld = (1.D0-wt(n,i))*albld + dfalbl*wt(n,i)
263:               albs = (1.D0-wt(n,i))*albs + dralbs*wt(n,i)
264:               albsd = (1.D0-wt(n,i))*albsd + dfalbs*wt(n,i)
265:             end if
266:  
267: !----------------------------------------------------------------------
268: !           4.1  compute albedo for snow on bare ground
269: !----------------------------------------------------------------------
270:             albgs = (1.D0-scvk(n,i))*albgs + dralbs*scvk(n,i)
271:             albgl = (1.D0-scvk(n,i))*albgl + dralbl*scvk(n,i)
272:             albgsd = (1.D0-scvk(n,i))*albgsd + dfalbs*scvk(n,i)
273:             albgld = (1.D0-scvk(n,i))*albgld + dfalbl*scvk(n,i)
274:           end if
275:  
276: !=====================================================================
277: !         5.  albedo over open ocean
278: !=====================================================================
279:           if ( ldoc1d(n,i).eq.0.D0 ) then
280: !           *********   ocean albedo depends on zenith angle
281:             if ( czeta.ge.0.0D0 ) then
282: !             **********   albedo independent of wavelength
283:               albg = 0.05D0/(czeta+0.15D0)
284:               albgs = albg
285:               albgl = albg
286:               albgsd = 0.08D0
287:               albgld = 0.08D0
288:             end if
289:           end if
290:  
291: !
292: !         ***************not part of albedo in the ccm ****************
293: !
294:           aldirs_s(n) = (1.D0-veg1d(n,i))*albgs + veg1d(n,i)*albs
295:           aldirl_s(n) = (1.D0-veg1d(n,i))*albgl + veg1d(n,i)*albl
296:           aldifs_s(n) = (1.D0-veg1d(n,i))*albgsd + veg1d(n,i)*albsd
297:           aldifl_s(n) = (1.D0-veg1d(n,i))*albgld + veg1d(n,i)*albld
298:         end do
299:         albvs(i) = albvs_s(1)
300:         albvl(i) = albvl_s(1)
301:         aldirs(i) = aldirs_s(1)
302:         aldirl(i) = aldirl_s(1)
303:         aldifs(i) = aldifs_s(1)
304:         aldifl(i) = aldifl_s(1)
305:         if ( iemiss.eq.1 ) emiss1d(i) = emiss2d(1,i,j)
306:         do n = 2 , nnsg
307:           albvs(i) = albvs(i) + albvs_s(n)
308:           albvl(i) = albvl(i) + albvl_s(n)
309:           aldirs(i) = aldirs(i) + aldirs_s(n)
310:           aldirl(i) = aldirl(i) + aldirl_s(n)
311:           aldifs(i) = aldifs(i) + aldifs_s(n)
312:           aldifl(i) = aldifl(i) + aldifl_s(n)
313:           if ( iemiss.eq.1 ) emiss1d(i) = emiss1d(i) + emiss2d(n,i,j)
314:         end do
315:         albvs(i) = albvs(i)/dble(nnsg)
316:         albvl(i) = albvl(i)/dble(nnsg)
317:         aldirs(i) = aldirs(i)/dble(nnsg)
318:         aldirl(i) = aldirl(i)/dble(nnsg)
319:         aldifs(i) = aldifs(i)/dble(nnsg)
320:         aldifl(i) = aldifl(i)/dble(nnsg)
321:         if ( iemiss.eq.1 ) emiss1d(i) = emiss1d(i)/dble(nnsg)
322:  
323: !       ******   fsw1d(i),sabveg(i),solis(i) computed in colrad
324:  
325:       end do
326:  
327:       end subroutine albedov
</PRE>

<HR>

</BODY>
</HTML>
