<HTML>

<HEAD>
<TITLE>blhnew.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>blhnew.F90</H1>
<HR>
<H2 ALIGN=CENTER>blhnew.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=blhnew><H3>blhnew</H3></a></p> Click <a href="./callingtree/blhnew_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where blhnew is used.
<hr>
20:       subroutine blhnew
21: !
22: ! ------------------------------------------------------------
23: ! this routine computes the boundary layer eddy diffusivities
24: ! for momentum, heat and moisture and the counter-gradient
25: ! terms for heat and moisture.
26: !
27: ! reference : holtslag, de bruijn and pan - mwr - 8/90
28: !
29: ! input arguments :  j       longitudinal position index
30: !                    ubx3d   u wind component
31: !                    vbx3d   v wind component
32: !                    thx3d   potential temperature
33: !                    thvx    virtual potential temperature
34: !                    za      height of half sigma levels
35: !                    f       coriolis parameter
36: !                    shum    specific humidity
37: !                    xhfx    sensible heat flux
38: !                    xqfx    sfc kinematic moisture flux
39: !                    th10    virt. pot. temp. at 10m
40: !                    hfxv    surface virtual heat flux
41: !                    obklen  monin obukov length
42: !                    ustr    friction velocity
43: !                    kzo     minimum eddy diffusivity
44: !
45: ! input/output
46: ! arguments :        therm   thermal temperature excess
47: !
48: ! output arguments : cgh     counter-gradient term for heat
49: !                    cgq     counter-gradient term for moisture
50: !                    kvm     eddy diffusivity for momentum
51: !                    kvh     eddy diffusivity for heat
52: !                    kvq     eddy diffusivity for moisture
53: !                    zpbl     boundary layer height
54: !
55:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
56:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a>
57:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : kt
58:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
59:       use <a href="./mod_slice.F90.html#mod_slice" TARGET=CENT_PANEL>mod_slice</a>
60:       use <a href="./mod_pbldim.F90.html#mod_pbldim" TARGET=CENT_PANEL>mod_pbldim</a>
61:       use <a href="./mod_blh_tmp.F90.html#mod_blh_tmp" TARGET=CENT_PANEL>mod_blh_tmp</a>
62:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : gti , vonkar
63:       implicit none
64: !
65: ! Local variables
66: !
67:       real(8) :: betah , betam , betas , binh , binm , ccon , fak ,     &
68:                & fak1 , fak2 , fht , xfmt , kzo , onet , pblk , pblk1 , &
69:                & pblk2 , pfcor , phpblm , pink , pr , ricr , sffrac ,   &
70:                & therm2 , tkv , tlv , ttkl , vv , vvl , wsc , z , zh ,  &
71:                & zl , zm , zp , zzh , zzhnew , zzhnew2
72:       integer :: i , j , k , k2
73:       real(8) , dimension(iy,kz) :: ri
74:       real(8) , dimension(iy) :: therm
75: !
76:       data kzo/1./
77: !
78: !
79: !     ------------------------------------------------------------
80: !
81: !     real(kind=8)  cgq(iy,kz)
82: !     -----------------------------------------------------------
83:  
84: !     gravity
85: !     coef. of proportionality and lower % of bl in sfc layer
86:       data fak , sffrac/8.5 , 0.1/
87: !     beta coefs. for momentum, stable conditions and heat
88:       data betam , betas , betah/15.0 , 5.0 , 15.0/
89: !     power in formula for k and critical ri for judging stability
90:       data pink , ricr/2.0 , 0.25/
91:  
92: !     exponent : one third
93:       onet = 1./3.
94:       pblk2 = 0.0
95:       zzhnew2 = 0.0
96: !     set constants
97:       ccon = fak*sffrac*vonkar
98:       binm = betam*sffrac
99:       binh = betah*sffrac
100: #ifdef MPP1
101:       do j = jbegin , jendx
102: #else
103:       do j = 2 , jxm1
104: #endif
105:  
106: !       ****note: kt, max no. of pbl levels, calculated in param
107: !       ******   compute richardson number
108:         do i = 2 , iym1
109:           therm(i) = 0.0
110:         end do
111:  
112:         do k = kz , kt , -1
113:           do i = 2 , iym1
114:             vv = ubx3d(i,k,j)*ubx3d(i,k,j) + vbx3d(i,k,j)*vbx3d(i,k,j)
115:             ri(i,k) = gti*(thvx(i,k,j)-th10(i,j))*za(i,k,j)/            &
116:                     & (th10(i,j)*vv)
117:           end do
118:         end do
119:  
120: !       ******   first, set bl height to height of lowest model level
121:         do i = 2 , iym1
122:           zpbl(i,j) = za(i,kz,j)
123:         end do
124:  
125: !       ******   looking for bl top
126:         do k = kz , kt + 1 , -1
127:           k2 = k - 1
128:           do i = 2 , iym1
129: !     ******   bl height lies between this level and the last
130: !     ******   use linear interp. of rich. no. to height of ri=ricr
131:             if ( (ri(i,k).lt.ricr) .and. (ri(i,k2).ge.ricr) ) zpbl(i,j) &
132:                & = za(i,k,j) + (za(i,k2,j)-za(i,k,j))                   &
133:                  & *((ricr-ri(i,k))/(ri(i,k2)-ri(i,k)))
134:           end do
135:         end do
136:  
137:         do i = 2 , iym1
138: !     ******   set bl top to highest allowable model layer
139:           if ( ri(i,kt).lt.ricr ) zpbl(i,j) = za(i,kt,j)
140:         end do
141:  
142: !       ******   recompute richardson no. at lowest model level
143:         do i = 2 , iym1
144:           if ( hfxv(i,j).gt.0. ) then
145: !           ******   estimate of convective velocity scale
146:             xfmt = (1.0-(binm*zpbl(i,j)/obklen(i,j)))**onet
147:             wsc = ustr(i,j)*xfmt
148: !           ******   thermal temperature excess
149:             therm(i) = (xhfx(i,j)+0.61*thx3d(i,kz,j)*xqfx(i,j))*fak/wsc
150:             vvl = ubx3d(i,kz,j)*ubx3d(i,kz,j) + vbx3d(i,kz,j)           &
151:                 & *vbx3d(i,kz,j)
152:             ri(i,kz) = -gti*therm(i)*za(i,kz,j)/(th10(i,j)*vvl)
153:           end if
154:         end do
155:  
156: !       ******   recompute richardson no. at other model levels
157:         do k = kz - 1 , kt , -1
158:           do i = 2 , iym1
159:             if ( hfxv(i,j).gt.0. ) then
160:               tlv = th10(i,j) + therm(i)
161:               tkv = thx3d(i,k,j)                                        &
162:                   & *(1.0+0.61*(qvb3d(i,k,j)/(qvb3d(i,k,j)+1)))
163:               ttkl = tkv - tlv
164:               vv = ubx3d(i,k,j)*ubx3d(i,k,j) + vbx3d(i,k,j)*vbx3d(i,k,j)
165:               ri(i,k) = gti*ttkl*za(i,k,j)/(th10(i,j)*vv)
166:             end if
167:           end do
168:         end do
169:  
170: !       ******   improve estimate of bl height under convective
171: !       conditions ******   using convective temperature excess (therm)
172:         do k = kz , kt + 1 , -1
173:           k2 = k - 1
174:           do i = 2 , iym1
175:             if ( hfxv(i,j).gt.0. ) then
176: !     ******   bl height lies between this level and the last
177: !     ******   use linear interp. of rich. no. to height of ri=ricr
178:               if ( (ri(i,k).lt.ricr) .and. (ri(i,k2).ge.ricr) )         &
179:                  & zpbl(i,j) = za(i,k,j) + (za(i,k2,j)-za(i,k,j))       &
180:                              & *((ricr-ri(i,k))/(ri(i,k2)-ri(i,k)))
181:             end if
182:           end do
183:         end do
184:  
185:         do i = 2 , iym1
186:           if ( hfxv(i,j).gt.0. ) then
187: !     ******   set bl top to highest allowable model layer
188:             if ( ri(i,kt).lt.ricr ) zpbl(i,j) = za(i,kt,j)
189:           end if
190:         end do
191:  
192: !       ******   limit bl height to be at least mech. mixing depth
193:         do i = 2 , iym1
194: !         ******   limit coriolis parameter to value at 10 deg. latitude
195:           pfcor = dmax1(dabs(f(i,j)),2.546D-5)
196: !         ******   compute mechanical mixing depth,
197: !         ******   set to lowest model level if lower
198:           phpblm = 0.07*ustr(i,j)/pfcor
199:           phpblm = dmax1(phpblm,za(i,kz,j))
200:           zpbl(i,j) = dmax1(zpbl(i,j),phpblm)
201:         end do
202:  
203:         do k = kz , kt + 1 , -1
204:           k2 = k - 1
205:           do i = 2 , iym1
206:             pblk = 0.0
207:             zm = za(i,k,j)
208:             zp = za(i,k2,j)
209:             if ( zm.lt.zpbl(i,j) ) then
210:               zp = dmin1(zp,zpbl(i,j))
211:               z = 0.5*(zm+zp)
212:               zh = z/zpbl(i,j)
213:               zl = z/obklen(i,j)
214:               if ( zh.le.1. ) then
215:                 zzh = 1. - zh
216:                 zzh = zzh**pink
217: !xexp4          zzhnew = zpbl(i,j)*(1.-zh)*zh**1.5
218: !xexp5          zzhnew = 0.5*zpbl(i,j)*(1.-zh)*zh**1.5
219: !xexp6          zzhnew = 1. - zh
220: !xexp7          zzhnew =0.5* (1. - zh)
221: !Sara
222: !               zzhnew =0.25* (1. - zh)
223: !               zzhnew =0.75* (1. - zh)
224: !Sara_
225:                 zzhnew = 0.25*(1.-zh)
226: !xexp10         zzhnew =zh * (1. - zh)**2
227: !chem
228:                 if ( ichem.eq.1 ) zzhnew2 = (1.-zh)**2
229: !chem_
230:               else
231:                 zzh = 0.
232:                 zzhnew = 0.
233: !chem
234:                 zzhnew2 = 0.
235: !chem_
236:               end if
237:               fak1 = ustr(i,j)*zpbl(i,j)*vonkar
238:               if ( hfxv(i,j).le.0. ) then
239: !**             stable and neutral conditions
240: !**             igroup = 1
241:  
242: !**             prevent pblk from becoming too small in very stable
243: !               conditions
244:                 if ( zl.le.1. ) then
245:                   pblk = fak1*zh*zzh/(1.+betas*zl)
246: !xexp5            pblk1 = vonkar * ustr(i,j) / (1.+betas*zl) * zzhnew
247:                   pblk1 = fak1*zh*zzhnew/(1.+betas*zl)
248: !chem
249:                   if ( ichem.eq.1 )                                     &
250:                      & pblk2 = fak1*zh*zzhnew2/(1.+betas*zl)
251: !chem_
252:                 else
253:                   pblk = fak1*zh*zzh/(betas+zl)
254: !xexp5            pblk1 = vonkar * ustr(i,j) / (betas+zl) * zzhnew
255:                   pblk1 = fak1*zh*zzhnew/(betas+zl)
256: !chem
257:                   if ( ichem.eq.1 ) pblk2 = fak1*zh*zzhnew2/(betas+zl)
258: !chem_
259:                 end if
260: !**             compute eddy diffusivities
261:                 kvm(i,k,j) = dmax1(pblk,kzo)
262:                 kvh(i,k,j) = kvm(i,k,j)
263:                 kvq(i,k,j) = dmax1(pblk1,kzo)
264: !chem
265:                 if ( ichem.eq.1 ) kvc(i,k,j) = dmax1(pblk2,kzo)
266: !chem_
267: !**             compute counter-gradient term
268:                 cgh(i,k,j) = 0.0
269: !               cgq(i,k) = 0.0
270:               else
271: !**             unstable conditions
272:  
273: !**             compute counter gradient term
274:                 if ( zh.ge.sffrac ) then
275: !**               igroup = 2
276:                   xfmt = (1.-binm*zpbl(i,j)/obklen(i,j))**onet
277:                   fht = dsqrt(1.-binh*zpbl(i,j)/obklen(i,j))
278:                   wsc = ustr(i,j)*xfmt
279:                   pr = (xfmt/fht) + ccon
280:                   fak2 = wsc*zpbl(i,j)*vonkar
281:                   pblk = fak2*zh*zzh
282: !xexp5            pblk1 = vonkar * wsc * zzhnew
283:                   pblk1 = fak2*zh*zzhnew
284: !chem
285:                   if ( ichem.eq.1 ) pblk2 = fak2*zh*zzhnew2
286: !chem_
287:                   therm2 = fak/(zpbl(i,j)*wsc)
288:                   cgh(i,k,j) = hfxv(i,j)*therm2
289: !                 cgq(i,k) = xqfx(i,j)*therm2
290: !                 cgq(i,k) = 0.0
291:                 else
292: !**               igroup = 3
293:                   pblk = fak1*zh*zzh*(1.-betam*zl)**onet
294: !xexp5            pblk1 = vonkar * ustr(i,j) * zzhnew *
295: !                 (1.-betam*zl)**onet
296:                   pblk1 = fak1*zh*zzhnew*(1.-betam*zl)**onet
297: !chem
298:                   if ( ichem.eq.1 )                                     &
299:                      & pblk2 = fak1*zh*zzhnew2*(1.-betam*zl)**onet
300: !chem_
301:                   pr = ((1.-betam*zl)**onet)/dsqrt(1.-betah*zl)
302:                   cgh(i,k,j) = 0.0
303: !                 cgq(i,k) = 0.0
304:                 end if
305:  
306: !**             compute eddy diffusivities
307:                 kvm(i,k,j) = dmax1(pblk,kzo)
308:                 kvh(i,k,j) = dmax1((pblk/pr),kzo)
309: !               kvq(i,k,j) = kvh(i,k,j)
310:                 kvq(i,k,j) = dmax1(pblk1,kzo)
311: !chem
312:                 if ( ichem.eq.1 ) kvc(i,k,j) = dmax1(pblk2,kzo)
313: !chem_
314:  
315:               end if
316:             end if
317:           end do
318:         end do
319:       end do
320:  
321:       end subroutine blhnew
</PRE>

<HR>

</BODY>
</HTML>
