<HTML>

<HEAD>
<TITLE>interfclm.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>interfclm.F90</H1>
<HR>
<H2 ALIGN=CENTER>interfclm.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
20: #ifdef MPP1
21: 
<p><a name=interfclm><H3>interfclm</H3></a></p> Click <a href="./callingtree/interfclm_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where interfclm is used.
<hr>
22:       subroutine interfclm(ivers)
23: 
24: !=======================================================================
25: !l  built for clm version 3.0
26: !=======================================================================
27: ! ivers = 1 : regcm -> clm
28: ! ivers = 2 : clm -> regcm
29: !
30:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
31:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a>,    only : landmask, landfrac
32:       use <a href="#" TARGET=CENT_PANEL>clmtype</a>
33:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a>,    only : c2r_allout,omap_i,omap_j
34:       use <a href="#" TARGET=CENT_PANEL>mpi</a>
35:       use <a href="./mod_clm.F90.html#mod_clm" TARGET=CENT_PANEL>mod_clm</a>
36:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a>
37:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
38:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a>
39:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a>
40:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a>
41:       use <a href="./mod_slice.F90.html#mod_slice" TARGET=CENT_PANEL>mod_slice</a>
42:       use <a href="./mod_pbldim.F90.html#mod_pbldim" TARGET=CENT_PANEL>mod_pbldim</a>
43:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a>
44:       use <a href="./mod_mppio.F90.html#mod_mppio" TARGET=CENT_PANEL>mod_mppio</a>
45:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a>
46:       use <a href="./mod_zengocn.F90.html#mod_zengocn" TARGET=CENT_PANEL>mod_zengocn</a> , only : zengocndrv
47:       implicit none
48: !
49: ! Dummy arguments
50: !
51:       integer :: ivers
52:       intent (in) ivers
53: !
54: ! Local variables
55: !
56:       real(8) :: mmpd , wpm2
57:       integer :: ci , cj , counter , i , ii , iii , j , jj , kk ,       &
58:                 & locid , n , nn1 , nnn , nout
59:       real(8) , dimension(jxp,iy) :: r2cflwd , r2cpsb , r2cqb ,    &
60:                 & r2crnc , r2crnnc , r2csoll , r2csolld , r2csols ,     &
61:                 & r2csolsd , r2ctb , r2cuxb , r2cvxb , r2czga
62:       real(4) :: real_4
63:       real(8) , dimension(jxp*iy*13) :: workin
64:       real(8) , dimension(jx*iy*13) :: workout
65:       integer :: ierr
66: !
67: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
68: !     About the dimension ordering:
69: !     regcm: ix=lat,jx=lon, arrays are lat by lon
70: !     clm: i=lon, j=lat, arrays are lon by lat
71: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
72:  
73:       if ( ivers==1 ) then
74:  
75:         locid = 1
76: !       clm3 currently works on all iy,jx instead of 2-ilx and 2-jlx so
77: !       copy neighboring values for now
78:         do j = 1 , jxp
79:           do i = 1 , iy
80:  
81: !jlb        10/05 treat all variables identically. Copy i=2 to i=1 and
82: !           i=ilx to i=iy. For myid = 0, copy j=2 to j=1. For myid =
83: !           nproc-1, copy j=jendx to j=jxp.
84:             if ( myid==0 .and. j==1 ) then
85:               cj = 2
86:             else if ( myid==(nproc-1) .and. j==jxp ) then
87:               cj = jxp - 1
88:             else
89:               cj = j
90:             end if
91:             if ( i==1 ) then
92:               ci = 2
93:             else if ( i==iy ) then
94:               ci = iy - 1
95:             else
96:               ci = i
97:             end if
98:  
99: !           T(K) at bottom layer
100:             r2ctb(j,i) = tb3d(ci,kz,cj)
101: !           Specific Humidity ?
102:             r2cqb(j,i) = qvb3d(ci,kz,cj)/(1+qvb3d(ci,kz,cj))
103: !           Reference Height (m)
104:             r2czga(j,i) = za(ci,kz,cj)
105: !           Surface winds
106:             r2cuxb(j,i) = ubx3d(ci,kz,cj)
107:             r2cvxb(j,i) = vbx3d(ci,kz,cj)
108: !           Surface Pressure in Pa from cbar
109:             r2cpsb(j,i) = (psb(ci,cj)+ptop)*1000.
110: !           Rainfall
111:             r2crnc(j,i) = pptc(ci,cj)
112:             r2crnnc(j,i) = pptnc(ci,cj)
113: !           Incident Solar Radiation
114:             r2csols(j,i) = sols2d(ci,cj)
115:             r2csoll(j,i) = soll2d(ci,cj)
116:             r2csolsd(j,i) = solsd2d(ci,cj)
117:             r2csolld(j,i) = solld2d(ci,cj)
118:             r2cflwd(j,i) = flwd2d(ci,cj)
119:  
120:           end do
121:         end do
122:  
123: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
124: !c      cc
125: !c      1. Copy 2d (jxp,iy) arrays to 1d work_in (jx*iy) array.      cc
126: !c      2. Gather jxp values of each nproc work_in array and fill     cc
127: !c      work_out(jx*iy) array.                                   cc
128: !c      3. Copy 1d work_out array to 2d (jx,iy) array for passing    cc
129: !c      to clm.                                                   cc
130: !c      abt updated below 1/09                                        cc
131: !c      UPDATE:  copy all r2c vars to one large array; this allows    cc
132: !c      for one MPI_ALLGATHER call instead of several        cc
133: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
134:  
135:         ii = 1
136:         do j = 1 , jxp
137:           do i = 1 , iy
138:             workin(ii) = r2ctb(j,i)
139:             workin(ii+(jxp*iy)) = r2cqb(j,i)
140:             workin(ii+(2*jxp*iy)) = r2czga(j,i)
141:             workin(ii+(3*jxp*iy)) = r2cpsb(j,i)
142:             workin(ii+(4*jxp*iy)) = r2cuxb(j,i)
143:             workin(ii+(5*jxp*iy)) = r2cvxb(j,i)
144:             workin(ii+(6*jxp*iy)) = r2crnc(j,i)
145:             workin(ii+(7*jxp*iy)) = r2crnnc(j,i)
146:             workin(ii+(8*jxp*iy)) = r2csols(j,i)
147:             workin(ii+(9*jxp*iy)) = r2csoll(j,i)
148:             workin(ii+(10*jxp*iy)) = r2csolsd(j,i)
149:             workin(ii+(11*jxp*iy)) = r2csolld(j,i)
150:             workin(ii+(12*jxp*iy)) = r2cflwd(j,i)
151:             ii = ii + 1
152:           end do
153:         end do
154:         call <a href="#" TARGET=CENT_PANEL>mpi_allgather</a>(workin,13*jxp*iy,mpi_double_precision,       &
155:                          & workout,13*jxp*iy,mpi_double_precision,      &
156:                          & mpi_comm_world,ierr)
157:  
158:         ii = 1
159:         kk = 1
160:         counter = 1
161:         do j = 1 , jx
162:           do i = 1 , iy
163:             r2ctb_all(j,i) = workout(ii)
164:             r2cqb_all(j,i) = workout(ii+(jxp*iy))
165:             r2czga_all(j,i) = workout(ii+(2*jxp*iy))
166:             r2cpsb_all(j,i) = workout(ii+(3*jxp*iy))
167:             r2cuxb_all(j,i) = workout(ii+(4*jxp*iy))
168:             r2cvxb_all(j,i) = workout(ii+(5*jxp*iy))
169:             r2crnc_all(j,i) = workout(ii+(6*jxp*iy))
170:             r2crnnc_all(j,i) = workout(ii+(7*jxp*iy))
171:             r2csols_all(j,i) = workout(ii+(8*jxp*iy))
172:             r2csoll_all(j,i) = workout(ii+(9*jxp*iy))
173:             r2csolsd_all(j,i) = workout(ii+(10*jxp*iy))
174:             r2csolld_all(j,i) = workout(ii+(11*jxp*iy))
175:             r2cflwd_all(j,i) = workout(ii+(12*jxp*iy))
176:             ii = ii + 1
177:             counter = counter + 1
178:           end do
179:           if ( counter>jxp*iy ) then
180:             kk = kk + 1
181:             counter = 1
182:             ii = jxp*(kk-1)*13*iy + 1
183:           end if
184:         end do
185: 
186:       else if ( ivers==2 ) then ! end of ivers = 1
187: 
188: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
189: !c
190: !c 1. Copy the parts of 2d (jx,iy) clm arrays that contain
191: !c     data to 1d work_in (jx*iy) array.
192: !c 2. Gather jxp values of each nproc work_in array and fill
193: !c     work_out (jx*iy) array.
194: !c 3. Copy 1d work_out array to 2d (jx,iy) array for passing
195: !c     to nproc 2d (jxp,iy) arrays.
196: !c
197: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
198:  
199: !JLB    3/06: NEED TO CREATE MASK/FILTER FOR EACH CPU. CLM DOES NOT
200: !       ASSIGN GRID CELLS IN QUITE THE ROUND ROBIN FASHION INDICATED.
201: !       TGB
202: !       3/06 -> New routine utilizing c2rprocmap in case of non-round
203: !       robin cpu assignment in clm.
204: !abt    updated below
205: !       1/09 -> update use MPI_ALLGATHER call located in clm_atmlnd.F90
206: !       module This module saves each land surface variable regcm needs
207: !       into a large array (c2r_all).  gathers that array (c2r_allout)
208: !       and the corresponding grid point on the i/j grid to omap_i/j
209: !       Finally, below c2r_allout vars are placed into the proper place
210: !       on the grid for each c2r variable
211: !       NOTE: CLM refers to i = lon while REGCM refers to j = lon
212: !
213:         iii = 0
214:         jj = 1
215:         if ( aertyp/='AER00D0' ) then
216:           nout = 22
217:         else
218:           nout = 20
219:         end if
220:         do nn1 = 1 , nproc
221:           do ii = 1 , c2rngc(nn1)
222:             kk = c2rngc(nn1)
223:             j = omap_i(jj)
224:             i = omap_j(jj)
225:  
226:             c2rtgb(j,i) = c2r_allout(ii+iii)
227:             c2rsnowc(j,i) = c2r_allout(ii+kk+iii)
228:             c2rsenht(j,i) = c2r_allout(ii+(2*kk)+iii)
229:             c2rlatht(j,i) = c2r_allout(ii+(3*kk)+iii)
230:             c2ruvdrag(j,i) = c2r_allout(ii+(4*kk)+iii)
231:             c2ralbdirs(j,i) = c2r_allout(ii+(5*kk)+iii)
232:             c2ralbdirl(j,i) = c2r_allout(ii+(6*kk)+iii)
233:             c2ralbdifs(j,i) = c2r_allout(ii+(7*kk)+iii)
234:             c2ralbdifl(j,i) = c2r_allout(ii+(8*kk)+iii)
235:             c2rtgbb(j,i) = c2r_allout(ii+(9*kk)+iii)
236:             c2r2mt(j,i) = c2r_allout(ii+(10*kk)+iii)
237:             c2r2mq(j,i) = c2r_allout(ii+(11*kk)+iii)
238:             c2ru10(j,i) = c2r_allout(ii+(12*kk)+iii)
239:             c2rtlef(j,i) = c2r_allout(ii+(13*kk)+iii)
240:             c2rsm10cm(j,i) = c2r_allout(ii+(14*kk)+iii)
241:             c2rsm1m(j,i) = c2r_allout(ii+(15*kk)+iii)
242:             c2rsmtot(j,i) = c2r_allout(ii+(16*kk)+iii)
243:             c2rinfl(j,i) = c2r_allout(ii+(17*kk)+iii)
244:             c2rro_sur(j,i) = c2r_allout(ii+(18*kk)+iii)
245:             c2rro_sub(j,i) = c2r_allout(ii+(19*kk)+iii)
246:             if ( aertyp/='AER00D0' ) then
247:               c2rfracsno(j,i) = c2r_allout(ii+(20*kk)+iii)
248:               c2rfvegnosno(j,i) = c2r_allout(ii+(21*kk)+iii)
249:             end if
250:             jj = jj + 1
251:           end do
252:           iii = iii + c2rngc(nn1)*nout
253:         end do
254:  
255:         deallocate(c2r_allout)
256:  
257: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
258: !c      cc
259: !c      Fill nproc 2d (jxp,iy) arrays from full 2d (jx,iy) clm data. cc
260: !c      cc
261: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
262:  
263:         if ( jyear==jyear0 .and. ktau<=1 ) then
264:           mmpd = 86400./dtbat
265:           wpm2 = 1./dtbat
266:         else if ( jyear==jyear0 .and. dble(ktau*dtmin)<=batfrq*60.+     &
267:                 & 0.01 ) then
268:           mmpd = 24./(batfrq-dtmin/60.)
269:           wpm2 = 1./((batfrq-dtmin/60.)*3600.)
270:         else
271:           mmpd = 24./batfrq
272:           wpm2 = 1./(batfrq*3600.)
273:         end if
274:  
275:  
276:         jj = 0
277:         do j = jbegin , jendx
278:           jj = (jxp*myid) + j
279:  
280:           call <a href="./mod_bats.F90.html#interf" TARGET=CENT_PANEL>interf</a>(1 , j , kz , 2 , iym1 , nnsg)
281:           if ( iocnflx==2 ) call <a href="./mod_zengocn.F90.html#zengocndrv" TARGET=CENT_PANEL>zengocndrv</a>(j, nnsg , 2 , iym1 , kz)
282:  
283:           do i = 2 , iym1
284:             ci = i
285:             uvdrag(i,j) = 0.0
286:             hfx(i,j) = 0.0
287:             qfx(i,j) = 0.0
288:             tgb(i,j) = 0.0
289:             tga(i,j) = 0.0
290:             tgbb(i,j) = 0.0
291: !chem2
292:             ssw2da(i,j) = 0.0
293:             sdeltk2d(i,j) = 0.0
294:             sdelqk2d(i,j) = 0.0
295:             sfracv2d(i,j) = 0.0
296:             sfracb2d(i,j) = 0.0
297:             sfracs2d(i,j) = 0.0
298: !chem2_
299:             if ( landmask(jj,ci)==1 ) then
300:               tgb(i,j) = c2rtgb(jj,ci)
301:               tga(i,j) = c2rtgb(jj,ci)
302:               hfx(i,j) = c2rsenht(jj,ci)
303:               qfx(i,j) = c2rlatht(jj,ci)
304:               uvdrag(i,j) = c2ruvdrag(jj,ci)
305:               tgbb(i,j) = c2rtgbb(jj,ci)
306:  
307:               if ( r2cdoalb ) coszrs2d(i,j) = c2rcosz(jj,ci)
308:               if ( i<=iy-1 ) then
309:                 aldirs2d(i,j) = c2ralbdirs(jj,ci)
310:                 aldirl2d(i,j) = c2ralbdirl(jj,ci)
311:                 aldifs2d(i,j) = c2ralbdifs(jj,ci)
312:                 aldifl2d(i,j) = c2ralbdifl(jj,ci)
313:               end if
314:  
315:               do n = 1 , nnsg
316:                 snowc(n,i,j) = c2rsnowc(jj,ci)
317:                 tg2d(n,i,j) = c2rtgb(jj,ci)
318:                 tgb2d(n,i,j) = c2rtgb(jj,ci)
319:                 !supposed to be lower soil layer temp not tgrnd
320:                 taf2d(n,i,j) = c2r2mt(jj,ci)
321:                 tlef2d(n,i,j) = c2rtlef(jj,ci)
322:                 swt2d(n,i,j) = c2rsmtot(jj,ci)
323:                 srw2d(n,i,j) = c2rsm1m(jj,ci)
324:                 ssw2d(n,i,j) = c2rsm10cm(jj,ci)
325:                 dew2d(n,i,j) = ldew1d(n,i)
326:                 sag2d(n,i,j) = sag1d(n,i)    !snow age
327:                 scv2d(n,i,j) = c2rsnowc(jj,ci)
328:                 sice2d(n,i,j) = sice1d(n,i)  ! sea ice
329:                 gwet2d(n,i,j) = gwet1d(n,i)
330:                 ircp2d(n,i,j) = ircp1d(n,i)
331:                 evpa2d(n,i,j) = evpa2d(n,i,j) + dtbat*qfx(i,j)
332:                 sena2d(n,i,j) = sena2d(n,i,j) + dtbat*hfx(i,j)
333:                 rnos2d(n,i,j) = c2rro_sur(jj,ci)*dtbat
334:                 rno2d(n,i,j) = (c2rro_sub(jj,ci)+c2rro_sur(jj,ci))*dtbat
335:  
336:                 ssw2da(i,j) = ssw2da(i,j) + ssw2d(n,i,j)
337:                 sdeltk2d(i,j) = sdeltk2d(i,j) + delt1d(n,i)
338:                 sdelqk2d(i,j) = sdelqk2d(i,j) + delq1d(n,i)
339:                 sfracv2d(i,j) = sfracv2d(i,j) + c2rfvegnosno(jj,ci)
340:                 sfracb2d(i,j) = sfracb2d(i,j)                           &
341:                               & + 1 - (c2rfvegnosno(jj,ci)+             &
342:                               & c2rfracsno(jj,ci))
343:                 sfracs2d(i,j) = sfracs2d(i,j) + c2rfracsno(jj,ci)
344:               end do
345:  
346:               !abt added for 2m humidity when landmask = 1 or 3
347:               q2d(i,j) = c2r2mq(jj,ci)
348: !
349: !             quantities stored on 2d surface array for bats use only
350: !
351:               prca2d(i,j) = prca2d(i,j) + dtbat*pptc(i,j)
352:               prnca2d(i,j) = prnca2d(i,j) + dtbat*pptnc(i,j)
353:               flwa2d(i,j) = flwa2d(i,j) + dtbat*flw1d(i)
354:               flwda2d(i,j) = flwda2d(i,j) + dtbat*flwd2d(i,j)
355:               fswa2d(i,j) = fswa2d(i,j) + dtbat*fsw1d(i)
356:               svga2d(i,j) = svga2d(i,j) + dtbat*sabveg(i)
357:               sina2d(i,j) = sina2d(i,j) + dtbat*sinc2d(i,j)
358:               pptnc(i,j) = 0.
359:               pptc(i,j) = 0.
360: !chem2
361:               ssw2da(i,j) = ssw2da(i,j)/float(nnsg)
362:               sdeltk2d(i,j) = sdeltk2d(i,j)/float(nnsg)
363:               sdelqk2d(i,j) = sdelqk2d(i,j)/float(nnsg)
364:               sfracv2d(i,j) = sfracv2d(i,j)/float(nnsg)
365:               sfracb2d(i,j) = sfracb2d(i,j)/float(nnsg)
366:               sfracs2d(i,j) = sfracs2d(i,j)/float(nnsg)
367: !             svegfrac2d(i,j)= svegfrac2d(i,j)/float(NNSG)
368: !chem2_
369:             else if ( landmask(jj,ci)==0 ) then !ocean
370:  
371:               do n = 1 , nnsg
372:                 uvdrag(i,j) = uvdrag(i,j) + drag1d(n,i)
373:                 hfx(i,j) = hfx(i,j) + sent1d(n,i)
374:                 qfx(i,j) = qfx(i,j) + evpr1d(n,i)
375:                 tgb(i,j) = tgb(i,j) + tg1d(n,i)
376:                 tga(i,j) = tga(i,j) + tg1d(n,i)
377: !chem2
378:                 ssw2da(i,j) = ssw2da(i,j) + ssw1d(n,i)
379:                 sdeltk2d(i,j) = sdeltk2d(i,j) + delt1d(n,i)
380:                 sdelqk2d(i,j) = sdelqk2d(i,j) + delq1d(n,i)
381:                 sfracv2d(i,j) = sfracv2d(i,j) + sigf(n,i)
382:                 sfracb2d(i,j) = sfracb2d(i,j) + (1.-sigf(n,i))          &
383:                               & *(1.-scvk(n,i))
384:                 sfracs2d(i,j) = sfracs2d(i,j) + sigf(n,i)*wt(n,i)       &
385:                               & + (1.-sigf(n,i))*scvk(n,i)
386: !               svegfrac2d(i,j)= svegfrac2d(i,j)+veg1d(n,i)
387: !chem2_
388:  
389:                 if ( iocnflx==1 .or.                                    &
390:                    & (iocnflx==2 .and. ocld2d(n,i,j)>=0.5) ) then
391:                   tgbb(i,j) = tgbb(i,j)                                 &
392:                             & + ((1.-veg1d(n,i))*tg1d(n,i)**4+veg1d(n,i)&
393:                             & *tlef1d(n,i)**4)**0.25
394:                 else
395:                   tgbb(i,j) = tgbb(i,j) + tg1d(n,i)
396:                 end if
397:                 ssw1d(n,i) = -1.E34
398:                 rsw1d(n,i) = -1.E34
399:                 tsw1d(n,i) = -1.E34
400:                 rno1d(n,i) = -1.E34
401:                 rnos1d(n,i) = -1.E34
402:                 scv1d(n,i) = -1.E34
403:               end do
404:  
405:               uvdrag(i,j) = uvdrag(i,j)/float(nnsg)
406:               hfx(i,j) = hfx(i,j)/float(nnsg)
407:               qfx(i,j) = qfx(i,j)/float(nnsg)
408:               tgb(i,j) = tgb(i,j)/float(nnsg)
409:               tga(i,j) = tga(i,j)/float(nnsg)
410:               tgbb(i,j) = tgbb(i,j)/float(nnsg)
411: !chem2
412:               ssw2da(i,j) = ssw2da(i,j)/float(nnsg)
413:               sdeltk2d(i,j) = sdeltk2d(i,j)/float(nnsg)
414:               sdelqk2d(i,j) = sdelqk2d(i,j)/float(nnsg)
415:               sfracv2d(i,j) = sfracv2d(i,j)/float(nnsg)
416:               sfracb2d(i,j) = sfracb2d(i,j)/float(nnsg)
417:               sfracs2d(i,j) = sfracs2d(i,j)/float(nnsg)
418: !             svegfrac2d(i,j)= svegfrac2d(i,j)/float(NNSG)
419: !chem2_
420:               do n = 1 , nnsg
421:                 snowc(n,i,j) = scv1d(n,i)
422: !fix
423:                 tg2d(n,i,j) = tg1d(n,i)
424: !fix_
425:                 tgb2d(n,i,j) = tgb1d(n,i)
426: !               taf2d(n,i,j)=taf1d(n,i)
427:                 taf2d(n,i,j) = t2m_1d(n,i)
428:                 !note taf2d is not temp in canopy but 2m temp
429:                 tlef2d(n,i,j) = tlef1d(n,i)
430:                 swt2d(n,i,j) = tsw1d(n,i)
431:                 srw2d(n,i,j) = rsw1d(n,i)
432:                 ssw2d(n,i,j) = ssw1d(n,i)
433:                 dew2d(n,i,j) = ldew1d(n,i)
434:                 sag2d(n,i,j) = sag1d(n,i)
435:                 scv2d(n,i,j) = scv1d(n,i)
436:                 sice2d(n,i,j) = sice1d(n,i)
437:                 gwet2d(n,i,j) = gwet1d(n,i)
438:                 ircp2d(n,i,j) = ircp1d(n,i)
439:                 evpa2d(n,i,j) = evpa2d(n,i,j) + dtbat*evpr1d(n,i)
440:                 sena2d(n,i,j) = sena2d(n,i,j) + dtbat*sent1d(n,i)
441:                 if ( rnos2d(n,i,j)>-1.E10 .and. rnos1d(n,i)>-1.E10 )    &
442:                    & then
443:                   rnos2d(n,i,j) = rnos2d(n,i,j) + rnos1d(n,i)/tau1*dtbat
444:                 else
445:                   rnos2d(n,i,j) = -1.E34
446:                 end if
447:                 if ( rno2d(n,i,j)>-1.E10 .and. rnos1d(n,i)>-1.E10 .and. &
448:                    & rno1d(n,i)>-1.E10 ) then
449:                   rno2d(n,i,j) = rno2d(n,i,j) + (rno1d(n,i)-rnos1d(n,i))&
450:                                & /tau1*dtbat
451:                 else
452:                   rno2d(n,i,j) = -1.E34
453:                 end if
454:               end do
455: !
456: !             quantities stored on 2d surface array for bats use only
457: !
458:               prca2d(i,j) = prca2d(i,j) + dtbat*pptc(i,j)
459:               prnca2d(i,j) = prnca2d(i,j) + dtbat*pptnc(i,j)
460:               flwa2d(i,j) = flwa2d(i,j) + dtbat*flw1d(i)
461:               flwda2d(i,j) = flwda2d(i,j) + dtbat*flwd2d(i,j)
462:               fswa2d(i,j) = fswa2d(i,j) + dtbat*fsw1d(i)
463:               svga2d(i,j) = svga2d(i,j) + dtbat*sabveg(i)
464:               sina2d(i,j) = sina2d(i,j) + dtbat*sinc2d(i,j)
465:               pptnc(i,j) = 0.
466:               pptc(i,j) = 0.
467:  
468:             else if ( landmask(jj,ci)==3 ) then
469:             !gridcell with some % land and ocean
470:  
471:               do n = 1 , nnsg
472:                 uvdrag(i,j) = uvdrag(i,j) + drag1d(n,i)
473:                 hfx(i,j) = hfx(i,j) + sent1d(n,i)
474:                 qfx(i,j) = qfx(i,j) + evpr1d(n,i)
475:                 tgb(i,j) = tgb(i,j) + tg1d(n,i)
476:                 tga(i,j) = tga(i,j) + tg1d(n,i)
477: !chem2
478:                 ssw2da(i,j) = ssw2da(i,j) + ssw2d(n,i,j)
479:                 sdeltk2d(i,j) = sdeltk2d(i,j) + delt1d(n,i)
480:                 sdelqk2d(i,j) = sdelqk2d(i,j) + delq1d(n,i)
481:                 sfracv2d(i,j) = sfracv2d(i,j) + c2rfvegnosno(jj,ci)
482:                 sfracb2d(i,j) = sfracb2d(i,j)                           &
483:                               & + 1 - (c2rfvegnosno(jj,ci)+             &
484:                               & c2rfracsno(jj,ci))
485:                 sfracs2d(i,j) = sfracs2d(i,j) + c2rfracsno(jj,ci)
486:  
487:                 ssw2da(i,j) = ssw2da(i,j)*landfrac(jj,ci)               &
488:                             & + (1-landfrac(jj,ci))*ssw1d(n,i)
489:                 sdeltk2d(i,j) = sdeltk2d(i,j)*landfrac(jj,ci)           &
490:                               & + (1-landfrac(jj,ci))*delt1d(n,i)
491:                 sdelqk2d(i,j) = sdelqk2d(i,j)*landfrac(jj,ci)           &
492:                               & + (1-landfrac(jj,ci))*delq1d(n,i)
493:                 sfracv2d(i,j) = sfracv2d(i,j)*landfrac(jj,ci)           &
494:                               & + (1-landfrac(jj,ci))*sigf(n,i)
495:                 sfracb2d(i,j) = sfracb2d(i,j)*landfrac(jj,ci)           &
496:                               & + (1-landfrac(jj,ci))*(1.-sigf(n,i))    &
497:                               & *(1.-scvk(n,i))
498:                 sfracs2d(i,j) = sfracs2d(i,j)*landfrac(jj,ci)           &
499:                               & + (1-landfrac(jj,ci))                   &
500:                               & *(sigf(n,i)*wt(n,i)+(1.-sigf(n,i))      &
501:                               & *scvk(n,i))
502: !chem2_
503:  
504:                 if ( iocnflx==1 .or.                                    &
505:                    & (iocnflx==2 .and. ocld2d(n,i,j)>=0.5) ) then
506:                   tgbb(i,j) = tgbb(i,j)                                 &
507:                             & + ((1.-veg1d(n,i))*tg1d(n,i)**4+veg1d(n,i)&
508:                             & *tlef1d(n,i)**4)**0.25
509:                 else
510:                   tgbb(i,j) = tgbb(i,j) + tg1d(n,i)
511:                 end if
512: !               ssw1d(n,i)=-1.e34
513: !               rsw1d(n,i)=-1.e34
514: !               tsw1d(n,i)=-1.e34
515: !               rno1d(n,i)=-1.e34
516: !               rnos1d(n,i)=-1.e34
517: !               scv1d(n,i)=-1.e34
518:               end do
519:  
520:               uvdrag(i,j) = uvdrag(i,j)*(1-landfrac(jj,ci))             &
521:                           & + c2ruvdrag(jj,ci)*landfrac(jj,ci)
522:               hfx(i,j) = hfx(i,j)*(1-landfrac(jj,ci)) + c2rsenht(jj,ci) &
523:                        & *landfrac(jj,ci)
524:               qfx(i,j) = qfx(i,j)*(1-landfrac(jj,ci)) + c2rlatht(jj,ci) &
525:                        & *landfrac(jj,ci)
526:               tgb(i,j) = tgb(i,j)*(1-landfrac(jj,ci)) + c2rtgb(jj,ci)   &
527:                        & *landfrac(jj,ci)
528:               tgbb(i,j) = tgbb(i,j)*(1-landfrac(jj,ci)) + c2rtgbb(jj,ci)&
529:                         & *landfrac(jj,ci)
530:               tga(i,j) = tga(i,j)*(1-landfrac(jj,ci)) + c2rtgb(jj,ci)   &
531:                        & *landfrac(jj,ci)
532:  
533:               uvdrag(i,j) = uvdrag(i,j)/float(nnsg)
534:               hfx(i,j) = hfx(i,j)/float(nnsg)
535:               qfx(i,j) = qfx(i,j)/float(nnsg)
536:               tgb(i,j) = tgb(i,j)/float(nnsg)
537:               tga(i,j) = tga(i,j)/float(nnsg)
538:               tgbb(i,j) = tgbb(i,j)/float(nnsg)
539: !chem2
540:               ssw2da(i,j) = ssw2da(i,j)/float(nnsg)
541:               sdeltk2d(i,j) = sdeltk2d(i,j)/float(nnsg)
542:               sdelqk2d(i,j) = sdelqk2d(i,j)/float(nnsg)
543:               sfracv2d(i,j) = sfracv2d(i,j)/float(nnsg)
544:               sfracb2d(i,j) = sfracb2d(i,j)/float(nnsg)
545:               sfracs2d(i,j) = sfracs2d(i,j)/float(nnsg)
546: !             svegfrac2d(i,j)= svegfrac2d(i,j)/float(NNSG)
547: !chem2_
548:               do n = 1 , nnsg
549:                 dew2d(n,i,j) = ldew1d(n,i)
550:                 sag2d(n,i,j) = sag1d(n,i)
551:                 scv2d(n,i,j) = scv1d(n,i)
552:                 sice2d(n,i,j) = sice1d(n,i)
553:                 gwet2d(n,i,j) = gwet1d(n,i)
554:                 ircp2d(n,i,j) = ircp1d(n,i)
555: !abt            added below for the landfraction method
556:                 snowc(n,i,j) = c2rsnowc(jj,ci)*landfrac(jj,ci)          &
557:                              & + scv1d(n,i)*(1-landfrac(jj,ci))
558:                 tg2d(n,i,j) = c2rtgb(jj,ci)*landfrac(jj,ci) + tg1d(n,i) &
559:                             & *(1-landfrac(jj,ci))
560:                 tgb2d(n,i,j) = c2rtgb(jj,ci)*landfrac(jj,ci)            &
561:                              & + tgb1d(n,i)*(1-landfrac(jj,ci))
562:                 taf2d(n,i,j) = c2r2mt(jj,ci)*landfrac(jj,ci)            &
563:                              & + t2m_1d(n,i)*(1-landfrac(jj,ci))
564:                 !note taf2d is 2m temp not temp in foilage
565:                 tlef2d(n,i,j) = c2rtlef(jj,ci)*landfrac(jj,ci)          &
566:                               & + tlef1d(n,i)*(1-landfrac(jj,ci))
567:                 swt2d(n,i,j) = c2rsmtot(jj,ci)*landfrac(jj,ci)          &
568:                              & + tsw1d(n,i)*(1-landfrac(jj,ci))
569:                 srw2d(n,i,j) = c2rsm1m(jj,ci)*landfrac(jj,ci)           &
570:                              & + rsw1d(n,i)*(1-landfrac(jj,ci))
571:                 ssw2d(n,i,j) = c2rsm10cm(jj,ci)*landfrac(jj,ci)         &
572:                              & + ssw1d(n,i)*(1-landfrac(jj,ci))
573:                 q2d(i,j) = c2r2mq(jj,ci)*landfrac(jj,ci) + q2m_1d(n,i)  &
574:                          & *(1-landfrac(jj,ci))
575:  
576:  
577:                 evpa2d(n,i,j) = evpa2d(n,i,j) + dtbat*qfx(i,j)
578:                 sena2d(n,i,j) = sena2d(n,i,j) + dtbat*hfx(i,j)
579:                 rnos2d(n,i,j) = c2rro_sur(jj,ci)*dtbat
580:                 rno2d(n,i,j) = c2rro_sub(jj,ci)*dtbat + c2rro_sur(jj,ci)&
581:                              & *dtbat
582: !abt            above
583:               end do
584: !
585: !             quantities stored on 2d surface array for bats use only
586: !
587:               prca2d(i,j) = prca2d(i,j) + dtbat*pptc(i,j)
588:               prnca2d(i,j) = prnca2d(i,j) + dtbat*pptnc(i,j)
589:               flwa2d(i,j) = flwa2d(i,j) + dtbat*flw1d(i)
590:               flwda2d(i,j) = flwda2d(i,j) + dtbat*flwd2d(i,j)
591:               fswa2d(i,j) = fswa2d(i,j) + dtbat*fsw1d(i)
592:               svga2d(i,j) = svga2d(i,j) + dtbat*sabveg(i)
593:               sina2d(i,j) = sina2d(i,j) + dtbat*sinc2d(i,j)
594:               pptnc(i,j) = 0.
595:               pptc(i,j) = 0.
596:  
597:             else
598:                !landmask
599:             end if
600:           end do !i loop
601:  
602: !!!!!!!!!!!!!!!! addition from new RegCM !!!!!!!!!!!!!!!!!!!
603:  
604:           do i = 2 , iym1
605:             ci = i
606:  
607:             u10m_o(j,i-1) = 0.0
608:             v10m_o(j,i-1) = 0.0
609:             tg_o(j,i-1) = 0.0
610:             t2m_o(j,i-1) = 0.0
611:  
612:             do n = 1 , nnsg
613:               if ( ocld2d(n,i,j)>0.5 ) then
614:                 u10m_s(n,j,i-1) = ubx3d(i,kz,j)
615:                 v10m_s(n,j,i-1) = vbx3d(i,kz,j)
616:                 tg_s(n,j,i-1) = tg2d(n,i,j)
617:                 t2m_s(n,j,i-1) = taf2d(n,i,j)
618: !               abt            u10m_o(j,i-1)= u10m_o(j,i-1)+ u10m1d(n,i)
619: !               abt            v10m_o(j,i-1)= v10m_o(j,i-1)+ v10m1d(n,i)
620:                 u10m_o(j,i-1) = u10m_o(j,i-1) + ubx3d(i,kz,j)
621:                 v10m_o(j,i-1) = v10m_o(j,i-1) + vbx3d(i,kz,j)
622:                 t2m_o(j,i-1) = t2m_o(j,i-1) + taf2d(n,i,j)
623:                 tg_o(j,i-1) = tg_o(j,i-1) + tg2d(n,i,j)
624:               else if ( ocld2d(n,i,j)<0.5 ) then
625:                 tg_s(n,j,i-1) = tg1d(n,i)
626:                 u10m_s(n,j,i-1) = u10m1d(n,i)
627:                 v10m_s(n,j,i-1) = v10m1d(n,i)
628:                 t2m_s(n,j,i-1) = t2m_1d(n,i)
629:  
630:                 u10m_o(j,i-1) = u10m_o(j,i-1) + u10m1d(n,i)
631:                 v10m_o(j,i-1) = v10m_o(j,i-1) + v10m1d(n,i)
632:                 t2m_o(j,i-1) = t2m_o(j,i-1) + t2m_1d(n,i)
633:                 tg_o(j,i-1) = tg_o(j,i-1) + tg1d(n,i)
634:               else
635:               end if
636:             end do
637:  
638:             u10m_o(j,i-1) = u10m_o(j,i-1)/float(nnsg)
639:             v10m_o(j,i-1) = v10m_o(j,i-1)/float(nnsg)
640:             t2m_o(j,i-1) = t2m_o(j,i-1)/float(nnsg)
641:             tg_o(j,i-1) = tg_o(j,i-1)/float(nnsg)
642:  
643:             tgmx_o(j,i-1) = amax1(tgmx_o(j,i-1),tg_o(j,i-1))
644:             tgmn_o(j,i-1) = amin1(tgmn_o(j,i-1),tg_o(j,i-1))
645:             t2mx_o(j,i-1) = amax1(t2mx_o(j,i-1),t2m_o(j,i-1))
646:             t2mn_o(j,i-1) = amin1(t2mn_o(j,i-1),t2m_o(j,i-1))
647:             w10x_o(j,i-1) = amax1(w10x_o(j,i-1),sqrt(u10m_o(j,i-1)**2+  &
648:                           & v10m_o(j,i-1)**2))
649:             real_4 = (psb(i,j)+ptop)*10.
650:             psmn_o(j,i-1) = amin1(psmn_o(j,i-1),real_4)
651:  
652:           end do
653:              !i loop
654:  
655:           if ( mod(ntime+nint(dtmin*60.),kbats)==0 .or.                 &
656:              & (jyear==jyearr .and. ktau==ktaur) ) then
657:             if ( jyear==jyear0 .and. ktau<=1 ) then
658:               mmpd = 86400./dtbat
659:               wpm2 = 1./dtbat
660:             else if ( jyear==jyear0 .and. dble(ktau*dtmin)<=batfrq*60.+ &
661:                     & 0.01 ) then
662:               mmpd = 24./(batfrq-dtmin/60.)
663:               wpm2 = 1./((batfrq-dtmin/60.)*3600.)
664:             else
665:               mmpd = 24./batfrq
666:               wpm2 = 1./(batfrq*3600.)
667:             end if
668:  
669:             do i = 2 , iym1
670:               ci = i
671:  
672:               drag_o(j,i-1) = 0.0
673:               q2m_o(j,i-1) = 0.0
674:               evpa_o(j,i-1) = 0.0
675:               sena_o(j,i-1) = 0.0
676:               do n = 1 , nnsg
677:                 if ( ocld2d(n,i,j)>=0.5 ) then
678:                   q2m_s(n,j,i-1) = q2d(i,j)
679:                   drag_s(n,j,i-1) = uvdrag(i,j)
680:                   evpa_s(n,j,i-1) = evpa2d(n,ci,j)*mmpd
681:                   sena_s(n,j,i-1) = sena2d(n,ci,j)*wpm2
682:                   tpr_s(n,j,i-1) = (prnca2d(ci,j)+prca2d(ci,j))*mmpd
683:                   prcv_s(n,j,i-1) = prca2d(ci,j)*mmpd
684:                   ps_s(n,j,i-1) = p1d(n,i)*0.01
685:  
686:                   q2m_o(j,i-1) = q2m_o(j,i-1) + q2d(i,j)
687:                   drag_o(j,i-1) = drag_o(j,i-1) + uvdrag(i,j)
688:                   evpa_o(j,i-1) = evpa_o(j,i-1) + evpa2d(n,ci,j)
689:                   sena_o(j,i-1) = sena_o(j,i-1) + sena2d(n,ci,j)
690:                 else if ( ocld2d(n,i,j)<=0.5 ) then
691:                   q2m_s(n,j,i-1) = q2m_1d(n,i)
692:                   drag_s(n,j,i-1) = drag1d(n,i)
693:                   evpa_s(n,j,i-1) = evpa2d(n,i,j)*mmpd
694:                   sena_s(n,j,i-1) = sena2d(n,i,j)*wpm2
695:                   tpr_s(n,j,i-1) = (prnca2d(i,j)+prca2d(i,j))*mmpd
696:                   prcv_s(n,j,i-1) = prca2d(i,j)*mmpd
697:                   ps_s(n,j,i-1) = p1d(n,i)*0.01
698:  
699:                   q2m_o(j,i-1) = q2m_o(j,i-1) + q2m_1d(n,i)
700:                   drag_o(j,i-1) = drag_o(j,i-1) + drag1d(n,i)
701:                   evpa_o(j,i-1) = evpa_o(j,i-1) + evpa2d(n,i,j)
702:                   sena_o(j,i-1) = sena_o(j,i-1) + sena2d(n,i,j)
703:                 else
704:                 end if
705:               end do
706:               tpr_o(j,i-1) = (prnca2d(ci,j)+prca2d(ci,j))*mmpd
707:               q2m_o(j,i-1) = q2m_o(j,i-1)/float(nnsg)
708:               drag_o(j,i-1) = drag_o(j,i-1)/float(nnsg)
709:               evpa_o(j,i-1) = evpa_o(j,i-1)/float(nnsg)*mmpd
710:               sena_o(j,i-1) = sena_o(j,i-1)/float(nnsg)*wpm2
711:               flwa_o(j,i-1) = flwa2d(ci,j)*wpm2
712:               fswa_o(j,i-1) = fswa2d(ci,j)*wpm2
713:               flwd_o(j,i-1) = flwda2d(ci,j)*wpm2
714:               sina_o(j,i-1) = sina2d(ci,j)*wpm2
715:               prcv_o(j,i-1) = prca2d(ci,j)*mmpd
716:               ps_o(j,i-1) = (psb(i,j)+ptop)*10.
717:               zpbl_o(j,i-1) = zpbl(i,j)
718:  
719:               tlef_o(j,i-1) = 0.0
720:               ssw_o(j,i-1) = 0.0
721:               rsw_o(j,i-1) = 0.0
722:               rnos_o(j,i-1) = 0.0
723:               scv_o(j,i-1) = 0.0
724:               nnn = 0
725:               do n = 1 , nnsg
726: !abt           if(ocld2d(n,ci,j).ge.0.5) then
727:                 if ( ocld2d(n,ci,j)>=0.5 .and. landmask(jj,ci)/=3 ) then
728:                   tlef_o(j,i-1) = tlef_o(j,i-1) + c2rtlef(jj,ci)
729:                   ssw_o(j,i-1) = ssw_o(j,i-1) + c2rsm10cm(jj,ci)
730:                   rsw_o(j,i-1) = rsw_o(j,i-1) + c2rsm1m(jj,ci)
731:                   rnos_o(j,i-1) = rnos_o(j,i-1) + rnos2d(n,ci,j)
732:                   scv_o(j,i-1) = scv_o(j,i-1) + c2rsnowc(jj,ci)
733:                   tlef_s(n,j,i-1) = c2rtlef(jj,ci)
734:                   ssw_s(n,j,i-1) = c2rsm10cm(jj,ci)
735:                   rsw_s(n,j,i-1) = c2rsm1m(jj,ci)
736:                   rnos_s(n,j,i-1) = rnos2d(n,ci,j)*mmpd
737:                   scv_s(n,j,i-1) = c2rsnowc(jj,ci)
738:                   nnn = nnn + 1
739:                 else
740:                   tlef_s(n,j,i-1) = -1.E34
741:                   ssw_s(n,j,i-1) = -1.E34
742:                   rsw_s(n,j,i-1) = -1.E34
743:                   rnos_s(n,j,i-1) = -1.E34
744:                   scv_s(n,j,i-1) = -1.E34
745:                 end if
746:               end do
747:               if ( nnn>=max0(nnsg/2,1) ) then
748:                 tlef_o(j,i-1) = tlef_o(j,i-1)/float(nnn)
749:                 ssw_o(j,i-1) = ssw_o(j,i-1)/float(nnn)
750:                 rsw_o(j,i-1) = rsw_o(j,i-1)/float(nnn)
751:                 rnos_o(j,i-1) = rnos_o(j,i-1)/float(nnn)*mmpd
752:                 scv_o(j,i-1) = scv_o(j,i-1)/float(nnn)
753:               else
754:                 tlef_o(j,i-1) = -1.E34
755:                 ssw_o(j,i-1) = -1.E34
756:                 rsw_o(j,i-1) = -1.E34
757:                 rnos_o(j,i-1) = -1.E34
758:                 scv_o(j,i-1) = -1.E34
759:               end if
760: !             ******    reset accumulation arrays to zero
761:               do n = 1 , nnsg
762:                 evpa2d(n,ci,j) = 0.
763:                 rnos2d(n,ci,j) = 0.
764:                 sena2d(n,ci,j) = 0.
765:               end do
766:               prnca2d(ci,j) = 0.
767:               prca2d(ci,j) = 0.
768:               flwa2d(ci,j) = 0.
769:               flwda2d(ci,j) = 0.
770:               fswa2d(ci,j) = 0.
771:               svga2d(ci,j) = 0.
772:               sina2d(ci,j) = 0.
773:  
774:             end do  ! end of i loop
775:           end if    ! end if jyear eq jyearr
776:         end do      ! end of j loop
777:       else          ! end if ivers = 2
778:       end if
779:  
780:       end subroutine interfclm
781: 
782: #endif
</PRE>

<HR>

</BODY>
</HTML>
