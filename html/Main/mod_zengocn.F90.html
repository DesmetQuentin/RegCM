<HTML>

<HEAD>
<TITLE>mod_zengocn.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_zengocn.F90</H1>
<HR>
<H2 ALIGN=CENTER>mod_zengocn.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19: 
<p><a name=mod_zengocn><H3>mod_zengocn</H3></a></p>20:       module mod_zengocn
21: 
22:       implicit none
23: 
24:       private
25: 
26:       public :: zengocndrv
27: 
28:       contains
29: !
<p><a name=zengocndrv><H3>zengocndrv</H3></a></p> Click <a href="./callingtree/zengocndrv_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where zengocndrv is used.
<hr>
30:       subroutine zengocndrv(j , ng , istart , iend , k)
31: !
32:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : dtmin
33:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a> , only : kbats
34:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : r8pt
35:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a> , only : tgb , psb , zpbl
36:       use <a href="./mod_pbldim.F90.html#mod_pbldim" TARGET=CENT_PANEL>mod_pbldim</a> , only : rhox2d , za
37:       use <a href="./mod_slice.F90.html#mod_slice" TARGET=CENT_PANEL>mod_slice</a> , only : tb3d , ubx3d , vbx3d , qvb3d
38:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a> , only : tgb1d , ocld2d , tgb2d , tg1d , sent1d ,    &
39:                    & evpr1d , drag1d , u10m1d , v10m1d , t2m_1d , q2m_1d
40:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : jyear , jyearr , ntime , ktau , ktaur
41:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : wlhv , tzero
42: 
43: #ifdef CLM
44:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a> , only : myid , jxp
45:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a> , only : landmask
46: #endif
47: #ifdef DCSST
48:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : dtbat
49:       use mod_bats , only : deltas , tdeltas , firstcall , dtskin ,     &
50:                  &          fsw2d , flw2d
51:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a> , only : ts1
52:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : sigm , rhoh2o , cpw0 , emsw , gti ,    &
53:                  &               vonkar
54: #endif
55:       implicit none
56: !
57: ! Dummy arguments
58: !
59:       integer , intent (in) :: j , ng , istart , iend , k
60: !
61: ! Local variables
62: !
63:       real(kind=8) :: dqh , dth , facttq , lh , psurf , q995 , qs , sh ,&
64:                & t995 , tau , tsurf , ustar , uv10 , uv995 , z995 , zi ,&
65:                & zo
66:       integer :: i , n
67: #ifdef CLM
68:       integer :: jj
69: #endif
70: #ifdef DCSST
71: !     Implement Zeng and Beljaars, GRL , 2005, ZB2005
72: !     Account for SST diurnal evoluation warm layer/ skin temperature
73: !     scheme
74: !     real(8) :: lwds , lwus
75:       real(8) :: rs , rd , td , tdelta , delta
76:       real(8) :: q , ustarw , fd , l , phidl , aa , bb , cc , lamb
77:       real(8) :: dtstend , dts , fs , tskin , dtsst
78:       real(8) , parameter :: a1 = 0.28D+00
79:       real(8) , parameter :: a2 = 0.27D+00
80:       real(8) , parameter :: a3 = 0.45D+00
81:       real(8) , parameter :: b1 = 71.5D+00
82:       real(8) , parameter :: b2 = 2.8D+00
83:       real(8) , parameter :: b3 = 0.07D+00
84:       real(8) , parameter :: alphaw = 0.207D-06
85:       real(8) , parameter :: nuw = 1.004D-06
86:       real(8) , parameter :: kw = 0.60
87:       real(8) , parameter :: nu = 0.3
88:       real(8) , parameter :: d = 3 ! reference depth for bulk SST
89: #endif
90: !
91: #ifdef CLM
92:       jj = (jxp*myid) + j
93: #endif
94:       do i = istart , iend
95:         do n = 1 , ng
96: #ifdef CLM
97:           if ( ocld2d(n,i,j).lt.0.5 .or. landmask(jj,i).eq.3 ) then
98: #else
99:           if ( ocld2d(n,i,j).lt.0.5 ) then
100: #endif
101:             uv995 = sqrt(ubx3d(i,k,j)**2+vbx3d(i,k,j)**2)
102:             tsurf = tgb(i,j) - tzero
103:             t995 = tb3d(i,k,j) - tzero
104:             q995 = qvb3d(i,k,j)/(1.+qvb3d(i,k,j))
105:             z995 = za(i,k,j)
106:             zi = zpbl(i,j)
107:             psurf = (psb(i,j)+r8pt)*10.
108:             call <a href="./mod_zengocn.F90.html#zengocn" TARGET=CENT_PANEL>zengocn</a>(uv995,tsurf,t995,q995,z995,zi,psurf,qs,        &
109:                        & uv10,tau,lh,sh,dth,dqh,ustar,zo)
110: #ifdef DCSST
111: !           time step considered for the integration of prognostic skin
112: !           temperature , equal to BATS time step
113:             dtsst = dtbat
114: !           handle the first call of the scheme
115:             if ( .not.firstcall(i,j) ) then
116:               deltas(i,j) = 0.001
117:               tdeltas(i,j) = tgb(i,j) - 0.001
118:               firstcall(i,j) = .true.
119:               td = tdeltas(i,j)
120:             end if
121: !           Init local variables
122:             delta = deltas(i,j)
123:             tdelta = tdeltas(i,j)
124: !           td is now the 3m bulk SST from the forcing variable
125:             td = ts1(i,j)
126: !
127: !           deep impact of aod on sst
128: !           if ( sum(aerext(i,:,j)).le.1 ) then
129: !             td = ts1(i,j) - sum(aerext(i,:,j))*0.8
130: !           else if ( sum(aerext(i,:,j)).gt.1 ) then
131: !             td = ts1(i,j)- 1.*0.8
132: !           end if
133: !
134: !           rs is the net surface sw flux (sw energy absorbed)
135:             rs = fsw2d(i,j)
136: !           rd is sw flux at 3m
137:             rd = rs*(a1*dexp(-d*b1) + a2*dexp(-d*b2) + a3*dexp(-d*b3))
138: !           ustar water (with air density ==1)
139:             ustarw = 0.5*ustar*(rhox2d(i,j)/rhoh2o)**0.5
140: !           lwds =  flwd2d(i,j)
141: !           lwus =  emsw*sigm*(tsurf+273.16)**4
142: !           q is the skin cooling term inckude net lw flux from
143: !           the radiative scheme
144: !           q = -(lh+sh+(lwus-lwds))
145:             q = -(lh+sh+flw2d(i,j))
146: !           fraction of solar radiation abosrbed in the sublayer
147:             fs = 0.065+11.*delta-(6.6e-5/delta)*(1-dexp(-delta/8.e-4))
148: !           dts= temperature difference between bulk level and skin level
149: !                determined from previous time step (via tdelta and td)
150:             dts = tdelta-td
151: !           m.o lenght calculation
152:             if ( dts.gt.0 ) then
153:               fd = (nu*gti*alphaw/(5*d))**0.5*                         &
154:                   &  rhoh2o*cpw0*ustarw**2*dts**0.5
155:             else
156:               fd = gti*alphaw*(q+rs-rd)
157:             end if
158:             l = rhoh2o*cpw0*ustarw**3/(vonkar*fd)
159: !           calulation of phidl (stability function)
160:             if ( (d/l).ge.0 ) then
161:               phidl = 1+5.*(d/l)
162:             else
163:               phidl = (1-16.*(d/l))**(-0.5)
164:             end if
165: !           prognostic evolution of dts
166: !           we can split the tendencies ddts/dt = a - b * dts
167: !           with a and b are ultimately function of dts through q
168:             aa = (q + rs - rd) / (d * cpw0 * rhoh2o * nu/(nu+1))
169:             bb = (nu+1) * vonkar * ustarw / (d*phidl)
170: !           exponential solution
171:             dtstend = aa - dts*(1-dexp(-bb*dtsst))/dtsst
172: !           update dts
173:             dts = dts + dtstend * dtsst
174: !           update tdelta
175:             tdelta = dts + td
176: !           update delta thickness  and cool skin tempearture
177:             aa = -16.*gti*alphaw*rhoh2o*cpw0*nuw**3./                   &
178:                 &     (ustarw**4. *kw**2.)
179:             bb =  aa *(q+rs*fs)
180:             if ( bb.gt.0 ) then
181: !             case of cool skin layer correction
182:               cc= bb**(3./4.)
183:               lamb=6.*( (1.+(aa*(q+rs*fs))**0.75)**(-0.333))
184:               delta = lamb*nuw/ustarw
185:               tskin= delta/(rhoh2o*cpw0*kw)*(q+rs*fs) + tdelta
186:             else
187: !             no cool skin layer in this case, tskin = warm layer
188: !             temperature
189:               tskin=tdelta
190:             end if
191: !           save the temperature difference and skin layer thickness
192: !           for next time step
193:             deltas(i,j) = delta
194:             tdeltas(i,j) = tdelta
195:             dtskin(i,j) = tskin-td
196: !           now feedback tskin in surface variable
197:             tgb(i,j) = tskin
198: #endif
199:             tg1d(n,i) = tgb(i,j)
200:             tgb1d(n,i) = tgb(i,j)
201:             sent1d(n,i) = sh
202:             evpr1d(n,i) = lh/wlhv
203: !           Back out Drag Coefficient
204:             drag1d(n,i) = ustar**2*rhox2d(i,j)/uv995
205:             facttq = dlog(z995/2.)/dlog(z995/zo)
206:             u10m1d(n,i) = ubx3d(i,k,j)*uv10/uv995
207:             v10m1d(n,i) = vbx3d(i,k,j)*uv10/uv995
208:             t2m_1d(n,i) = t995 + tzero - dth*facttq
209: !
210:             if ( mod(ntime+nint(dtmin*60.),kbats).eq.0 .or.             &
211:                & (jyear.eq.jyearr .and. ktau.eq.ktaur) ) then
212:               facttq = dlog(z995/2.)/dlog(z995/zo)
213:               q2m_1d(n,i) = q995 - dqh*facttq
214:               tgb2d(n,i,j) = tgb(i,j)
215:             end if
216:           end if
217:         end do
218:       end do
219: !
220:       end subroutine zengocndrv
221: !
222: !
223: !
<p><a name=zengocn><H3>zengocn</H3></a></p> Click <a href="./callingtree/zengocn_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where zengocn is used.
<hr>
224:       subroutine zengocn(u,ts,t,q,hgt,zi,ps,qs,u10,tau,                 &
225:                        & alh,ash,dth,dqh,ustar,zo)
226: !
227: !:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
228: !
229: !
230: !     U. of Arizona (UA)   Bulk Aerodynamic Algorithm
231: !     12/22/97
232: !     --------
233: !     Add the `zo/L' term to the equations, because in a global modeling
234: !     environment (particularly over land), the absolute value of L could
235: !     be smaller than zo (either zom or zoh)   (11/04/98)
236: !     Add restriction: -100 <= z/L <= 2        (02/23/00)
237: !
238: !     Reference: Zeng et al. 1998, Intercomparison of bulk aerodynamic
239: !     algorithms for the computation of sea surface fluxes
240: !     using the TOGA COARE and TAO data. J. Climate,
241: !     11, 2628-2644.
242: !
243: !     For additional information, contact
244: !     Prof. Xubin Zeng
245: !     Department of Atmospheric Science
246: !     PAS Building, #81
247: !     The University of Arizona
248: !     Tucson, AZ 85721
249: !     USA
250: !     Tel:520-621-4782
251: !     Email:xubin@gogo.atmo.arizona.edu
252: !
253: !     input:
254: !       u   = sqrt(u_x^2 + u_y^2): wind speed in m/s at hu (m) height
255: !       ts: surface temperature in (deg C)
256: !       t:  air temperature in (deg C) at ht (m) height
257: !       q: air specific humidity in (kg/kg) at hq (m) height
258: !     output:
259: !       u10: wind speed at 10 meter (m/s)
260: !       tau: wind stress (N/m2)
261: !       alh: latent heat flux (W/m2)
262: !       ash: sensible heat flux (W/m2)
263: !       dth: air-surface potential temperature difference
264: !       dqh: air-surface specific humidity difference
265: !
266: !:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
267: !
268:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : gti , rgti , rgas , rovcp , vonkar ,   &
269:                                  cpd , ep2 , tzero
270:       implicit none
271: !
272: ! Dummy arguments
273: !
274:       real(kind=8) , intent (in) :: hgt , q , t , u , zi , ts , ps
275:       real(kind=8) , intent (out) :: alh , ash , tau , u10
276:       real(kind=8) , intent (inout) :: dqh , dth , qs , ustar , zo
277: !
278: ! Local variables
279: !
280:       real(kind=8) :: dthv , hq , ht , hu , obu , pr , qstar , rb ,     &
281:                & rho , th , thv , thvstar , tstar , um , visa , zot ,   &
282:                & wc , xlv , z10 , zbeta , zeta , zetam , zetat , zoq
283:       integer :: i
284: !
285: !***********************************************************************
286: !
287:       zbeta = 1.   ! -  (in computing W_*)
288:       pr = 0.71    ! =nu/thermal diffusivity (the Prandtl number)
289:       z10 = 10.    ! m  (reference height)
290: !
291:       hu = hgt
292:       ht = hgt
293:       hq = hgt
294: !
295:       th = (t+tzero)*(1000./ps)**rovcp
296:       ! potential T
297:       dth = t + 0.0098*ht - ts
298:       qs = <a href="./mod_zengocn.F90.html#qsat" TARGET=CENT_PANEL>qsat</a>(ts,ps)*0.98
299:       qs = ep2*qs/(ps-0.378*qs)
300:       ! in kg/kg
301:       dqh = q - qs
302:       thv = th*(1.+0.61*q)
303:       ! virtual potential T
304:       dthv = dth*(1.+0.61*q) + 0.61*th*dqh
305:       rho = ps*100./(rgas*(ts+tzero)*(1.+0.61*qs))
306:       ! density
307:       xlv = (2.501-0.00237*ts)*1.E+6
308:       ! J/kg
309: !
310: !     Kinematic viscosity of dry air (m2/s)- Andreas (1989) CRREL Rep.
311: !     89-11
312: !
313:       visa = 1.326E-5*(1+6.542E-3*t+8.301E-6*t*t-4.84E-9*t*t*t)
314: !
315: !     initial values of u* and convective velocity
316: !
317:       ustar = 0.06
318:       wc = 0.5
319:       if ( dthv.ge.0. ) then
320:         um = max(u,0.1D0)
321:       else
322:         um = sqrt(u*u+wc*wc)
323:       end if
324: !
325: !     loop to obtain initial and good ustar and zo
326: !
327:       do i = 1 , 5
328:         zo = 0.013*ustar*ustar*rgti + 0.11*visa/ustar
329:         ustar = vonkar*um/dlog(hu/zo)
330:       end do
331: !
332:       rb = gti*hu*dthv/(thv*um*um)
333:       if ( rb.ge.0. ) then       ! neutral or stable
334:         zeta = rb*dlog(hu/zo)/(1.-5.*dmin1(rb,0.19D0))
335:         zeta = dmin1(2.D0,dmax1(zeta,1.D-6))
336:       else                      !unstable
337:         zeta = rb*dlog(hu/zo)
338:         zeta = dmax1(-100.D0,dmin1(zeta,-1.D-6))
339:       end if
340:       obu = hu/zeta
341: !
342: !     main iterations (2-10 iterations would be fine)
343: !
344:       do i = 1 , 10
345:         call <a href="./mod_zengocn.F90.html#rough" TARGET=CENT_PANEL>rough</a>(zo,zot,zoq,ustar,visa,gti)
346: !
347: !       wind
348: !
349:         zeta = hu/obu
350:         zetam = 1.574
351:         if ( zeta.lt.-zetam ) then
352:                                  ! zeta < -1
353:           ustar = vonkar*um/(dlog(-zetam*obu/zo)-<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(1,-zetam)+         &
354:                 & <a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(1,zo/obu)+1.14*((-zeta)**0.333-(zetam)**0.333))
355:         else if ( zeta.lt.0. ) then
356:                                   ! -1 <= zeta < 0
357:           ustar = vonkar*um/(dlog(hu/zo)-<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(1,zeta)+<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(1,zo/obu))
358:         else if ( zeta.le.1. ) then
359:                                   !  0 <= zeta <= 1
360:           ustar = vonkar*um/(dlog(hu/zo)+5.*zeta-5.*zo/obu)
361:         else                   !  1 < zeta, phi=5+zeta
362:           ustar = vonkar*um/(dlog(obu/zo)+5.-5.*zo/obu+                 &
363:                 & (5.*dlog(zeta)+zeta-1.))
364:         end if
365: !
366: !       temperature
367: !
368:         zeta = ht/obu
369:         zetat = 0.465
370:         if ( zeta.lt.-zetat ) then
371:                                  ! zeta < -1
372:           tstar = vonkar*dth/(dlog(-zetat*obu/zot)-<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(2,-zetat)        &
373:                 & +<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(2,zot/obu)                                       &
374:                 & +0.8*((zetat)**(-0.333)-(-zeta)**(-0.333)))
375:         else if ( zeta.lt.0. ) then
376:                                   ! -1 <= zeta < 0
377:           tstar = vonkar*dth/(dlog(ht/zot)-<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(2,zeta)+<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(2,zot/obu))
378:         else if ( zeta.le.1. ) then
379:                                   !  0 <= ztea <= 1
380:           tstar = vonkar*dth/(dlog(ht/zot)+5.*zeta-5.*zot/obu)
381:         else                   !  1 < zeta, phi=5+zeta
382:           tstar = vonkar*dth/(dlog(obu/zot)+5.-5.*zot/obu+              &
383:                 & (5.*dlog(zeta)+zeta-1.))
384:         end if
385: !
386: !       humidity
387: !
388:         zeta = hq/obu
389:         zetat = 0.465
390:         if ( zeta.lt.-zetat ) then
391:                                  ! zeta < -1
392:           qstar = vonkar*dqh/(dlog(-zetat*obu/zoq)-<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(2,-zetat)        &
393:                 & +<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(2,zoq/obu)                                       &
394:                 & +0.8*((zetat)**(-0.333)-(-zeta)**(-0.333)))
395:         else if ( zeta.lt.0. ) then
396:                                   ! -1 <= zeta < 0
397:           qstar = vonkar*dqh/(dlog(hq/zoq)-<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(2,zeta)+<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(2,zoq/obu))
398:         else if ( zeta.le.1. ) then
399:                                   !  0 <= ztea <= 1
400:           qstar = vonkar*dqh/(dlog(hq/zoq)+5.*zeta-5.*zoq/obu)
401:         else                   !  1 < zeta, phi=5+zeta
402:           qstar = vonkar*dqh/(dlog(obu/zoq)+5.-5.*zoq/obu+              &
403:                 & (5.*dlog(zeta)+zeta-1.))
404:         end if
405:         thvstar = tstar*(1.+0.61*q) + 0.61*th*qstar
406: !
407:         zeta = vonkar*gti*thvstar*hu/(ustar**2*thv)
408:         if ( zeta.ge.0 ) then   !neutral or stable
409:           um = max(u,0.1D0)
410:           zeta = dmin1(2.D0,max(zeta,1.D-6))
411:         else                   !unstable
412:           wc = zbeta*(-gti*ustar*thvstar*zi/thv)**0.333
413:           um = sqrt(u*u+wc*wc)
414:           zeta = dmax1(-100.D0,min(zeta,-1.D-6))
415:         end if
416:         obu = hu/zeta
417:       end do
418: !
419: !--------------------------------------------------------------
420: !
421:       tau = rho*ustar*ustar*u/um
422:       alh = -rho*xlv*qstar*ustar
423:       ash = -rho*cpd*tstar*ustar
424: !
425: !     x and y components of tau:
426: !     taux=rho*ustar*ustar*u_x/um
427: !     tauy=rho*ustar*ustar*u_y/um
428: !     10-meter wind (without w_* part)
429: !
430:       zeta = z10/obu
431:       if ( zeta.lt.0. ) then
432:         u10 = u + (ustar/vonkar)*(dlog(z10/hu)-(<a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(1,zeta)-            &
433:               & <a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a>(1,hu/obu)))
434:       else
435:         u10 = u + (ustar/vonkar)*(dlog(z10/hu)+5.*zeta-5.*hu/obu)
436:       end if
437:       end subroutine zengocn
438: !
439: ! stability function for rb < 0
440: !
<p><a name=psi><H3>psi</H3></a></p> Click <a href="./callingtree/psi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where psi is used.
<hr>
441:       function psi(k,zeta)
442:       implicit none
443: !
444: ! Dummy arguments
445: !
446:       integer , intent(in) :: k
447:       real(kind=8) , intent(in) :: zeta
448:       real(kind=8) :: psi
449: !
450: ! Local variables
451: !
452:       real(kind=8) :: chik
453: !
454:       chik = (1.-16*zeta)**0.25
455:       if ( k.eq.1 ) then
456:         <a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a> = 2.*dlog((1.+chik)*0.5) + dlog((1.+chik*chik)*0.5)         &
457:             & - 2.*atan(chik) + 2.*atan(1.)
458:       else
459:         <a href="./mod_zengocn.F90.html#psi" TARGET=CENT_PANEL>psi</a> = 2.*dlog((1.+chik*chik)*0.5)
460:       end if
461:       end function psi
462: 
463: !
464: ! Tetens' formula for saturation vp Buck(1981) JAM 20, 1527-1532
465: ! p in mb, t in C, and qsat in mb
466: !
<p><a name=qsat><H3>qsat</H3></a></p> Click <a href="./callingtree/qsat_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where qsat is used.
<hr>
467:       function qsat(t,p)
468:       implicit none
469: !
470: ! Dummy arguments
471: !
472:       real(kind=8) , intent (in) :: p , t
473:       real(kind=8) :: qsat
474: !
475:       <a href="./mod_zengocn.F90.html#qsat" TARGET=CENT_PANEL>qsat</a> = (1.0007+3.46E-6*p)*6.1121*exp(17.502*t/(240.97+t))
476: !
477:       end function qsat
478: 
479: !
480: !  our formulation for zo,zot,zoq
481: !
<p><a name=rough><H3>rough</H3></a></p> Click <a href="./callingtree/rough_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rough is used.
<hr>
482:       subroutine rough(zo,zot,zoq,ustar,visa,g)
483: !
484:       implicit none
485: !
486: ! Dummy arguments
487: !
488:       real(kind=8) , intent (in) :: g , ustar , visa
489:       real(kind=8) , intent (out) :: zoq , zot
490:       real(kind=8) , intent (inout) :: zo
491: !
492: ! Local variables
493: !
494:       real(kind=8) :: re , xq , xt
495: !
496: !Im
497: !     zo=0.013*ustar*ustar/g+0.11*visa/ustar
498: !     zo=0.013*ustar*ustar/g
499:       zo = 0.0065*ustar*ustar/g
500: !Im_
501:       re = ustar*zo/visa
502:       xq = 2.67*re**0.25 - 2.57
503:       xt = xq
504:       zoq = zo/exp(xq)
505:       zot = zo/exp(xt)
506:       end subroutine rough
507: !
508:       end module mod_zengocn
</PRE>

<HR>

</BODY>
</HTML>
