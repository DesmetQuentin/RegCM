<HTML>

<HEAD>
<TITLE>linpack.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>linpack.f90</H1>
<HR>
<H2 ALIGN=CENTER>linpack.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
<p><a name=i_swap><H3>i_swap</H3></a></p> Click <a href="./callingtree/i_swap_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where i_swap is used.
<hr>
1: subroutine i_swap ( i, j )
2: !
3: !*******************************************************************************
4: !
5: !! I_SWAP swaps two integer values.
6: !
7: !
8: !  Modified:
9: !
10: !    30 November 1998
11: !
12: !  Author:
13: !
14: !    John Burkardt
15: !
16: !  Parameters:
17: !
18: !    Input/output, integer I, J.  On output, the values of I and
19: !    J have been interchanged.
20: !
21:   implicit none
22: !
23:   integer i
24:   integer j
25:   integer k
26: !
27:   k = i
28:   i = j
29:   j = k
30: 
31:   return
32: end
<p><a name=isamax><H3>isamax</H3></a></p> Click <a href="./callingtree/isamax_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where isamax is used.
<hr>
33: function isamax ( n, x, incx )
34: !
35: !*******************************************************************************
36: !
37: !! ISAMAX finds the index of the vector element of maximum absolute value.
38: !
39: !
40: !  Modified:
41: !
42: !    08 April 1999
43: !
44: !  Reference:
45: !
46: !    Lawson, Hanson, Kincaid, Krogh,
47: !    Basic Linear Algebra Subprograms for Fortran Usage,
48: !    Algorithm 539,
49: !    ACM Transactions on Mathematical Software,
50: !    Volume 5, Number 3, September 1979, pages 308-323.
51: !
52: !    Dongarra, Moler, Bunch and Stewart,
53: !    LINPACK User's Guide,
54: !    SIAM, (Society for Industrial and Applied Mathematics),
55: !    3600 University City Science Center,
56: !    Philadelphia, PA, 19104-2688.
57: !    ISBN 0-89871-172-X
58: !
59: !  Parameters:
60: !
61: !    Input, integer N, the number of entries in the vector.
62: !
63: !    Input, real(8) X(*), the vector to be examined.
64: !
65: !    Input, integer INCX, the increment between successive entries of SX.
66: !
67: !    Output, integer ISAMAX, the index of the element of SX of maximum
68: !    absolute value.
69: !
70:   implicit none
71: !
72:   integer i
73:   integer incx
74:   integer <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a>
75:   integer ix
76:   integer n
77:   real(8) samax
78:   real(8) x(*)
79: !
80:   if ( n <= 0 ) then
81: 
82:     <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> = 0
83: 
84:   else if ( n == 1 ) then
85: 
86:     <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> = 1
87: 
88:   else if ( incx == 1 ) then
89: 
90:     <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> = 1
91:     <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(1) )
92: 
93:     do i = 2, n
94: 
95:       if ( abs ( x(i) ) > samax ) then
96:         <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> = i
97:         <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(i) )
98:       end if
99: 
100:     end do
101: 
102:   else
103: 
104:     if ( incx >= 0 ) then
105:       ix = 1
106:     else
107:       ix = ( - n + 1 ) * incx + 1
108:     end if
109: 
110:     <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> = 1
111:     <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(ix) )
112: 
113:     ix = ix + incx
114: 
115:     do i = 2, n
116:       if ( abs ( x(ix) ) > samax ) then
117:         <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> = i
118:         <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(ix) )
119:       end if
120:       ix = ix + incx
121:     end do
122: 
123:   end if
124: 
125:   return
126: end
<p><a name=r_swap><H3>r_swap</H3></a></p> Click <a href="./callingtree/r_swap_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where r_swap is used.
<hr>
127: subroutine r_swap ( x, y )
128: !
129: !*******************************************************************************
130: !
131: !! R_SWAP swaps two real(8) values.
132: !
133: !
134: !  Modified:
135: !
136: !    01 May 2000
137: !
138: !  Author:
139: !
140: !    John Burkardt
141: !
142: !  Parameters:
143: !
144: !    Input/output, real(8) X, Y.  On output, the values of X and
145: !    Y have been interchanged.
146: !
147:   implicit none
148: !
149:   real(8) x
150:   real(8) y
151:   real(8) z
152: !
153:   z = x
154:   x = y
155:   y = z
156: 
157:   return
158: end
<p><a name=samax><H3>samax</H3></a></p> Click <a href="./callingtree/samax_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where samax is used.
<hr>
159: function samax ( n, x, incx )
160: !
161: !*******************************************************************************
162: !
163: !! SAMAX returns the maximum absolute value of the entries in a vector.
164: !
165: !
166: !  Modified:
167: !
168: !    08 April 1999
169: !
170: !  Parameters:
171: !
172: !    Input, integer N, the number of entries in the vector.
173: !
174: !    Input, real(8) X(*), the vector to be examined.
175: !
176: !    Input, integer INCX, the increment between successive entries of X.
177: !
178: !    Output, real(8) SAMAX, the maximum absolute value of an element of X.
179: !
180:   implicit none
181: !
182:   integer i
183:   integer incx
184:   integer ix
185:   integer n
186:   real(8) samax
187:   real(8) x(*)
188: !
189:   if ( n <= 0 ) then
190: 
191:     <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = 0.0D+00
192: 
193:   else if ( n == 1 ) then
194: 
195:     <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(1) )
196: 
197:   else if ( incx == 1 ) then
198: 
199:     <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(1) )
200: 
201:     do i = 2, n
202:       if ( abs ( x(i) ) > samax ) then
203:         <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(i) )
204:       end if
205:     end do
206: 
207:   else
208: 
209:     if ( incx >= 0 ) then
210:       ix = 1
211:     else
212:       ix = ( - n + 1 ) * incx + 1
213:     end if
214: 
215:     <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(ix) )
216:     ix = ix + incx
217: 
218:     do i = 2, n
219:       if ( abs ( x(ix) ) > samax ) then
220:         <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> = abs ( x(ix) )
221:       end if
222:       ix = ix + incx
223:     end do
224: 
225:   end if
226: 
227:   return
228: end
<p><a name=sasum><H3>sasum</H3></a></p> Click <a href="./callingtree/sasum_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sasum is used.
<hr>
229: function sasum ( n, x, incx )
230: !
231: !*******************************************************************************
232: !
233: !! SASUM sums the absolute values of the entries of a vector.
234: !
235: !
236: !  Modified:
237: !
238: !    15 February 2001
239: !
240: !  Reference:
241: !
242: !    Lawson, Hanson, Kincaid, Krogh,
243: !    Basic Linear Algebra Subprograms for Fortran Usage,
244: !    Algorithm 539,
245: !    ACM Transactions on Mathematical Software,
246: !    Volume 5, Number 3, September 1979, pages 308-323.
247: !
248: !    Dongarra, Moler, Bunch and Stewart,
249: !    LINPACK User's Guide,
250: !    SIAM, (Society for Industrial and Applied Mathematics),
251: !    3600 University City Science Center,
252: !    Philadelphia, PA, 19104-2688.
253: !    ISBN 0-89871-172-X
254: !
255: !  Parameters:
256: !
257: !    Input, integer N, the number of entries in the vector.
258: !
259: !    Input, real(8) X(*), the vector to be examined.
260: !
261: !    Input, integer INCX, the increment between successive entries of X.
262: !    INCX must not be negative.
263: !
264: !    Output, real(8) SASUM, the sum of the absolute values of X.
265: !
266:   implicit none
267: !
268:   integer incx
269:   integer n
270:   real(8) sasum
271:   real(8) x(*)
272: !
273:   <a href="./linpack.f90.html#sasum" TARGET=CENT_PANEL>sasum</a> = sum ( abs ( x(1:1+(n-1)*incx:incx) ) )
274: 
275:   return
276: end
<p><a name=saxpy><H3>saxpy</H3></a></p> Click <a href="./callingtree/saxpy_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where saxpy is used.
<hr>
277: subroutine saxpy ( n, sa, x, incx, y, incy )
278: !
279: !*******************************************************************************
280: !
281: !! SAXPY adds a constant times one vector to another.
282: !
283: !
284: !  Modified:
285: !
286: !    08 April 1999
287: !
288: !  Reference:
289: !
290: !    Lawson, Hanson, Kincaid, Krogh,
291: !    Basic Linear Algebra Subprograms for Fortran Usage,
292: !    Algorithm 539,
293: !    ACM Transactions on Mathematical Software,
294: !    Volume 5, Number 3, September 1979, pages 308-323.
295: !
296: !    Dongarra, Moler, Bunch and Stewart,
297: !    LINPACK User's Guide,
298: !    SIAM, (Society for Industrial and Applied Mathematics),
299: !    3600 University City Science Center,
300: !    Philadelphia, PA, 19104-2688.
301: !    ISBN 0-89871-172-X
302: !
303: !  Parameters:
304: !
305: !    Input, integer N, the number of entries in the vector.
306: !
307: !    Input, real(8) SA, the multiplier.
308: !
309: !    Input, real(8) X(*), the vector to be scaled and added to Y.
310: !
311: !    Input, integer INCX, the increment between successive entries of X.
312: !
313: !    Input/output, real(8) Y(*), the vector to which a multiple of X is to
314: !    be added.
315: !
316: !    Input, integer INCY, the increment between successive entries of Y.
317: !
318:   implicit none
319: !
320:   integer i
321:   integer incx
322:   integer incy
323:   integer ix
324:   integer iy
325:   integer n
326:   real(8) sa
327:   real(8) x(*)
328:   real(8) y(*)
329: !
330:   if ( n <= 0 ) then
331: 
332:   else if ( sa == 0.0D+00 ) then
333: 
334:   else if ( incx == 1 .and. incy == 1 ) then
335: 
336:     y(1:n) = y(1:n) + sa * x(1:n)
337: 
338:   else
339: 
340:     if ( incx >= 0 ) then
341:       ix = 1
342:     else
343:       ix = ( - n + 1 ) * incx + 1
344:     end if
345: 
346:     if ( incy >= 0 ) then
347:       iy = 1
348:     else
349:       iy = ( - n + 1 ) * incy + 1
350:     end if
351: 
352:     do i = 1, n
353:       y(iy) = y(iy) + sa * x(ix)
354:       ix = ix + incx
355:       iy = iy + incy
356:     end do
357: 
358:   end if
359: 
360:   return
361: end
<p><a name=schdc><H3>schdc</H3></a></p> Click <a href="./callingtree/schdc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where schdc is used.
<hr>
362: subroutine schdc ( a, lda, p, work, ipvt, job, info )
363: !
364: !*******************************************************************************
365: !
366: !! SCHDC computes the Cholesky decomposition of a positive definite matrix. 
367: !
368: !
369: !  Discussion:
370: !
371: !    A pivoting option allows the user to estimate the condition of a 
372: !    positive definite matrix or determine the rank of a positive 
373: !    semidefinite matrix.
374: !
375: !    For positive definite matrices, INFO = P is the normal return.
376: !
377: !    For pivoting with positive semidefinite matrices, INFO will
378: !    in general be less than P.  However, INFO may be greater than
379: !    the rank of A, since rounding error can cause an otherwise zero
380: !    element to be positive.  Indefinite systems will always cause
381: !    INFO to be less than P.
382: !
383: !  Reference:
384: !
385: !    Dongarra, Moler, Bunch and Stewart,
386: !    LINPACK User's Guide,
387: !    SIAM, (Society for Industrial and Applied Mathematics),
388: !    3600 University City Science Center,
389: !    Philadelphia, PA, 19104-2688.
390: !    ISBN 0-89871-172-X
391: !
392: !  Author:
393: !
394: !    J Dongarra and G Stewart, 
395: !    Argonne National Laboratory and University of Maryland.
396: !
397: !  Parameters:
398: !
399: !    Input/output, real(8) A(LDA,P).
400: !    On input, A contains the matrix whose decomposition is to
401: !    be computed.  Only the upper half of A need be stored.
402: !    The lower part of the array a is not referenced.
403: !    On output, A contains in its upper half the Cholesky factor
404: !    of the input matrix, as it has been permuted by pivoting.
405: !
406: !    Input, integer LDA, the leading dimension of the array A.
407: !
408: !    Input, integer P, the order of the matrix.
409: !
410: !    Input, real(8) WORK(P) is a work array.
411: !
412: !    Input/output, integer IPVT(P).
413: !    On input, IPVT contains integers that control the selection
414: !    of the pivot elements, if pivoting has been requested.
415: !    Each diagonal element A(K,K) is placed in one of three classes 
416: !    according to the value of IPVT(K).
417: !
418: !      > 0, then X(K) is an initial element.
419: !      = 0, then X(K) is a free element.
420: !      < 0, then X(K) is a final element.
421: !
422: !    Before the decomposition is computed, initial elements are moved by 
423: !    symmetric row and column interchanges to the beginning of the array A 
424: !    and final elements to the end.  Both initial and final elements are 
425: !    frozen in place during the computation and only free elements are moved.  
426: !    At the K-th stage of the reduction, if A(K,K) is occupied by a free 
427: !    element, it is interchanged with the largest free element A(L,L) with 
428: !    L >= K.  IPVT is not referenced if JOB is 0.
429: !
430: !    On output, IPVT(J) contains the index of the diagonal element
431: !    of A that was moved into the J-th position, if pivoting was requested.
432: !
433: !    Input, integer JOB, initiates column pivoting.
434: !    0, no pivoting is done.
435: !    nonzero, pivoting is done.
436: !
437: !    Output, integer INFO, contains the index of the last positive diagonal
438: !    element of the Cholesky factor.
439: !
440:   implicit none
441: !
442:   integer lda
443:   integer p
444: !
445:   real(8) a(lda,p)
446:   integer info
447:   integer j
448:   integer job
449:   integer ipvt(p)
450:   integer k
451:   integer l
452:   real(8) maxdia
453:   integer maxl
454:   logical negk
455:   integer pl
456:   integer pu
457:   logical swapk
458:   real(8) temp
459:   real(8) work(*)
460: !
461:   pl = 1
462:   pu = 0
463:   info = p
464: 
465:   if ( job /= 0 ) then
466: !
467: !  Pivoting has been requested. 
468: !  Rearrange the the elements according to IPVT.
469: !
470:     do k = 1, p
471: 
472:       swapk = ipvt(k) > 0
473: 
474:       negk = ipvt(k) < 0
475:  
476:       if ( negk ) then
477:         ipvt(k) = -k
478:       else
479:         ipvt(k) = k
480:       end if
481: 
482:       if ( swapk ) then
483: 
484:         if ( k /= pl ) then
485: 
486:           call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( pl-1, a(1,k), 1, a(1,pl), 1 )
487: 
488:           call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(k,k), a(pl,pl) )
489: 
490:           do j = pl+1, p
491: 
492:             if ( j < k ) then
493:               call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(pl,j), a(j,k) )
494:             else if ( j > k ) then
495:               call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(pl,j), a(k,j) )
496:             end if
497: 
498:           end do
499: 
500:           ipvt(k) = ipvt(pl)
501:           ipvt(pl) = k
502: 
503:         end if
504: 
505:         pl = pl + 1
506: 
507:       end if     
508: 
509:     end do
510: 
511:     pu = p
512: 
513:     do k = p, pl, -1
514: 
515:       if ( ipvt(k) < 0 ) then
516: 
517:         ipvt(k) = -ipvt(k)
518: 
519:         if ( pu /= k ) then
520: 
521:           call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( k-1, a(1,k), 1, a(1,pu), 1 )
522:           call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(k,k), a(pu,pu) )
523: 
524:           do j = k+1, p
525: 
526:             if ( j < pu ) then
527:               call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(k,j), a(j,pu) )
528:             else if ( j > pu ) then
529:               call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(k,j), a(pu,j) )
530:             end if
531: 
532:           end do
533: 
534:           call <a href="./linpack.f90.html#i_swap" TARGET=CENT_PANEL>i_swap</a> ( ipvt(k), ipvt(pu) )
535: 
536:         end if
537: 
538:         pu = pu - 1
539: 
540:       end if
541: 
542:     end do
543: 
544:   end if
545: 
546:   do k = 1, p
547: !
548: !  Reduction loop.
549: !
550:     maxdia = a(k,k)
551:     maxl = k
552: !
553: !  Determine the pivot element.
554: !
555:     if ( k >= pl .and. k < pu ) then
556: 
557:       do l = k+1, pu
558:         if ( a(l,l) > maxdia ) then
559:           maxdia = a(l,l)
560:           maxl = l
561:         end if
562:       end do
563: 
564:     end if
565: !
566: !  Quit if the pivot element is not positive.
567: !
568:     if ( maxdia <= 0.0D+00 ) then
569:       info = k - 1
570:       return
571:     end if
572: !
573: !  Start the pivoting and update IPVT.
574: !
575:     if ( k /= maxl ) then
576: 
577:       call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( k-1, a(1,k), 1, a(1,maxl), 1 )
578: 
579:       a(maxl,maxl) = a(k,k)
580:       a(k,k) = maxdia
581: 
582:       call <a href="./linpack.f90.html#i_swap" TARGET=CENT_PANEL>i_swap</a> ( ipvt(maxl), ipvt(k) )
583: 
584:     end if
585: !
586: !  Reduction step. 
587: !  Pivoting is contained across the rows.
588: !
589:     work(k) = sqrt ( a(k,k) )
590:     a(k,k) = work(k)
591: 
592:     do j = k+1, p
593: 
594:       if ( k /= maxl ) then
595: 
596:         if ( j < maxl ) then
597:           call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(k,j), a(j,maxl) )
598:         else if ( j > maxl ) then
599:           call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(k,j), a(maxl,j) )
600:         end if
601: 
602:       end if
603: 
604:       a(k,j) = a(k,j) / work(k)
605:       work(j) = a(k,j)
606:       temp = -a(k,j)
607:       call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j-k, temp, work(k+1), 1, a(k+1,j), 1 )
608: 
609:     end do
610:   
611:   end do
612: 
613:   return
614: end
<p><a name=schdd><H3>schdd</H3></a></p> Click <a href="./callingtree/schdd_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where schdd is used.
<hr>
615: subroutine schdd ( r, ldr, p, x, z, ldz, nz, y, rho, c, s, info )
616: !
617: !*******************************************************************************
618: !
619: !! SCHDD downdates an augmented Cholesky decomposition.
620: !
621: !
622: !  Discussion:
623: !
624: !    SCHDD can also downdate the triangular factor of an augmented QR 
625: !    decomposition.
626: !
627: !    Specifically, given an upper triangular matrix R of order P, a
628: !    row vector X, a column vector Z, and a scalar Y, SCHDD
629: !    determines an orthogonal matrix U and a scalar ZETA such that
630: !
631: !          ( R   Z  )     ( RR  ZZ )
632: !      U * (        )  =  (        ),
633: !          ( 0 ZETA )     (  X   Y )
634: !
635: !    where RR is upper triangular.  
636: !
637: !    If R and Z have been obtained from the factorization of a least squares 
638: !    problem, then RR and ZZ are the factors corresponding to the problem
639: !    with the observation (X,Y) removed.  In this case, if RHO
640: !    is the norm of the residual vector, then the norm of
641: !    the residual vector of the downdated problem is
642: !    sqrt ( RHO**2 - ZETA**2 ). SCHDD will simultaneously downdate
643: !    several triplets (Z, Y, RHO) along with R.
644: !
645: !    For a less terse description of what SCHDD does and how
646: !    it may be applied, see the LINPACK guide.
647: !
648: !    The matrix U is determined as the product U(1)*...*U(P)
649: !    where U(I) is a rotation in the (P+1,I)-plane of the form
650: !
651: !      ( C(I)      -S(I)    )
652: !      (                    ).
653: !      ( S(I)       C(I)    )
654: !
655: !    The rotations are chosen so that C(I) is real.
656: !
657: !    The user is warned that a given downdating problem may be impossible 
658: !    to accomplish or may produce inaccurate results.  For example, this 
659: !    can happen if X is near a vector whose removal will reduce the
660: !    rank of R.  Beware.
661: !
662: !  Modified:
663: !
664: !    17 April 2002
665: !
666: !  Reference:
667: !
668: !    Dongarra, Moler, Bunch and Stewart,
669: !    LINPACK User's Guide,
670: !    SIAM, (Society for Industrial and Applied Mathematics),
671: !    3600 University City Science Center,
672: !    Philadelphia, PA, 19104-2688.
673: !    ISBN 0-89871-172-X
674: !
675: !  Parameters:
676: !
677: !    Input/output, real(8) R(LDR,P), the upper triangular matrix that is to be 
678: !    downdated.  The part of R below the diagonal is not referenced.
679: !
680: !    Input, integer LDR, the leading dimension of the array R.
681: !    LDR must be at least P.
682: !
683: !    Input, integer P, the order of the matrix R.
684: !
685: !    Input, real(8) X(P), the row vector that is to be removed from R.  
686: !
687: !    Input/output, real(8) Z(LDZ,NZ), an array of NZ P-vectors which are to 
688: !    be downdated along with R.
689: !
690: !    Input, integer LDZ, the leading dimension of the array Z.
691: !    LDZ must be at least P.
692: !
693: !    Input, integer NZ, the number of vectors to be downdated.
694: !    NZ may be zero, in which case Z, Y, and RHO are not referenced.
695: !
696: !    Input, real(8) Y(NZ), the scalars for the downdating of the vectors Z.  
697: !
698: !    Input/output, real(8) RHO(NZ), the norms of the residual vectors.  On
699: !    output these have been changed along with R and Z.
700: !
701: !    Output, real(8) C(P), S(P), the cosines and sines of the transforming
702: !    rotations.
703: !
704: !    Output, integer INFO, return flag.
705: !     0, the entire downdating was successful.
706: !    -1, if R could not be downdated.  In this case, all quantities
707: !        are left unaltered.
708: !     1, if some RHO could not be downdated.  The offending RHO's are
709: !        set to -1.
710: !
711:   implicit none
712: !
713:   integer ldr
714:   integer ldz
715:   integer nz
716:   integer p
717: !
718:   real(8) a
719:   real(8) alpha
720:   real(8) azeta
721:   real(8) b
722:   real(8) c(p)
723:   integer i
724:   integer ii
725:   integer info
726:   integer j
727:   real(8) norm
728:   real(8) r(ldr,p)
729:   real(8) rho(nz)
730:   real(8) s(p)
731:   real(8) scale
732:   real(8) snrm2
733:   real(8) t
734:   real(8) x(p)
735:   real(8) xx
736:   real(8) y(nz)
737:   real(8) z(ldz,nz)
738:   real(8) zeta
739: !
740: !  Solve the system R'*A = X, placing the result in the array S.
741: !
742:   info = 0
743:   s(1) = x(1) / r(1,1)
744: 
745:   do j = 2, p
746:     s(j) = x(j) - dot_product ( r(1:j-1,j), s(1:j-1) )
747:     s(j) = s(j) / r(j,j)
748:   end do
749: 
750:   norm = <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> ( p, s, 1 )
751: 
752:   if ( norm >= 1.0D+00 ) then
753:     info = -1
754:     return
755:   end if
756: 
757:   alpha = sqrt ( 1.0D+00 - norm**2 )
758: !
759: !  Determine the transformations.
760: !
761:   do ii = 1, p
762:     i = p - ii + 1
763:     scale = alpha + abs ( s(i) )
764:     a = alpha / scale
765:     b = s(i) / scale
766:     norm = sqrt ( a**2 + b**2 )
767:     c(i) = a / norm
768:     s(i) = b / norm
769:     alpha = scale * norm
770:   end do
771: !
772: !  Apply the transformations to R.
773: !
774:   do j = 1, p
775:     xx = 0.0D+00
776:     do ii = 1, j
777:       i = j - ii + 1
778:       t = c(i) * xx + s(i) * r(i,j)
779:       r(i,j) = c(i) * r(i,j) - s(i) * xx
780:       xx = t
781:     end do
782:   end do
783: !
784: !  If required, downdate Z and RHO.
785: !
786:   do j = 1, nz
787: 
788:     zeta = y(j)
789:     do i = 1, p
790:       z(i,j) = ( z(i,j) - s(i) * zeta ) / c(i)
791:       zeta = c(i) * zeta - s(i) * z(i,j)
792:     end do
793: 
794:     azeta = abs ( zeta )
795: 
796:     if ( azeta > rho(j) ) then
797:       info = 1
798:       rho(j) = -1.0D+00
799:     else
800:       rho(j) = rho(j) * sqrt ( 1.0D+00 - ( azeta / rho(j) )**2 )
801:     end if
802: 
803:   end do
804: 
805:   return
806: end
<p><a name=schex><H3>schex</H3></a></p> Click <a href="./callingtree/schex_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where schex is used.
<hr>
807: subroutine schex ( r, ldr, p, k, l, z, ldz, nz, c, s, job )
808: !
809: !*******************************************************************************
810: !
811: !! SCHEX updates the Cholesky factorization of a positive definite matrix.
812: !
813: !
814: !  Discussion:
815: !
816: !    The factorization has the form
817: !
818: !      A = R' * R
819: !
820: !    where A is a positive definite matrix of order P.
821: !
822: !    The updating involves diagonal permutations of the form
823: !
824: !      E' * A * E
825: !
826: !    where E is a permutation matrix.  Specifically, given
827: !    an upper triangular matrix R and a permutation matrix
828: !    E (which is specified by K, L, and JOB), SCHEX determines
829: !    a orthogonal matrix U such that
830: !
831: !      U * R * E = RR,
832: !
833: !    where RR is upper triangular.  At the user's option, the
834: !    transformation U will be multiplied into the array Z.
835: !    If A = X'*X, so that R is the triangular part of the
836: !    QR factorization of X, then RR is the triangular part of the
837: !    QR factorization of X*E, i.e. X with its columns permuted.
838: !    For a less terse description of what SCHEX does and how
839: !    it may be applied, see the LINPACK guide.
840: !
841: !    The matrix Q is determined as the product U(L-K)*...*U(1)
842: !    of plane rotations of the form
843: !
844: !      (    C(I)       S(I) )
845: !      (                    ),
846: !      (   -S(I)       C(I) )
847: !
848: !    where C(I) is real, the rows these rotations operate on
849: !    are described below.
850: !
851: !    There are two types of permutations, which are determined
852: !    by the value of JOB.
853: !
854: !    1, right circular shift.  The columns are rearranged in the order:
855: !
856: !         1,...,K-1,L,K,K+1,...,L-1,L+1,...,P.
857: !
858: !       U is the product of L-K rotations U(I), where U(I)
859: !       acts in the (L-I,L-I+1)-plane.
860: !
861: !    2, left circular shift: the columns are rearranged in the order
862: !
863: !         1,...,K-1,K+1,K+2,...,L,K,L+1,...,P.
864: !
865: !       U is the product of L-K rotations U(I), where U(I)
866: !       acts in the (K+I-1,K+I)-plane.
867: !
868: !  Reference:
869: !
870: !    Dongarra, Moler, Bunch and Stewart,
871: !    LINPACK User's Guide,
872: !    SIAM, (Society for Industrial and Applied Mathematics),
873: !    3600 University City Science Center,
874: !    Philadelphia, PA, 19104-2688.
875: !    ISBN 0-89871-172-X
876: !
877: !  Parameters:
878: !
879: !    Input/output, real(8) R(LDR,P).  On input, the upper triangular factor
880: !    that is to be updated.  Elements of R below the diagonal are not 
881: !    referenced.  On output, R has been updated.
882: !
883: !    Input, integer LDR, the leading dimension of the array R.
884: !    LDR must be at least P.
885: !
886: !    Input, integer P, the order of the matrix R.
887: !
888: !    Input, integer K, the first column to be permuted.
889: !
890: !    Input, integer L, the last column to be permuted.
891: !    L must be strictly greater than K.
892: !
893: !    Input/output real(8) Z(LDZ,NZ), an array of NZ P-vectors into which the
894: !    transformation U is multiplied.  Z is not referenced if NZ = 0.
895: !    On output, Z has been updated.
896: !
897: !    Input, integer LDZ, the leading dimension of the array Z.
898: !    LDZ must be at least P.
899: !
900: !    Input, integer NZ, the number of columns of the matrix Z.
901: !
902: !    Input, integer JOB, determines the type of permutation.
903: !    1, right circular shift.
904: !    2, left circular shift.
905: !
906: !    Output, real(8) C(P), S(P), the cosines and sines of the transforming
907: !    rotations.
908: !
909:   implicit none
910: !
911:   integer ldr
912:   integer ldz
913:   integer p
914:   integer nz
915: !
916:   real(8) c(p)
917:   integer job
918:   integer i
919:   integer ii
920:   integer il
921:   integer iu
922:   integer j
923:   integer jj
924:   integer k
925:   integer l
926:   integer lm1
927:   integer lmk
928:   real(8) r(ldr,p)
929:   real(8) s(p)
930:   real(8) t
931:   real(8) z(ldz,nz)
932: !
933: !  Initialize
934: !
935:   lmk = l - k
936:   lm1 = l - 1
937: !
938: !  Right circular shift.
939: !
940:   if ( job == 1 ) then
941: !
942: !  Reorder the columns.
943: !
944:      do i = 1, l
945:        ii = l - i + 1
946:        s(i) = r(ii,l)
947:      end do
948: 
949:      do jj = k, lm1
950:        j = lm1 - jj + k
951:        do i = 1, j
952:          r(i,j+1) = r(i,j)
953:        end do
954:        r(j+1,j+1) = 0.0D+00
955:      end do
956: 
957:      do i = 1, k-1
958:        ii = l - i + 1
959:        r(i,k) = s(ii)
960:      end do
961: !
962: !  Calculate the rotations.
963: !
964:      t = s(1)
965:      do i = 1, lmk
966:        call <a href="./linpack.f90.html#srotg" TARGET=CENT_PANEL>srotg</a> ( s(i+1), t, c(i), s(i) )
967:        t = s(i+1)
968:      end do
969: 
970:      r(k,k) = t
971: 
972:      do j = k+1, p
973:        il = max (1,l-j+1)
974:        do ii = il, lmk
975:          i = l - ii
976:          t = c(ii) * r(i,j) + s(ii) * r(i+1,j)
977:          r(i+1,j) = c(ii) * r(i+1,j) - s(ii) * r(i,j)
978:          r(i,j) = t
979:        end do
980:      end do
981: !
982: !  If required, apply the transformations to Z.
983: !
984:      do j = 1, nz
985:        do ii = 1, lmk
986:          i = l - ii
987:          t = c(ii) * z(i,j) + s(ii) * z(i+1,j)
988:          z(i+1,j) = c(ii) * z(i+1,j) - s(ii) * z(i,j)
989:          z(i,j) = t
990:        end do
991:      end do
992: !
993: !  Left circular shift.
994: !
995:   else
996: !
997: !  Reorder the columns.
998: !
999:      do i = 1, k
1000:        ii = lmk + i
1001:        s(ii) = r(i,k)
1002:      end do
1003: 
1004:      do j = k, lm1
1005:        do i = 1, j
1006:          r(i,j) = r(i,j+1)
1007:        end do
1008:        jj = j - k + 1
1009:        s(jj) = r(j+1,j+1)
1010:      end do
1011: 
1012:      do i = 1, k
1013:        ii = lmk + i
1014:        r(i,l) = s(ii)
1015:      end do
1016: 
1017:      r(k+1:l,l) = 0.0D+00
1018: !
1019: !  Reduction loop.
1020: !
1021:      do j = k, p
1022: !
1023: !  Apply the rotations.
1024: !
1025:         if ( j /= k ) then
1026: 
1027:            iu = min ( j-1, l-1 )
1028: 
1029:            do i = k, iu
1030:               ii = i - k + 1
1031:               t = c(ii) * r(i,j) + s(ii) * r(i+1,j)
1032:               r(i+1,j) = c(ii) * r(i+1,j) - s(ii) * r(i,j)
1033:               r(i,j) = t
1034:            end do
1035: 
1036:         end if
1037: 
1038:         if ( j < l ) then
1039:            jj = j - k + 1
1040:            t = s(jj)
1041:            call <a href="./linpack.f90.html#srotg" TARGET=CENT_PANEL>srotg</a> ( r(j,j), t, c(jj), s(jj) )
1042:         end if
1043: 
1044:      end do
1045: !
1046: !  Apply the rotations to Z.
1047: !
1048:      do j = 1, nz
1049:         do i = k, lm1
1050:            ii = i - k + 1
1051:            t = c(ii) * z(i,j) + s(ii) * z(i+1,j)
1052:            z(i+1,j) = c(ii) * z(i+1,j) - s(ii) * z(i,j)
1053:            z(i,j) = t
1054:         end do
1055:      end do
1056: 
1057:   end if
1058: 
1059:   return
1060: end
<p><a name=schud><H3>schud</H3></a></p> Click <a href="./callingtree/schud_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where schud is used.
<hr>
1061: subroutine schud ( r, ldr, p, x, z, ldz, nz, y, rho, c, s )
1062: !
1063: !*******************************************************************************
1064: !
1065: !! SCHUD updates an augmented Cholesky decomposition.
1066: !
1067: !
1068: !  Discussion:
1069: !
1070: !    SCHUD can also update the triangular part of an augmented QR 
1071: !    decomposition.
1072: !
1073: !    Specifically, given an upper triangular matrix R of order P, a row vector
1074: !    X, a column vector Z, and a scalar Y, SCHUD determines a unitary matrix 
1075: !    U and a scalar ZETA such that
1076: !
1077: !           (R  Z)     (RR   ZZ )
1078: !      U  * (    )  =  (        ),
1079: !           (X  Y)     ( 0  ZETA)
1080: !
1081: !    where RR is upper triangular.  
1082: !
1083: !    If R and Z have been obtained from the factorization of a least squares
1084: !    problem, then RR and ZZ are the factors corresponding to the problem 
1085: !    with the observation (X,Y) appended.  In this case, if RHO is the 
1086: !    norm of the residual vector, then the norm of the residual vector of 
1087: !    the updated problem is sqrt ( RHO**2 + ZETA**2 ).  SCHUD will 
1088: !    simultaneously update several triplets (Z, Y, RHO).
1089: !
1090: !    For a less terse description of what SCHUD does and how
1091: !    it may be applied, see the LINPACK guide.
1092: !
1093: !    The matrix U is determined as the product U(P)*...*U(1),
1094: !    where U(I) is a rotation in the (I,P+1) plane of the form
1095: !
1096: !      (     C(I)      S(I) )
1097: !      (                    ).
1098: !      (    -S(I)      C(I) )
1099: !
1100: !    The rotations are chosen so that C(I) is real.
1101: !
1102: !  Reference:
1103: !
1104: !    Dongarra, Moler, Bunch and Stewart,
1105: !    LINPACK User's Guide,
1106: !    SIAM, (Society for Industrial and Applied Mathematics),
1107: !    3600 University City Science Center,
1108: !    Philadelphia, PA, 19104-2688.
1109: !    ISBN 0-89871-172-X
1110: !
1111: !  Parameters:
1112: !
1113: !    Input, real(8) R(LDR,P), the upper triangular matrix that is to be updated.  
1114: !    the part of R below the diagonal is not referenced.
1115: !
1116: !    Input, integer LDR, the leading dimension of the array R.
1117: !    LDR must be at least equal to P.
1118: !
1119: !    Input, integer P, the order of the matrix R.
1120: !
1121: !    Input, real(8) X(P), the row to be added to R.
1122: !
1123: !    Input/output, real(8) Z(LDZ,NZ), contains NZ P-vectors to be updated with R.
1124: !
1125: !    Input, integer LDZ, the leading dimension of the array Z.
1126: !    LDZ must be at least P.
1127: !
1128: !    Input, integer NZ, the number of vectors to be updated.  NZ may be 
1129: !    zero, in which case Z, Y, and RHO are not referenced.
1130: !
1131: !    Input, real(8) Y(NZ), the scalars for updating the vectors Z.  
1132: !
1133: !    Input/output, real(8) RHO(NZ).  On input, the norms of the residual
1134: !    vectors that are to be updated.  If RHO(J) is negative, it is left 
1135: !    unaltered.
1136: !
1137: !    Output, real(8) C(P), S(P), the cosines and sines of the transforming
1138: !    rotations.
1139: !
1140:   implicit none
1141: !
1142:   integer ldr
1143:   integer ldz
1144:   integer nz
1145:   integer p
1146: !
1147:   real(8) azeta
1148:   real(8) c(p)
1149:   integer i
1150:   integer j
1151:   real(8) r(ldr,p)
1152:   real(8) rho(nz)
1153:   real(8) s(p)
1154:   real(8) scale
1155:   real(8) t
1156:   real(8) x(p)
1157:   real(8) xj
1158:   real(8) y(nz)
1159:   real(8) z(ldz,nz)
1160:   real(8) zeta
1161: !
1162: !  Update R.
1163: !
1164:   do j = 1, p
1165: 
1166:      xj = x(j)
1167: !
1168: !  Apply the previous rotations.
1169: !
1170:      do i = 1, j-1
1171:         t = c(i) * r(i,j) + s(i) * xj
1172:         xj = c(i) * xj - s(i) * r(i,j)
1173:         r(i,j) = t
1174:      end do
1175: !
1176: !  Compute the next rotation.
1177: !
1178:      call <a href="./linpack.f90.html#srotg" TARGET=CENT_PANEL>srotg</a> ( r(j,j), xj, c(j), s(j) )
1179: 
1180:   end do
1181: !
1182: !  If required, update Z and RHO.
1183: !
1184:   do j = 1, nz
1185: 
1186:      zeta = y(j)
1187: 
1188:      do i = 1, p
1189:         t = c(i) * z(i,j) + s(i) * zeta
1190:         zeta = c(i) * zeta - s(i) * z(i,j)
1191:         z(i,j) = t
1192:      end do
1193: 
1194:      azeta = abs ( zeta )
1195: 
1196:      if ( azeta /= 0.0D+00 .and. rho(j) >= 0.0 ) then
1197:         scale = azeta + rho(j)
1198:         rho(j) = scale * sqrt ( ( azeta / scale )**2 + ( rho(j) / scale )**2 )
1199:      end if
1200: 
1201:   end do
1202: 
1203:   return
1204: end
<p><a name=scopy><H3>scopy</H3></a></p> Click <a href="./callingtree/scopy_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where scopy is used.
<hr>
1205: subroutine scopy ( n, x, incx, y, incy )
1206: !
1207: !*******************************************************************************
1208: !
1209: !! SCOPY copies one real(8) vector into another.
1210: !
1211: !
1212: !  Modified:
1213: !
1214: !    08 April 1999
1215: !
1216: !  Reference:
1217: !
1218: !    Lawson, Hanson, Kincaid, Krogh,
1219: !    Basic Linear Algebra Subprograms for Fortran Usage,
1220: !    Algorithm 539,
1221: !    ACM Transactions on Mathematical Software,
1222: !    Volume 5, Number 3, September 1979, pages 308-323.
1223: !
1224: !    Dongarra, Moler, Bunch and Stewart,
1225: !    LINPACK User's Guide,
1226: !    SIAM, (Society for Industrial and Applied Mathematics),
1227: !    3600 University City Science Center,
1228: !    Philadelphia, PA, 19104-2688.
1229: !    ISBN 0-89871-172-X
1230: !
1231: !  Parameters:
1232: !
1233: !    Input, integer N, the number of entries in the vector.
1234: !
1235: !    Input, real(8) X(*), the vector to be copied into Y.
1236: !
1237: !    Input, integer INCX, the increment between successive entries of X.
1238: !
1239: !    Output, real(8) Y(*), the copy of X.
1240: !
1241: !    Input, integer INCY, the increment between successive elements of Y.
1242: !
1243:   implicit none
1244: !
1245:   integer i
1246:   integer incx
1247:   integer incy
1248:   integer ix
1249:   integer iy
1250:   integer n
1251:   real(8) x(*)
1252:   real(8) y(*)
1253: !
1254:   if ( n <= 0 ) then
1255: 
1256:   else if ( incx == 1 .and. incy == 1 ) then
1257: 
1258:     y(1:n) = x(1:n)
1259: 
1260:   else
1261: 
1262:     if ( incx >= 0 ) then
1263:       ix = 1
1264:     else
1265:       ix = ( - n + 1 ) * incx + 1
1266:     end if
1267: 
1268:     if ( incy >= 0 ) then
1269:       iy = 1
1270:     else
1271:       iy = ( - n + 1 ) * incy + 1
1272:     end if
1273: 
1274:     do i = 1, n
1275:       y(iy) = x(ix)
1276:       ix = ix + incx
1277:       iy = iy + incy
1278:     end do
1279: 
1280:   end if
1281: 
1282:   return
1283: end
<p><a name=sdot><H3>sdot</H3></a></p> Click <a href="./callingtree/sdot_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sdot is used.
<hr>
1284: function sdot ( n, x, incx, y, incy )
1285: !
1286: !*******************************************************************************
1287: !
1288: !! SDOT forms the dot product of two vectors.
1289: !
1290: !
1291: !  Discussion:
1292: !
1293: !    For many purposes, SDOT can be replaced by the FORTRAN 90
1294: !    intrinsic DOT_PRODUCT.
1295: !
1296: !  Modified:
1297: !
1298: !    02 June 2000
1299: !
1300: !  Reference:
1301: !
1302: !    Lawson, Hanson, Kincaid, Krogh,
1303: !    Basic Linear Algebra Subprograms for Fortran Usage,
1304: !    Algorithm 539,
1305: !    ACM Transactions on Mathematical Software,
1306: !    Volume 5, Number 3, September 1979, pages 308-323.
1307: !
1308: !    Dongarra, Moler, Bunch and Stewart,
1309: !    LINPACK User's Guide,
1310: !    SIAM, (Society for Industrial and Applied Mathematics),
1311: !    3600 University City Science Center,
1312: !    Philadelphia, PA, 19104-2688.
1313: !    ISBN 0-89871-172-X
1314: !
1315: !  Parameters:
1316: !
1317: !    Input, integer N, the number of entries in the vectors.
1318: !
1319: !    Input, real(8) X(*), one of the vectors to be multiplied.
1320: !
1321: !    Input, integer INCX, the increment between successive entries of X.
1322: !
1323: !    Input, real(8) Y(*), one of the vectors to be multiplied.
1324: !
1325: !    Input, integer INCY, the increment between successive elements of Y.
1326: !
1327: !    Output, real(8) SDOT, the dot product of X and Y.
1328: !
1329:   implicit none
1330: !
1331:   integer i
1332:   integer incx
1333:   integer incy
1334:   integer ix
1335:   integer iy
1336:   integer n
1337:   real(8) sdot
1338:   real(8) stemp
1339:   real(8) x(*)
1340:   real(8) y(*)
1341: !
1342:   if ( n <= 0 ) then
1343: 
1344:     <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> = 0.0D+00
1345: 
1346:   else if ( incx == 1 .and. incy == 1 ) then
1347: 
1348:     <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> = dot_product ( x(1:n), y(1:n) )
1349: 
1350:   else
1351: 
1352:     if ( incx >= 0 ) then
1353:       ix = 1
1354:     else
1355:       ix = ( - n + 1 ) * incx + 1
1356:     end if
1357: 
1358:     if ( incy >= 0 ) then
1359:       iy = 1
1360:     else
1361:       iy = ( - n + 1 ) * incy + 1
1362:     end if
1363: 
1364:     stemp = 0.0D+00
1365:     do i = 1, n
1366:       stemp = stemp + x(ix) * y(iy)
1367:       ix = ix + incx
1368:       iy = iy + incy
1369:     end do
1370: 
1371:     <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> = stemp
1372: 
1373:   end if
1374: 
1375:   return
1376: end
<p><a name=sgbco><H3>sgbco</H3></a></p> Click <a href="./callingtree/sgbco_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgbco is used.
<hr>
1377: subroutine sgbco ( abd, lda, n, ml, mu, ipvt, rcond, z )
1378: !
1379: !*******************************************************************************
1380: !
1381: !! SGBCO factors a real(8) band matrix and estimates its condition.
1382: !
1383: !
1384: !  Discussion:
1385: !
1386: !    If RCOND is not needed, SGBFA is slightly faster.
1387: !
1388: !    To solve A*X = B, follow SGBCO by SGBSL.
1389: !
1390: !    To compute inverse(A)*C, follow SGBCO by SGBSL.
1391: !
1392: !    To compute determinant(A), follow SGBCO by SGBDI.
1393: !
1394: !  Example:  
1395: !
1396: !    If the original matrix is
1397: !
1398: !      11 12 13  0  0  0
1399: !      21 22 23 24  0  0
1400: !       0 32 33 34 35  0
1401: !       0  0 43 44 45 46
1402: !       0  0  0 54 55 56
1403: !       0  0  0  0 65 66
1404: !
1405: !    then for proper band storage,
1406: !
1407: !      N = 6, ML = 1, MU = 2, LDA >= 5  and ABD should contain
1408: !
1409: !       *  *  *  +  +  +      * = not used
1410: !       *  * 13 24 35 46      + = used for pivoting
1411: !       * 12 23 34 45 56
1412: !      11 22 33 44 55 66
1413: !      21 32 43 54 65  *
1414: !
1415: !  Band storage:
1416: !
1417: !    If A is a band matrix, the following program segment
1418: !    will set up the input.
1419: !
1420: !      ml = (band width below the diagonal)
1421: !      mu = (band width above the diagonal)
1422: !      m = ml + mu + 1
1423: !
1424: !      do j = 1, n
1425: !        i1 = max ( 1, j-mu )
1426: !        i2 = min ( n, j+ml )
1427: !        do i = i1, i2
1428: !          k = i - j + m
1429: !          abd(k,j) = a(i,j)
1430: !        end do
1431: !      end do
1432: !
1433: !    This uses rows ML+1 through 2*ML+MU+1 of ABD.  In addition, the first  
1434: !    ML rows in ABD are used for elements generated during the
1435: !    triangularization.
1436: !
1437: !    The total number of rows needed in ABD is  2*ML+MU+1.  The ML+MU by 
1438: !    ML+MU upper left triangle and the ML by ML lower right triangle are 
1439: !    not referenced.
1440: !
1441: !  Reference:
1442: !
1443: !    Dongarra, Moler, Bunch and Stewart,
1444: !    LINPACK User's Guide,
1445: !    SIAM, (Society for Industrial and Applied Mathematics),
1446: !    3600 University City Science Center,
1447: !    Philadelphia, PA, 19104-2688.
1448: !    ISBN 0-89871-172-X
1449: !
1450: !  Parameters:
1451: !
1452: !    Input/output, real(8) ABD(LDA,N).  On input, the matrix in band storage.  
1453: !    The columns of the matrix are stored in the columns of ABD and
1454: !    the diagonals of the matrix are stored in rows ML+1 through 2*ML+MU+1 
1455: !    of ABD.  On output, an upper triangular matrix in band storage and
1456: !    the multipliers which were used to obtain it.  The factorization can 
1457: !    be written A = L*U where L is a product of permutation and unit lower
1458: !    triangular matrices and U is upper triangular.
1459: !
1460: !    Input, integer LDA, the leading dimension of the array ABD.
1461: !    LDA must be >= 2*ML + MU + 1.
1462: !
1463: !    Input, integer N, the order of the matrix.
1464: !
1465: !    Input, integer ML, MU, the number of diagonals below and above the 
1466: !    main diagonal.  0 <= ML < N, 0 <= MU < N.
1467: !
1468: !    Output, integer IPVT(N), the pivot indices.
1469: !
1470: !    Output, real(8) RCOND, an estimate of the reciprocal condition of A.
1471: !    For the system A*X = B, relative perturbations in A and B of size  
1472: !    EPSILON may cause relative perturbations in X of size EPSILON/RCOND.
1473: !    If RCOND is so small that the logical expression
1474: !      1.0D+00 + RCOND == 1.0D+00
1475: !    is true, then A may be singular to working precision.  In particular,  
1476: !    RCOND is zero if exact singularity is detected or the estimate underflows.
1477: !
1478: !    Workspace, real(8) Z(N), a work vector whose contents are usually unimportant.
1479: !    If A is close to a singular matrix, then Z is an approximate null vector 
1480: !    in the sense that
1481: !      norm(A*Z) = RCOND * norm(A) * norm(Z).
1482: !
1483:   implicit none
1484: !
1485:   integer lda
1486:   integer n
1487: !
1488:   real(8) abd(lda,n)
1489:   real(8) anorm
1490:   real(8) ek
1491:   integer info
1492:   integer ipvt(n)
1493:   integer is
1494:   integer j
1495:   integer ju
1496:   integer k
1497:   integer l
1498:   integer la
1499:   integer lm
1500:   integer lz
1501:   integer m
1502:   integer ml
1503:   integer mm
1504:   integer mu
1505:   real(8) rcond
1506:   real(8) s
1507:   real(8) sm
1508:   real(8) t
1509:   real(8) wk
1510:   real(8) wkm
1511:   real(8) ynorm
1512:   real(8) z(n)
1513: !
1514: !  Compute the 1-norm of A.
1515: !
1516:   anorm = 0.0D+00
1517:   l = ml + 1
1518:   is = l + mu
1519:   do j = 1, n
1520:     anorm = max ( anorm, sum ( abs ( abd(is:is+l-1,j) ) ) )
1521:     if ( is > ml + 1 ) is = is - 1
1522:     if ( j <= mu ) l = l + 1
1523:     if ( j >= n - ml ) l = l - 1
1524:   end do
1525: !
1526: !  Factor.
1527: !
1528:   call <a href="./linpack.f90.html#sgbfa" TARGET=CENT_PANEL>sgbfa</a> ( abd, lda, n, ml, mu, ipvt, info )
1529: !
1530: !  RCOND = 1/(norm(A)*(estimate of norm(inverse(A)))).
1531: !
1532: !  Estimate = norm(Z)/norm(Y) where  a*z = y  and A'*Y = E.
1533: !
1534: !  A' is the transpose of A.  The components of E are
1535: !  chosen to cause maximum local growth in the elements of W where
1536: !  U'*W = E.  The vectors are frequently rescaled to avoid
1537: !  overflow.
1538: !
1539: !  Solve U'*W = E.
1540: !
1541:   ek = 1.0D+00
1542:   z(1:n) = 0.0D+00
1543:   m = ml + mu + 1
1544:   ju = 0
1545: 
1546:   do k = 1, n
1547: 
1548:      if ( z(k) /= 0.0D+00 ) then
1549:        ek = sign ( ek, -z(k) )
1550:      end if
1551: 
1552:      if ( abs ( ek - z(k) ) > abs ( abd(m,k) ) ) then
1553:        s = abs ( abd(m,k) ) / abs ( ek - z(k) )
1554:        z(1:n) = s * z(1:n)
1555:        ek = s * ek
1556:      end if
1557: 
1558:      wk = ek - z(k)
1559:      wkm = -ek - z(k)
1560:      s = abs ( wk )
1561:      sm = abs ( wkm )
1562: 
1563:      if ( abd(m,k) /= 0.0D+00 ) then
1564:        wk = wk / abd(m,k)
1565:        wkm = wkm / abd(m,k)
1566:      else
1567:        wk = 1.0D+00
1568:        wkm = 1.0D+00
1569:      end if
1570: 
1571:      ju = min ( max ( ju, mu+ipvt(k) ), n )
1572:      mm = m
1573: 
1574:      if ( k+1 <= ju ) then
1575: 
1576:         do j = k+1, ju
1577:           mm = mm - 1
1578:           sm = sm + abs ( z(j ) + wkm * abd(mm,j) )
1579:           z(j) = z(j) + wk * abd(mm,j)
1580:           s = s + abs ( z(j) )
1581:         end do
1582: 
1583:         if ( s < sm ) then
1584:            t = wkm - wk
1585:            wk = wkm
1586:            mm = m
1587:            do j = k+1, ju
1588:              mm = mm - 1
1589:              z(j) = z(j) + t * abd(mm,j)
1590:            end do
1591:         end if
1592: 
1593:      end if
1594: 
1595:      z(k) = wk
1596: 
1597:   end do
1598: 
1599:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
1600: !
1601: !  Solve L'*Y = W.
1602: !
1603:   do k = n, 1, -1
1604: 
1605:      lm = min ( ml, n-k )
1606: 
1607:      if ( k < n ) then
1608:        z(k) = z(k) + dot_product ( abd(m+1:m+lm,k), z(k+1:k+lm) )
1609:      end if
1610: 
1611:      if ( abs ( z(k) ) > 1.0D+00 ) then
1612:        s = 1.0D+00 / abs ( z(k) )
1613:        z(1:n) = s * z(1:n)
1614:      end if
1615: 
1616:      l = ipvt(k)
1617:      t = z(l)
1618:      z(l) = z(k)
1619:      z(k) = t
1620:   end do
1621: 
1622:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
1623:   ynorm = 1.0D+00
1624: !
1625: !  Solve L*V = Y.
1626: !
1627:   do k = 1, n
1628: 
1629:      l = ipvt(k)
1630:      t = z(l)
1631:      z(l) = z(k)
1632:      z(k) = t
1633:      lm = min ( ml, n-k )
1634: 
1635:      if ( k < n ) then
1636:        call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( lm, t, abd(m+1,k), 1, z(k+1), 1 )
1637:      end if
1638: 
1639:      if ( abs ( z(k) ) > 1.0D+00 ) then
1640:        s = 1.0D+00 / abs ( z(k) )
1641:        z(1:n) = s * z(1:n)
1642:        ynorm = s * ynorm
1643:      end if
1644: 
1645:   end do
1646: 
1647:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
1648:   z(1:n) = s * z(1:n)
1649:   ynorm = s * ynorm
1650: !
1651: !  Solve U*Z = W.
1652: !
1653:   do k = n, 1, -1
1654: 
1655:      if ( abs ( z(k) ) > abs ( abd(m,k) ) ) then
1656:        s = abs ( abd(m,k) ) / abs ( z(k) )
1657:        z(1:n) = s * z(1:n)
1658:        ynorm = s * ynorm
1659:      end if
1660: 
1661:      if ( abd(m,k) /= 0.0D+00 ) then
1662:        z(k) = z(k) / abd(m,k)
1663:      else
1664:        z(k) = 1.0D+00
1665:      end if
1666: 
1667:      lm = min ( k, m ) - 1
1668:      la = m - lm
1669:      lz = k - lm
1670:      t = -z(k)
1671:      call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( lm, t, abd(la,k), 1, z(lz), 1 )
1672: 
1673:   end do
1674: !
1675: !  Make ZNORM = 1.0.
1676: !
1677:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
1678:   z(1:n) = s * z(1:n)
1679:   ynorm = s * ynorm
1680: 
1681:   if ( anorm /= 0.0D+00 ) then
1682:     rcond = ynorm / anorm
1683:   else
1684:     rcond = 0.0D+00
1685:   end if
1686: 
1687:   return
1688: end
<p><a name=sgbdi><H3>sgbdi</H3></a></p> Click <a href="./callingtree/sgbdi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgbdi is used.
<hr>
1689: subroutine sgbdi ( abd, lda, n, ml, mu, ipvt, det )
1690: !
1691: !*******************************************************************************
1692: !
1693: !! SGBDI computes the determinant of a band matrix factored by SGBCO or SGBFA.
1694: !
1695: !
1696: !  Discussion:
1697: !
1698: !    If the inverse is needed, use SGBSL N times.
1699: !
1700: !  Reference:
1701: !
1702: !    Dongarra, Moler, Bunch and Stewart,
1703: !    LINPACK User's Guide,
1704: !    SIAM, (Society for Industrial and Applied Mathematics),
1705: !    3600 University City Science Center,
1706: !    Philadelphia, PA, 19104-2688.
1707: !    ISBN 0-89871-172-X
1708: !
1709: !  Parameters:
1710: !
1711: !    Input, real(8) ABD(LDA,N), the output from SGBCO or SGBFA.
1712: !
1713: !    Input, integer LDA, the leading dimension of the array ABD.
1714: !
1715: !    Input, integer N, the order of the matrix.
1716: !
1717: !    Input, integer ML, MU, the number of diagonals below and above the 
1718: !    main diagonal.  0 <= ML < N, 0 <= MU < N.
1719: !
1720: !    Input, integer IPVT(N), the pivot vector from SGBCO or SGBFA.
1721: !
1722: !    Output, real(8) DET(2), the determinant of the original matrix.
1723: !      determinant = DET(1) * 10.0**DET(2)
1724: !    with  1.0D+00 <= abs ( DET(1) ) < 10.0D+00 or DET(1) = 0.0D+00.
1725: !
1726:   implicit none
1727: !
1728:   integer lda
1729:   integer n
1730: !
1731:   real(8) abd(lda,n)
1732:   real(8) det(2)
1733:   integer i
1734:   integer ipvt(n)
1735:   integer m
1736:   integer ml
1737:   integer mu
1738:   real, parameter :: ten = 10.0D+00
1739: !
1740:   m = ml + mu + 1
1741:   det(1) = 1.0D+00
1742:   det(2) = 0.0D+00
1743: 
1744:   do i = 1, n
1745: 
1746:      if ( ipvt(i) /= i ) then
1747:        det(1) = -det(1)
1748:      end if
1749: 
1750:      det(1) = abd(m,i) * det(1)
1751: 
1752:      if ( det(1) == 0.0D+00 ) then
1753:        return
1754:      end if
1755: 
1756:      do while ( abs ( det(1) ) < 1.0D+00 ) 
1757:        det(1) = ten * det(1)
1758:        det(2) = det(2) - 1.0D+00
1759:      end do
1760: 
1761:      do while ( abs ( det(1) ) >= ten ) 
1762:        det(1) = det(1) / ten
1763:        det(2) = det(2) + 1.0D+00
1764:      end do
1765: 
1766:   end do
1767: 
1768:   return
1769: end
<p><a name=sgbfa><H3>sgbfa</H3></a></p> Click <a href="./callingtree/sgbfa_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgbfa is used.
<hr>
1770: subroutine sgbfa ( abd, lda, n, ml, mu, ipvt, info )
1771: !
1772: !*******************************************************************************
1773: !
1774: !! SGBFA factors a real(8) band matrix by elimination.
1775: !
1776: !
1777: !  Discussion:
1778: !
1779: !    SGBFA is usually called by SGBCO, but it can be called
1780: !    directly with a saving in time if RCOND is not needed.
1781: !
1782: !  Reference:
1783: !
1784: !    Dongarra, Moler, Bunch and Stewart,
1785: !    LINPACK User's Guide,
1786: !    SIAM, (Society for Industrial and Applied Mathematics),
1787: !    3600 University City Science Center,
1788: !    Philadelphia, PA, 19104-2688.
1789: !    ISBN 0-89871-172-X
1790: !
1791: !  Parameters:
1792: !
1793: !    Input/output, real(8) ABD(LDA,N).  On input, contains the matrix in band 
1794: !    storage.  The columns of the matrix are stored in the columns of ABD 
1795: !    and the diagonals of the matrix are stored in rows ML+1 through 
1796: !    2*ML+MU+1 of ABD.  On output, an upper triangular matrix in band storage 
1797: !    and the multipliers which were used to obtain it.  The factorization 
1798: !    can be written A = L*U where L is a product of permutation and unit lower
1799: !    triangular matrices and U is upper triangular.
1800: !
1801: !    Input, integer LDA, the leading dimension of the array ABD.
1802: !    LDA must be >= 2*ML + MU + 1.
1803: !
1804: !    Input, integer N, the order of the matrix.
1805: !
1806: !    Input, integer ML, MU, the number of diagonals below and above the 
1807: !    main diagonal.  0 <= ML < N, 0 <= MU < N.
1808: !
1809: !    Output, integer IPVT(N), the pivot indices.
1810: !
1811: !    Output, integer INFO, error flag.
1812: !    0, normal value.
1813: !    K, if U(K,K) == 0.0D+00.  This is not an error condition for this 
1814: !      subroutine, but it does indicate that SGBSL will divide by zero if
1815: !      called.  Use RCOND in SGBCO for a reliable indication of singularity.
1816: !
1817:   implicit none
1818: !
1819:   integer lda
1820:   integer n
1821: !
1822:   real(8) abd(lda,n)
1823:   integer i0
1824:   integer info
1825:   integer ipvt(n)
1826:   integer <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a>
1827:   integer j
1828:   integer j0
1829:   integer j1
1830:   integer ju
1831:   integer jz
1832:   integer k
1833:   integer l
1834:   integer lm
1835:   integer m
1836:   integer ml
1837:   integer mm
1838:   integer mu
1839:   real(8) t
1840: !
1841:   m = ml + mu + 1
1842:   info = 0
1843: !
1844: !  Zero initial fill-in columns.
1845: !
1846:   j0 = mu + 2
1847:   j1 = min ( n, m ) - 1
1848: 
1849:   do jz = j0, j1
1850:     i0 = m + 1 - jz
1851:     abd(i0:ml,jz) = 0.0D+00
1852:   end do
1853: 
1854:   jz = j1
1855:   ju = 0
1856: !
1857: !  Gaussian elimination with partial pivoting.
1858: !
1859:   do k = 1, n-1
1860: !
1861: !  Zero next fill-in column.
1862: !
1863:      jz = jz + 1
1864:      if ( jz <= n ) then
1865:        abd(1:ml,jz) = 0.0D+00
1866:      end if
1867: !
1868: !  Find L = pivot index.
1869: !
1870:      lm = min ( ml, n-k )
1871:      l = <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> ( lm+1, abd(m,k), 1 ) + m - 1
1872:      ipvt(k) = l + k - m
1873: !
1874: !  Zero pivot implies this column already triangularized.
1875: !
1876:      if ( abd(l,k) == 0.0D+00 ) then
1877: 
1878:        info = k
1879: !
1880: !  Interchange if necessary.
1881: !
1882:      else
1883: 
1884:         if ( l /= m ) then
1885:           call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( abd(l,k), abd(m,k) )
1886:         end if
1887: !
1888: !  Compute multipliers.
1889: !
1890:         t = -1.0D+00 / abd(m,k)
1891:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( lm, t, abd(m+1,k), 1 )
1892: !
1893: !  Row elimination with column indexing.
1894: !
1895:         ju = min ( max ( ju, mu+ipvt(k) ), n )
1896:         mm = m
1897: 
1898:         do j = k+1, ju
1899:            l = l - 1
1900:            mm = mm - 1
1901:            t = abd(l,j)
1902:            if ( l /= mm ) then
1903:               abd(l,j) = abd(mm,j)
1904:               abd(mm,j) = t
1905:            end if
1906:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( lm, t, abd(m+1,k), 1, abd(mm+1,j), 1 )
1907:         end do
1908: 
1909:      end if
1910: 
1911:   end do
1912: 
1913:   ipvt(n) = n
1914: 
1915:   if ( abd(m,n) == 0.0D+00 ) then
1916:     info = n
1917:   end if
1918: 
1919:   return
1920: end
<p><a name=sgbsl><H3>sgbsl</H3></a></p> Click <a href="./callingtree/sgbsl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgbsl is used.
<hr>
1921: subroutine sgbsl ( abd, lda, n, ml, mu, ipvt, b, job )
1922: !
1923: !*******************************************************************************
1924: !
1925: !! SGBSL solves a real(8) banded system factored by SGBCO or SGBFA.
1926: !
1927: !
1928: !  Discussion:
1929: !
1930: !    SGBSL can solve either A * X = B  or  A' * X = B.
1931: !
1932: !    A division by zero will occur if the input factor contains a
1933: !    zero on the diagonal.  Technically this indicates singularity
1934: !    but it is often caused by improper arguments or improper
1935: !    setting of LDA.  It will not occur if the subroutines are
1936: !    called correctly and if SGBCO has set RCOND > 0.0D+00
1937: !    or SGBFA has set INFO == 0.
1938: !
1939: !    To compute inverse(A) * C  where C is a matrix with P columns:
1940: !
1941: !      call sgbco ( abd, lda, n, ml, mu, ipvt, rcond, z )
1942: !
1943: !      if ( rcond is too small ) then
1944: !        exit
1945: !      end if
1946: !
1947: !      do j = 1, p
1948: !        call sgbsl ( abd, lda, n, ml, mu, ipvt, c(1,j), 0 )
1949: !      end do
1950: !
1951: !  Reference:
1952: !
1953: !    Dongarra, Moler, Bunch and Stewart,
1954: !    LINPACK User's Guide,
1955: !    SIAM, (Society for Industrial and Applied Mathematics),
1956: !    3600 University City Science Center,
1957: !    Philadelphia, PA, 19104-2688.
1958: !    ISBN 0-89871-172-X
1959: !
1960: !  Parameters:
1961: !
1962: !    Input, real(8) ABD(LDA,N), the output from SGBCO or SGBFA.
1963: !
1964: !    Input, integer LDA, the leading dimension of the array ABD.
1965: !
1966: !    Input, integer N, the order of the matrix.
1967: !
1968: !    Input, integer ML, MU, the number of diagonals below and above the 
1969: !    main diagonal.  0 <= ML < N, 0 <= MU < N.
1970: !
1971: !    Input, integer IPVT(N), the pivot vector from SGBCO or SGBFA.
1972: !
1973: !    Input/output, real(8) B(N).  On input, the right hand side.
1974: !    On output, the solution.
1975: !
1976: !    Input, integer JOB, job choice.
1977: !    0, solve A*X=B.
1978: !    nonzero, solve A'*X=B.
1979: !
1980:   implicit none
1981: !
1982:   integer lda
1983:   integer n
1984: !
1985:   real(8) abd(lda,n)
1986:   real(8) b(n)
1987:   integer ipvt(n)
1988:   integer job
1989:   integer k
1990:   integer l
1991:   integer la
1992:   integer lb
1993:   integer lm
1994:   integer m
1995:   integer ml
1996:   integer mu
1997:   real(8) t
1998: !
1999:   m = mu + ml + 1
2000: !
2001: !  JOB = 0, Solve  a * x = b.
2002: !
2003: !  First solve l*y = b.
2004: !
2005:   if ( job == 0 ) then
2006: 
2007:      if ( ml > 0 ) then
2008: 
2009:         do k = 1, n-1
2010:            lm = min ( ml, n-k )
2011:            l = ipvt(k)
2012:            t = b(l)
2013:            if ( l /= k ) then
2014:              b(l) = b(k)
2015:              b(k) = t
2016:            end if
2017:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( lm, t, abd(m+1,k), 1, b(k+1), 1 )
2018:         end do
2019: 
2020:      end if
2021: !
2022: !  Now solve u*x = y.
2023: !
2024:      do k = n, 1, -1
2025:        b(k) = b(k) / abd(m,k)
2026:        lm = min ( k, m ) - 1
2027:        la = m - lm
2028:        lb = k - lm
2029:        t = -b(k)
2030:        call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( lm, t, abd(la,k), 1, b(lb), 1 )
2031:      end do
2032: !
2033: !  JOB nonzero, solve A' * X = B.
2034: !
2035: !  First solve U'*Y = B.
2036: !
2037:   else
2038: 
2039:      do k = 1, n
2040:        lm = min ( k, m ) - 1
2041:        t = dot_product ( abd(m-lm:m-1,k), b(k-lm:k-1) )
2042:        b(k) = ( b(k) - t ) / abd(m,k)
2043:      end do
2044: !
2045: !  Now solve L'*X = Y.
2046: !
2047:      if ( ml > 0 ) then
2048: 
2049:         do k = n-1, 1, -1
2050:           lm = min ( ml, n-k )
2051:           b(k) = b(k) + dot_product ( abd(m+1:m+lm,k), b(k+1:k+lm) )
2052:           l = ipvt(k)
2053:           if ( l /= k ) then
2054:             call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(l), b(k) )
2055:           end if
2056:         end do
2057: 
2058:       end if
2059: 
2060:   end if
2061: 
2062:   return
2063: end
<p><a name=sgeco><H3>sgeco</H3></a></p> Click <a href="./callingtree/sgeco_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgeco is used.
<hr>
2064: subroutine sgeco ( a, lda, n, ipvt, rcond, z )
2065: !
2066: !*******************************************************************************
2067: !
2068: !! SGECO factors a real(8) matrix and estimates its condition number.
2069: !
2070: !
2071: !  Discussion:
2072: !
2073: !    If RCOND is not needed, SGEFA is slightly faster.
2074: !
2075: !    To solve A * X = B, follow SGECO by SGESL.
2076: !
2077: !    To compute inverse ( A ) * C, follow SGECO by SGESL.
2078: !
2079: !    To compute determinant ( A ), follow SGECO by SGEDI.
2080: !
2081: !    To compute inverse ( A ), follow SGECO by SGEDI.
2082: !
2083: !    For the system A * X = B, relative perturbations in A and B 
2084: !    of size EPSILON may cause relative perturbations in X of size  
2085: !    EPSILON/RCOND.
2086: !
2087: !    If RCOND is so small that the logical expression
2088: !      1.0D+00 + RCOND == 1.0D+00
2089: !    is true, then A may be singular to working precision.  In particular,  
2090: !    RCOND is zero if exact singularity is detected or the estimate
2091: !    underflows.
2092: !
2093: !  Reference:
2094: !
2095: !    Dongarra, Moler, Bunch and Stewart,
2096: !    LINPACK User's Guide,
2097: !    SIAM, (Society for Industrial and Applied Mathematics),
2098: !    3600 University City Science Center,
2099: !    Philadelphia, PA, 19104-2688.
2100: !    ISBN 0-89871-172-X
2101: !
2102: !  Author:
2103: !
2104: !    Cleve Moler, 
2105: !    University of New Mexico / Argonne National Lab.
2106: !
2107: !  Parameters:
2108: !
2109: !    Input/output, real(8) A(LDA,N).  On input, a matrix to be factored.
2110: !    On output, the LU factorization of the matrix. 
2111: !
2112: !    Input, integer LDA, the leading dimension of the array A.
2113: !
2114: !    Input, integer N, the order of the matrix A.
2115: !
2116: !    Output, integer IPVT(N), the pivot indices.
2117: !
2118: !    Output, real(8) RCOND, an estimate of the reciprocal condition number of A.  
2119: !
2120: !    Output, real(8) Z(N), a work vector whose contents are usually unimportant.
2121: !    If A is close to a singular matrix, then Z is an approximate null vector 
2122: !    in the sense that
2123: !      norm ( A * Z ) = RCOND * norm ( A ) * norm ( Z ).
2124: !
2125:   implicit none
2126: !
2127:   integer lda
2128:   integer n
2129: !
2130:   real(8) a(lda,n)
2131:   real(8) anorm
2132:   real(8) ek
2133:   integer info
2134:   integer ipvt(n)
2135:   integer j
2136:   integer k
2137:   integer l
2138:   real(8) rcond
2139:   real(8) s
2140:   real(8) sm
2141:   real(8) t
2142:   real(8) wk
2143:   real(8) wkm
2144:   real(8) ynorm
2145:   real(8) z(n)
2146: !
2147: !  Compute the L1 norm of A.
2148: !
2149:   anorm = 0.0D+00
2150:   do j = 1, n
2151:     anorm = max ( anorm, sum ( abs ( a(1:n,j) ) ) )
2152:   end do
2153: !
2154: !  Compute the LU factorization.
2155: !
2156:   call <a href="./linpack.f90.html#sgefa" TARGET=CENT_PANEL>sgefa</a> ( a, lda, n, ipvt, info )
2157: !
2158: !  RCOND = 1 / ( norm(A) * (estimate of norm(inverse(A))) )
2159: !
2160: !  estimate of norm(inverse(A)) = norm(Z) / norm(Y) 
2161: !
2162: !  where  
2163: !    A * Z = Y  
2164: !  and  
2165: !    A' * Y = E
2166: !
2167: !  The components of E are chosen to cause maximum local growth in the 
2168: !  elements of W, where U'*W = E.  The vectors are frequently rescaled 
2169: !  to avoid overflow.
2170: !
2171: !  Solve U' * W = E.
2172: !
2173:   ek = 1.0D+00
2174:   z(1:n) = 0.0D+00
2175: 
2176:   do k = 1, n
2177: 
2178:     if ( z(k) /= 0.0D+00 ) then
2179:       ek = sign ( ek, -z(k) )
2180:     end if
2181: 
2182:     if ( abs ( ek - z(k) ) > abs ( a(k,k) ) ) then
2183:       s = abs ( a(k,k) ) / abs ( ek - z(k) )
2184:       z(1:n) = s * z(1:n)
2185:       ek = s * ek
2186:     end if
2187: 
2188:     wk = ek - z(k)
2189:     wkm = -ek - z(k)
2190:     s = abs ( wk )
2191:     sm = abs ( wkm )
2192: 
2193:     if ( a(k,k) /= 0.0D+00 ) then
2194:       wk = wk / a(k,k)
2195:       wkm = wkm / a(k,k)
2196:     else
2197:       wk = 1.0D+00
2198:       wkm = 1.0D+00
2199:     end if
2200: 
2201:     if ( k+1 <= n ) then
2202: 
2203:       do j = k+1, n
2204:         sm = sm + abs ( z(j) + wkm * a(k,j) )
2205:         z(j) = z(j) + wk * a(k,j)
2206:         s = s + abs ( z(j) )
2207:       end do
2208: 
2209:       if ( s < sm ) then
2210:         t = wkm - wk
2211:         wk = wkm
2212:         z(k+1:n) = z(k+1:n) + t * a(k,k+1:n)
2213:       end if
2214: 
2215:     end if
2216: 
2217:     z(k) = wk
2218: 
2219:   end do
2220: 
2221:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
2222: !
2223: !  Solve L' * Y = W
2224: !
2225:   do k = n, 1, -1
2226: 
2227:     z(k) = z(k) + dot_product ( a(k+1:n,k), z(k+1:n) )
2228: 
2229:     if ( abs ( z(k) ) > 1.0D+00 ) then
2230:       z(1:n) = z(1:n) / abs ( z(k) )
2231:     end if
2232: 
2233:     l = ipvt(k)
2234: 
2235:     t = z(l)
2236:     z(l) = z(k)
2237:     z(k) = t
2238: 
2239:   end do
2240: 
2241:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
2242: 
2243:   ynorm = 1.0D+00
2244: !
2245: !  Solve L * V = Y.
2246: !
2247:   do k = 1, n
2248: 
2249:     l = ipvt(k)
2250: 
2251:     t = z(l)
2252:     z(l) = z(k)
2253:     z(k) = t
2254: 
2255:     z(k+1:n) = z(k+1:n) + t * a(k+1:n,k)
2256: 
2257:     if ( abs ( z(k) ) > 1.0D+00 ) then
2258:       ynorm = ynorm / abs ( z(k) )
2259:       z(1:n) = z(1:n) / abs ( z(k) )
2260:     end if
2261: 
2262:   end do
2263: 
2264:   s = sum ( abs ( z(1:n) ) )
2265:   z(1:n) = z(1:n) / s
2266:   ynorm = ynorm / s
2267: !
2268: !  Solve U * Z = V.
2269: !
2270:   do k = n, 1, -1
2271: 
2272:     if ( abs ( z(k) ) > abs ( a(k,k) ) ) then
2273:       s = abs ( a(k,k) ) / abs ( z(k) )
2274:       z(1:n) = s * z(1:n)
2275:       ynorm = s * ynorm
2276:     end if
2277: 
2278:     if ( a(k,k) /= 0.0D+00 ) then
2279:       z(k) = z(k) / a(k,k)
2280:     else
2281:       z(k) = 1.0D+00
2282:     end if
2283: 
2284:     z(1:k-1) = z(1:k-1) - z(k) * a(1:k-1,k)
2285: 
2286:   end do
2287: !
2288: !  Normalize Z in the L1 norm.
2289: !
2290:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
2291:   z(1:n) = s * z(1:n)
2292:   ynorm = s * ynorm
2293: 
2294:   if ( anorm /= 0.0D+00 ) then
2295:     rcond = ynorm / anorm
2296:   else
2297:     rcond = 0.0D+00
2298:   end if
2299: 
2300:   return
2301: end
<p><a name=sgedi><H3>sgedi</H3></a></p> Click <a href="./callingtree/sgedi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgedi is used.
<hr>
2302: subroutine sgedi ( a, lda, n, ipvt, det, work, job )
2303: !
2304: !*******************************************************************************
2305: !
2306: !! SGEDI computes the determinant and inverse of a matrix factored by SGECO or SGEFA.
2307: !
2308: !
2309: !  Discussion:
2310: !
2311: !    A division by zero will occur if the input factor contains
2312: !    a zero on the diagonal and the inverse is requested.
2313: !    It will not occur if the subroutines are called correctly
2314: !    and if SGECO has set RCOND > 0.0D+00 or SGEFA has set INFO == 0.
2315: !
2316: !  Reference:
2317: !
2318: !    Dongarra, Moler, Bunch and Stewart,
2319: !    LINPACK User's Guide,
2320: !    SIAM, (Society for Industrial and Applied Mathematics),
2321: !    3600 University City Science Center,
2322: !    Philadelphia, PA, 19104-2688.
2323: !    ISBN 0-89871-172-X
2324: !
2325: !  Parameters:
2326: !
2327: !    Input/output, real(8) A(LDA,N), on input, the N by N factored matrix.
2328: !    as output by SGECO or SGEFA.  On output, contains the inverse
2329: !    matrix if requested.
2330: !
2331: !    Input, integer LDA, the leading dimension of the array A.
2332: !
2333: !    Input, integer N, the order of the matrix A.
2334: !
2335: !    Input, integer IPVT(N), the pivot vector from SGECO or SGEFA.
2336: !
2337: !    Workspace, real(8) WORK(N).
2338: !
2339: !    Output, real(8) DET(2), the determinant of original matrix if requested.
2340: !    determinant = DET(1) * 10.0**DET(2)
2341: !    with  1.0D+00 <= abs ( DET(1) ) < 10.0D+00
2342: !    or DET(1) == 0.0D+00.
2343: !
2344: !    Input, integer JOB, specifies what is to be computed.
2345: !    11, both determinant and inverse.
2346: !    01, inverse only.
2347: !    10, determinant only.
2348: !
2349:   implicit none
2350: !
2351:   integer lda
2352:   integer n
2353: !
2354:   real(8) a(lda,n)
2355:   real(8) det(2)
2356:   integer i
2357:   integer ipvt(n)
2358:   integer j
2359:   integer job
2360:   integer k
2361:   integer l
2362:   real(8) t
2363:   real, parameter :: ten = 10.0D+00
2364:   real(8) work(n)
2365: !
2366: !  Compute the determinant.
2367: !
2368:   if ( job / 10 /= 0 ) then
2369: 
2370:      det(1) = 1.0D+00
2371:      det(2) = 0.0D+00
2372: 
2373:      do i = 1, n
2374: 
2375:         if ( ipvt(i) /= i ) then
2376:           det(1) = - det(1)
2377:         end if
2378: 
2379:         det(1) = a(i,i) * det(1)
2380: 
2381:         if ( det(1) == 0.0D+00 ) then
2382:           exit
2383:         end if
2384: 
2385:         do while ( abs ( det(1) ) < 1.0D+00 ) 
2386:           det(1) = ten * det(1)
2387:           det(2) = det(2) - 1.0D+00
2388:         end do
2389: 
2390:         do while ( abs ( det(1) ) >= ten )
2391:           det(1) = det(1) / ten
2392:           det(2) = det(2) + 1.0D+00
2393:         end do
2394: 
2395:     end do
2396: 
2397:   end if
2398: !
2399: !  Compute inverse(U).
2400: !
2401:   if ( mod ( job, 10 ) /= 0 ) then
2402: 
2403:      do k = 1, n
2404: 
2405:         a(k,k) = 1.0D+00 / a(k,k)
2406:         t = - a(k,k)
2407:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( k-1, t, a(1,k), 1 )
2408: 
2409:         do j = k+1, n
2410:            t = a(k,j)
2411:            a(k,j) = 0.0D+00
2412:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k, t, a(1,k), 1, a(1,j), 1 )
2413:         end do
2414: 
2415:      end do
2416: !
2417: !  Form inverse(U) * inverse(L).
2418: !
2419:      do k = n-1, 1, -1
2420: 
2421:         do i = k+1, n
2422:            work(i) = a(i,k)
2423:            a(i,k) = 0.0D+00
2424:         end do
2425: 
2426:         do j = k+1, n
2427:            t = work(j)
2428:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n, t, a(1,j), 1, a(1,k), 1 )
2429:         end do
2430: 
2431:         l = ipvt(k)
2432:         if ( l /= k ) then
2433:           call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( n, a(1,k), 1, a(1,l), 1 )
2434:         end if
2435: 
2436:      end do
2437: 
2438:   end if
2439: 
2440:   return
2441: end
<p><a name=sgefa><H3>sgefa</H3></a></p> Click <a href="./callingtree/sgefa_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgefa is used.
<hr>
2442: subroutine sgefa ( a, lda, n, ipvt, info )
2443: !
2444: !*******************************************************************************
2445: !
2446: !! SGEFA factors a real(8) matrix.
2447: !
2448: !
2449: !  Modified:
2450: !
2451: !    17 April 2002
2452: !
2453: !  Reference:
2454: !
2455: !    Dongarra, Moler, Bunch and Stewart,
2456: !    LINPACK User's Guide,
2457: !    SIAM, (Society for Industrial and Applied Mathematics),
2458: !    3600 University City Science Center,
2459: !    Philadelphia, PA, 19104-2688.
2460: !    ISBN 0-89871-172-X
2461: !
2462: !  Parameters:
2463: !
2464: !    Input/output, real(8) A(LDA,N).
2465: !    On intput, the matrix to be factored.
2466: !    On output, an upper triangular matrix and the multipliers used to obtain
2467: !    it.  The factorization can be written A=L*U, where L is a product of
2468: !    permutation and unit lower triangular matrices, and U is upper triangular.
2469: !
2470: !    Input, integer LDA, the leading dimension of A.
2471: !
2472: !    Input, integer N, the order of the matrix A.
2473: !
2474: !    Output, integer IPVT(N), the pivot indices.
2475: !
2476: !    Output, integer INFO, singularity indicator.
2477: !    0, normal value.
2478: !    K, if U(K,K) == 0.  This is not an error condition for this subroutine,
2479: !    but it does indicate that SGESL or SGEDI will divide by zero if called.
2480: !    Use RCOND in SGECO for a reliable indication of singularity.
2481: !
2482:   implicit none
2483: !
2484:   integer lda
2485:   integer n
2486: !
2487:   real(8) a(lda,n)
2488:   integer info
2489:   integer ipvt(n)
2490:   integer <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a>
2491:   integer j
2492:   integer k
2493:   integer l
2494:   real(8) t
2495: !
2496: !  Gaussian elimination with partial pivoting.
2497: !
2498:   info = 0
2499: 
2500:   do k = 1, n - 1
2501: !
2502: !  Find L = pivot index.
2503: !
2504:     l = <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> ( n-k+1, a(k,k), 1 ) + k - 1
2505:     ipvt(k) = l
2506: !
2507: !  Zero pivot implies this column already triangularized.
2508: !
2509:     if ( a(l,k) == 0.0D+00 ) then
2510:       info = k
2511:       cycle
2512:     end if
2513: !
2514: !  Interchange if necessary.
2515: !
2516:     if ( l /= k ) then
2517:       call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(l,k), a(k,k) )
2518:     end if
2519: !
2520: !  Compute multipliers.
2521: !
2522:     a(k+1:n,k) = - a(k+1:n,k) / a(k,k)
2523: !
2524: !  Row elimination with column indexing.
2525: !
2526:     do j = k+1, n
2527:       t = a(l,j)
2528:       if ( l /= k ) then
2529:         a(l,j) = a(k,j)
2530:         a(k,j) = t
2531:       end if
2532:       call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-k, t, a(k+1,k), 1, a(k+1,j), 1 )
2533:     end do
2534: 
2535:   end do
2536: 
2537:   ipvt(n) = n
2538: 
2539:   if ( a(n,n) == 0.0D+00 ) then
2540:     info = n
2541:   end if
2542: 
2543:   return
2544: end
<p><a name=sgesl><H3>sgesl</H3></a></p> Click <a href="./callingtree/sgesl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgesl is used.
<hr>
2545: subroutine sgesl ( a, lda, n, ipvt, b, job )
2546: !
2547: !*******************************************************************************
2548: !
2549: !! SGESL solves a real(8) general linear system A * X = B.
2550: !
2551: !
2552: !  Discussion:
2553: !
2554: !    SGESL can solve either of the systems A * X = B or A' * X = B.
2555: !
2556: !    The system matrix must have been factored by SGECO or SGEFA.
2557: !
2558: !    A division by zero will occur if the input factor contains a
2559: !    zero on the diagonal.  Technically this indicates singularity
2560: !    but it is often caused by improper arguments or improper
2561: !    setting of LDA.  It will not occur if the subroutines are
2562: !    called correctly and if SGECO has set RCOND > 0.0D+00
2563: !    or SGEFA has set INFO == 0.
2564: !
2565: !  Reference:
2566: !
2567: !    Dongarra, Moler, Bunch and Stewart,
2568: !    LINPACK User's Guide,
2569: !    SIAM, (Society for Industrial and Applied Mathematics),
2570: !    3600 University City Science Center,
2571: !    Philadelphia, PA, 19104-2688.
2572: !    ISBN 0-89871-172-X
2573: !
2574: !  Modified:
2575: !
2576: !    17 April 2002
2577: !
2578: !  Parameters:
2579: !
2580: !    Input, real(8) A(LDA,N), the output from SGECO or SGEFA.
2581: !
2582: !    Input, integer LDA, the leading dimension of A.
2583: !
2584: !    Input, integer N, the order of the matrix A.
2585: !
2586: !    Input, integer IPVT(N), the pivot vector from SGECO or SGEFA.
2587: !
2588: !    Input/output, real(8) B(N).
2589: !    On input, the right hand side vector.
2590: !    On output, the solution vector.
2591: !
2592: !    Input, integer JOB.
2593: !    0, solve A * X = B;
2594: !    nonzero, solve A' * X = B.
2595: !
2596:   implicit none
2597: !
2598:   integer lda
2599:   integer n
2600: !
2601:   real(8) a(lda,n)
2602:   real(8) b(n)
2603:   integer ipvt(n)
2604:   integer job
2605:   integer k
2606:   integer l
2607:   real(8) t
2608: !
2609: !  Solve A * X = B.
2610: !
2611:   if ( job == 0 ) then
2612: 
2613:     do k = 1, n-1
2614: 
2615:       l = ipvt(k)
2616:       t = b(l)
2617: 
2618:       if ( l /= k ) then
2619:         b(l) = b(k)
2620:         b(k) = t
2621:       end if
2622: 
2623:       call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-k, t, a(k+1,k), 1, b(k+1), 1 )
2624: 
2625:     end do
2626: 
2627:     do k = n, 1, -1
2628:       b(k) = b(k) / a(k,k)
2629:       t = -b(k)
2630:       call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, t, a(1,k), 1, b(1), 1 )
2631:     end do
2632: 
2633:   else
2634: !
2635: !  Solve A' * X = B.
2636: !
2637:     do k = 1, n
2638:       t = dot_product ( a(1:k-1,k), b(1:k-1) )
2639:       b(k) = ( b(k) - t ) / a(k,k)
2640:     end do
2641: 
2642:     do k = n-1, 1, -1
2643: 
2644:       b(k) = b(k) + dot_product ( a(k+1:n,k), b(k+1:n) )
2645:       l = ipvt(k)
2646: 
2647:       if ( l /= k ) then
2648:         call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(l), b(k) )
2649:       end if
2650: 
2651:     end do
2652: 
2653:   end if
2654: 
2655:   return
2656: end
<p><a name=sgtsl><H3>sgtsl</H3></a></p> Click <a href="./callingtree/sgtsl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sgtsl is used.
<hr>
2657: subroutine sgtsl ( n, c, d, e, b, info )
2658: !
2659: !*******************************************************************************
2660: !
2661: !! SGTSL solves a general tridiagonal linear system.
2662: !
2663: !
2664: !  Reference:
2665: !
2666: !    Dongarra, Moler, Bunch and Stewart,
2667: !    LINPACK User's Guide,
2668: !    SIAM, (Society for Industrial and Applied Mathematics),
2669: !    3600 University City Science Center,
2670: !    Philadelphia, PA, 19104-2688.
2671: !    ISBN 0-89871-172-X
2672: !
2673: !  Modified:
2674: !
2675: !    31 October 2001
2676: !
2677: !  Parameters:
2678: !
2679: !    Input, integer N, the order of the tridiagonal matrix.
2680: !
2681: !    Input/output, real(8) C(N), contains the subdiagonal of the tridiagonal 
2682: !    matrix in entries C(2:N).  On output, C is destroyed.
2683: !
2684: !    Input/output, real(8) D(N).  On input, the diagonal of the matrix.
2685: !    On output, D is destroyed.
2686: !
2687: !    Input/output, real(8) E(N), contains the superdiagonal of the tridiagonal 
2688: !    matrix in entries E(1:N-1).  On output E is destroyed.
2689: !
2690: !    Input/output, real(8) B(N).  On input, the right hand side.  On output,
2691: !    the solution.
2692: !
2693: !    Output, integer INFO, error flag.
2694: !    0, normal value.
2695: !    K, the K-th element of the diagonal becomes exactly zero.  The 
2696: !       subroutine returns if this error condition is detected.
2697: !
2698:   implicit none
2699: !
2700:   integer n
2701: !
2702:   real(8) b(n)
2703:   real(8) c(n)
2704:   real(8) d(n)
2705:   real(8) e(n)
2706:   integer info
2707:   integer k
2708:   real(8) t
2709: !
2710:   info = 0
2711:   c(1) = d(1)
2712: 
2713:   if ( n >= 2 ) then
2714: 
2715:     d(1) = e(1)
2716:     e(1) = 0.0D+00
2717:     e(n) = 0.0D+00
2718: 
2719:     do k = 1, n - 1
2720: !
2721: !  Find the larger of the two rows, and interchange if necessary.
2722: !
2723:       if ( abs ( c(k+1) ) >= abs ( c(k) ) ) then
2724:         call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( c(k), c(k+1) )
2725:         call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( d(k), d(k+1) )
2726:         call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( e(k), e(k+1) )
2727:         call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k), b(k+1) )
2728:       end if
2729: !
2730: !  Fail if no nonzero pivot could be found.
2731: !
2732:       if ( c(k) == 0.0D+00 ) then
2733:         info = k
2734:         return
2735:       end if
2736: !
2737: !  Zero elements.
2738: !
2739:       t = -c(k+1) / c(k)
2740:       c(k+1) = d(k+1) + t * d(k)
2741:       d(k+1) = e(k+1) + t * e(k)
2742:       e(k+1) = 0.0D+00
2743:       b(k+1) = b(k+1) + t * b(k)
2744: 
2745:     end do
2746: 
2747:   end if
2748: 
2749:   if ( c(n) == 0.0D+00 ) then
2750:     info = n
2751:     return
2752:   end if
2753: !
2754: !  Back solve.
2755: !
2756:   b(n) = b(n) / c(n)
2757: 
2758:   if ( n > 1 ) then
2759: 
2760:     b(n-1) = ( b(n-1) - d(n-1) * b(n) ) / c(n-1)
2761: 
2762:     do k = n-2, 1, -1
2763:       b(k) = ( b(k) - d(k) * b(k+1) - e(k) * b(k+2) ) / c(k)
2764:     end do
2765: 
2766:   end if
2767: 
2768:   return
2769: end
<p><a name=snrm2><H3>snrm2</H3></a></p> Click <a href="./callingtree/snrm2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where snrm2 is used.
<hr>
2770: function snrm2 ( n, x, incx )
2771: !
2772: !*******************************************************************************
2773: !
2774: !! SNRM2 computes the Euclidean norm of a vector.
2775: !
2776: !
2777: !  Discussion:
2778: !
2779: !    The original SNRM2 algorithm is accurate but written in an
2780: !    obscure and obsolete format.  This version goes for clarity.
2781: !
2782: !  Modified:
2783: !
2784: !    01 June 2000
2785: !
2786: !  Author:
2787: !
2788: !    John Burkardt
2789: !
2790: !  Parameters:
2791: !
2792: !    Input, integer N, the number of entries in the vector.
2793: !
2794: !    Input, real(8) X(*), the vector whose norm is to be computed.
2795: !
2796: !    Input, integer INCX, the increment between successive entries of X.
2797: !
2798: !    Output, real(8) SNRM2, the Euclidean norm of X.
2799: !
2800:   implicit none
2801: !
2802:   integer i
2803:   integer incx
2804:   integer ix
2805:   integer n
2806:   real(8) samax
2807:   real(8) snrm2
2808:   real(8) stemp
2809:   real(8) x(*)
2810:   real(8) xmax
2811: !
2812:   if ( n <= 0 ) then
2813: 
2814:     <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> = 0.0D+00
2815: 
2816:   else
2817: 
2818:     xmax = <a href="./linpack.f90.html#samax" TARGET=CENT_PANEL>samax</a> ( n, x, incx )
2819: 
2820:     if ( xmax == 0.0D+00 ) then
2821: 
2822:       <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> = 0.0D+00
2823: 
2824:     else
2825: 
2826:       if ( incx >= 0 ) then
2827:         ix = 1
2828:       else
2829:         ix = ( - n + 1 ) * incx + 1
2830:       end if
2831: 
2832:       stemp = 0.0D+00
2833:       do i = 1, n
2834:         stemp = stemp + ( x(ix) / xmax )**2
2835:         ix = ix + incx
2836:       end do
2837: 
2838:       <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> = xmax * sqrt ( stemp )
2839: 
2840:     end if
2841: 
2842:   end if
2843: 
2844:   return
2845: end
<p><a name=spbco><H3>spbco</H3></a></p> Click <a href="./callingtree/spbco_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spbco is used.
<hr>
2846: subroutine spbco ( abd, lda, n, m, rcond, z, info )
2847: !
2848: !*******************************************************************************
2849: !
2850: !! SPBCO factors a real(8) symmetric positive definite banded matrix.
2851: !
2852: !
2853: !  Discussion:
2854: !
2855: !    SPBCO also estimates the condition of the matrix.
2856: !
2857: !    If RCOND is not needed, SPBFA is slightly faster.
2858: !
2859: !    To solve A*X = B, follow SPBCO by SPBSL.
2860: !
2861: !    To compute inverse(A)*C, follow SPBCO by SPBSL.
2862: !
2863: !    To compute determinant(A), follow SPBCO by SPBDI.
2864: !
2865: !  Band storage:
2866: !
2867: !    If A is a symmetric positive definite band matrix, the following 
2868: !    program segment will set up the input.
2869: !
2870: !      m = (band width above diagonal)
2871: !      do j = 1, n
2872: !        i1 = max (1, j-m)
2873: !        do i = i1, j
2874: !          k = i-j+m+1
2875: !          abd(k,j) = a(i,j)
2876: !        end do
2877: !      end do
2878: !
2879: !    This uses M + 1 rows of A, except for the M by M upper left triangle, 
2880: !    which is ignored.
2881: !
2882: !    For example, if the original matrix is
2883: !
2884: !      11 12 13  0  0  0
2885: !      12 22 23 24  0  0
2886: !      13 23 33 34 35  0
2887: !       0 24 34 44 45 46
2888: !       0  0 35 45 55 56
2889: !       0  0  0 46 56 66
2890: !
2891: !    then N = 6, M = 2  and ABD should contain
2892: !
2893: !       *  * 13 24 35 46
2894: !       * 12 23 34 45 56
2895: !      11 22 33 44 55 66
2896: !
2897: !  Reference:
2898: !
2899: !    Dongarra, Moler, Bunch and Stewart,
2900: !    LINPACK User's Guide,
2901: !    SIAM, (Society for Industrial and Applied Mathematics),
2902: !    3600 University City Science Center,
2903: !    Philadelphia, PA, 19104-2688.
2904: !    ISBN 0-89871-172-X
2905: !
2906: !  Parameters:
2907: !
2908: !    Input/output, real(8) ABD(LDA,N).  On input, the matrix to be factored.  
2909: !    The columns of the upper triangle are stored in the columns of ABD and the
2910: !    diagonals of the upper triangle are stored in the rows of ABD.
2911: !    On output, an upper triangular matrix R, stored in band form, so that 
2912: !    A = R'*R.  If INFO /= 0, the factorization is not complete.
2913: !
2914: !    Input, integer LDA, the leading dimension of the array ABD.
2915: !    LDA must be >= M+1.
2916: !
2917: !    Input, integer N, the order of the matrix.
2918: !
2919: !    Input, integer M, the number of diagonals above the main diagonal.
2920: !
2921: !    Output, real(8) RCOND, an estimate of the reciprocal condition of A.
2922: !    For the system A*X = B, relative perturbations in A and B of size  
2923: !    EPSILON may cause relative perturbations in X of size EPSILON/RCOND.
2924: !    If RCOND is so small that the logical expression
2925: !      1.0D+00 + RCOND == 1.0D+00
2926: !    is true, then A may be singular to working precision.  In particular,  
2927: !    RCOND is zero if exact singularity is detected or the estimate underflows.
2928: !
2929: !    Output, real(8) Z(N), a work vector whose contents are usually unimportant.
2930: !    If A is singular to working precision, then Z is an approximate null 
2931: !    vector in the sense that
2932: !      norm(A*Z) = RCOND * norm(A) * norm(Z).
2933: !    If INFO /= 0, Z is unchanged.
2934: !
2935: !    Output, integer INFO, error flag.
2936: !    0, for normal return.
2937: !    K, signals an error condition.  The leading minor of order K is not 
2938: !    positive definite.
2939: !
2940:   implicit none
2941: !
2942:   integer lda
2943:   integer n
2944: !
2945:   real(8) abd(lda,n)
2946:   real(8) anorm
2947:   real(8) ek
2948:   integer i
2949:   integer info
2950:   integer j
2951:   integer j2
2952:   integer k
2953:   integer kp1
2954:   integer l
2955:   integer la
2956:   integer lb
2957:   integer lm
2958:   integer m
2959:   integer mu
2960:   real(8) rcond
2961:   real(8) s
2962:   real(8) sm
2963:   real(8) t
2964:   real(8) wk
2965:   real(8) wkm
2966:   real(8) ynorm
2967:   real(8) z(n)
2968: !
2969: !  Find the norm of A.
2970: !
2971:   do j = 1, n
2972: 
2973:     l = min ( j, m+1 )
2974:     mu = max ( m+2-j, 1 )
2975:     z(j) = sum ( abs ( abd(mu:mu+l-1,j) ) )
2976:     k = j - l
2977:     do i = mu, m
2978:       k = k + 1
2979:       z(k) = z(k) + abs ( abd(i,j) )
2980:     end do
2981: 
2982:   end do
2983: 
2984:   anorm = maxval ( z(1:n) )
2985: !
2986: !  Factor.
2987: !
2988:   call <a href="./linpack.f90.html#spbfa" TARGET=CENT_PANEL>spbfa</a> ( abd, lda, n, m, info )
2989: 
2990:   if ( info /= 0 ) then
2991:     return
2992:   end if
2993: !
2994: !  RCOND = 1/(norm(A)*(estimate of norm(inverse(A)))).
2995: !
2996: !  Estimate = norm(Z)/norm(Y) where A*Z = Y and A*Y = E.
2997: !
2998: !  The components of E are chosen to cause maximum local
2999: !  growth in the elements of W where R'*W = E.
3000: !
3001: !  The vectors are frequently rescaled to avoid overflow.
3002: !
3003: !  Solve R'*W = E.
3004: !
3005:   ek = 1.0D+00
3006:   z(1:n) = 0.0D+00
3007: 
3008:   do k = 1, n
3009: 
3010:     if ( z(k) /= 0.0D+00 ) then
3011:       ek = sign ( ek, -z(k) )
3012:     end if
3013: 
3014:     if ( abs ( ek - z(k) ) > abd(m+1,k) ) then
3015:       s = abd(m+1,k) / abs ( ek - z(k) )
3016:       z(1:n) = s * z(1:n)
3017:       ek = s * ek
3018:     end if
3019: 
3020:     wk = ek - z(k)
3021:     wkm = -ek - z(k)
3022:     s = abs ( wk )
3023:     sm = abs ( wkm )
3024:     wk = wk / abd(m+1,k)
3025:     wkm = wkm / abd(m+1,k)
3026:     kp1 = k + 1
3027:     j2 = min ( k+m, n )
3028:     i = m + 1
3029: 
3030:     if ( k+1 <= j2 ) then
3031: 
3032:       do j = k+1, j2
3033:         i = i - 1
3034:         sm = sm + abs ( z(j) + wkm * abd(i,j) )
3035:         z(j) = z(j) + wk * abd(i,j)
3036:         s = s + abs ( z(j) )
3037:       end do
3038: 
3039:       if ( s < sm ) then
3040: 
3041:         t = wkm - wk
3042:         wk = wkm
3043:         i = m + 1
3044: 
3045:         do j = k+1, j2
3046:           i = i - 1
3047:           z(j) = z(j) + t * abd(i,j)
3048:         end do
3049: 
3050:       end if
3051: 
3052:     end if
3053: 
3054:     z(k) = wk
3055: 
3056:   end do
3057: 
3058:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
3059: !
3060: !  Solve R*Y = W.
3061: !
3062:   do k = n, 1, -1
3063: 
3064:     if ( abs ( z(k) ) > abd(m+1,k) ) then
3065:       s = abd(m+1,k) / abs ( z(k) )
3066:       z(1:n) = s * z(1:n)
3067:     end if
3068: 
3069:     z(k) = z(k) / abd(m+1,k)
3070:     lm = min ( k-1, m )
3071:     la = m + 1 - lm
3072:     lb = k - lm
3073:     t = -z(k)
3074:     call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( lm, t, abd(la,k), 1, z(lb), 1 )
3075: 
3076:   end do
3077: 
3078:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
3079: 
3080:   ynorm = 1.0D+00
3081: !
3082: !  Solve R'*V = Y.
3083: !
3084:   do k = 1, n
3085: 
3086:     lm = min ( k-1, m )
3087:     la = m + 1 - lm
3088:     lb = k - lm
3089: 
3090:     z(k) = z(k) - dot_product ( abd(la:la+lm-1,k), z(lb:lb+lm-1) )
3091: 
3092:     if ( abs ( z(k) ) > abd(m+1,k) ) then
3093:       s = abd(m+1,k) / abs ( z(k) )
3094:       z(1:n) = s * z(1:n)
3095:       ynorm = s * ynorm
3096:     end if
3097: 
3098:     z(k) = z(k) / abd(m+1,k)
3099: 
3100:   end do
3101: 
3102:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
3103:   z(1:n) = s * z(1:n)
3104:   ynorm = s * ynorm
3105: !
3106: !  Solve R*Z = W.
3107: !
3108:   do k = n, 1, -1
3109: 
3110:     if ( abs ( z(k) ) > abd(m+1,k) ) then
3111:       s = abd(m+1,k) / abs ( z(k) )
3112:       z(1:n) = s * z(1:n)
3113:       ynorm = s * ynorm
3114:     end if
3115: 
3116:     z(k) = z(k) / abd(m+1,k)
3117:     lm = min ( k-1, m )
3118:     la = m + 1 - lm
3119:     lb = k - lm
3120:     t = -z(k)
3121:     call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( lm, t, abd(la,k), 1, z(lb), 1 )
3122: 
3123:   end do
3124: !
3125: !  Make ZNORM = 1.0.
3126: !
3127:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
3128:   z(1:n) = s * z(1:n)
3129:   ynorm = s * ynorm
3130: 
3131:   if ( anorm /= 0.0D+00 ) then
3132:     rcond = ynorm / anorm
3133:   else
3134:     rcond = 0.0D+00
3135:   end if
3136: 
3137:   return
3138: end
<p><a name=spbdi><H3>spbdi</H3></a></p> Click <a href="./callingtree/spbdi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spbdi is used.
<hr>
3139: subroutine spbdi ( abd, lda, n, m, det )
3140: !
3141: !*******************************************************************************
3142: !
3143: !! SPBDI computes the determinant of a matrix factored by SPBCO or SPBFA.
3144: !
3145: !
3146: !  Discussion:
3147: !
3148: !    If the inverse is needed, use SPBSL N times.
3149: !
3150: !  Reference:
3151: !
3152: !    Dongarra, Moler, Bunch and Stewart,
3153: !    LINPACK User's Guide,
3154: !    SIAM, (Society for Industrial and Applied Mathematics),
3155: !    3600 University City Science Center,
3156: !    Philadelphia, PA, 19104-2688.
3157: !    ISBN 0-89871-172-X
3158: !
3159: !  Parameters:
3160: !
3161: !    Input, real(8) ABD(LDA,N), the output from SPBCO or SPBFA.
3162: !
3163: !    Input, integer LDA, the leading dimension of the array ABD.
3164: !
3165: !    Input, integer N, the order of the matrix.
3166: !
3167: !    Input, integer M, the number of diagonals above the main diagonal.
3168: !
3169: !    Output, real(8) DET(2), the determinant of the original matrix in the form
3170: !      determinant = DET(1) * 10.0**DET(2)
3171: !    with 1.0D+00 <= DET(1) < 10.0D+00 or DET(1) == 0.0D+00.
3172: !
3173:   implicit none
3174: !
3175:   integer lda
3176:   integer n
3177: !
3178:   real(8) abd(lda,n)
3179:   real(8) det(2)
3180:   integer i
3181:   integer m
3182:   real(8) s
3183: !
3184: !  Compute the determinant.
3185: !
3186:   det(1) = 1.0D+00
3187:   det(2) = 0.0D+00
3188:   s = 10.0D+00
3189: 
3190:   do i = 1, n
3191: 
3192:     det(1) = abd(m+1,i)**2 * det(1)
3193: 
3194:     if ( det(1) == 0.0D+00 ) then
3195:       return
3196:     end if
3197: 
3198:     do while ( det(1) < 1.0D+00 )
3199:       det(1) = s * det(1)
3200:       det(2) = det(2) - 1.0D+00
3201:     end do
3202: 
3203:     do while ( det(1) >= s ) 
3204:       det(1) = det(1) / s
3205:       det(2) = det(2) + 1.0D+00
3206:     end do
3207: 
3208:   end do
3209: 
3210:   return
3211: end
<p><a name=spbfa><H3>spbfa</H3></a></p> Click <a href="./callingtree/spbfa_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spbfa is used.
<hr>
3212: subroutine spbfa ( abd, lda, n, m, info )
3213: !
3214: !*******************************************************************************
3215: !
3216: !! SPBFA factors a real(8) symmetric positive definite matrix stored in band form.
3217: !
3218: !
3219: !  Discussion:
3220: !
3221: !    SPBFA is usually called by SPBCO, but it can be called
3222: !    directly with a saving in time if RCOND is not needed.
3223: !
3224: !  Band storage:
3225: !
3226: !    If A is a symmetric positive definite band matrix,
3227: !    the following program segment will set up the input.
3228: !
3229: !      m = (band width above diagonal)
3230: !      do j = 1, n
3231: !        i1 = max (1, j-m)
3232: !        do i = i1, j
3233: !          k = i-j+m+1
3234: !          abd(k,j) = a(i,j)
3235: !        end do
3236: !      end do
3237: !
3238: !  Reference:
3239: !
3240: !    Dongarra, Moler, Bunch and Stewart,
3241: !    LINPACK User's Guide,
3242: !    SIAM, (Society for Industrial and Applied Mathematics),
3243: !    3600 University City Science Center,
3244: !    Philadelphia, PA, 19104-2688.
3245: !    ISBN 0-89871-172-X
3246: !
3247: !  Parameters:
3248: !
3249: !    Input/output, real(8) ABD(LDA,N).  On input, the matrix to be factored.  
3250: !    The columns of the upper triangle are stored in the columns of ABD 
3251: !    and the diagonals of the upper triangle are stored in the
3252: !    rows of ABD.  On output, an upper triangular matrix R, stored in band
3253: !    form, so that A = R' * R.
3254: !
3255: !    Input, integer LDA, the leading dimension of the array ABD.
3256: !    LDA must be >= M+1.
3257: !
3258: !    Input, integer N, the order of the matrix.
3259: !
3260: !    Input, integer M, the number of diagonals above the main diagonal.
3261: !
3262: !    Output, integer INFO, error indicator.
3263: !    0, for normal return.
3264: !    K, if the leading minor of order K is not positive definite.
3265: !
3266:   implicit none
3267: !
3268:   integer lda
3269:   integer n
3270: !
3271:   real(8) abd(lda,n)
3272:   integer ik
3273:   integer info
3274:   integer j
3275:   integer jk
3276:   integer k
3277:   integer m
3278:   integer mu
3279:   real(8) sdot
3280:   real(8) s
3281:   real(8) t
3282: !
3283:   do j = 1, n
3284: 
3285:     s = 0.0D+00
3286:     ik = m + 1
3287:     jk = max (j-m,1)
3288:     mu = max (m+2-j,1)
3289: 
3290:     do k = mu, m
3291:       t = abd(k,j) - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-mu, abd(ik,jk), 1, abd(mu,j), 1 )
3292:       t = t / abd(m+1,jk)
3293:       abd(k,j) = t
3294:       s = s + t * t
3295:       ik = ik - 1
3296:       jk = jk + 1
3297:     end do
3298: 
3299:     s = abd(m+1,j) - s
3300: 
3301:     if ( s <= 0.0D+00 ) then
3302:       info = j
3303:       return
3304:     end if
3305: 
3306:     abd(m+1,j) = sqrt ( s )
3307: 
3308:   end do
3309: 
3310:   info = 0
3311: 
3312:   return
3313: end
<p><a name=spbsl><H3>spbsl</H3></a></p> Click <a href="./callingtree/spbsl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spbsl is used.
<hr>
3314: subroutine spbsl ( abd, lda, n, m, b )
3315: !
3316: !*******************************************************************************
3317: !
3318: !! SPBSL solves a real(8) symmetric positive definite band factored by SPBCO or SPBFA.
3319: !
3320: !
3321: !  Discussion:
3322: !
3323: !    To compute inverse(A) * C  where C is a matrix with P columns:
3324: !
3325: !      call spbco ( abd, lda, n, rcond, z, info )
3326: !
3327: !      if ( rcond is too small .or. info /= 0) go to ...
3328: !
3329: !      do j = 1, p
3330: !        call spbsl ( abd, lda, n, c(1,j) )
3331: !      end do
3332: !
3333: !    A division by zero will occur if the input factor contains
3334: !    a zero on the diagonal.  Technically this indicates
3335: !    singularity but it is usually caused by improper subroutine
3336: !    arguments.  It will not occur if the subroutines are called
3337: !    correctly and INFO == 0.
3338: !
3339: !  Reference:
3340: !
3341: !    Dongarra, Moler, Bunch and Stewart,
3342: !    LINPACK User's Guide,
3343: !    SIAM, (Society for Industrial and Applied Mathematics),
3344: !    3600 University City Science Center,
3345: !    Philadelphia, PA, 19104-2688.
3346: !    ISBN 0-89871-172-X
3347: !
3348: !  Parameters:
3349: !
3350: !    Input, real(8) ABD(LDA,N), the output from SPBCO or SPBFA.
3351: !
3352: !    Input, integer LDA, the leading dimension of the array ABD.
3353: !
3354: !    Input, integer N, the order of the matrix.
3355: !
3356: !    Input, integer M, the number of diagonals above the main diagonal.
3357: !
3358: !    Input/output, real(8) B(N).  On input, the right hand side.
3359: !    On output, the solution.
3360: !
3361:   implicit none
3362: !
3363:   integer lda
3364:   integer n
3365: !
3366:   real(8) abd(lda,n)
3367:   real(8) b(n)
3368:   integer k
3369:   integer la
3370:   integer lb
3371:   integer lm
3372:   integer m
3373:   real(8) t
3374: !
3375: !  Solve R'*Y = B.
3376: !
3377:   do k = 1, n
3378:      lm = min ( k-1, m )
3379:      t = dot_product ( abd(m+1-lm:m,k), b(k-lm:k-1) )
3380:      b(k) = ( b(k) - t ) / abd(m+1,k)
3381:   end do
3382: !
3383: !  Solve R*X = Y.
3384: !
3385:   do k = n, 1, -1
3386:      lm = min ( k-1, m )
3387:      la = m + 1 - lm
3388:      lb = k - lm
3389:      b(k) = b(k) / abd(m+1,k)
3390:      t = -b(k)
3391:      call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( lm, t, abd(la,k), 1, b(lb), 1 )
3392:   end do
3393: 
3394:   return
3395: end
<p><a name=spoco><H3>spoco</H3></a></p> Click <a href="./callingtree/spoco_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spoco is used.
<hr>
3396: subroutine spoco ( a, lda, n, rcond, z, info )
3397: !
3398: !*******************************************************************************
3399: !
3400: !! SPOCO factors a real(8) symmetric positive definite matrix and estimates its condition.
3401: !
3402: !
3403: !  Discussion:
3404: !
3405: !     If RCOND is not needed, SPOFA is slightly faster.
3406: !
3407: !     To solve A*X = B, follow SPOCO by SPOSL.
3408: !
3409: !     To compute inverse(A)*C, follow SPOCO by SPOSL.
3410: !
3411: !     To compute determinant(A), follow SPOCO by SPODI.
3412: !
3413: !     To compute inverse(A), follow SPOCO by SPODI.
3414: !
3415: !  Reference:
3416: !
3417: !    Dongarra, Moler, Bunch and Stewart,
3418: !    LINPACK User's Guide,
3419: !    SIAM, (Society for Industrial and Applied Mathematics),
3420: !    3600 University City Science Center,
3421: !    Philadelphia, PA, 19104-2688.
3422: !    ISBN 0-89871-172-X
3423: !
3424: !  Parameters:
3425: !
3426: !    Input/output, real(8) A(LDA,N).  On input, the symmetric matrix to 
3427: !    be factored.  Only the diagonal and upper triangle are used.
3428: !    On output, an upper triangular matrix R so that A = R'*R where R' 
3429: !    is the transpose.  The strict lower triangle is unaltered.
3430: !    If INFO /= 0, the factorization is not complete.
3431: !
3432: !    Input, integer LDA, the leading dimension of the array A.
3433: !
3434: !    Input, integer N, the order of the matrix.
3435: !
3436: !    Output, real(8) RCOND, an estimate of the reciprocal condition of A.
3437: !    For the system A*X = B, relative perturbations in A and B of size  
3438: !    EPSILON may cause relative perturbations in X of size EPSILON/RCOND.
3439: !    If RCOND is so small that the logical expression
3440: !      1.0D+00 + RCOND == 1.0D+00
3441: !    is true, then A may be singular to working precision.  In particular,  
3442: !    RCOND is zero if exact singularity is detected or the estimate underflows.
3443: !
3444: !    Output, real(8) Z(N), a work vector whose contents are usually unimportant.
3445: !    If A is close to a singular matrix, then Z is an approximate null vector 
3446: !    in the sense that
3447: !      norm(A*Z) = RCOND * norm(A) * norm(Z).
3448: !    If INFO /= 0, Z is unchanged.
3449: !
3450: !    Output, integer INFO, error flag.
3451: !    0, for normal return.
3452: !    K, signals an error condition.  The leading minor of order K is not 
3453: !    positive definite.
3454: !
3455:   implicit none
3456: !
3457:   integer lda
3458:   integer n
3459: 
3460:   real(8) a(lda,n)
3461:   real(8) anorm
3462:   real(8) ek
3463:   integer i
3464:   integer info
3465:   integer j
3466:   integer k
3467:   integer kp1
3468:   real(8) rcond
3469:   real(8) s
3470:   real(8) sm
3471:   real(8) t
3472:   real(8) wk
3473:   real(8) wkm
3474:   real(8) ynorm
3475:   real(8) z(n)
3476: !
3477: !  Find norm of A using only upper half.
3478: !
3479:   do j = 1, n
3480:     z(j) = sum ( abs ( a(1:j,j) ) )
3481:     do i = 1, j-1
3482:       z(i) = z(i) + abs ( a(i,j) )
3483:     end do
3484:   end do
3485: 
3486:   anorm = maxval ( z(1:n) )
3487: !
3488: !  Factor.
3489: !
3490:   call <a href="./linpack.f90.html#spofa" TARGET=CENT_PANEL>spofa</a> ( a, lda, n, info )
3491: 
3492:   if ( info /= 0 ) then
3493:     return
3494:   end if
3495: !
3496: !  RCOND = 1/(norm(A)*(estimate of norm(inverse(A)))).
3497: !
3498: !  Estimate = norm(Z)/norm(Y) where A*Z = Y and A*Y = E.
3499: !
3500: !  The components of E are chosen to cause maximum local
3501: !  growth in the elements of W where R'*W = E.
3502: !
3503: !  The vectors are frequently rescaled to avoid overflow.
3504: !
3505: !  Solve R'*W = E.
3506: !
3507:      ek = 1.0D+00
3508:      z(1:n) = 0.0D+00
3509: 
3510:      do k = 1, n
3511: 
3512:         if ( z(k) /= 0.0D+00 ) then
3513:           ek = sign ( ek, -z(k) )
3514:         end if
3515: 
3516:         if ( abs ( ek - z(k) ) > a(k,k) ) then
3517:           s = a(k,k) / abs ( ek - z(k) )
3518:           z(1:n) = s * z(1:n)
3519:           ek = s * ek
3520:         end if
3521: 
3522:         wk = ek - z(k)
3523:         wkm = -ek - z(k)
3524:         s = abs ( wk )
3525:         sm = abs ( wkm )
3526:         wk = wk / a(k,k)
3527:         wkm = wkm / a(k,k)
3528:         kp1 = k + 1
3529: 
3530:         if ( k+1 <= n ) then
3531: 
3532:            do j = k+1, n
3533:               sm = sm + abs ( z(j) + wkm * a(k,j) )
3534:               z(j) = z(j) + wk * a(k,j)
3535:               s = s + abs ( z(j) )
3536:            end do
3537: 
3538:            if ( s < sm ) then
3539: 
3540:               t = wkm - wk
3541:               wk = wkm
3542:               do j = k+1, n
3543:                 z(j) = z(j) + t * a(k,j)
3544:               end do
3545: 
3546:            end if
3547: 
3548:         end if
3549: 
3550:         z(k) = wk
3551: 
3552:      end do
3553: 
3554:      z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
3555: !
3556: !  Solve R*Y = W.
3557: !
3558:      do k = n, 1, -1
3559: 
3560:         if ( abs ( z(k) ) > a(k,k) ) then
3561:            s = a(k,k) / abs ( z(k) )
3562:            z(1:n) = s * z(1:n)
3563:         end if
3564: 
3565:         z(k) = z(k)/a(k,k)
3566:         t = -z(k)
3567:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, t, a(1,k), 1, z(1), 1 )
3568: 
3569:      end do
3570: 
3571:      z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
3572:      ynorm = 1.0D+00
3573: !
3574: !  Solve R'*V = Y.
3575: !
3576:      do k = 1, n
3577: 
3578:         z(k) = z(k) - dot_product ( a(1:k-1,k), z(1:k-1) )
3579: 
3580:         if ( abs ( z(k) ) > a(k,k) ) then
3581:            s = a(k,k) / abs ( z(k) )
3582:            z(1:n) = s * z(1:n)
3583:            ynorm = s * ynorm
3584:         end if
3585: 
3586:         z(k) = z(k) / a(k,k)
3587: 
3588:      end do
3589: 
3590:      s = 1.0D+00 / sum ( abs ( z(1:n) ) )
3591:      z(1:n) = s * z(1:n)
3592:      ynorm = s * ynorm
3593: !
3594: !  Solve R*Z = V.
3595: !
3596:      do k = n, 1, -1
3597: 
3598:         if ( abs ( z(k) ) > a(k,k) ) then
3599:            s = a(k,k) / abs ( z(k) )
3600:            z(1:n) = s * z(1:n)
3601:            ynorm = s * ynorm
3602:         end if
3603: 
3604:         z(k) = z(k)/a(k,k)
3605:         t = -z(k)
3606:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, t, a(1,k), 1, z(1), 1 )
3607: 
3608:      end do
3609: !
3610: !  Make ZNORM = 1.0.
3611: !
3612:      s = 1.0D+00 / sum ( abs ( z(1:n) ) )
3613:      z(1:n) = s * z(1:n)
3614:      ynorm = s * ynorm
3615: 
3616:      if ( anorm /= 0.0D+00 ) then
3617:        rcond = ynorm / anorm
3618:      else
3619:        rcond = 0.0D+00
3620:      end if
3621: 
3622:   return
3623: end
<p><a name=spodi><H3>spodi</H3></a></p> Click <a href="./callingtree/spodi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spodi is used.
<hr>
3624: subroutine spodi ( a, lda, n, det, job )
3625: !
3626: !*******************************************************************************
3627: !
3628: !! SPODI computes the determinant and inverse of a certain matrix.
3629: !
3630: !
3631: !  Discussion:
3632: !
3633: !    The matrix is real(8) symmetric positive definite.
3634: !    SPODI uses the factors computed by SPOCO, SPOFA or SQRDC.
3635: !
3636: !    A division by zero will occur if the input factor contains
3637: !    a zero on the diagonal and the inverse is requested.
3638: !    It will not occur if the subroutines are called correctly
3639: !    and if SPOCO or SPOFA has set INFO == 0.
3640: !
3641: !  Reference:
3642: !
3643: !    Dongarra, Moler, Bunch and Stewart,
3644: !    LINPACK User's Guide,
3645: !    SIAM, (Society for Industrial and Applied Mathematics),
3646: !    3600 University City Science Center,
3647: !    Philadelphia, PA, 19104-2688.
3648: !    ISBN 0-89871-172-X
3649: !
3650: !  Parameters:
3651: !
3652: !    Input/output, real(8) A(LDA,N).  On input, the output A from SPOCO 
3653: !    or SPOFA, or the output X from SQRDC.  On output, if SPOCO or 
3654: !    SPOFA was used to factor A then SPODI produces the upper half of
3655: !    inverse(A).  If SQRDC was used to decompose X then SPODI produces 
3656: !    the upper half of inverse(X'*X) where X' is the transpose.
3657: !    Elements of A below the diagonal are unchanged.  If the units digit 
3658: !    of JOB is zero, A is unchanged.
3659: !
3660: !    Input, integer LDA, the leading dimension of the array A.
3661: !
3662: !    Input, integer N, the order of the matrix A.
3663: !
3664: !    Input, integer JOB, specifies the task.
3665: !    11, both determinant and inverse.
3666: !    01, inverse only.
3667: !    10, determinant only.
3668: !
3669: !    Output, real(8) DET(2), the determinant of A or of X'*X if requested.
3670: !      determinant = DET(1) * 10.0**DET(2)
3671: !    with 1.0D+00 <= DET(1) < 10.0D+00 or DET(1) == 0.0D+00.
3672: !
3673:   implicit none
3674: !
3675:   integer lda
3676:   integer n
3677: !
3678:   real(8) a(lda,n)
3679:   real(8) det(2)
3680:   integer i
3681:   integer j
3682:   integer job
3683:   integer k
3684:   integer kp1
3685:   real(8) s
3686:   real(8) t
3687: !
3688: !  Compute the determinant.
3689: !
3690:   if ( job / 10 /= 0 ) then
3691: 
3692:      det(1) = 1.0D+00
3693:      det(2) = 0.0D+00
3694:      s = 10.0D+00
3695: 
3696:      do i = 1, n
3697: 
3698:         det(1) = a(i,i)**2 * det(1)
3699: 
3700:         if ( det(1) == 0.0D+00 ) then
3701:           exit
3702:         end if
3703: 
3704:         do while ( det(1) < 1.0D+00 )
3705:           det(1) = s * det(1)
3706:           det(2) = det(2) - 1.0D+00
3707:         end do
3708: 
3709:         do while ( det(1) >= s )
3710:           det(1) = det(1) / s
3711:           det(2) = det(2) + 1.0D+00
3712:         end do
3713: 
3714:     end do
3715: 
3716:   end if
3717: !
3718: !  Compute inverse(R).
3719: !
3720:   if ( mod ( job, 10 ) /= 0 ) then
3721: 
3722:      do k = 1, n
3723: 
3724:         a(k,k) = 1.0D+00 / a(k,k)
3725:         t = -a(k,k)
3726:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( k-1, t, a(1,k), 1 )
3727:         kp1 = k + 1
3728: 
3729:         do j = k+1, n
3730:           t = a(k,j)
3731:           a(k,j) = 0.0D+00
3732:           call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k, t, a(1,k), 1, a(1,j), 1 )
3733:         end do
3734: 
3735:      end do
3736: !
3737: !  Form inverse(R) * transpose(inverse(R)).
3738: !
3739:      do j = 1, n
3740:         do k = 1, j-1
3741:           t = a(k,j)
3742:           call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k, t, a(1,j), 1, a(1,k), 1 )
3743:         end do
3744:         t = a(j,j)
3745:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( j, t, a(1,j), 1 )
3746:      end do
3747: 
3748:   end if
3749: 
3750:   return
3751: end
<p><a name=spofa><H3>spofa</H3></a></p> Click <a href="./callingtree/spofa_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spofa is used.
<hr>
3752: subroutine spofa ( a, lda, n, info )
3753: !
3754: !*******************************************************************************
3755: !
3756: !! SPOFA factors a real(8) symmetric positive definite matrix.
3757: !
3758: !
3759: !  Discussion:
3760: !
3761: !    SPOFA is usually called by SPOCO, but it can be called
3762: !    directly with a saving in time if RCOND is not needed.
3763: !
3764: !  Modified:
3765: !
3766: !    17 April 2002
3767: !
3768: !  Reference:
3769: !
3770: !    Dongarra, Moler, Bunch and Stewart,
3771: !    LINPACK User's Guide,
3772: !    SIAM, (Society for Industrial and Applied Mathematics),
3773: !    3600 University City Science Center,
3774: !    Philadelphia, PA, 19104-2688.
3775: !    ISBN 0-89871-172-X
3776: !
3777: !  Parameters:
3778: !
3779: !    Input/output, real(8) A(LDA,N).  On input, the symmetric matrix to be 
3780: !    factored.  Only the diagonal and upper triangle are used.
3781: !    On output, an upper triangular matrix R so that A = R'*R
3782: !    where R' is the transpose.  The strict lower triangle is unaltered.
3783: !    If INFO /= 0, the factorization is not complete.
3784: !
3785: !    Input, integer LDA, the leading dimension of the array A.
3786: !
3787: !    Input, integer N, the order of the matrix.
3788: !
3789: !    Output, integer INFO, error flag.
3790: !    0, for normal return.
3791: !    K, signals an error condition.  The leading minor of order K is not 
3792: !    positive definite.
3793: !
3794:   implicit none
3795: !
3796:   integer lda
3797:   integer n
3798: !
3799:   real(8) a(lda,n)
3800:   integer info
3801:   integer j
3802:   integer k
3803:   real(8) s
3804:   real(8) t
3805: !
3806:   do j = 1, n
3807: 
3808:     s = 0.0D+00
3809: 
3810:     do k = 1, j-1
3811:       t = a(k,j) - dot_product ( a(1:k-1,k), a(1:k-1,j) )
3812:       t = t / a(k,k)
3813:       a(k,j) = t
3814:       s = s + t * t
3815:     end do
3816: 
3817:     s = a(j,j) - s
3818: 
3819:     if ( s <= 0.0D+00 ) then
3820:       info = j
3821:       return
3822:     end if
3823: 
3824:     a(j,j) = sqrt ( s )
3825: 
3826:   end do
3827: 
3828:   info = 0
3829: 
3830:   return
3831: end
<p><a name=sposl><H3>sposl</H3></a></p> Click <a href="./callingtree/sposl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sposl is used.
<hr>
3832: subroutine sposl ( a, lda, n, b )
3833: !
3834: !*******************************************************************************
3835: !
3836: !! SPOSL solves a linear system factored by SPOCO or SPOFA.
3837: !
3838: !
3839: !  Discussion:
3840: !
3841: !    To compute inverse(A) * C where C is a matrix with P columns:
3842: !
3843: !      call spoco ( a, lda, n, rcond, z, info )
3844: !
3845: !      if ( rcond is not too small .and. info == 0 ) then
3846: !        do j = 1, p
3847: !          call sposl ( a, lda, n, c(1,j) )
3848: !        end do
3849: !      end if
3850: !
3851: !    A division by zero will occur if the input factor contains
3852: !    a zero on the diagonal.  Technically this indicates
3853: !    singularity but it is usually caused by improper subroutine
3854: !    arguments.  It will not occur if the subroutines are called
3855: !    correctly and INFO == 0.
3856: !
3857: !  Reference:
3858: !
3859: !    Dongarra, Moler, Bunch and Stewart,
3860: !    LINPACK User's Guide,
3861: !    SIAM, (Society for Industrial and Applied Mathematics),
3862: !    3600 University City Science Center,
3863: !    Philadelphia, PA, 19104-2688.
3864: !    ISBN 0-89871-172-X
3865: !
3866: !  Parameters:
3867: !
3868: !    Input, real(8) A(LDA,N), the output from SPOCO or SPOFA.
3869: !
3870: !    Input, integer LDA, the leading dimension of the array A.
3871: !
3872: !    Input, integer N, the order of the matrix.
3873: !
3874: !    Input/output, real(8) B(N).  On input, the right hand side.
3875: !    On output, the solution.
3876: !
3877:   implicit none
3878: !
3879:   integer lda
3880:   integer n
3881: !
3882:   real(8) a(lda,n)
3883:   real(8) b(n)
3884:   integer k
3885:   real(8) t
3886: !
3887: !  Solve R'*Y = B.
3888: !
3889:   do k = 1, n
3890:     t = dot_product ( a(1:k-1,k), b(1:k-1) )
3891:     b(k) = ( b(k) - t ) / a(k,k)
3892:   end do
3893: !
3894: !  Solve R*X = Y.
3895: !
3896:   do k = n, 1, -1
3897:     b(k) = b(k)/a(k,k)
3898:     t = -b(k)
3899:     call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, t, a(1,k), 1, b(1), 1 )
3900:   end do
3901: 
3902:   return
3903: end
<p><a name=sppco><H3>sppco</H3></a></p> Click <a href="./callingtree/sppco_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sppco is used.
<hr>
3904: subroutine sppco ( ap, n, rcond, z, info )
3905: !
3906: !*******************************************************************************
3907: !
3908: !! SPPCO factors a real(8) symmetric positive definite matrix in packed form.
3909: !
3910: !
3911: !  Discussion:
3912: !
3913: !    SPPCO also estimates the condition of the matrix.
3914: !
3915: !    If RCOND is not needed, SPPFA is slightly faster.
3916: !
3917: !    To solve A*X = B, follow SPPCO by SPPSL.
3918: !
3919: !    To compute inverse(A)*C, follow SPPCO by SPPSL.
3920: !
3921: !    To compute determinant(A), follow SPPCO by SPPDI.
3922: !
3923: !    To compute inverse(A), follow SPPCO by SPPDI.
3924: !
3925: !  Packed storage:
3926: !
3927: !    The following program segment will pack the upper triangle of 
3928: !    a symmetric matrix.
3929: !
3930: !      k = 0
3931: !      do j = 1, n
3932: !        do i = 1, j
3933: !          k = k + 1
3934: !          ap(k) = a(i,j)
3935: !        end do
3936: !      end do
3937: !
3938: !  Reference:
3939: !
3940: !    Dongarra, Moler, Bunch and Stewart,
3941: !    LINPACK User's Guide,
3942: !    SIAM, (Society for Industrial and Applied Mathematics),
3943: !    3600 University City Science Center,
3944: !    Philadelphia, PA, 19104-2688.
3945: !    ISBN 0-89871-172-X
3946: !
3947: !  Parameters:
3948: !
3949: !    Input/output, real(8) AP(N*(N+1)/2).  On input, the packed form of a 
3950: !    symmetric matrix A.  The columns of the upper triangle are stored 
3951: !    sequentially in a one-dimensional array.  On output, an upper 
3952: !    triangular matrix R, stored in packed form, so that A = R'*R.
3953: !    If INFO /= 0, the factorization is not complete.
3954: !
3955: !    Input, integer N, the order of the matrix.
3956: !
3957: !    Output, real(8) RCOND, an estimate of the reciprocal condition of A.
3958: !    For the system A*X = B, relative perturbations in A and B of size  
3959: !    EPSILON may cause relative perturbations in X of size EPSILON/RCOND.
3960: !    If RCOND is so small that the logical expression
3961: !      1.0D+00 + RCOND == 1.0D+00
3962: !    is true, then A may be singular to working precision.  In particular,  
3963: !    RCOND is zero if exact singularity is detected or the estimate underflows.
3964: !
3965: !    Output, real(8) Z(N), a work vector whose contents are usually unimportant.
3966: !    If A is singular to working precision, then Z is an approximate null 
3967: !    vector in the sense that
3968: !      norm(A*Z) = RCOND * norm(A) * norm(Z).
3969: !    If INFO /= 0, Z is unchanged.
3970: !
3971: !    Output, integer INFO, error flag.
3972: !    0, for normal return.
3973: !    K, signals an error condition.  The leading minor of order K is 
3974: !    not positive definite.
3975: !
3976:   implicit none
3977: !
3978:   integer n
3979: !
3980:   real(8) anorm
3981:   real(8) ap((n*(n+1))/2)
3982:   real(8) ek
3983:   integer i
3984:   integer ij
3985:   integer info
3986:   integer j
3987:   integer j1
3988:   integer k
3989:   integer kj
3990:   integer kk
3991:   integer kp1
3992:   real(8) rcond
3993:   real(8) s
3994:   real(8) sdot
3995:   real(8) sm
3996:   real(8) t
3997:   real(8) wk
3998:   real(8) wkm
3999:   real(8) ynorm
4000:   real(8) z(n)
4001: !
4002: !  Find the norm of A.
4003: !
4004:   j1 = 1
4005:   do j = 1, n
4006:     z(j) = sum ( abs ( ap(j1:j1+j-1) ) )
4007:     ij = j1
4008:     j1 = j1 + j
4009:     do i = 1, j-1
4010:       z(i) = z(i) + abs ( ap(ij) )
4011:       ij = ij + 1
4012:     end do
4013:   end do
4014: 
4015:   anorm = maxval ( z(1:n) )
4016: !
4017: !  Factor.
4018: !
4019:   call <a href="./linpack.f90.html#sppfa" TARGET=CENT_PANEL>sppfa</a> ( ap, n, info )
4020: 
4021:   if ( info /= 0 ) then
4022:     return
4023:   end if
4024: !
4025: !  RCOND = 1/(norm(A)*(estimate of norm(inverse(A)))).
4026: !
4027: !  Estimate = norm(Z)/norm(Y) where A*Z = Y and A*Y = E.
4028: !
4029: !  The components of E are chosen to cause maximum local
4030: !  growth in the elements of W where R'*W = E.
4031: !
4032: !  The vectors are frequently rescaled to avoid overflow.
4033: !
4034: !  Solve R'*W = E.
4035: !
4036:      ek = 1.0D+00
4037:      z(1:n) = 0.0D+00
4038: 
4039:      kk = 0
4040: 
4041:      do k = 1, n
4042: 
4043:         kk = kk + k
4044: 
4045:         if ( z(k) /= 0.0D+00 ) then
4046:           ek = sign ( ek, -z(k) )
4047:         end if
4048: 
4049:         if ( abs ( ek - z(k) ) > ap(kk) ) then
4050:            s = ap(kk) / abs ( ek - z(k) )
4051:            z(1:n) = s * z(1:n)
4052:            ek = s * ek
4053:         end if
4054: 
4055:         wk = ek - z(k)
4056:         wkm = -ek - z(k)
4057:         s = abs ( wk )
4058:         sm = abs ( wkm )
4059:         wk = wk / ap(kk)
4060:         wkm = wkm / ap(kk)
4061:         kp1 = k + 1
4062:         kj = kk + k
4063: 
4064:         if ( k+1 <= n ) then
4065: 
4066:            do j = k+1, n
4067:               sm = sm + abs ( z(j) + wkm * ap(kj) )
4068:               z(j) = z(j) + wk * ap(kj)
4069:               s = s + abs ( z(j) )
4070:               kj = kj + j
4071:            end do
4072: 
4073:            if ( s < sm ) then
4074: 
4075:               t = wkm - wk
4076:               wk = wkm
4077:               kj = kk + k
4078: 
4079:               do j = k+1, n
4080:                  z(j) = z(j) + t * ap(kj)
4081:                  kj = kj + j
4082:               end do
4083: 
4084:            end if
4085: 
4086:         end if
4087: 
4088:         z(k) = wk
4089: 
4090:      end do
4091: 
4092:      z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
4093: !
4094: !  Solve R*Y = W.
4095: !
4096:      do k = n, 1, -1
4097: 
4098:         if ( abs ( z(k) ) > ap(kk) ) then
4099:           s = ap(kk) / abs ( z(k) )
4100:           z(1:n) = s * z(1:n)
4101:         end if
4102: 
4103:         z(k) = z(k) / ap(kk)
4104:         kk = kk - k
4105:         t = -z(k)
4106:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, t, ap(kk+1), 1, z(1), 1 )
4107: 
4108:      end do
4109: 
4110:      z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
4111: 
4112:      ynorm = 1.0D+00
4113: !
4114: !  Solve R'*V = Y.
4115: !
4116:      do k = 1, n
4117: 
4118:         z(k) = z(k) - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(kk+1), 1, z(1), 1 )
4119:         kk = kk + k
4120: 
4121:         if ( abs ( z(k) ) > ap(kk) ) then
4122:           s = ap(kk) / abs ( z(k) )
4123:           z(1:n) = s * z(1:n)
4124:           ynorm = s * ynorm
4125:         end if
4126: 
4127:         z(k) = z(k) / ap(kk)
4128: 
4129:      end do
4130: 
4131:      s = 1.0D+00 / sum ( abs ( z(1:n) ) )
4132:      z(1:n) = s * z(1:n)
4133:      ynorm = s * ynorm
4134: !
4135: !  Solve R*Z = V.
4136: !
4137:      do k = n, 1, -1
4138: 
4139:         if ( abs ( z(k) ) > ap(kk) ) then
4140:            s = ap(kk) / abs ( z(k) )
4141:            z(1:n) = s * z(1:n)
4142:            ynorm = s * ynorm
4143:         end if
4144: 
4145:         z(k) = z(k) / ap(kk)
4146:         kk = kk - k
4147:         t = -z(k)
4148:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, t, ap(kk+1), 1, z(1), 1 )
4149: 
4150:      end do
4151: !
4152: !  Make ZNORM = 1.0.
4153: !
4154:      s = 1.0D+00 / sum ( abs ( z(1:n) ) )
4155:      z(1:n) = s * z(1:n)
4156:      ynorm = s * ynorm
4157: 
4158:      if ( anorm /= 0.0D+00 ) then
4159:        rcond = ynorm / anorm
4160:      else
4161:        rcond = 0.0D+00
4162:      end if
4163: 
4164:   return
4165: end
<p><a name=sppdi><H3>sppdi</H3></a></p> Click <a href="./callingtree/sppdi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sppdi is used.
<hr>
4166: subroutine sppdi ( ap, n, det, job )
4167: !
4168: !*******************************************************************************
4169: !
4170: !! SPPDI computes the determinant and inverse of a matrix factored by SPPCO or SPPFA.
4171: !
4172: !
4173: !  Discussion:
4174: !
4175: !    A division by zero will occur if the input factor contains
4176: !    a zero on the diagonal and the inverse is requested.
4177: !    It will not occur if the subroutines are called correctly
4178: !    and if SPOCO or SPOFA has set INFO == 0.
4179: !
4180: !  Reference:
4181: !
4182: !    Dongarra, Moler, Bunch and Stewart,
4183: !    LINPACK User's Guide,
4184: !    SIAM, (Society for Industrial and Applied Mathematics),
4185: !    3600 University City Science Center,
4186: !    Philadelphia, PA, 19104-2688.
4187: !    ISBN 0-89871-172-X
4188: !
4189: !  Parameters:
4190: !
4191: !    Input/output, real(8) AP(N*(N+1)/2).  On input, the output from 
4192: !    SPPCO or SPPFA.  On output, the upper triangular half of the 
4193: !    inverse, if requested.
4194: !
4195: !    Input, integer N, the order of the matrix.
4196: !
4197: !    Output, real(8) DET(2), the determinant of the original matrix if requested.
4198: !      determinant = DET(1) * 10.0**DET(2)
4199: !    with  1.0D+00 <= DET(1) < 10.0D+00 or DET(1) == 0.0D+00.
4200: !
4201: !    Input, integer JOB, job request.
4202: !    11, both determinant and inverse.
4203: !    01, inverse only.
4204: !    10, determinant only.
4205: !
4206:   implicit none
4207: !
4208:   integer n
4209: !
4210:   real(8) ap((n*(n+1))/2)
4211:   real(8) det(2)
4212:   integer i
4213:   integer ii
4214:   integer j
4215:   integer j1
4216:   integer jj
4217:   integer job
4218:   integer k
4219:   integer k1
4220:   integer kj
4221:   integer kk
4222:   integer kp1
4223:   real(8) s
4224:   real(8) t
4225: !
4226: !  Compute the determinant.
4227: !
4228:   if ( job/10 /= 0 ) then
4229: 
4230:      det(1) = 1.0D+00
4231:      det(2) = 0.0D+00
4232:      s = 10.0D+00
4233:      ii = 0
4234: 
4235:      do i = 1, n
4236: 
4237:         ii = ii + i
4238: 
4239:         det(1) = ap(ii)**2 * det(1)
4240: 
4241:         if ( det(1) == 0.0D+00 ) then
4242:           exit
4243:         end if
4244: 
4245:         do while ( det(1) < 1.0D+00 ) 
4246:           det(1) = s * det(1)
4247:           det(2) = det(2) - 1.0D+00
4248:         end do
4249: 
4250:         do while ( det(1) >= s ) 
4251:           det(1) = det(1) / s
4252:           det(2) = det(2) + 1.0D+00
4253:         end do
4254: 
4255:     end do
4256: 
4257:   end if
4258: !
4259: !  Compute inverse(R).
4260: !
4261:   if ( mod ( job, 10 ) /= 0 ) then
4262: 
4263:      kk = 0
4264: 
4265:      do k = 1, n
4266: 
4267:         k1 = kk + 1
4268:         kk = kk + k
4269:         ap(kk) = 1.0D+00 / ap(kk)
4270:         t = - ap(kk)
4271:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( k-1, t, ap(k1), 1 )
4272:         kp1 = k + 1
4273:         j1 = kk + 1
4274:         kj = kk + k
4275: 
4276:         do j = k+1, n
4277:            t = ap(kj)
4278:            ap(kj) = 0.0D+00
4279:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k, t, ap(k1), 1, ap(j1), 1 )
4280:            j1 = j1 + j
4281:            kj = kj + j
4282:         end do
4283: 
4284:      end do
4285: !
4286: !  Form inverse(R) * transpose(inverse(R)).
4287: !
4288:      jj = 0
4289: 
4290:      do j = 1, n
4291: 
4292:         j1 = jj + 1
4293:         jj = jj + j
4294:         k1 = 1
4295:         kj = j1
4296: 
4297:         do k = 1, j-1
4298:            t = ap(kj)
4299:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k, t, ap(j1), 1, ap(k1), 1 )
4300:            k1 = k1 + k
4301:            kj = kj + 1
4302:         end do
4303: 
4304:         t = ap(jj)
4305:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( j, t, ap(j1), 1 )
4306: 
4307:     end do
4308: 
4309:   end if
4310: 
4311:   return
4312: end
<p><a name=sppfa><H3>sppfa</H3></a></p> Click <a href="./callingtree/sppfa_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sppfa is used.
<hr>
4313: subroutine sppfa ( ap, n, info )
4314: !
4315: !*******************************************************************************
4316: !
4317: !! SPPFA factors a real(8) symmetric positive definite matrix in packed form.
4318: !
4319: !
4320: !  Discussion:
4321: !
4322: !    SPPFA is usually called by SPPCO, but it can be called
4323: !    directly with a saving in time if RCOND is not needed.
4324: !
4325: !  Packed storage:
4326: !
4327: !    The following program segment will pack the upper
4328: !    triangle of a symmetric matrix.
4329: !
4330: !      k = 0
4331: !      do j = 1, n
4332: !        do i = 1, j
4333: !          k = k + 1
4334: !          ap(k) = a(i,j)
4335: !        end do
4336: !      end do
4337: !
4338: !  Reference:
4339: !
4340: !    Dongarra, Moler, Bunch and Stewart,
4341: !    LINPACK User's Guide,
4342: !    SIAM, (Society for Industrial and Applied Mathematics),
4343: !    3600 University City Science Center,
4344: !    Philadelphia, PA, 19104-2688.
4345: !    ISBN 0-89871-172-X
4346: !
4347: !  Parameters:
4348: !
4349: !    Input/output, real(8) AP(N*(N+1)/2).  On input, the packed form of a 
4350: !    symmetric matrix A.  The columns of the upper triangle are stored 
4351: !    sequentially in a one-dimensional array.  On output, an upper 
4352: !    triangular matrix R, stored in packed form, so that A = R'*R.
4353: !
4354: !    Input, integer N, the order of the matrix.
4355: !
4356: !    Output, integer INFO, error flag.
4357: !    0, for normal return.
4358: !    K, if the leading minor of order K is not positive definite.
4359: !
4360:   implicit none
4361: !
4362:   integer n
4363: !
4364:   real(8) ap((n*(n+1))/2)
4365:   integer info
4366:   integer j
4367:   integer jj
4368:   integer k
4369:   integer kj
4370:   integer kk
4371:   real(8) s
4372:   real(8) sdot
4373:   real(8) t
4374: !
4375:   info = 0
4376:   jj = 0
4377: 
4378:   do j = 1, n
4379: 
4380:     s = 0.0D+00
4381:     kj = jj
4382:     kk = 0
4383: 
4384:     do k = 1, j-1
4385: 
4386:       kj = kj + 1
4387:       t = ap(kj) - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(kk+1), 1, ap(jj+1), 1 )
4388:       kk = kk + k
4389:       t = t / ap(kk)
4390:       ap(kj) = t
4391:       s = s + t * t
4392: 
4393:     end do
4394: 
4395:     jj = jj + j
4396:     s = ap(jj) - s
4397: 
4398:     if ( s <= 0.0D+00 ) then
4399:       info = j
4400:       return
4401:     end if
4402: 
4403:     ap(jj) = sqrt ( s )
4404: 
4405:   end do
4406: 
4407:   return
4408: end
<p><a name=sppsl><H3>sppsl</H3></a></p> Click <a href="./callingtree/sppsl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sppsl is used.
<hr>
4409: subroutine sppsl ( ap, n, b )
4410: !
4411: !*******************************************************************************
4412: !
4413: !! SPPSL solves a real(8) symmetric positive definite system factored by SPPCO or SPPFA.
4414: !
4415: !
4416: !  Discussion:
4417: !
4418: !    To compute inverse(A) * C where C is a matrix with P columns
4419: !
4420: !      call sppco ( ap, n, rcond, z, info )
4421: !
4422: !      if ( rcond is too small .or. info /= 0 ) then
4423: !        exit
4424: !      end if
4425: !
4426: !      do j = 1, p
4427: !        call sppsl ( ap, n, c(1,j) )
4428: !      end do
4429: !
4430: !    A division by zero will occur if the input factor contains
4431: !    a zero on the diagonal.  Technically this indicates
4432: !    singularity but it is usually caused by improper subroutine
4433: !    arguments.  It will not occur if the subroutines are called
4434: !    correctly and INFO == 0.
4435: !
4436: !  Reference:
4437: !
4438: !    Dongarra, Moler, Bunch and Stewart,
4439: !    LINPACK User's Guide,
4440: !    SIAM, (Society for Industrial and Applied Mathematics),
4441: !    3600 University City Science Center,
4442: !    Philadelphia, PA, 19104-2688.
4443: !    ISBN 0-89871-172-X
4444: !
4445: !  Parameters:
4446: !
4447: !    Input, real(8) AP(N*(N+1)/2), the output from SPPCO or SPPFA.
4448: !
4449: !    Input, integer N, the order of the matrix.
4450: !
4451: !    Input/output, real(8) B(N).  On input, the right hand side.
4452: !    On output, the solution.
4453: !
4454:   implicit none
4455: !
4456:   integer n
4457: !
4458:   real(8) ap((n*(n+1))/2)
4459:   real(8) b(n)
4460:   integer k
4461:   integer kk
4462:   real(8) sdot
4463:   real(8) t
4464: !
4465:   kk = 0
4466: 
4467:   do k = 1, n
4468:     t = <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(kk+1), 1, b(1), 1 )
4469:     kk = kk + k
4470:     b(k) = (b(k) - t)/ap(kk)
4471:   end do
4472: 
4473:   do k = n, 1, -1
4474:     b(k) = b(k) / ap(kk)
4475:     kk = kk - k
4476:     t = - b(k)
4477:     call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, t, ap(kk+1), 1, b(1), 1 )
4478:   end do
4479: 
4480:   return
4481: end
<p><a name=sptsl><H3>sptsl</H3></a></p> Click <a href="./callingtree/sptsl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sptsl is used.
<hr>
4482: subroutine sptsl ( n, d, e, b )
4483: !
4484: !*******************************************************************************
4485: !
4486: !! SPTSL solves a positive definite tridiagonal linear system.
4487: !
4488: !
4489: !  Reference:
4490: !
4491: !    Dongarra, Moler, Bunch and Stewart,
4492: !    LINPACK User's Guide,
4493: !    SIAM, (Society for Industrial and Applied Mathematics),
4494: !    3600 University City Science Center,
4495: !    Philadelphia, PA, 19104-2688.
4496: !    ISBN 0-89871-172-X
4497: !
4498: !  Parameters:
4499: !
4500: !    Input, integer N, the order of the matrix.
4501: !
4502: !    Input/output, real(8) D(N), on input the diagonal of the tridiagonal matrix.
4503: !    On output, D is destroyed.
4504: !
4505: !    Input, real(8) E(N), the offdiagonal of the tridiagonal matrix in
4506: !    entries E(1:N-1).
4507: !
4508: !    Input/output, real(8) B(N).  On input, the right hand side.
4509: !    On output, the solution.
4510: !
4511:   implicit none
4512: !
4513:   integer n
4514: !
4515:   real(8) b(n)
4516:   real(8) d(n)
4517:   real(8) e(n)
4518:   integer k
4519:   integer kbm1
4520:   integer ke
4521:   integer kf
4522:   integer kp1
4523:   integer nm1d2
4524:   real(8) t1
4525:   real(8) t2
4526: !
4527: !  Check for 1 x 1 case.
4528: !
4529:   if ( n == 1 ) then
4530:     b(1) = b(1) / d(1)
4531:     return
4532:   end if
4533: 
4534:   nm1d2 = ( n - 1 ) / 2
4535: 
4536:   if ( n > 2 ) then
4537: 
4538:     kbm1 = n - 1
4539: !
4540: !  Zero top half of subdiagonal and bottom half of superdiagonal.
4541: !
4542:     do k = 1, nm1d2
4543:       t1 = e(k) / d(k)
4544:       d(k+1) = d(k+1) - t1 * e(k)
4545:       b(k+1) = b(k+1) - t1 * b(k)
4546:       t2 = e(kbm1) / d(kbm1+1)
4547:       d(kbm1) = d(kbm1) - t2 * e(kbm1)
4548:       b(kbm1) = b(kbm1) - t2 * b(kbm1+1)
4549:       kbm1 = kbm1 - 1
4550:     end do
4551: 
4552:   end if
4553: 
4554:   kp1 = nm1d2 + 1
4555: !
4556: !  Clean up for possible 2 x 2 block at center.
4557: !
4558:   if ( mod ( n, 2 ) == 0 ) then
4559:     t1 = e(kp1) / d(kp1)
4560:     d(kp1+1) = d(kp1+1) - t1 * e(kp1)
4561:     b(kp1+1) = b(kp1+1) - t1 * b(kp1)
4562:     kp1 = kp1 + 1
4563:   end if
4564: !
4565: !  Back solve starting at the center, going towards the top and bottom.
4566: !
4567:   b(kp1) = b(kp1)/d(kp1)
4568: 
4569:   if ( n > 2 ) then
4570: 
4571:     k = kp1 - 1
4572:     ke = kp1 + nm1d2 - 1
4573: 
4574:     do kf = kp1, ke
4575:       b(k) = ( b(k) - e(k) * b(k+1) ) / d(k)
4576:       b(kf+1) = ( b(kf+1) - e(kf) * b(kf) ) / d(kf+1)
4577:       k = k - 1
4578:     end do
4579: 
4580:   end if
4581: 
4582:   if ( mod ( n, 2 ) == 0 ) then
4583:     b(1) = ( b(1) - e(1) * b(2) ) / d(1)
4584:   end if
4585: 
4586:   return
4587: end
<p><a name=sqrdc><H3>sqrdc</H3></a></p> Click <a href="./callingtree/sqrdc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sqrdc is used.
<hr>
4588: subroutine sqrdc ( a, lda, n, p, qraux, jpvt, work, job )
4589: !
4590: !*******************************************************************************
4591: !
4592: !! SQRDC computes the QR factorization of a real(8) rectangular matrix.
4593: !
4594: !
4595: !  Discussion:
4596: !
4597: !    SQRDC uses Householder transformations.  
4598: !
4599: !    Column pivoting based on the 2-norms of the reduced columns may be
4600: !    performed at the user's option.
4601: !
4602: !  Reference:
4603: !
4604: !    Dongarra, Moler, Bunch and Stewart,
4605: !    LINPACK User's Guide,
4606: !    SIAM, (Society for Industrial and Applied Mathematics),
4607: !    3600 University City Science Center,
4608: !    Philadelphia, PA, 19104-2688.
4609: !    ISBN 0-89871-172-X
4610: !
4611: !  Parameters:
4612: !
4613: !    Input/output, real(8) A(LDA,P).  On input, the N by P matrix
4614: !    whose decomposition is to be computed.  On output, A contains in 
4615: !    its upper triangle the upper triangular matrix R of the QR 
4616: !    factorization.  Below its diagonal A contains information from
4617: !    which the orthogonal part of the decomposition can be recovered.  
4618: !    Note that if pivoting has been requested, the decomposition is not that
4619: !    of the original matrix A but that of A with its columns permuted 
4620: !    as described by JPVT.
4621: !
4622: !    Input, integer LDA, the leading dimension of the array A.  LDA must
4623: !    be at least N.
4624: !
4625: !    Input, integer N, the number of rows of the matrix A.
4626: !
4627: !    Input, integer P, the number of columns of the matrix A.
4628: !
4629: !    Output, real(8) QRAUX(P), contains further information required to recover
4630: !    the orthogonal part of the decomposition.
4631: !
4632: !    Input/output, integer JPVT(P).  On input, JPVT contains integers that 
4633: !    control the selection of the pivot columns.  The K-th column A(*,K) of A
4634: !    is placed in one of three classes according to the value of JPVT(K).
4635: !      > 0, then A(K) is an initial column.
4636: !      = 0, then A(K) is a free column.
4637: !      < 0, then A(K) is a final column.
4638: !    Before the decomposition is computed, initial columns are moved to 
4639: !    the beginning of the array A and final columns to the end.  Both 
4640: !    initial and final columns are frozen in place during the computation 
4641: !    and only free columns are moved.  At the K-th stage of the
4642: !    reduction, if A(*,K) is occupied by a free column it is interchanged 
4643: !    with the free column of largest reduced norm.  JPVT is not referenced 
4644: !    if JOB == 0.  On output, JPVT(K) contains the index of the column of the
4645: !    original matrix that has been interchanged into the K-th column, if 
4646: !    pivoting was requested.
4647: !
4648: !    Workspace, real(8) WORK(P).  WORK is not referenced if JOB == 0.
4649: !
4650: !    Input, integer JOB, initiates column pivoting.
4651: !    0, no pivoting is done.
4652: !    nonzero, pivoting is done.
4653: !
4654:   implicit none
4655: !
4656:   integer lda
4657:   integer n
4658:   integer p
4659: !
4660:   real(8) a(lda,p)
4661:   integer jpvt(p)
4662:   real(8) qraux(p)
4663:   real(8) work(p)
4664:   integer j
4665:   integer job
4666:   integer l
4667:   integer lup
4668:   integer maxj
4669:   real(8) maxnrm
4670:   real(8) nrmxl
4671:   integer pl
4672:   integer pu
4673:   real(8) sdot
4674:   real(8) snrm2
4675:   logical swapj
4676:   real(8) t
4677:   real(8) tt
4678: !
4679:   pl = 1
4680:   pu = 0
4681: !
4682: !  If pivoting is requested, rearrange the columns.
4683: !
4684:   if ( job /= 0 ) then
4685: 
4686:     do j = 1, p
4687: 
4688:       swapj = jpvt(j) > 0
4689: 
4690:       if ( jpvt(j) < 0 ) then
4691:         jpvt(j) = - j
4692:       else
4693:         jpvt(j) = j
4694:       end if
4695: 
4696:       if ( swapj ) then
4697: 
4698:         if ( j /= pl ) then
4699:           call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( n, a(1,pl), 1, a(1,j), 1 )
4700:         end if
4701: 
4702:         jpvt(j) = jpvt(pl)
4703:         jpvt(pl) = j
4704:         pl = pl + 1
4705: 
4706:       end if
4707: 
4708:     end do
4709: 
4710:     pu = p
4711: 
4712:     do j = p, 1, -1
4713: 
4714:       if ( jpvt(j) < 0 ) then
4715: 
4716:         jpvt(j) = - jpvt(j)
4717: 
4718:         if ( j /= pu ) then
4719:           call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( n, a(1,pu), 1, a(1,j), 1 )
4720:           call <a href="./linpack.f90.html#i_swap" TARGET=CENT_PANEL>i_swap</a> ( jpvt(pu), jpvt(j) )
4721:         end if
4722: 
4723:         pu = pu - 1
4724: 
4725:       end if
4726: 
4727:     end do
4728: 
4729:   end if
4730: !
4731: !  Compute the norms of the free columns.
4732: !
4733:   do j = pl, pu
4734:     qraux(j) = <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> ( n, a(1,j), 1 )
4735:   end do
4736: 
4737:   work(pl:pu) = qraux(pl:pu)
4738: !
4739: !  Perform the Householder reduction of A.
4740: !
4741:   lup = min ( n, p )
4742: 
4743:   do l = 1, lup
4744: !
4745: !  Bring the column of largest norm into the pivot position.
4746: !
4747:     if ( l >= pl .and. l < pu ) then
4748: 
4749:       maxnrm = 0.0D+00
4750:       maxj = l
4751:       do j = l, pu
4752:         if ( qraux(j) > maxnrm ) then
4753:           maxnrm = qraux(j)
4754:           maxj = j
4755:         end if
4756:       end do
4757: 
4758:       if ( maxj /= l ) then
4759:         call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( n, a(1,l), 1, a(1,maxj), 1 )
4760:         qraux(maxj) = qraux(l)
4761:         work(maxj) = work(l)
4762:         call <a href="./linpack.f90.html#i_swap" TARGET=CENT_PANEL>i_swap</a> ( jpvt(maxj), jpvt(l) )
4763:       end if
4764: 
4765:     end if
4766: !
4767: !  Compute the Householder transformation for column L.
4768: !
4769:     qraux(l) = 0.0D+00
4770: 
4771:     if ( l /= n ) then
4772: 
4773:       nrmxl = <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> ( n-l+1, a(l,l), 1 )
4774: 
4775:       if ( nrmxl /= 0.0D+00 ) then
4776: 
4777:         if ( a(l,l) /= 0.0D+00 ) then
4778:           nrmxl = sign ( nrmxl, a(l,l) )
4779:         end if
4780: 
4781:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( n-l+1, 1.0D+00 / nrmxl, a(l,l), 1 )
4782:         a(l,l) = 1.0D+00 + a(l,l)
4783: !
4784: !  Apply the transformation to the remaining columns, updating the norms.
4785: !
4786:         do j = l + 1, p
4787: 
4788:           t = - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( n-l+1, a(l,l), 1, a(l,j), 1 ) / a(l,l)
4789:           call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-l+1, t, a(l,l), 1, a(l,j), 1 )
4790: 
4791:           if ( j >= pl .and. j <= pu ) then
4792: 
4793:             if ( qraux(j) /= 0.0D+00 ) then
4794: 
4795:               tt = 1.0D+00 - ( abs ( a(l,j) ) / qraux(j) )**2
4796:               tt = max ( tt, 0.0D+00 )
4797:               t = tt
4798:               tt = 1.0D+00 + 0.05D+00 * tt * ( qraux(j) / work(j) )**2
4799: 
4800:               if ( tt /= 1.0D+00 ) then
4801:                 qraux(j) = qraux(j) * sqrt ( t )
4802:               else
4803:                 qraux(j) = <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> ( n-l, a(l+1,j), 1 )
4804:                 work(j) = qraux(j)
4805:               end if
4806: 
4807:             end if
4808: 
4809:           end if
4810: 
4811:         end do
4812: !
4813: !  Save the transformation.
4814: !
4815:         qraux(l) = a(l,l)
4816:         a(l,l) = - nrmxl
4817: 
4818:       end if
4819: 
4820:     end if
4821: 
4822:   end do
4823: 
4824:   return
4825: end
<p><a name=sqrsl><H3>sqrsl</H3></a></p> Click <a href="./callingtree/sqrsl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sqrsl is used.
<hr>
4826: subroutine sqrsl ( a, lda, n, k, qraux, y, qy, qty, b, rsd, ab, job, info )
4827: !
4828: !*******************************************************************************
4829: !
4830: !! SQRSL computes transformations, projections, and least squares solutions.
4831: !
4832: !
4833: !  Discussion:
4834: !
4835: !    SQRSL requires the output of SQRDC.
4836: !
4837: !    For K <= min(N,P), let AK be the matrix
4838: !
4839: !      AK = ( A(JPVT(1)), A(JPVT(2)), ..., A(JPVT(K)) )
4840: !
4841: !    formed from columns JPVT(1), ..., JPVT(K) of the original
4842: !    N by P matrix A that was input to SQRDC.  If no pivoting was
4843: !    done, AK consists of the first K columns of A in their
4844: !    original order.  SQRDC produces a factored orthogonal matrix Q
4845: !    and an upper triangular matrix R such that
4846: !
4847: !      AK = Q * (R)
4848: !               (0)
4849: !
4850: !    This information is contained in coded form in the arrays
4851: !    A and QRAUX.
4852: !
4853: !    The parameters QY, QTY, B, RSD, and AB are not referenced
4854: !    if their computation is not requested and in this case
4855: !    can be replaced by dummy variables in the calling program.
4856: !    To save storage, the user may in some cases use mod_the same
4857: !    array for different parameters in the calling sequence.  A
4858: !    frequently occuring example is when one wishes to compute
4859: !    any of B, RSD, or AB and does not need Y or QTY.  In this
4860: !    case one may identify Y, QTY, and one of B, RSD, or AB, while
4861: !    providing separate arrays for anything else that is to be
4862: !    computed.  
4863: !
4864: !    Thus the calling sequence
4865: !
4866: !      call sqrsl ( a, lda, n, k, qraux, y, dum, y, b, y, dum, 110, info )
4867: !
4868: !    will result in the computation of B and RSD, with RSD
4869: !    overwriting Y.  More generally, each item in the following
4870: !    list contains groups of permissible identifications for
4871: !    a single calling sequence.
4872: !
4873: !      1. (Y,QTY,B) (RSD) (AB) (QY)
4874: !
4875: !      2. (Y,QTY,RSD) (B) (AB) (QY)
4876: !
4877: !      3. (Y,QTY,AB) (B) (RSD) (QY)
4878: !
4879: !      4. (Y,QY) (QTY,B) (RSD) (AB)
4880: !
4881: !      5. (Y,QY) (QTY,RSD) (B) (AB)
4882: !
4883: !      6. (Y,QY) (QTY,AB) (B) (RSD)
4884: !
4885: !    In any group the value returned in the array allocated to
4886: !    the group corresponds to the last member of the group.
4887: !
4888: !  Reference:
4889: !
4890: !    Dongarra, Moler, Bunch and Stewart,
4891: !    LINPACK User's Guide,
4892: !    SIAM, (Society for Industrial and Applied Mathematics),
4893: !    3600 University City Science Center,
4894: !    Philadelphia, PA, 19104-2688.
4895: !    ISBN 0-89871-172-X
4896: !
4897: !  Parameters:
4898: !
4899: !    Input, real(8) A(LDA,P), contains the output of SQRDC.
4900: !
4901: !    Input, integer LDA, the leading dimension of the array A.
4902: !
4903: !    Input, integer N, the number of rows of the matrix AK.  It must
4904: !    have the same value as N in SQRDC.
4905: !
4906: !    Input, integer K, the number of columns of the matrix AK.  K
4907: !    must not be greater than min(N,P), where P is the same as in the 
4908: !    calling sequence to SQRDC.
4909: !
4910: !    Input, real(8) QRAUX(P), the auxiliary output from SQRDC.
4911: !
4912: !    Input, real(8) Y(N), a vector to be manipulated by SQRSL.
4913: !
4914: !    Output, real(8) QY(N), contains Q * Y, if requested.
4915: !
4916: !    Output, real(8) QTY(N), contains Q' * Y, if requested.
4917: !
4918: !    Output, real(8) B(K), the solution of the least squares problem
4919: !      minimize norm2 ( Y - AK * B),
4920: !    if its computation has been requested.  Note that if pivoting was 
4921: !    requested in SQRDC, the J-th component of B will be associated with 
4922: !    column JPVT(J) of the original matrix A that was input into SQRDC.
4923: !
4924: !    Output, real(8) RSD(N), the least squares residual Y - AK * B,
4925: !    if its computation has been requested.  RSD is also the orthogonal 
4926: !    projection of Y onto the orthogonal complement of the column space 
4927: !    of AK.
4928: !
4929: !    Output, real(8) AB(N), the least squares approximation Ak * B, if its 
4930: !    computation has been requested.  AB is also the orthogonal projection 
4931: !    of Y onto the column space of A.
4932: !
4933: !    Input, integer JOB, specifies what is to be computed.  JOB has
4934: !    the decimal expansion ABCDE, with the following meaning:
4935: !
4936: !      if A /= 0, compute QY.
4937: !      if B /= 0, compute QTY.
4938: !      if C /= 0, compute QTY and B.
4939: !      if D /= 0, compute QTY and RSD.
4940: !      if E /= 0, compute QTY and AB.
4941: !
4942: !    Note that a request to compute B, RSD, or AB automatically triggers 
4943: !    the computation of QTY, for which an array must be provided in the 
4944: !    calling sequence.
4945: !
4946: !    Output, integer INFO, is zero unless the computation of B has
4947: !    been requested and R is exactly singular.  In this case, INFO is the 
4948: !    index of the first zero diagonal element of R, and B is left unaltered.
4949: !
4950:   implicit none
4951: !
4952:   integer k
4953:   integer lda
4954:   integer n
4955: !
4956:   real(8) a(lda,*)
4957:   real(8) ab(n)
4958:   real(8) b(k)
4959:   logical cab
4960:   logical cb
4961:   logical cqty
4962:   logical cqy
4963:   logical cr
4964:   integer info
4965:   integer j
4966:   integer jj
4967:   integer job
4968:   integer ju
4969:   integer kp1
4970:   real(8) qraux(*)
4971:   real(8) qty(n)
4972:   real(8) qy(n)
4973:   real(8) rsd(n)
4974:   real(8) sdot
4975:   real(8) t
4976:   real(8) temp
4977:   real(8) y(n)
4978: !
4979: !  set info flag.
4980: !
4981:   info = 0
4982: !
4983: !  Determine what is to be computed.
4984: !
4985:   cqy =        job / 10000         /= 0
4986:   cqty = mod ( job,  10000 )       /= 0
4987:   cb =   mod ( job,   1000 ) / 100 /= 0
4988:   cr =   mod ( job,    100 ) /  10 /= 0
4989:   cab =  mod ( job,     10 )       /= 0
4990: 
4991:   ju = min ( k, n-1 )
4992: !
4993: !  Special action when N = 1.
4994: !
4995:   if ( ju == 0 ) then
4996: 
4997:     if ( cqy ) then
4998:       qy(1) = y(1)
4999:     end if
5000: 
5001:     if ( cqty ) then
5002:       qty(1) = y(1)
5003:     end if
5004: 
5005:     if ( cab ) then
5006:       ab(1) = y(1)
5007:      end if
5008: 
5009:     if ( cb ) then
5010: 
5011:       if ( a(1,1) == 0.0D+00 ) then
5012:         info = 1
5013:       else
5014:         b(1) = y(1) / a(1,1)
5015:       end if
5016: 
5017:     end if
5018: 
5019:     if ( cr ) then
5020:       rsd(1) = 0.0D+00
5021:     end if
5022: 
5023:     return
5024: 
5025:   end if
5026: !
5027: !  Set up to compute QY or QTY.
5028: !
5029:   if ( cqy ) then
5030:     qy(1:n) = y(1:n)
5031:   end if
5032: 
5033:   if ( cqty ) then
5034:     qty(1:n) = y(1:n)
5035:   end if
5036: !
5037: !  Compute QY.
5038: !
5039:   if ( cqy ) then
5040: 
5041:     do jj = 1, ju
5042: 
5043:       j = ju - jj + 1
5044: 
5045:       if ( qraux(j) /= 0.0D+00 ) then
5046:         temp = a(j,j)
5047:         a(j,j) = qraux(j)
5048:         t = - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( n-j+1, a(j,j), 1, qy(j), 1 ) / a(j,j)
5049:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-j+1, t, a(j,j), 1, qy(j), 1 )
5050:         a(j,j) = temp
5051:       end if
5052: 
5053:     end do
5054: 
5055:   end if
5056: !
5057: !  Compute Q'*Y.
5058: !
5059:      if ( cqty ) then
5060: 
5061:         do j = 1, ju
5062:            if ( qraux(j) /= 0.0D+00 ) then
5063:               temp = a(j,j)
5064:               a(j,j) = qraux(j)
5065:               t = - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( n-j+1, a(j,j), 1, qty(j), 1 ) / a(j,j)
5066:               call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-j+1, t, a(j,j), 1, qty(j), 1 )
5067:               a(j,j) = temp
5068:            end if
5069:         end do
5070: 
5071:      end if
5072: !
5073: !  Set up to compute B, RSD, or AB.
5074: !
5075:      if ( cb ) then
5076:        b(1:k) = qty(1:k)
5077:      end if
5078: 
5079:      kp1 = k + 1
5080: 
5081:      if ( cab ) then
5082:        ab(1:k) = qty(1:k)
5083:      end if
5084: 
5085:      if ( cr .and. k < n ) then
5086:        rsd(k+1:n) = qty(k+1:n)
5087:      end if
5088: 
5089:      if ( cab .and. k+1 <= n ) then
5090:        ab(k+1:n) = 0.0D+00
5091:      end if
5092: 
5093:      if ( cr ) then
5094:        rsd(1:k) = 0.0D+00
5095:      end if
5096: !
5097: !  Compute B.
5098: !
5099:      if ( cb ) then
5100: 
5101:         do jj = 1, k
5102: 
5103:           j = k - jj + 1
5104: 
5105:           if ( a(j,j) == 0.0D+00 ) then
5106:             info = j
5107:             exit
5108:           end if
5109: 
5110:           b(j) = b(j)/a(j,j)
5111: 
5112:           if ( j /= 1 ) then
5113:             t = -b(j)
5114:             call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j-1, t, a(1,j), 1, b, 1 )
5115:           end if
5116: 
5117:         end do
5118: 
5119:      end if
5120: 
5121:      if ( cr .or. cab ) then
5122: !
5123: !  Compute RSD or AB as required.
5124: !
5125:         do jj = 1, ju
5126: 
5127:            j = ju - jj + 1
5128: 
5129:            if ( qraux(j) /= 0.0D+00 ) then
5130: 
5131:               temp = a(j,j)
5132:               a(j,j) = qraux(j)
5133: 
5134:               if ( cr ) then
5135:                 t = - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( n-j+1, a(j,j), 1, rsd(j), 1 ) / a(j,j)
5136:                 call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-j+1, t, a(j,j), 1, rsd(j), 1 )
5137:               end if
5138: 
5139:               if ( cab ) then
5140:                 t = - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( n-j+1, a(j,j), 1, ab(j), 1 ) / a(j,j)
5141:                 call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-j+1, t, a(j,j), 1, ab(j), 1 )
5142:               end if
5143: 
5144:               a(j,j) = temp
5145: 
5146:            end if
5147: 
5148:         end do
5149: 
5150:   end if
5151: 
5152:   return
5153: end
<p><a name=srot><H3>srot</H3></a></p> Click <a href="./callingtree/srot_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where srot is used.
<hr>
5154: subroutine srot ( n, x, incx, y, incy, c, s )
5155: !
5156: !*******************************************************************************
5157: !
5158: !! SROT applies a plane rotation.
5159: !
5160: !
5161: !  Reference:
5162: !
5163: !    Lawson, Hanson, Kincaid, Krogh,
5164: !    Basic Linear Algebra Subprograms for Fortran Usage,
5165: !    Algorithm 539,
5166: !    ACM Transactions on Mathematical Software,
5167: !    Volume 5, Number 3, September 1979, pages 308-323.
5168: !
5169: !  Modified:
5170: !
5171: !    08 April 1999
5172: !
5173: !  Parameters:
5174: !
5175: !    Input, integer N, the number of entries in the vectors.
5176: !
5177: !    Input/output, real(8) X(*), one of the vectors to be rotated.
5178: !
5179: !    Input, integer INCX, the increment between successive entries of X.
5180: !
5181: !    Input/output, real(8) Y(*), one of the vectors to be rotated.
5182: !
5183: !    Input, integer INCY, the increment between successive elements of Y.
5184: !
5185: !    Input, real(8) C, S, parameters (presumably the cosine and sine of
5186: !    some angle) that define a plane rotation.
5187: !
5188:   implicit none
5189: !
5190:   real(8) c
5191:   integer i
5192:   integer incx
5193:   integer incy
5194:   integer ix
5195:   integer iy
5196:   integer n
5197:   real(8) s
5198:   real(8) stemp
5199:   real(8) x(*)
5200:   real(8) y(*)
5201: !
5202:   if ( n <= 0 ) then
5203: 
5204:   else if ( incx == 1 .and. incy == 1 ) then
5205: 
5206:     do i = 1, n
5207:       stemp = c * x(i) + s * y(i)
5208:       y(i) = c * y(i) - s * x(i)
5209:       x(i) = stemp
5210:     end do
5211: 
5212:   else
5213: 
5214:     if ( incx >= 0 ) then
5215:       ix = 1
5216:     else
5217:       ix = ( - n + 1 ) * incx + 1
5218:     end if
5219: 
5220:     if ( incy >= 0 ) then
5221:       iy = 1
5222:     else
5223:       iy = ( - n + 1 ) * incy + 1
5224:     end if
5225: 
5226:     do i = 1, n
5227:       stemp = c * x(ix) + s * y(iy)
5228:       y(iy) = c * y(iy) - s * x(ix)
5229:       x(ix) = stemp
5230:       ix = ix + incx
5231:       iy = iy + incy
5232:     end do
5233: 
5234:   end if
5235: 
5236:   return
5237: end
<p><a name=srotg><H3>srotg</H3></a></p> Click <a href="./callingtree/srotg_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where srotg is used.
<hr>
5238: subroutine srotg ( sa, sb, c, s )
5239: !
5240: !*******************************************************************************
5241: !
5242: !! SROTG constructs a Givens plane rotation.
5243: !
5244: !
5245: !  Reference:
5246: !
5247: !    Lawson, Hanson, Kincaid, Krogh,
5248: !    Basic Linear Algebra Subprograms for Fortran Usage,
5249: !    Algorithm 539,
5250: !    ACM Transactions on Mathematical Software,
5251: !    Volume 5, Number 3, September 1979, pages 308-323.
5252: !
5253: !  Modified:
5254: !
5255: !    08 April 1999
5256: !
5257: !  Parameters:
5258: !
5259: !    Input/output, real(8) SA, SB, ...
5260: !
5261: !    Output, real(8) C, S, ...
5262: !
5263:   implicit none
5264: !
5265:   real(8) c
5266:   real(8) r
5267:   real(8) roe
5268:   real(8) s
5269:   real(8) sa
5270:   real(8) sb
5271:   real(8) scale
5272:   real(8) z
5273: !
5274:   if ( abs ( sa ) > abs ( sb ) ) then
5275:     roe = sa
5276:   else
5277:     roe = sb
5278:   end if
5279: 
5280:   scale = abs ( sa ) + abs ( sb )
5281: 
5282:   if ( scale == 0.0D+00 ) then
5283:     c = 1.0D+00
5284:     s = 0.0D+00
5285:     r = 0.0D+00
5286:   else
5287:     r = scale * sqrt ( ( sa / scale )**2 + ( sb / scale )**2 )
5288:     r = sign ( 1.0D+00, roe ) * r
5289:     c = sa / r
5290:     s = sb / r
5291:   end if
5292: 
5293:   if ( abs ( c ) > 0.0D+00 .and. abs ( c ) <= s ) then
5294:     z = 1.0D+00 / c
5295:   else
5296:     z = s
5297:   end if
5298: 
5299:   sa = r
5300:   sb = z
5301: 
5302:   return
5303: end
<p><a name=sscal><H3>sscal</H3></a></p> Click <a href="./callingtree/sscal_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sscal is used.
<hr>
5304: subroutine sscal ( n, sa, x, incx )
5305: !
5306: !*******************************************************************************
5307: !
5308: !! SSCAL scales a vector by a constant.
5309: !
5310: !
5311: !  Reference:
5312: !
5313: !    Lawson, Hanson, Kincaid, Krogh,
5314: !    Basic Linear Algebra Subprograms for Fortran Usage,
5315: !    Algorithm 539,
5316: !    ACM Transactions on Mathematical Software,
5317: !    Volume 5, Number 3, September 1979, pages 308-323.
5318: !
5319: !  Modified:
5320: !
5321: !    08 April 1999
5322: !
5323: !  Parameters:
5324: !
5325: !    Input, integer N, the number of entries in the vector.
5326: !
5327: !    Input, real(8) SA, the multiplier.
5328: !
5329: !    Input/output, real(8) X(*), the vector to be scaled.
5330: !
5331: !    Input, integer INCX, the increment between successive entries of X.
5332: !
5333:   implicit none
5334: !
5335:   integer i
5336:   integer incx
5337:   integer ix
5338:   integer m
5339:   integer n
5340:   real(8) sa
5341:   real(8) x(*)
5342: !
5343:   if ( n <= 0 ) then
5344: 
5345:   else if ( incx == 1 ) then
5346: 
5347:     m = mod ( n, 5 )
5348: 
5349:     x(1:m) = sa * x(1:m)
5350: 
5351:     do i = m+1, n, 5
5352:       x(i)   = sa * x(i)
5353:       x(i+1) = sa * x(i+1)
5354:       x(i+2) = sa * x(i+2)
5355:       x(i+3) = sa * x(i+3)
5356:       x(i+4) = sa * x(i+4)
5357:     end do
5358: 
5359:   else
5360: 
5361:     if ( incx >= 0 ) then
5362:       ix = 1
5363:     else
5364:       ix = ( - n + 1 ) * incx + 1
5365:     end if
5366: 
5367:     do i = 1, n
5368:       x(ix) = sa * x(ix)
5369:       ix = ix + incx
5370:     end do
5371: 
5372:   end if
5373: 
5374:   return
5375: end
<p><a name=ssico><H3>ssico</H3></a></p> Click <a href="./callingtree/ssico_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ssico is used.
<hr>
5376: subroutine ssico ( a, lda, n, kpvt, rcond, z )
5377: !
5378: !*******************************************************************************
5379: !
5380: !! SSICO factors a real(8) symmetric matrix and estimates its condition.
5381: !
5382: !
5383: !  Discussion:
5384: !
5385: !    If RCOND is not needed, SSIFA is slightly faster.
5386: !
5387: !    To solve A*X = B, follow SSICO by SSISL.
5388: !
5389: !    To compute inverse(A)*C, follow SSICO by SSISL.
5390: !
5391: !    To compute inverse(A), follow SSICO by SSIDI.
5392: !
5393: !    To compute determinant(A), follow SSICO by SSIDI.
5394: !
5395: !    To compute inertia(A), follow SSICO by SSIDI.
5396: !
5397: !  Reference:
5398: !
5399: !    Dongarra, Moler, Bunch and Stewart,
5400: !    LINPACK User's Guide,
5401: !    SIAM, (Society for Industrial and Applied Mathematics),
5402: !    3600 University City Science Center,
5403: !    Philadelphia, PA, 19104-2688.
5404: !    ISBN 0-89871-172-X
5405: !
5406: !  Parameters:
5407: !
5408: !    Input/output, real(8) A(LDA,N).  On input, the symmetric matrix to be 
5409: !    factored.  Only the diagonal and upper triangle are used.
5410: !    On output, a block diagonal matrix and the multipliers which
5411: !    were used to obtain it.  The factorization can be written A = U*D*U'
5412: !    where U is a product of permutation and unit upper triangular 
5413: !    matrices, U' is the transpose of U, and D is block diagonal
5414: !    with 1 by 1 and 2 by 2 blocks.
5415: !
5416: !    Input, integer LDA, the leading dimension of the array A.
5417: !
5418: !    Input, integer N, the order of the matrix.
5419: !
5420: !    Output, integer KPVT(N), pivot indices.
5421: !
5422: !    Output, real(8) RCOND, an estimate of the reciprocal condition of A.
5423: !    For the system A*X = B, relative perturbations in A and B of size  
5424: !    EPSILON may cause relative perturbations in X of size EPSILON/RCOND.
5425: !    If RCOND is so small that the logical expression
5426: !      1.0D+00 + RCOND == 1.0D+00
5427: !    is true, then A may be singular to working precision.  In particular,  
5428: !    RCOND is zero if exact singularity is detected or the estimate underflows.
5429: !
5430: !    Output, real(8) Z(N), a work vector whose contents are usually unimportant.
5431: !    If A is close to a singular matrix, then Z is an approximate null vector 
5432: !    in the sense that
5433: !      norm(A*Z) = RCOND * norm(A) * norm(Z).
5434: !
5435:   implicit none
5436: !
5437:   integer lda
5438:   integer n
5439: !
5440:   real(8) a(lda,n)
5441:   real(8) ak
5442:   real(8) akm1
5443:   real(8) anorm
5444:   real(8) bk
5445:   real(8) bkm1
5446:   real(8) denom
5447:   real(8) ek
5448:   integer i
5449:   integer info
5450:   integer j
5451:   integer k
5452:   integer kp
5453:   integer kps
5454:   integer kpvt(n)
5455:   integer ks
5456:   real(8) rcond
5457:   real(8) s
5458:   real(8) sdot
5459:   real(8) ynorm
5460:   real(8) z(n)
5461: !
5462: !  Find the norm of A, using only entries in the upper half of the matrix.
5463: !
5464:   do j = 1, n
5465:     z(j) = sum ( abs ( a(1:j-1,j) ) )
5466:     do i = 1, j-1
5467:       z(i) = z(i) + abs ( a(i,j) )
5468:     end do
5469:   end do
5470: 
5471:   anorm = maxval ( z(1:n) )
5472: !
5473: !  Factor.
5474: !
5475:   call <a href="./linpack.f90.html#ssifa" TARGET=CENT_PANEL>ssifa</a> ( a, lda, n, kpvt, info )
5476: !
5477: !  RCOND = 1/(norm(A)*(estimate of norm(inverse(A)))).
5478: !
5479: !  Estimate = norm(Z)/norm(Y) where A*Z = Y and A*Y = E.
5480: !
5481: !  The components of E are chosen to cause maximum local
5482: !  growth in the elements of W where U*D*W = E.
5483: !
5484: !  The vectors are frequently rescaled to avoid overflow.
5485: !
5486: !  Solve U*D*W = E.
5487: !
5488:   ek = 1.0D+00
5489:   z(1:n) = 0.0D+00
5490:   k = n
5491: 
5492:   do while ( k /= 0 )
5493: 
5494:      if ( kpvt(k) < 0 ) then
5495:        ks = 2
5496:      else
5497:        ks = 1
5498:      end if
5499: 
5500:      kp = abs ( kpvt(k) )
5501:      kps = k + 1 - ks
5502: 
5503:      if ( kp /= kps ) then
5504:        call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( z(kps), z(kp) )
5505:      end if
5506: 
5507:      if ( z(k) /= 0.0D+00 ) then
5508:        ek = sign ( ek, z(k) )
5509:      end if
5510: 
5511:      z(k) = z(k) + ek
5512:      call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-ks, z(k), a(1,k), 1, z(1), 1 )
5513: 
5514:      if ( ks /= 1 ) then
5515:        if ( z(k-1) /= 0.0D+00 ) then
5516:          ek = sign ( ek, z(k-1) )
5517:        end if
5518:        z(k-1) = z(k-1) + ek
5519:        call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-ks, z(k-1), a(1,k-1), 1, z(1), 1 )
5520:      end if
5521: 
5522:      if ( ks /= 2 ) then
5523: 
5524:        if ( abs ( z(k) ) > abs ( a(k,k) ) ) then
5525:          s = abs ( a(k,k) ) / abs ( z(k) )
5526:          z(1:n) = s * z(1:n)
5527:          ek = s * ek
5528:        end if
5529: 
5530:        if ( a(k,k) /= 0.0D+00 ) then
5531:          z(k) = z(k) / a(k,k)
5532:        else
5533:          z(k) = 1.0D+00
5534:        end if
5535: 
5536:      else
5537: 
5538:        ak = a(k,k) / a(k-1,k)
5539:        akm1 = a(k-1,k-1) / a(k-1,k)
5540:        bk = z(k) / a(k-1,k)
5541:        bkm1 = z(k-1) / a(k-1,k)
5542:        denom = ak * akm1 - 1.0D+00
5543:        z(k) = ( akm1 * bk - bkm1 ) / denom
5544:        z(k-1) = ( ak * bkm1 - bk ) / denom
5545: 
5546:      end if
5547: 
5548:      k = k - ks
5549: 
5550:   end do
5551: 
5552:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
5553: !
5554: !  Solve U'*Y = W.
5555: !
5556:   k = 1
5557: 
5558:   do while ( k <= n ) 
5559: 
5560:      ks = 1
5561:      if ( kpvt(k) < 0 ) ks = 2
5562: 
5563:      if ( k /= 1 ) then
5564: 
5565:        z(k) = z(k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, a(1,k), 1, z(1), 1 )
5566: 
5567:        if ( ks == 2 ) then
5568:          z(k+1) = z(k+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, a(1,k+1), 1, z(1), 1 )
5569:        end if
5570: 
5571:        kp = abs ( kpvt(k) )
5572: 
5573:        if ( kp /= k ) then
5574:          call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( z(k), z(kp) )
5575:        end if
5576: 
5577:      end if
5578: 
5579:      k = k + ks
5580: 
5581:   end do
5582: 
5583:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
5584: 
5585:   ynorm = 1.0D+00
5586: !
5587: !  Solve U*D*V = Y.
5588: !
5589:   k = n
5590: 
5591:   do while ( k /= 0 ) 
5592: 
5593:      if ( kpvt(k) < 0 ) then
5594:        ks = 2
5595:      else
5596:        ks = 1
5597:      end if
5598: 
5599:      if ( k /= ks ) then
5600: 
5601:        kp = abs ( kpvt(k) )
5602:        kps = k + 1 - ks
5603: 
5604:        if ( kp /= kps ) then
5605:          call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( z(kps), z(kp) )
5606:        end if
5607: 
5608:        call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-ks, z(k), a(1,k), 1, z(1), 1 )
5609: 
5610:        if ( ks == 2 ) then
5611:          call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-ks, z(k-1), a(1,k-1), 1, z(1), 1 )
5612:        end if
5613: 
5614:      end if
5615: 
5616:      if ( ks /= 2 ) then
5617: 
5618:         if ( abs ( z(k) ) > abs ( a(k,k) ) ) then
5619:           s = abs ( a(k,k) ) / abs ( z(k) )
5620:           z(1:n) = s * z(1:n)
5621:           ynorm = s * ynorm
5622:         end if
5623: 
5624:         if ( a(k,k) /= 0.0D+00 ) then
5625:           z(k) = z(k) / a(k,k)
5626:         else
5627:           z(k) = 1.0D+00
5628:         end if
5629: 
5630:      else
5631: 
5632:         ak = a(k,k) / a(k-1,k)
5633:         akm1 = a(k-1,k-1) / a(k-1,k)
5634:         bk = z(k) / a(k-1,k)
5635:         bkm1 = z(k-1) / a(k-1,k)
5636:         denom = ak * akm1 - 1.0D+00
5637:         z(k) = ( akm1 * bk - bkm1 ) / denom
5638:         z(k-1) = ( ak * bkm1 - bk ) / denom
5639: 
5640:      end if
5641: 
5642:      k = k - ks
5643:   
5644:   end do
5645: 
5646:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
5647:   z(1:n) = s * z(1:n)
5648:   ynorm = s * ynorm
5649: !
5650: !  Solve U'*Z = V.
5651: !
5652:   k = 1
5653: 
5654:   do while ( k <= n ) 
5655: 
5656:      if ( kpvt(k) < 0 ) then
5657:        ks = 2
5658:      else
5659:        ks = 1
5660:      end if
5661: 
5662:      if ( k /= 1 ) then
5663: 
5664:         z(k) = z(k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, a(1,k), 1, z(1), 1 )
5665:         if ( ks == 2 ) then
5666:           z(k+1) = z(k+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, a(1,k+1), 1, z(1), 1 )
5667:         end if
5668:         kp = abs ( kpvt(k) )
5669: 
5670:         if ( kp /= k ) then
5671:           call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( z(k), z(kp) )
5672:         end if
5673: 
5674:      end if
5675: 
5676:      k = k + ks
5677: 
5678:   end do
5679: !
5680: !  Make ZNORM = 1.0.
5681: !
5682:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
5683:   z(1:n) = s * z(1:n)
5684:   ynorm = s * ynorm
5685: 
5686:   if ( anorm /= 0.0D+00 ) then
5687:     rcond = ynorm / anorm
5688:   else
5689:     rcond = 0.0D+00
5690:   end if
5691: 
5692:   return
5693: end
<p><a name=ssidi><H3>ssidi</H3></a></p> Click <a href="./callingtree/ssidi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ssidi is used.
<hr>
5694: subroutine ssidi ( a, lda, n, kpvt, det, inert, work, job )
5695: !
5696: !*******************************************************************************
5697: !
5698: !! SSIDI computes the determinant, inertia and inverse of a real(8) symmetric matrix.
5699: !
5700: !
5701: !  Discussion:
5702: !
5703: !    SSIDI uses the factors from SSIFA.
5704: !
5705: !    A division by zero may occur if the inverse is requested
5706: !    and SSICO has set RCOND == 0.0D+00 or SSIFA has set INFO /= 0.
5707: !
5708: !    Variables not requested by JOB are not used.
5709: !
5710: !  Reference:
5711: !
5712: !    Dongarra, Moler, Bunch and Stewart,
5713: !    LINPACK User's Guide,
5714: !    SIAM, (Society for Industrial and Applied Mathematics),
5715: !    3600 University City Science Center,
5716: !    Philadelphia, PA, 19104-2688.
5717: !    ISBN 0-89871-172-X
5718: !
5719: !  Parameters:
5720: !
5721: !    Input/output, real(8) A(LDA,N).  On input, the output from SSIFA.
5722: !    On output, the upper triangle of the inverse of the original matrix.  
5723: !    The strict lower triangle is never referenced.
5724: !
5725: !    Input, integer LDA, the leading dimension of the array A.
5726: !
5727: !    Input, integer N, the order of the matrix.
5728: !
5729: !    Input, integer KPVT(N), the pivot vector from SSIFA.
5730: !
5731: !    Output, real(8) DET(2), the determinant of the original matrix.
5732: !      determinant = DET(1) * 10.0**DET(2)
5733: !    with 1.0D+00 <= abs ( DET(1) ) < 10.0D+00 or DET(1) = 0.0.
5734: !
5735: !    Output, integer INERT(3), the inertia of the original matrix.
5736: !    INERT(1) = number of positive eigenvalues.
5737: !    INERT(2) = number of negative eigenvalues.
5738: !    INERT(3) = number of zero eigenvalues.
5739: !
5740: !    Workspace, real(8) WORK(N).
5741: !
5742: !    Input, integer JOB, specifies the tasks.
5743: !    JOB has the decimal expansion ABC where
5744: !    If C /= 0, the inverse is computed,
5745: !    If B /= 0, the determinant is computed,
5746: !    If A /= 0, the inertia is computed.
5747: !    For example, JOB = 111 gives all three.
5748: !
5749:   implicit none
5750: !
5751:   integer lda
5752:   integer n
5753: !
5754:   real(8) a(lda,n)
5755:   real(8) ak
5756:   real(8) akkp1
5757:   real(8) akp1
5758:   real(8) d
5759:   real(8) det(2)
5760:   logical dodet
5761:   logical doert
5762:   logical doinv
5763:   integer inert(3)
5764:   integer j
5765:   integer jb
5766:   integer job
5767:   integer k
5768:   integer kpvt(n)
5769:   integer ks
5770:   integer kstep
5771:   real(8) sdot
5772:   real(8) t
5773:   real, parameter :: ten = 10.0D+00
5774:   real(8) work(n)
5775: !
5776:   doinv = mod ( job,   10 )       /= 0
5777:   dodet = mod ( job,  100 ) /  10 /= 0
5778:   doert = mod ( job, 1000 ) / 100 /= 0
5779: 
5780:   if ( dodet .or. doert ) then
5781: 
5782:     if ( doert ) then
5783:       inert(1) = 0
5784:       inert(2) = 0
5785:       inert(3) = 0
5786:     end if
5787: 
5788:     if ( dodet ) then
5789:       det(1) = 1.0D+00
5790:       det(2) = 0.0D+00
5791:     end if
5792: 
5793:     t = 0.0D+00
5794: 
5795:     do k = 1, n
5796: 
5797:       d = a(k,k)
5798: !
5799: !  2 by 2 block.
5800: !
5801: !  use det (d  s)  =  (d/t * c - t) * t,  t = abs ( s )
5802: !          (s  c)
5803: !  to avoid underflow/overflow troubles.
5804: !
5805: !  Take two passes through scaling.  Use T for flag.
5806: !
5807:       if ( kpvt(k) <= 0 ) then
5808: 
5809:         if ( t == 0.0D+00 ) then
5810:           t = abs ( a(k,k+1) )
5811:           d = ( d / t ) * a(k+1,k+1) - t
5812:         else
5813:           d = t
5814:           t = 0.0D+00
5815:         end if
5816: 
5817:       end if
5818: 
5819:       if ( doert ) then
5820:         if ( d > 0.0D+00 ) then
5821:           inert(1) = inert(1) + 1
5822:         else if ( d < 0.0D+00 ) then
5823:           inert(2) = inert(2) + 1
5824:         else if ( d == 0.0D+00 ) then
5825:           inert(3) = inert(3) + 1
5826:         end if
5827:       end if
5828: 
5829:       if ( dodet ) then
5830: 
5831:         det(1) = d * det(1)
5832: 
5833:         if ( det(1) /= 0.0D+00 ) then
5834: 
5835:           do while ( abs ( det(1) ) < 1.0D+00 ) 
5836:             det(1) = ten * det(1)
5837:             det(2) = det(2) - 1.0D+00
5838:           end do
5839: 
5840:           do while ( abs ( det(1) ) >= ten )
5841:             det(1) = det(1) / ten
5842:             det(2) = det(2) + 1.0D+00
5843:           end do
5844: 
5845:         end if
5846: 
5847:       end if
5848: 
5849:     end do
5850: 
5851:   end if
5852: !
5853: !  Compute inverse(A).
5854: !
5855:   if ( doinv ) then
5856: 
5857:      k = 1
5858: 
5859:      do while ( k <= n )
5860: 
5861:         if ( kpvt(k) >= 0 ) then
5862: !
5863: !  1 by 1.
5864: !
5865:            a(k,k) = 1.0D+00 / a(k,k)
5866: 
5867:            if ( k >= 2 ) then
5868: 
5869:               work(1:k-1) = a(1:k-1,k)
5870: 
5871:               do j = 1, k-1
5872:                 a(j,k) = <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( j, a(1,j), 1, work, 1 )
5873:                 call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j-1, work(j), a(1,j), 1, a(1,k), 1 )
5874:               end do
5875: 
5876:               a(k,k) = a(k,k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, work, 1, a(1,k), 1 )
5877: 
5878:            end if
5879: 
5880:            kstep = 1
5881: !
5882: !  2 by 2.
5883: !
5884:         else
5885: 
5886:            t = abs ( a(k,k+1) )
5887:            ak = a(k,k) / t
5888:            akp1 = a(k+1,k+1) / t
5889:            akkp1 = a(k,k+1) / t
5890:            d = t * ( ak * akp1 - 1.0D+00 )
5891:            a(k,k) = akp1 / d
5892:            a(k+1,k+1) = ak / d
5893:            a(k,k+1) = - akkp1 / d
5894: 
5895:            if ( k >= 2 ) then
5896: 
5897:               call <a href="./linpack.f90.html#scopy" TARGET=CENT_PANEL>scopy</a> ( k-1, a(1,k+1), 1, work, 1 )
5898: 
5899:               do j = 1, k-1
5900:                  a(j,k+1) = <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( j, a(1,j), 1, work, 1 )
5901:                  call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j-1, work(j), a(1,j), 1, a(1,k+1), 1 )
5902:               end do
5903: 
5904:               a(k+1,k+1) = a(k+1,k+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, work, 1, a(1,k+1), 1 )
5905:               a(k,k+1) = a(k,k+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, a(1,k), 1, a(1,k+1), 1 )
5906:               call <a href="./linpack.f90.html#scopy" TARGET=CENT_PANEL>scopy</a> ( k-1, a(1,k), 1, work, 1 )
5907: 
5908:               do j = 1, k-1
5909:                  a(j,k) = <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( j, a(1,j), 1, work, 1 )
5910:                  call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j-1, work(j), a(1,j), 1, a(1,k), 1 )
5911:               end do
5912: 
5913:               a(k,k) = a(k,k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, work, 1, a(1,k), 1 )
5914: 
5915:            end if
5916: 
5917:            kstep = 2
5918: 
5919:         end if
5920: !
5921: !  Swap.
5922: !
5923:         ks = abs ( kpvt(k) )
5924: 
5925:         if ( ks /= k ) then
5926: 
5927:            call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( ks, a(1,ks), 1, a(1,k), 1 )
5928: 
5929:            do jb = ks, k
5930:              j = k + ks - jb
5931:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(j,k), a(ks,j) )
5932:            end do
5933: 
5934:            if ( kstep /= 1 ) then
5935:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(ks,k+1), a(k,k+1) )
5936:            end if
5937: 
5938:         end if
5939: 
5940:         k = k + kstep
5941: 
5942:     end do
5943: 
5944:   end if
5945: 
5946:   return
5947: end
<p><a name=ssifa><H3>ssifa</H3></a></p> Click <a href="./callingtree/ssifa_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ssifa is used.
<hr>
5948: subroutine ssifa ( a, lda, n, kpvt, info )
5949: !
5950: !*******************************************************************************
5951: !
5952: !! SSIFA factors a real(8) symmetric matrix.
5953: !
5954: !
5955: !  Discussion:
5956: !
5957: !     To solve A*X = B, follow SSIFA by SSISL.
5958: !
5959: !     To compute inverse(A)*C, follow SSIFA by SSISL.
5960: !
5961: !     To compute determinant(A), follow SSIFA by SSIDI.
5962: !
5963: !     To compute inertia(A), follow SSIFA by SSIDI.
5964: !
5965: !     To compute inverse(A), follow SSIFA by SSIDI.
5966: !
5967: !  Reference:
5968: !
5969: !    Dongarra, Moler, Bunch and Stewart,
5970: !    LINPACK User's Guide,
5971: !    SIAM, (Society for Industrial and Applied Mathematics),
5972: !    3600 University City Science Center,
5973: !    Philadelphia, PA, 19104-2688.
5974: !    ISBN 0-89871-172-X
5975: !
5976: !  Parameters:
5977: !
5978: !    Input/output, real(8) A(LDA,N).  On input, the symmetric matrix to be 
5979: !    factored.  Only the diagonal and upper triangle are used.
5980: !    On output, a block diagonal matrix and the multipliers which
5981: !    were used to obtain it.  The factorization can be written A = U*D*U'
5982: !    where U is a product of permutation and unit upper triangular 
5983: !    matrices, U' is the transpose of U, and D is block diagonal
5984: !    with 1 by 1 and 2 by 2 blocks.
5985: !
5986: !    Input, integer LDA, the leading dimension of the array A.
5987: !
5988: !    Input, integer N, the order of the matrix.
5989: !
5990: !    Output, integer KPVT(N), the pivot indices.
5991: !
5992: !    Output, integer INFO, error flag.
5993: !    0, normal value.
5994: !    K, if the K-th pivot block is singular.  This is not an error 
5995: !    condition for this subroutine, but it does indicate that SSISL
5996: !    or SSIDI may divide by zero if called.
5997: !
5998:   implicit none
5999: !
6000:   integer lda
6001:   integer n
6002: !
6003:   real(8) a(lda,n)
6004:   real(8) absakk
6005:   real(8) ak
6006:   real(8) akm1
6007:   real(8) alpha
6008:   real(8) bk
6009:   real(8) bkm1
6010:   real(8) colmax
6011:   real(8) denom
6012:   integer imax
6013:   integer imaxp1
6014:   integer info
6015:   integer <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a>
6016:   integer j
6017:   integer jj
6018:   integer jmax
6019:   integer k
6020:   integer km1
6021:   integer kpvt(n)
6022:   integer kstep
6023:   real(8) mulk
6024:   real(8) mulkm1
6025:   real(8) rowmax
6026:   logical swap
6027:   real(8) t
6028: !
6029: !  ALPHA is used in choosing pivot block size.
6030: !
6031:   alpha = ( 1.0D+00 + sqrt ( 17.0D+00 ) ) / 8.0D+00
6032: 
6033:   info = 0
6034: !
6035: !  Main loop on K, which goes from N to 1.
6036: !
6037:   k = n
6038: 
6039:   do while ( k > 0 )
6040: 
6041:     if ( k == 1 ) then
6042:       kpvt(1) = 1
6043:       if ( a(1,1) == 0.0D+00 ) then
6044:         info = 1
6045:       end if
6046:       return
6047:     end if
6048: !
6049: !  This section of code determines the kind of
6050: !  elimination to be performed.  When it is completed,
6051: !  KSTEP will be set to the size of the pivot block, and
6052: !  SWAP will be set to .true. if an interchange is required.
6053: !
6054:      km1 = k - 1
6055:      absakk = abs ( a(k,k) )
6056: !
6057: !  Determine the largest off-diagonal element in column K.
6058: !
6059:      imax = <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> ( k-1, a(1,k), 1 )
6060:      colmax = abs ( a(imax,k) )
6061: 
6062:      if ( absakk >= alpha * colmax ) then
6063:        kstep = 1
6064:        swap = .false.
6065:      else
6066: !
6067: !  Determine the largest off-diagonal element in row IMAX.
6068: !
6069:         rowmax = 0.0D+00
6070:         imaxp1 = imax + 1
6071: 
6072:         do j = imaxp1, k
6073:           rowmax = max ( rowmax, abs ( a(imax,j) ) )
6074:         end do
6075: 
6076:         if ( imax /= 1 ) then
6077:           jmax = <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> ( imax-1, a(1,imax), 1 )
6078:           rowmax = max ( rowmax, abs ( a(jmax,imax) ) )
6079:         end if
6080: 
6081:         if ( abs ( a(imax,imax) ) >= alpha * rowmax ) then
6082:           kstep = 1
6083:           swap = .true.
6084:         else if ( absakk >= alpha * colmax * ( colmax / rowmax ) ) then
6085:           kstep = 1
6086:           swap = .false.
6087:         else
6088:           kstep = 2
6089:           swap = ( imax /= k-1 )
6090:         end if
6091: 
6092:      end if
6093: !
6094: !  Column K is zero.  
6095: !  Set INFO and iterate the loop.
6096: !
6097:      if ( max ( absakk, colmax ) == 0.0D+00 ) then
6098: 
6099:         kpvt(k) = k
6100:         info = k
6101: !
6102: !  1 x 1 pivot block.
6103: !
6104: !  Perform an interchange.
6105: !
6106:      else if ( kstep /= 2 ) then
6107: 
6108:         if ( swap ) then
6109: 
6110:            call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( imax, a(1,imax), 1, a(1,k), 1 )
6111: 
6112:            do jj = imax, k
6113:              j = k + imax - jj
6114:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(j,k), a(imax,j) )
6115:            end do
6116: 
6117:         end if
6118: !
6119: !  Perform the elimination.
6120: !
6121:         do jj = 1, k-1
6122:           j = k - jj
6123:           mulk = - a(j,k) / a(k,k)
6124:           t = mulk
6125:           call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j, t, a(1,k), 1, a(1,j), 1 )
6126:           a(j,k) = mulk
6127:         end do
6128: !
6129: !  Set the pivot array.
6130: !
6131:         if ( swap ) then
6132:           kpvt(k) = imax
6133:         else
6134:           kpvt(k) = k
6135:         end if
6136: !
6137: !  2 x 2 pivot block.
6138: !
6139: !  Perform an interchange.
6140: !
6141:      else
6142: 
6143:         if ( swap ) then
6144: 
6145:            call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( imax, a(1,imax), 1, a(1,k-1), 1 )
6146: 
6147:            do jj = imax, k-1
6148:              j = k-1 + imax - jj
6149:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( a(j,k-1), a(imax,j) )
6150:            end do
6151: 
6152:            t = a(k-1,k)
6153:            a(k-1,k) = a(imax,k)
6154:            a(imax,k) = t
6155:   
6156:         end if
6157: !
6158: !  Perform the elimination.
6159: !
6160:         if ( k-2 /= 0 ) then
6161: 
6162:            ak = a(k,k) / a(k-1,k)
6163:            akm1 = a(k-1,k-1) / a(k-1,k)
6164:            denom = 1.0D+00 - ak * akm1
6165: 
6166:            do jj = 1, k-2
6167: 
6168:               j = k-1 - jj
6169:               bk = a(j,k) / a(k-1,k)
6170:               bkm1 = a(j,k-1) / a(k-1,k)
6171:               mulk = ( akm1 * bk - bkm1 ) / denom
6172:               mulkm1 = ( ak * bkm1 - bk ) / denom
6173:               t = mulk
6174:               call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j, t, a(1,k), 1, a(1,j), 1 )
6175:               t = mulkm1
6176:               call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j, t, a(1,k-1), 1, a(1,j), 1 )
6177:               a(j,k) = mulk
6178:               a(j,k-1) = mulkm1
6179: 
6180:            end do
6181: 
6182:         end if
6183: !
6184: !  Set the pivot array.
6185: !
6186:         if ( swap ) then
6187:           kpvt(k) = -imax
6188:         else
6189:           kpvt(k) = 1 - k
6190:         end if
6191: 
6192:         kpvt(k-1) = kpvt(k)
6193: 
6194:      end if
6195: 
6196:      k = k - kstep
6197: 
6198:   end do
6199: 
6200:   return
6201: end
<p><a name=ssisl><H3>ssisl</H3></a></p> Click <a href="./callingtree/ssisl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ssisl is used.
<hr>
6202: subroutine ssisl ( a, lda, n, kpvt, b )
6203: !
6204: !*******************************************************************************
6205: !
6206: !! SSISL solves a real(8) symmetric system factored by SSIFA.
6207: !
6208: !
6209: !  Discussion:
6210: !
6211: !    To compute inverse(A) * C where C is a matrix with P columns
6212: !
6213: !      call ssifa ( a, lda, n, kpvt, info )
6214: !
6215: !      if ( info == 0 ) then
6216: !        do j = 1, p
6217: !          call ssisl ( a, lda, n, kpvt, c(1,j) )
6218: !        end do
6219: !      end if
6220: !
6221: !    A division by zero may occur if the inverse is requested
6222: !    and SSICO has set RCOND == 0.0D+00 or SSIFA has set INFO /= 0.
6223: !
6224: !  Reference:
6225: !
6226: !    Dongarra, Moler, Bunch and Stewart,
6227: !    LINPACK User's Guide,
6228: !    SIAM, (Society for Industrial and Applied Mathematics),
6229: !    3600 University City Science Center,
6230: !    Philadelphia, PA, 19104-2688.
6231: !    ISBN 0-89871-172-X
6232: !
6233: !  Parameters:
6234: !
6235: !    Input, real(8) A(LDA,N), the output from SSIFA.
6236: !
6237: !    Input, integer LDA, the leading dimension of the array A.
6238: !
6239: !    Input, integer N, the order of the matrix.
6240: !
6241: !    Input, integer KPVT(N), the pivot vector from SSIFA.
6242: !
6243: !    Input/output, real(8) B(N).  On input, the right hand side.
6244: !    On output, the solution.
6245: !
6246:   implicit none
6247: !
6248:   integer lda
6249:   integer n
6250: !
6251:   real(8) a(lda,n)
6252:   real(8) ak
6253:   real(8) akm1
6254:   real(8) b(n)
6255:   real(8) bk
6256:   real(8) bkm1
6257:   real(8) denom
6258:   integer k
6259:   integer kp
6260:   integer kpvt(n)
6261:   real(8) sdot
6262: !
6263: !  Loop backward applying the transformations and D inverse to B.
6264: !
6265:   k = n
6266: 
6267:   do while ( k > 0 )
6268: 
6269:      if ( kpvt(k) >= 0 ) then
6270: !
6271: !  1 x 1 pivot block.
6272: !
6273:         if ( k /= 1 ) then
6274: 
6275:            kp = kpvt(k)
6276: !
6277: !  Interchange.
6278: !
6279:            if ( kp /= k ) then
6280:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k), b(kp) )
6281:            end if
6282: !
6283: !  Apply the transformation.
6284: !
6285:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, b(k), a(1,k), 1, b(1), 1 )
6286: 
6287:         end if
6288: !
6289: !  Apply D inverse.
6290: !
6291:         b(k) = b(k)/a(k,k)
6292:         k = k - 1
6293: 
6294:      else
6295: !
6296: !  2 x 2 pivot block.
6297: !
6298:         if ( k /= 2 ) then
6299: 
6300:            kp = abs (kpvt(k))
6301: !
6302: !  Interchange.
6303: !
6304:            if ( kp /= k-1 ) then
6305:               call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k-1), b(kp) )
6306:            end if
6307: !
6308: !  Apply the transformation.
6309: !
6310:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-2, b(k), a(1,k), 1, b(1), 1 )
6311:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-2, b(k-1), a(1,k-1), 1, b(1), 1 )
6312:    
6313:         end if
6314: !
6315: !  Apply D inverse.
6316: !
6317:         ak = a(k,k) / a(k-1,k)
6318:         akm1 = a(k-1,k-1) / a(k-1,k)
6319:         bk = b(k) / a(k-1,k)
6320:         bkm1 = b(k-1) / a(k-1,k)
6321:         denom = ak * akm1 - 1.0D+00
6322:         b(k) = ( akm1 * bk - bkm1 ) / denom
6323:         b(k-1) = ( ak * bkm1 - bk ) / denom
6324:         k = k - 2
6325: 
6326:     end if
6327: 
6328:   end do
6329: !
6330: !  Loop forward applying the transformations.
6331: !
6332:   k = 1
6333: 
6334:   do while ( k <= n )
6335: 
6336:      if ( kpvt(k) >= 0 ) then
6337: !
6338: !  1 x 1 pivot block.
6339: !
6340:         if ( k /= 1 ) then
6341: !
6342: !  Apply the transformation.
6343: !
6344:            b(k) = b(k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, a(1,k), 1, b(1), 1 )
6345:            kp = kpvt(k)
6346: !
6347: !  Interchange.
6348: !
6349:            if ( kp /= k ) then
6350:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k), b(kp) )
6351:            end if
6352: 
6353:         end if
6354: 
6355:         k = k + 1
6356: 
6357:      else
6358: !
6359: !  2 x 2 pivot block.
6360: !
6361:         if ( k /= 1 ) then
6362: !
6363: !  Apply the transformation.
6364: !
6365:            b(k) = b(k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, a(1,k), 1, b(1), 1 )
6366:            b(k+1) = b(k+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, a(1,k+1), 1, b(1), 1 )
6367:            kp = abs (kpvt(k))
6368: !
6369: !  Interchange.
6370: !
6371:            if ( kp /= k ) then
6372:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k), b(kp) )
6373:            end if
6374: 
6375:         end if
6376: 
6377:         k = k + 2
6378: 
6379:     end if
6380: 
6381:   end do
6382: 
6383:   return
6384: end
<p><a name=sspco><H3>sspco</H3></a></p> Click <a href="./callingtree/sspco_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sspco is used.
<hr>
6385: subroutine sspco ( ap, n, kpvt, rcond, z )
6386: !
6387: !*******************************************************************************
6388: !
6389: !! SSPCO factors a real(8) symmetric matrix stored in packed form.
6390: !
6391: !
6392: !  Discussion:
6393: !
6394: !    SSPCO uses elimination with symmetric pivoting and estimates
6395: !    the condition of the matrix.
6396: !
6397: !    If RCOND is not needed, SSPFA is slightly faster.
6398: !
6399: !    To solve A*X = B, follow SSPCO by SSPSL.
6400: !
6401: !    To compute inverse(A)*C, follow SSPCO by SSPSL.
6402: !
6403: !    To compute inverse(A), follow SSPCO by SSPDI.
6404: !
6405: !    To compute determinant(A), follow SSPCO by SSPDI.
6406: !
6407: !    To compute inertia(A), follow SSPCO by SSPDI.
6408: !
6409: !  Packed storage:
6410: !
6411: !    The following program segment will pack the upper triangle of a 
6412: !    symmetric matrix.
6413: !
6414: !      k = 0
6415: !      do j = 1, n
6416: !        do i = 1, j
6417: !          k = k + 1
6418: !          ap(k) = a(i,j)
6419: !        end do
6420: !      end do
6421: !
6422: !  Reference:
6423: !
6424: !    Dongarra, Moler, Bunch and Stewart,
6425: !    LINPACK User's Guide,
6426: !    SIAM, (Society for Industrial and Applied Mathematics),
6427: !    3600 University City Science Center,
6428: !    Philadelphia, PA, 19104-2688.
6429: !    ISBN 0-89871-172-X
6430: !
6431: !  Parameters:
6432: !
6433: !    Input/output, real(8) AP(N*(N+1)/2).  On input, the packed form of a 
6434: !    symmetric matrix A.  The columns of the upper triangle are stored 
6435: !    sequentially in a one-dimensional array.  On output, a block diagonal 
6436: !    matrix and the multipliers which were used to obtain it, stored in 
6437: !    packed form.  The factorization can be written A = U*D*U'
6438: !    where U is a product of permutation and unit upper triangular 
6439: !    matrices, U' is the transpose of U, and D is block diagonal
6440: !    with 1 by 1 and 2 by 2 blocks.
6441: !
6442: !    Input, integer N, the order of the matrix.
6443: !
6444: !    Output, integer KPVT(N), the pivot indices.
6445: !
6446: !    Output, real(8) RCOND, an estimate of the reciprocal condition of A.
6447: !    For the system A*X = B, relative perturbations in A and B of size  
6448: !    EPSILON may cause relative perturbations in X of size EPSILON/RCOND.
6449: !    If RCOND is so small that the logical expression
6450: !      1.0D+00 + RCOND == 1.0D+00
6451: !    is true, then A may be singular to working precision.  In particular,  
6452: !    RCOND is zero if exact singularity is detected or the estimate underflows.
6453: !
6454: !    Output, real(8) Z(N) a work vector whose contents are usually unimportant.
6455: !    If A is close to a singular matrix, then Z is an approximate null 
6456: !    vector in the sense that
6457: !      norm(A*Z) = RCOND * norm(A) * norm(Z).
6458: !
6459:   implicit none
6460: !
6461:   integer n
6462: !
6463:   real(8) ak
6464:   real(8) akm1
6465:   real(8) anorm
6466:   real(8) ap((n*(n+1))/2)
6467:   real(8) bk
6468:   real(8) bkm1
6469:   real(8) denom
6470:   real(8) ek
6471:   integer i
6472:   integer ij
6473:   integer ik
6474:   integer ikm1
6475:   integer ikp1
6476:   integer info
6477:   integer j
6478:   integer j1
6479:   integer k
6480:   integer kk
6481:   integer km1k
6482:   integer km1km1
6483:   integer kp
6484:   integer kps
6485:   integer kpvt(n)
6486:   integer ks
6487:   real(8) rcond
6488:   real(8) s
6489:   real(8) sdot
6490:   real(8) t
6491:   real(8) ynorm
6492:   real(8) z(n)
6493: !
6494: !  Find norm of A using only upper half.
6495: !
6496:   j1 = 1
6497:   do j = 1, n
6498:     z(j) = sum ( abs ( ap(j1:j1+j-1) ) )
6499:     ij = j1
6500:     j1 = j1 + j
6501:     do i = 1, j-1
6502:       z(i) = z(i) + abs ( ap(ij) )
6503:       ij = ij + 1
6504:     end do
6505:   end do
6506: 
6507:   anorm = maxval ( z(1:n) )
6508: !
6509: !  Factor.
6510: !
6511:   call <a href="./linpack.f90.html#sspfa" TARGET=CENT_PANEL>sspfa</a> ( ap, n, kpvt, info )
6512: !
6513: !  RCOND = 1/(norm(A)*(estimate of norm(inverse(A)))).
6514: !
6515: !  Estimate = norm(Z)/norm(Y) where A*Z = Y and A*Y = E.
6516: !
6517: !  The components of E are chosen to cause maximum local
6518: !  growth in the elements of W where U*D*W = E.
6519: !
6520: !  The vectors are frequently rescaled to avoid overflow.
6521: !
6522: !  Solve U*D*W = E.
6523: !
6524:   ek = 1.0D+00
6525:   z(1:n) = 0.0D+00
6526: 
6527:   k = n
6528:   ik = (n*(n - 1))/2
6529: 
6530:   do while ( k /= 0 ) 
6531: 
6532:      kk = ik + k
6533:      ikm1 = ik - (k - 1)
6534:      ks = 1
6535:      if ( kpvt(k) < 0 ) ks = 2
6536:      kp = abs (kpvt(k))
6537:      kps = k + 1 - ks
6538: 
6539:      if ( kp /= kps ) then
6540:         t = z(kps)
6541:         z(kps) = z(kp)
6542:         z(kp) = t
6543:      end if
6544: 
6545:      if ( z(k) /= 0.0D+00 ) then
6546:        ek = sign ( ek, z(k) )
6547:      end if
6548: 
6549:      z(k) = z(k) + ek
6550:      call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-ks, z(k), ap(ik+1), 1, z(1), 1 )
6551: 
6552:      if ( ks /= 1 ) then
6553:         if ( z(k-1) /= 0.0D+00 ) then
6554:           ek = sign ( ek, z(k-1) )
6555:         end if
6556:         z(k-1) = z(k-1) + ek
6557:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-ks, z(k-1), ap(ikm1+1), 1, z(1), 1 )
6558:      end if
6559: 
6560:      if ( ks /= 2 ) then
6561: 
6562:         if ( abs ( z(k) ) > abs ( ap(kk) ) ) then
6563:            s = abs ( ap(kk) ) / abs ( z(k) )
6564:            z(1:n) = s * z(1:n)
6565:            ek = s * ek
6566:         end if
6567: 
6568:         if ( ap(kk) /= 0.0D+00 ) then
6569:           z(k) = z(k) / ap(kk)
6570:         else
6571:           z(k) = 1.0D+00
6572:         end if
6573: 
6574:      else
6575: 
6576:         km1k = ik + k - 1
6577:         km1km1 = ikm1 + k - 1
6578:         ak = ap(kk) / ap(km1k)
6579:         akm1 = ap(km1km1) / ap(km1k)
6580:         bk = z(k) / ap(km1k)
6581:         bkm1 = z(k-1) / ap(km1k)
6582:         denom = ak * akm1 - 1.0D+00
6583:         z(k) = ( akm1 * bk - bkm1 ) / denom
6584:         z(k-1) = ( ak * bkm1 - bk ) / denom
6585: 
6586:      end if
6587: 
6588:      k = k - ks
6589:      ik = ik - k
6590:      if ( ks == 2 ) then
6591:        ik = ik - (k + 1)
6592:      end if
6593:   
6594:   end do
6595: 
6596:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
6597: !
6598: !  Solve U'*Y = W.
6599: !
6600:   k = 1
6601:   ik = 0
6602: 
6603:   do while ( k <= n ) 
6604: 
6605:      if ( kpvt(k) < 0 ) then
6606:        ks = 2
6607:      else
6608:        ks = 1
6609:      end if
6610: 
6611:      if ( k /= 1 ) then
6612: 
6613:         z(k) = z(k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(ik+1), 1, z(1), 1 )
6614:         ikp1 = ik + k
6615: 
6616:         if ( ks == 2 ) then
6617:           z(k+1) = z(k+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(ikp1+1), 1, z(1), 1 )
6618:         end if
6619: 
6620:         kp = abs (kpvt(k))
6621: 
6622:         if ( kp /= k ) then
6623:            t = z(k)
6624:            z(k) = z(kp)
6625:            z(kp) = t
6626:         end if
6627: 
6628:      end if
6629: 
6630:      ik = ik + k
6631:      if ( ks == 2 ) ik = ik + (k + 1)
6632:      k = k + ks
6633:   
6634:   end do
6635: 
6636:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
6637:   z(1:n) = s * z(1:n)
6638:   ynorm = 1.0D+00
6639: !
6640: !  Solve U*D*V = Y.
6641: !
6642:   k = n
6643: 
6644:   ik = n * ( n - 1 ) / 2
6645: 
6646:   do while ( k > 0 )
6647: 
6648:      kk = ik + k
6649:      ikm1 = ik - (k - 1)
6650: 
6651:      if ( kpvt(k) < 0 ) then
6652:        ks = 2
6653:      else
6654:        ks = 1
6655:      end if
6656: 
6657:      if ( k /= ks ) then
6658: 
6659:         kp = abs ( kpvt(k) )
6660:         kps = k + 1 - ks
6661: 
6662:         if ( kp /= kps ) then
6663:            t = z(kps)
6664:            z(kps) = z(kp)
6665:            z(kp) = t
6666:         end if
6667: 
6668:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-ks, z(k), ap(ik+1), 1, z(1), 1 )
6669: 
6670:         if ( ks == 2 ) then
6671:           call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-ks, z(k-1), ap(ikm1+1), 1, z(1), 1 )
6672:         end if
6673: 
6674:      end if
6675: 
6676:      if ( ks /= 2 ) then
6677: 
6678:         if ( abs ( z(k) ) > abs ( ap(kk) ) ) then
6679:            s = abs ( ap(kk) ) / abs ( z(k) )
6680:            z(1:n) = s * z(1:n)
6681:            ynorm = s * ynorm
6682:         end if
6683: 
6684:         if ( ap(kk) /= 0.0D+00 ) then
6685:           z(k) = z(k) / ap(kk)
6686:         else
6687:           z(k) = 1.0D+00
6688:         end if
6689: 
6690:      else
6691: 
6692:         km1k = ik + k - 1
6693:         km1km1 = ikm1 + k - 1
6694:         ak = ap(kk) / ap(km1k)
6695:         akm1 = ap(km1km1) / ap(km1k)
6696:         bk = z(k) / ap(km1k)
6697:         bkm1 = z(k-1) / ap(km1k)
6698:         denom = ak * akm1 - 1.0D+00
6699:         z(k) = ( akm1 * bk - bkm1 ) / denom
6700:         z(k-1) = ( ak * bkm1 - bk ) / denom
6701: 
6702:      end if
6703: 
6704:      k = k - ks
6705:      ik = ik - k
6706:      if ( ks == 2 ) ik = ik - (k + 1)
6707: 
6708:   end do
6709: 
6710:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
6711:   z(1:n) = s * z(1:n)
6712:   ynorm = s * ynorm
6713: !
6714: !  Solve U'*Z = V.
6715: !
6716:   k = 1
6717:   ik = 0
6718: 
6719:   do while ( k <= n )
6720: 
6721:      ks = 1
6722:      if ( kpvt(k) < 0 ) ks = 2
6723: 
6724:      if ( k /= 1 ) then
6725: 
6726:         z(k) = z(k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(ik+1), 1, z(1), 1 )
6727:         ikp1 = ik + k
6728: 
6729:         if ( ks == 2 ) then
6730:           z(k+1) = z(k+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(ikp1+1), 1, z(1), 1 )
6731:         end if
6732: 
6733:         kp = abs ( kpvt(k) )
6734: 
6735:         if ( kp /= k ) then
6736:            t = z(k)
6737:            z(k) = z(kp)
6738:            z(kp) = t
6739:         end if
6740: 
6741:      end if
6742: 
6743:      ik = ik + k
6744:      if ( ks == 2 ) ik = ik + (k + 1)
6745:      k = k + ks
6746: 
6747:   end do
6748: !
6749: !  Make ZNORM = 1.0.
6750: !
6751:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
6752:   z(1:n) = s * z(1:n)
6753:   ynorm = s * ynorm
6754: 
6755:   if ( anorm /= 0.0D+00 ) then
6756:     rcond = ynorm / anorm
6757:   else
6758:     rcond = 0.0D+00
6759:   end if
6760: 
6761:   return
6762: end
<p><a name=sspdi><H3>sspdi</H3></a></p> Click <a href="./callingtree/sspdi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sspdi is used.
<hr>
6763: subroutine sspdi ( ap, n, kpvt, det, inert, work, job )
6764: !
6765: !*******************************************************************************
6766: !
6767: !! SSPDI computes the determinant, inertia and inverse of a real(8) symmetric matrix.
6768: !
6769: !
6770: !  Discussion:
6771: !
6772: !    SSPDI uses the factors from SSPFA, where the matrix is stored in 
6773: !    packed form.
6774: !
6775: !    A division by zero will occur if the inverse is requested
6776: !    and SSPCO has set RCOND == 0.0D+00 or SSPFA has set INFO /= 0.
6777: !
6778: !    Variables not requested by JOB are not used.
6779: !
6780: !  Reference:
6781: !
6782: !    Dongarra, Moler, Bunch and Stewart,
6783: !    LINPACK User's Guide,
6784: !    SIAM, (Society for Industrial and Applied Mathematics),
6785: !    3600 University City Science Center,
6786: !    Philadelphia, PA, 19104-2688.
6787: !    ISBN 0-89871-172-X
6788: !
6789: !  Parameters:
6790: !
6791: !    Input/output, real(8) AP(N*(N+1)/2).  On input, the output from SSPFA.
6792: !    On output, the upper triangle of the inverse of the original matrix, 
6793: !    stored in packed form.  The columns of the upper triangle are stored
6794: !    sequentially in a one-dimensional array.
6795: !
6796: !    Input, integer N, the order of the matrix.
6797: !
6798: !    Input, integer KPVT(N), the pivot vector from SSPFA.
6799: !
6800: !    Output, real(8) DET(2), the determinant of the original matrix.
6801: !      determinant = DET(1) * 10.0**DET(2)
6802: !    with 1.0D+00 <= abs ( DET(1) ) < 10.0D+00 or DET(1) = 0.0.
6803: !
6804: !    Output, integer INERT(3), the inertia of the original matrix.
6805: !    INERT(1) = number of positive eigenvalues.
6806: !    INERT(2) = number of negative eigenvalues.
6807: !    INERT(3) = number of zero eigenvalues.
6808: !
6809: !    Workspace, real(8) WORK(N).
6810: !
6811: !    Input, integer JOB, has the decimal expansion ABC where:
6812: !      if A /= 0, the inertia is computed,
6813: !      if B /= 0, the determinant is computed,
6814: !      if C /= 0, the inverse is computed.
6815: !    For example, JOB = 111  gives all three.
6816: !
6817:   implicit none
6818: !
6819:   integer n
6820: !
6821:   real(8) ak
6822:   real(8) akkp1
6823:   real(8) akp1
6824:   real(8) ap((n*(n+1))/2)
6825:   real(8) d
6826:   real(8) det(2)
6827:   logical dodet
6828:   logical doert
6829:   logical doinv
6830:   integer ij
6831:   integer ik
6832:   integer ikp1
6833:   integer iks
6834:   integer inert(3)
6835:   integer j
6836:   integer jb
6837:   integer jk
6838:   integer jkp1
6839:   integer job
6840:   integer k
6841:   integer kk
6842:   integer kkp1
6843:   integer km1
6844:   integer kpvt(n)
6845:   integer ks
6846:   integer ksj
6847:   integer kskp1
6848:   integer kstep
6849:   real(8) sdot
6850:   real(8) t
6851:   real, parameter :: ten = 10.0D+00
6852:   real(8) work(n)
6853: !
6854:   doinv = mod ( job,   10 )       /= 0
6855:   dodet = mod ( job,  100 ) /  10 /= 0
6856:   doert = mod ( job, 1000 ) / 100 /= 0
6857: 
6858:   if ( dodet .or. doert ) then
6859: 
6860:      if ( doert ) then
6861:        inert(1) = 0
6862:        inert(2) = 0
6863:        inert(3) = 0
6864:      end if
6865: 
6866:      if ( dodet ) then
6867:        det(1) = 1.0D+00
6868:        det(2) = 0.0D+00
6869:      end if
6870: 
6871:      t = 0.0D+00
6872:      ik = 0
6873: 
6874:      do k = 1, n
6875: 
6876:         kk = ik + k
6877:         d = ap(kk)
6878: !
6879: !  2 by 2 block
6880: !  use det (d  s)  =  (d/t * c - t) * t,  t = abs ( s )
6881: !          (s  c)
6882: !  to avoid underflow/overflow troubles.
6883: !
6884: !  Take two passes through scaling.  Use T for flag.
6885: !
6886:         if ( kpvt(k) <= 0 ) then
6887: 
6888:            if ( t == 0.0D+00 ) then
6889:               ikp1 = ik + k
6890:               kkp1 = ikp1 + k
6891:               t = abs ( ap(kkp1) )
6892:               d = ( d / t ) * ap(kkp1+1) - t
6893:            else
6894:               d = t
6895:               t = 0.0D+00
6896:            end if
6897: 
6898:         end if
6899: 
6900:         if ( doert ) then
6901:            if ( d > 0.0D+00 ) then
6902:              inert(1) = inert(1) + 1
6903:            else if ( d < 0.0D+00 ) then
6904:              inert(2) = inert(2) + 1
6905:            else if ( d == 0.0D+00 ) then
6906:              inert(3) = inert(3) + 1
6907:            end if
6908:         end if
6909: 
6910:         if ( dodet ) then
6911: 
6912:            det(1) = d * det(1)
6913: 
6914:            if ( det(1) /= 0.0D+00 ) then
6915: 
6916:              do while ( abs ( det(1) ) < 1.0D+00 )
6917:                det(1) = ten * det(1)
6918:                det(2) = det(2) - 1.0D+00
6919:              end do
6920: 
6921:              do while ( abs ( det(1) ) >= ten )
6922:                det(1) = det(1) / ten
6923:                det(2) = det(2) + 1.0D+00
6924:              end do
6925: 
6926:           end if
6927: 
6928:         end if
6929: 
6930:         ik = ik + k
6931: 
6932:     end do
6933: 
6934:   end if
6935: !
6936: !  Compute inverse(A).
6937: !
6938:   if ( doinv ) then
6939: 
6940:      k = 1
6941:      ik = 0
6942: 
6943:      do while ( k <= n ) 
6944: 
6945:         km1 = k - 1
6946:         kk = ik + k
6947:         ikp1 = ik + k
6948:         kkp1 = ikp1 + k
6949: 
6950:         if ( kpvt(k) >= 0) then
6951: !
6952: !  1 by 1.
6953: !
6954:            ap(kk) = 1.0D+00 / ap(kk)
6955: 
6956:            if ( k-1 >= 1 ) then
6957: 
6958:               call <a href="./linpack.f90.html#scopy" TARGET=CENT_PANEL>scopy</a> ( k-1, ap(ik+1), 1, work, 1 )
6959:               ij = 0
6960: 
6961:               do j = 1, k-1
6962:                  jk = ik + j
6963:                  ap(jk) = <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( j, ap(ij+1), 1, work, 1 )
6964:                  call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j-1, work(j), ap(ij+1), 1, ap(ik+1), 1 )
6965:                  ij = ij + j
6966:               end do
6967: 
6968:               ap(kk) = ap(kk) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, work, 1, ap(ik+1), 1 )
6969: 
6970:            end if
6971: 
6972:            kstep = 1
6973: 
6974:         else
6975: !
6976: !  2 by 2.
6977: !
6978:            t = abs ( ap(kkp1) )
6979:            ak = ap(kk) / t
6980:            akp1 = ap(kkp1+1) / t
6981:            akkp1 = ap(kkp1) / t
6982:            d = t * ( ak * akp1 - 1.0D+00 )
6983:            ap(kk) = akp1 / d
6984:            ap(kkp1+1) = ak / d
6985:            ap(kkp1) = -akkp1 / d
6986: 
6987:            if ( km1 >= 1 ) then
6988: 
6989:               call <a href="./linpack.f90.html#scopy" TARGET=CENT_PANEL>scopy</a> ( km1, ap(ikp1+1), 1, work, 1 )
6990:               ij = 0
6991: 
6992:               do j = 1, km1
6993:                  jkp1 = ikp1 + j
6994:                  ap(jkp1) = <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( j, ap(ij+1), 1, work, 1 )
6995:                  call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j-1, work(j), ap(ij+1), 1, ap(ikp1+1), 1 )
6996:                  ij = ij + j
6997:               end do
6998: 
6999:               ap(kkp1+1) = ap(kkp1+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( km1, work, 1, ap(ikp1+1), 1 )
7000:               ap(kkp1) = ap(kkp1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( km1, ap(ik+1), 1, ap(ikp1+1), 1 )
7001:               call <a href="./linpack.f90.html#scopy" TARGET=CENT_PANEL>scopy</a> ( km1, ap(ik+1), 1, work, 1 )
7002:               ij = 0
7003: 
7004:               do j = 1, km1
7005:                  jk = ik + j
7006:                  ap(jk) = <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( j, ap(ij+1), 1, work, 1 )
7007:                  call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j-1, work(j), ap(ij+1), 1, ap(ik+1), 1 )
7008:                  ij = ij + j
7009:               end do
7010: 
7011:               ap(kk) = ap(kk) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( km1, work, 1, ap(ik+1), 1 )
7012: 
7013:            end if
7014: 
7015:            kstep = 2
7016:   
7017:         end if
7018: !
7019: !  Swap.
7020: !
7021:         ks = abs ( kpvt(k) )
7022: 
7023:         if ( ks /= k ) then
7024: 
7025:            iks = ( ks * ( ks - 1 ) ) / 2
7026:            call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( ks, ap(iks+1), 1, ap(ik+1), 1 )
7027:            ksj = ik + ks
7028: 
7029:            do jb = ks, k
7030:               j = k + ks - jb
7031:               jk = ik + j
7032:               call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( ap(jk), ap(ksj) )
7033:               ksj = ksj - (j - 1)
7034:            end do
7035: 
7036:            if ( kstep /= 1 ) then
7037:               kskp1 = ikp1 + ks
7038:               call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( ap(kskp1), ap(kkp1) )
7039:            end if
7040: 
7041:         end if
7042: 
7043:         ik = ik + k
7044:         if (kstep == 2) ik = ik + k + 1
7045:         k = k + kstep
7046: 
7047:      end do
7048: 
7049:   end if
7050: 
7051:   return
7052: end
<p><a name=sspfa><H3>sspfa</H3></a></p> Click <a href="./callingtree/sspfa_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sspfa is used.
<hr>
7053: subroutine sspfa ( ap, n, kpvt, info )
7054: !
7055: !*******************************************************************************
7056: !
7057: !! SSPFA factors a real(8) symmetric matrix stored in packed form.
7058: !
7059: !
7060: !  Discussion:
7061: !
7062: !    To solve A*X = B, follow SSPFA by SSPSL.
7063: !
7064: !    To compute inverse(A)*C, follow SSPFA by SSPSL.
7065: !
7066: !    To compute determinant(A), follow SSPFA by SSPDI.
7067: !
7068: !    To compute inertia(A), follow SSPFA by SSPDI.
7069: !
7070: !    To compute inverse(A), follow SSPFA by SSPDI.
7071: !
7072: !  Packed storage:
7073: !
7074: !    The following program segment will pack the upper triangle of a 
7075: !    symmetric matrix.
7076: !
7077: !      k = 0
7078: !      do j = 1, n
7079: !        do i = 1, j
7080: !          k = k + 1
7081: !          ap(k)  = a(i,j)
7082: !        end do
7083: !      end do
7084: !
7085: !  Reference:
7086: !
7087: !    Dongarra, Moler, Bunch and Stewart,
7088: !    LINPACK User's Guide,
7089: !    SIAM, (Society for Industrial and Applied Mathematics),
7090: !    3600 University City Science Center,
7091: !    Philadelphia, PA, 19104-2688.
7092: !    ISBN 0-89871-172-X
7093: !
7094: !  Parameters:
7095: !
7096: !    Input, real(8) AP(N*(N+1)/2).  On input, the packed form of a symmetric 
7097: !    matrix A.  The columns of the upper triangle are stored sequentially
7098: !    in a one-dimensional array.  On output, a block diagonal matrix and 
7099: !    the multipliers which were used to obtain it stored in packed form.
7100: !    The factorization can be written A = U*D*U' where U is a product of 
7101: !    permutation and unit upper triangular matrices, U' is the transpose 
7102: !    of U, and D is block diagonal with 1 by 1 and 2 by 2 blocks.
7103: !
7104: !    Input, integer N, the order of the matrix.
7105: !
7106: !    Output, integer KPVT(N), the pivot indices.
7107: !
7108: !    Output, integer INFO, error flag.
7109: !    0, normal value.
7110: !    K, if the K-th pivot block is singular.  This is not an error 
7111: !    condition for this subroutine, but it does indicate that SSPSL or 
7112: !    SSPDI may divide by zero if called.
7113: !
7114:   implicit none
7115: !
7116:   integer n
7117: !
7118:   real(8) absakk
7119:   real(8) ak
7120:   real(8) akm1
7121:   real(8) alpha
7122:   real(8) ap((n*(n+1))/2)
7123:   real(8) bk
7124:   real(8) bkm1
7125:   real(8) colmax
7126:   real(8) denom
7127:   integer ij
7128:   integer ijj
7129:   integer ik
7130:   integer ikm1
7131:   integer im
7132:   integer imax
7133:   integer imaxp1
7134:   integer imim
7135:   integer imj
7136:   integer imk
7137:   integer info
7138:   integer <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a>
7139:   integer j
7140:   integer jj
7141:   integer jk
7142:   integer jkm1
7143:   integer jmax
7144:   integer jmim
7145:   integer k
7146:   integer kk
7147:   integer km1
7148:   integer km1k
7149:   integer km1km1
7150:   integer kpvt(n)
7151:   integer kstep
7152:   real(8) mulk
7153:   real(8) mulkm1
7154:   real(8) rowmax
7155:   logical swap
7156:   real(8) t
7157: !
7158: !  ALPHA is used in choosing pivot block size.
7159: !
7160:   alpha = ( 1.0D+00 + sqrt ( 17.0D+00 ) ) / 8.0D+00
7161: 
7162:   info = 0
7163: !
7164: !  Main loop on K, which goes from N to 1.
7165: !
7166:   k = n
7167:   ik = (n*(n - 1))/2
7168: 
7169: 10 continue
7170: !
7171: !  Leave the loop if K=0 or K=1.
7172: !
7173:   if ( k == 0 ) then
7174:     return
7175:   end if
7176: 
7177:   if ( k == 1 ) then
7178:     kpvt(1) = 1
7179:     if ( ap(1) == 0.0D+00 ) then
7180:       info = 1
7181:     end if
7182:     return
7183:   end if
7184: !
7185: !  This section of code determines the kind of elimination to be performed.  
7186: !  When it is completed, KSTEP will be set to the size of the pivot block, 
7187: !  and SWAP will be set to .true. if an interchange is required.
7188: !
7189:   km1 = k - 1
7190:   kk = ik + k
7191:   absakk = abs ( ap(kk) )
7192: !
7193: !  Determine the largest off-diagonal element in column K.
7194: !
7195:   imax = <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> ( k-1, ap(ik+1), 1 )
7196:   imk = ik + imax
7197:   colmax = abs ( ap(imk) )
7198: 
7199:   if ( absakk >= alpha * colmax ) then
7200: 
7201:     kstep = 1
7202:     swap = .false.
7203: !
7204: !  Determine the largest off-diagonal element in row IMAX.
7205: !
7206:   else
7207: 
7208:     rowmax = 0.0D+00
7209:     imaxp1 = imax + 1
7210:     im = imax * ( imax - 1 ) / 2
7211:     imj = im + 2 * imax
7212:     do j = imaxp1, k
7213:       rowmax = max ( rowmax, abs ( ap(imj) ) )
7214:       imj = imj + j
7215:     end do
7216: 
7217:     if ( imax /= 1 ) then
7218:       jmax = <a href="./linpack.f90.html#isamax" TARGET=CENT_PANEL>isamax</a> ( imax-1, ap(im+1), 1 )
7219:       jmim = jmax + im
7220:       rowmax = max ( rowmax, abs ( ap(jmim) ) )
7221:     end if
7222: 
7223:     imim = imax + im
7224: 
7225:     if ( abs ( ap(imim) ) >= alpha * rowmax ) then
7226:       kstep = 1
7227:       swap = .true.
7228:     else if ( absakk >= alpha * colmax * ( colmax / rowmax ) ) then
7229:       kstep = 1
7230:       swap = .false.
7231:     else
7232:       kstep = 2
7233:       swap = imax /= km1
7234:     end if
7235: 
7236:   end if
7237: !
7238: !  Column K is zero.  Set INFO and iterate the loop.
7239: !
7240:      if ( max ( absakk, colmax ) == 0.0D+00 ) then
7241:        kpvt(k) = k
7242:        info = k
7243:        go to 190
7244:      end if
7245: 
7246:      if ( kstep /= 2 ) then
7247: !
7248: !  1 x 1 pivot block.
7249: !
7250:         if ( swap ) then
7251: !
7252: !  Perform an interchange.
7253: !
7254:            call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( imax, ap(im+1), 1, ap(ik+1), 1 )
7255:            imj = ik + imax
7256: 
7257:            do jj = imax, k
7258:               j = k + imax - jj
7259:               jk = ik + j
7260:               t = ap(jk)
7261:               ap(jk) = ap(imj)
7262:               ap(imj) = t
7263:               imj = imj - (j - 1)
7264:            end do
7265: 
7266:         end if
7267: !
7268: !  Perform the elimination.
7269: !
7270:         ij = ik - (k - 1)
7271: 
7272:         do jj = 1, km1
7273:            j = k - jj
7274:            jk = ik + j
7275:            mulk = -ap(jk)/ap(kk)
7276:            t = mulk
7277:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j, t, ap(ik+1), 1, ap(ij+1), 1 )
7278:            ijj = ij + j
7279:            ap(jk) = mulk
7280:            ij = ij - (j - 1)
7281:         end do
7282: !
7283: !  Set the pivot array.
7284: !
7285:         if ( swap ) then
7286:           kpvt(k) = imax
7287:         else
7288:           kpvt(k) = k
7289:         end if
7290: 
7291:      else
7292: !
7293: !  2 x 2 pivot block.
7294: !
7295:         km1k = ik + k - 1
7296:         ikm1 = ik - (k - 1)
7297: !
7298: !  Perform an interchange.
7299: !
7300:         if ( swap ) then
7301: 
7302:            call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( imax, ap(im+1), 1, ap(ikm1+1), 1 )
7303:            imj = ikm1 + imax
7304: 
7305:            do jj = imax, km1
7306:               j = km1 + imax - jj
7307:               jkm1 = ikm1 + j
7308:               t = ap(jkm1)
7309:               ap(jkm1) = ap(imj)
7310:               ap(imj) = t
7311:               imj = imj - ( j - 1 )
7312:            end do
7313: 
7314:            t = ap(km1k)
7315:            ap(km1k) = ap(imk)
7316:            ap(imk) = t
7317: 
7318:         end if
7319: !
7320: !  Perform the elimination.
7321: !
7322:         if ( k-2 /= 0 ) then
7323: 
7324:            ak = ap(kk) / ap(km1k)
7325:            km1km1 = ikm1 + k - 1
7326:            akm1 = ap(km1km1) / ap(km1k)
7327:            denom = 1.0D+00 - ak * akm1
7328:            ij = ik - ( k - 1 ) - ( k - 2 )
7329: 
7330:            do jj = 1, k-2
7331: 
7332:               j = km1 - jj
7333:               jk = ik + j
7334:               bk = ap(jk) / ap(km1k)
7335:               jkm1 = ikm1 + j
7336:               bkm1 = ap(jkm1) / ap(km1k)
7337:               mulk = ( akm1 * bk - bkm1 ) / denom
7338:               mulkm1 = ( ak * bkm1 - bk ) / denom
7339:               t = mulk
7340:               call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j, t, ap(ik+1), 1, ap(ij+1), 1 )
7341:               t = mulkm1
7342:               call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j, t, ap(ikm1+1), 1, ap(ij+1), 1 )
7343:               ap(jk) = mulk
7344:               ap(jkm1) = mulkm1
7345:               ijj = ij + j
7346:               ij = ij - (j - 1)
7347:           end do
7348: 
7349:         end if
7350: !
7351: !  Set the pivot array.
7352: !
7353:         kpvt(k) = 1 - k
7354:         if (swap) kpvt(k) = -imax
7355:         kpvt(k-1) = kpvt(k)
7356: 
7357:      end if
7358: 
7359: 190  continue
7360: 
7361:      ik = ik - (k - 1)
7362:      if ( kstep == 2 ) then
7363:        ik = ik - (k - 2)
7364:      end if
7365: 
7366:      k = k - kstep
7367: 
7368:   go to 10
7369: end
<p><a name=sspsl><H3>sspsl</H3></a></p> Click <a href="./callingtree/sspsl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sspsl is used.
<hr>
7370: subroutine sspsl ( ap, n, kpvt, b )
7371: !
7372: !*******************************************************************************
7373: !
7374: !! SSPSL solves the real(8) symmetric system factored by SSPFA.
7375: !
7376: !
7377: !  Discussion:
7378: !
7379: !    To compute inverse(A) * C where C is a matrix with P columns:
7380: !
7381: !      call sspfa ( ap, n, kpvt, info )
7382: !
7383: !      if ( info /= 0 ) go to ...
7384: !
7385: !      do j = 1, p
7386: !        call sspsl ( ap, n, kpvt, c(1,j) )
7387: !      end do
7388: !
7389: !    A division by zero may occur if SSPCO has set RCOND == 0.0D+00
7390: !    or SSPFA has set INFO /= 0.
7391: !
7392: !  Reference:
7393: !
7394: !    Dongarra, Moler, Bunch and Stewart,
7395: !    LINPACK User's Guide,
7396: !    SIAM, (Society for Industrial and Applied Mathematics),
7397: !    3600 University City Science Center,
7398: !    Philadelphia, PA, 19104-2688.
7399: !    ISBN 0-89871-172-X
7400: !
7401: !  Parameters:
7402: !
7403: !    Input, real(8) AP(N*(N+1)/2), the output from SSPFA.
7404: !
7405: !    Input, integer N, the order of the matrix.
7406: !
7407: !    Input, integer KPVT(N), the pivot vector from SSPFA.
7408: !
7409: !    Input/output, real(8) B(N).  On input, the right hand side.
7410: !    On output, the solution.
7411: !
7412:   implicit none
7413: !
7414:   integer n
7415: !
7416:   real(8) ak
7417:   real(8) akm1
7418:   real(8) ap((n*(n+1))/2)
7419:   real(8) b(n)
7420:   real(8) bk
7421:   real(8) bkm1
7422:   real(8) denom
7423:   integer ik
7424:   integer ikm1
7425:   integer ikp1
7426:   integer k
7427:   integer kk
7428:   integer km1k
7429:   integer km1km1
7430:   integer kp
7431:   integer kpvt(n)
7432:   real(8) sdot
7433: !
7434: !  Loop backward applying the transformations and D inverse to B.
7435: !
7436:   k = n
7437:   ik = (n*(n - 1))/2
7438: 
7439:   do while ( k > 0 ) 
7440: 
7441:      kk = ik + k
7442: 
7443:      if ( kpvt(k) >= 0 ) then
7444: !
7445: !  1 x 1 pivot block.
7446: !
7447:         if (k /= 1) then
7448: 
7449:            kp = kpvt(k)
7450: !
7451: !  Interchange.
7452: !
7453:            if ( kp /= k ) then
7454:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k), b(kp) )
7455:            end if
7456: !
7457: !  Apply the transformation.
7458: !
7459:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-1, b(k), ap(ik+1), 1, b(1), 1 )
7460: 
7461:         end if
7462: !
7463: !  Apply D inverse.
7464: !
7465:         b(k) = b(k) / ap(kk)
7466:         k = k - 1
7467:         ik = ik - k
7468: 
7469:      else
7470: !
7471: !  2 x 2 pivot block.
7472: !
7473:         ikm1 = ik - (k - 1)
7474: 
7475:         if ( k /= 2 ) then
7476: 
7477:            kp = abs ( kpvt(k) )
7478: !
7479: !  Interchange.
7480: !
7481:            if ( kp /= k-1 ) then
7482:               call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k-1), b(kp) )
7483:            end if
7484: !
7485: !  Apply the transformation.
7486: !
7487:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-2, b(k), ap(ik+1), 1, b(1), 1 )
7488:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k-2, b(k-1), ap(ikm1+1), 1, b(1), 1 )
7489: 
7490:         end if
7491: !
7492: !  Apply D inverse.
7493: !
7494:         km1k = ik + k - 1
7495:         kk = ik + k
7496:         ak = ap(kk) / ap(km1k)
7497:         km1km1 = ikm1 + k - 1
7498:         akm1 = ap(km1km1) / ap(km1k)
7499:         bk = b(k) / ap(km1k)
7500:         bkm1 = b(k-1) / ap(km1k)
7501:         denom = ak * akm1 - 1.0D+00
7502:         b(k) = ( akm1 * bk - bkm1 ) / denom
7503:         b(k-1) = ( ak * bkm1 - bk ) / denom
7504:         k = k - 2
7505:         ik = ik - (k + 1) - k
7506: 
7507:     end if
7508: 
7509:   end do
7510: !
7511: !  Loop forward applying the transformations.
7512: !
7513:   k = 1
7514:   ik = 0
7515: 
7516:   do while ( k <= n )
7517: 
7518:      if ( kpvt(k) >= 0 ) then
7519: !
7520: !  1 x 1 pivot block.
7521: !
7522:         if ( k /= 1 ) then
7523: !
7524: !  Apply the transformation.
7525: !
7526:            b(k) = b(k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(ik+1), 1, b(1), 1 )
7527:            kp = kpvt(k)
7528: !
7529: !  Interchange.
7530: !
7531:            if ( kp /= k ) then
7532:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k), b(kp) )
7533:            end if
7534: 
7535:         end if
7536: 
7537:         ik = ik + k
7538:         k = k + 1
7539: 
7540:      else
7541: !
7542: !  2 x 2 pivot block.
7543: !
7544:         if ( k /= 1 ) then
7545: !
7546: !  Apply the transformation.
7547: !
7548:            b(k) = b(k) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(ik+1), 1, b(1), 1 )
7549:            ikp1 = ik + k
7550:            b(k+1) = b(k+1) + <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( k-1, ap(ikp1+1), 1, b(1), 1 )
7551:            kp = abs ( kpvt(k) )
7552: !
7553: !  Interchange.
7554: !
7555:            if ( kp /= k ) then
7556:              call <a href="./linpack.f90.html#r_swap" TARGET=CENT_PANEL>r_swap</a> ( b(k), b(kp) )
7557:            end if
7558: 
7559:         end if
7560: 
7561:         ik = ik + k + k + 1
7562:         k = k + 2
7563: 
7564:     end if
7565: 
7566:   end do
7567: 
7568:   return
7569: end
<p><a name=ssvdc><H3>ssvdc</H3></a></p> Click <a href="./callingtree/ssvdc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ssvdc is used.
<hr>
7570: subroutine ssvdc ( x, ldx, n, p, s, e, u, ldu, v, ldv, work, job, info )
7571: !
7572: !*******************************************************************************
7573: !
7574: !! SSVDC computes the singular value decomposition of a real(8) rectangular matrix.
7575: !
7576: !
7577: !  Discussion:
7578: !
7579: !    SSVDC reduces a real(8) N by P matrix X to diagonal form by orthogonal 
7580: !    transformations U and V.  The diagonal elements S(I) are the singular 
7581: !    values of X.  The columns of U are the corresponding left singular 
7582: !    vectors, and the columns of V the right singular vectors.
7583: !
7584: !  Reference:
7585: !
7586: !    Dongarra, Moler, Bunch and Stewart,
7587: !    LINPACK User's Guide,
7588: !    SIAM, (Society for Industrial and Applied Mathematics),
7589: !    3600 University City Science Center,
7590: !    Philadelphia, PA, 19104-2688.
7591: !    ISBN 0-89871-172-X
7592: !
7593: !  Parameters:
7594: !
7595: !    Input/output, real(8) X(LDX,P).  On input, the matrix whose singular value
7596: !    decomposition is to be computed.  On output, the matrix has been
7597: !    destroyed.
7598: !
7599: !    Input, integer LDX, the leading dimension of the array X.
7600: !    LDX must be at least N.
7601: !
7602: !    Input, integer N, the number of rows of the matrix.
7603: !
7604: !    Input, integer P, the number of columns of the matrix X.
7605: !
7606: !    Output, real(8) S(MM), where MM = min(N+1,P).  The first min(N,P) entries 
7607: !    of S contain the singular values of X arranged in descending
7608: !    order of magnitude.
7609: !
7610: !    Output, real(8) E(P), ordinarily contains zeros.  However see the
7611: !    discussion of INFO for exceptions.
7612: !
7613: !    Output, real(8) U(LDU,K).  If JOBA = 1 then K = N; if JOBA >= 2 then
7614: !    K = min(N,P).  U contains the matrix of left singular vectors.
7615: !    U is not referenced if JOBA = 0.  If N <= P or if JOBA = 2, then 
7616: !    U may be identified with X in the subroutine call.
7617: !
7618: !    Input, integer LDU, the leading dimension of the array U.
7619: !    LDU must be at least N.
7620: !
7621: !    Output, real(8) V(LDV,P), the matrix of right singular vectors.
7622: !    V is not referenced if JOB is 0.  If P <= N, then V may be identified 
7623: !    with X in the subroutine call.
7624: !
7625: !    Input, integer LDV, the leading dimension of the array V.
7626: !    LDV must be at least P.
7627: !
7628: !    Workspace, real(8) WORK(N).
7629: !
7630: !    Input, integer JOB, controls the computation of the singular
7631: !    vectors.  It has the decimal expansion AB with the following meaning:
7632: !
7633: !      A =  0, do not compute the left singular vectors.
7634: !      A =  1, return the N left singular vectors in U.
7635: !      A >= 2, return the first min(N,P) singular vectors in U.
7636: !      B =  0, do not compute the right singular vectors.
7637: !      B =  1, return the right singular vectors in V.
7638: !
7639: !    Output, integer INFO, status indicator.
7640: !    The singular values (and their corresponding singular vectors) 
7641: !    S(INFO+1), S(INFO+2),...,S(M) are correct (here M=min(N,P)).  
7642: !    Thus if INFO is 0, all the singular values and their vectors are 
7643: !    correct.  In any event, the matrix B = U'*X*V is the bidiagonal matrix
7644: !    with the elements of S on its diagonal and the elements of E on 
7645: !    its super-diagonal (U' is the transpose of U).  Thus the singular
7646: !    values of X and B are the same.
7647: !
7648:   implicit none
7649: !
7650:   integer ldu
7651:   integer ldv
7652:   integer ldx
7653:   integer n
7654:   integer p
7655: !
7656:   real(8) b
7657:   real(8) c
7658:   real(8) cs
7659:   real(8) e(p)
7660:   real(8) el
7661:   real(8) emm1
7662:   real(8) f
7663:   real(8) g
7664:   integer info
7665:   integer iter
7666:   integer j
7667:   integer job
7668:   integer jobu
7669:   integer k
7670:   integer kase
7671:   integer kk
7672:   integer l
7673:   integer ll
7674:   integer lls
7675:   integer ls
7676:   integer lu
7677:   integer m
7678:   integer, parameter :: maxit = 30
7679:   integer mm
7680:   integer mm1
7681:   integer mp1
7682:   integer nct
7683:   integer nctp1
7684:   integer ncu
7685:   integer nrt
7686:   integer nrtp1
7687:   real(8) s(*)
7688:   real(8) scale
7689:   real(8) sdot
7690:   real(8) shift
7691:   real(8) sl
7692:   real(8) sm
7693:   real(8) smm1
7694:   real(8) sn
7695:   real(8) snrm2
7696:   real(8) t
7697:   real(8) t1
7698:   real(8) test
7699:   real(8) u(ldu,*)
7700:   real(8) v(ldv,p)
7701:   logical wantu
7702:   logical wantv
7703:   real(8) work(n)
7704:   real(8) x(ldx,p)
7705:   real(8) ztest
7706: !
7707: !  Determine what is to be computed.
7708: !
7709:   wantu = .false.
7710:   wantv = .false.
7711:   jobu = mod ( job, 100 ) / 10
7712: 
7713:   if (jobu > 1) then
7714:     ncu = min ( n, p )
7715:   else
7716:     ncu = n
7717:   end if
7718: 
7719:   if ( jobu /= 0 ) then
7720:     wantu = .true.
7721:   end if
7722: 
7723:   if ( mod ( job, 10 ) /= 0 ) then
7724:     wantv = .true.
7725:   end if
7726: !
7727: !  Reduce X to bidiagonal form, storing the diagonal elements
7728: !  in S and the super-diagonal elements in E.
7729: !
7730:   info = 0
7731:   nct = min ( n-1, p )
7732:   nrt = max ( 0, min ( p-2, n ) )
7733:   lu = max ( nct, nrt )
7734: 
7735:   do l = 1, lu
7736: !
7737: !  Compute the transformation for the L-th column and
7738: !  place the L-th diagonal in S(L).
7739: !
7740:      if ( l <= nct ) then
7741: 
7742:         s(l) = <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> ( n-l+1, x(l,l), 1 )
7743: 
7744:         if ( s(l) /= 0.0D+00 ) then
7745:           if (x(l,l) /= 0.0D+00 ) then
7746:             s(l) = sign ( s(l), x(l,l) )
7747:           end if
7748:           call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( n-l+1, 1.0D+00 / s(l), x(l,l), 1 )
7749:           x(l,l) = 1.0D+00 + x(l,l)
7750:         end if
7751: 
7752:         s(l) = -s(l)
7753: 
7754:      end if
7755: 
7756:      do j = l+1, p
7757: !
7758: !  Apply the transformation.
7759: !
7760:         if ( l <= nct .and. s(l) /= 0.0D+00 ) then
7761:            t = - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( n-l+1, x(l,l), 1, x(l,j), 1 ) / x(l,l)
7762:            call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-l+1, t, x(l,l), 1, x(l,j), 1 )
7763:         end if
7764: !
7765: !  Place the L-th row of X into E for the
7766: !  subsequent calculation of the row transformation.
7767: !
7768:         e(j) = x(l,j)
7769:      end do
7770: !
7771: !  Place the transformation in U for subsequent back multiplication.
7772: !
7773:      if ( wantu .and. l <= nct ) then
7774:         u(l:n,l) = x(l:n,l)
7775:      end if
7776: 
7777:      if ( l <= nrt ) then
7778: !
7779: !  Compute the L-th row transformation and place the
7780: !  L-th superdiagonal in E(L).
7781: !
7782:         e(l) = <a href="./linpack.f90.html#snrm2" TARGET=CENT_PANEL>snrm2</a> ( p-l, e(l+1), 1 )
7783: 
7784:         if ( e(l) /= 0.0D+00 ) then
7785:           if ( e(l+1) /= 0.0D+00 ) then
7786:             e(l) = sign ( e(l), e(l+1) )
7787:           end if
7788:           call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( p-l, 1.0D+00 / e(l), e(l+1), 1 )
7789:           e(l+1) = 1.0D+00 + e(l+1)
7790:         end if
7791: 
7792:         e(l) = -e(l)
7793: !
7794: !  Apply the transformation.
7795: !
7796:         if ( l+1 <= n .and. e(l) /= 0.0D+00 ) then
7797: 
7798:            work(l+1:n) = 0.0D+00
7799: 
7800:            do j = l+1, p
7801:               call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-l, e(j), x(l+1,j), 1, work(l+1), 1 )
7802:            end do
7803: 
7804:            do j = l+1, p
7805:               call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-l, -e(j)/e(l+1), work(l+1), 1, x(l+1,j), 1 )
7806:            end do
7807: 
7808:         end if
7809: !
7810: !  Place the transformation in V for subsequent back multiplication.
7811: !
7812:         if ( wantv ) then
7813:           v(l+1:p,l) = e(l+1:p)
7814:         end if
7815: 
7816:      end if
7817: 
7818:   end do
7819: !
7820: !  Set up the final bidiagonal matrix of order M.
7821: !
7822:   m = min ( p, n+1 )
7823:   nctp1 = nct + 1
7824:   nrtp1 = nrt + 1
7825: 
7826:   if ( nct < p ) then
7827:     s(nctp1) = x(nctp1,nctp1)
7828:   end if
7829: 
7830:   if ( n < m ) then
7831:     s(m) = 0.0D+00
7832:   end if
7833: 
7834:   if ( nrtp1 < m ) then
7835:     e(nrtp1) = x(nrtp1,m)
7836:   end if
7837: 
7838:   e(m) = 0.0D+00
7839: !
7840: !  If required, generate U.
7841: !
7842:   if ( wantu ) then
7843: 
7844:     u(1:n,nctp1:ncu) = 0.0D+00
7845: 
7846:     do j = nctp1, ncu
7847:       u(j,j) = 1.0D+00
7848:     end do
7849: 
7850:     do ll = 1, nct
7851: 
7852:       l = nct - ll + 1
7853: 
7854:       if ( s(l) /= 0.0D+00 ) then
7855: 
7856:         do j = l+1, ncu
7857:           t = - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( n-l+1, u(l,l), 1, u(l,j), 1 ) / u(l,l)
7858:           call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-l+1, t, u(l,l), 1, u(l,j), 1 )
7859:         end do
7860: 
7861:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( n-l+1, -1.0D+00, u(l,l), 1 )
7862:         u(l,l) = 1.0D+00 + u(l,l)
7863:         u(1:l-1,l) = 0.0D+00
7864: 
7865:       else
7866: 
7867:         u(1:n,l) = 0.0D+00
7868:         u(l,l) = 1.0D+00
7869: 
7870:       end if
7871: 
7872:     end do
7873: 
7874:   end if
7875: !
7876: !  If it is required, generate V.
7877: !
7878:   if ( wantv ) then
7879: 
7880:      do ll = 1, p
7881: 
7882:         l = p - ll + 1
7883: 
7884:         if ( l <= nrt .and. e(l) /= 0.0D+00 ) then
7885: 
7886:            do j = l+1, p
7887:               t = - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( p-l, v(l+1,l), 1, v(l+1,j), 1 ) / v(l+1,l)
7888:               call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( p-l, t, v(l+1,l), 1, v(l+1,j), 1 )
7889:            end do
7890: 
7891:         end if
7892: 
7893:         v(1:p,l) = 0.0D+00
7894:         v(l,l) = 1.0D+00
7895: 
7896:      end do
7897: 
7898:   end if
7899: !
7900: !  Main iteration loop for the singular values.
7901: !
7902:   mm = m
7903:   iter = 0
7904: 
7905:   do while ( m > 0 )
7906: !
7907: !  If too many iterations have been performed, set flag and return.
7908: !
7909:      if ( iter >= maxit ) then
7910:         info = m
7911:         return
7912:      end if
7913: !
7914: !  This section of the program inspects for
7915: !  negligible elements in the S and E arrays.  
7916: !
7917: !  On completion the variables KASE and L are set as follows:
7918: !
7919: !  KASE = 1     if S(M) and E(L-1) are negligible and L<M
7920: !  KASE = 2     if S(L) is negligible and L<M
7921: !  KASE = 3     if E(L-1) is negligible, L<M, and
7922: !               S(L), ..., s(M) are not negligible (QR step).
7923: !  KASE = 4     if E(M-1) is negligible (convergence).
7924: !
7925:      do ll = 1, m
7926: 
7927:         l = m - ll
7928: 
7929:         if ( l == 0 ) then
7930:           exit
7931:         end if
7932: 
7933:         test = abs ( s(l) ) + abs ( s(l+1) )
7934:         ztest = test + abs ( e(l) )
7935: 
7936:         if ( ztest == test ) then
7937:            e(l) = 0.0D+00
7938:            exit
7939:         end if
7940: 
7941:      end do
7942: 
7943:      if ( l == m - 1 ) then
7944: 
7945:         kase = 4
7946: 
7947:      else
7948: 
7949:         mp1 = m + 1
7950: 
7951:         do lls = l+1, m+1
7952: 
7953:            ls = m - lls + l+1
7954: 
7955:            if ( ls == l ) then
7956:              exit
7957:            end if
7958: 
7959:            test = 0.0D+00
7960:            if ( ls /= m ) then
7961:              test = test + abs ( e(ls) )
7962:            end if
7963: 
7964:            if ( ls /= l + 1 ) then
7965:              test = test + abs ( e(ls-1) )
7966:            end if
7967: 
7968:            ztest = test + abs ( s(ls) )
7969: 
7970:            if ( ztest == test ) then
7971:               s(ls) = 0.0D+00
7972:               exit
7973:            end if
7974: 
7975:         end do
7976: 
7977:         if ( ls == l ) then
7978:           kase = 3
7979:         else if ( ls == m ) then
7980:           kase = 1
7981:         else
7982:           kase = 2
7983:           l = ls
7984:         end if
7985: 
7986:      end if
7987: 
7988:      l = l + 1
7989: !
7990: !  Deflate negligible S(M).
7991: !
7992:      if ( kase == 1 ) then
7993: 
7994:         mm1 = m - 1
7995:         f = e(m-1)
7996:         e(m-1) = 0.0D+00
7997: 
7998:         do kk = l, mm1
7999: 
8000:            k = mm1 - kk + l
8001:            t1 = s(k)
8002:            call <a href="./linpack.f90.html#srotg" TARGET=CENT_PANEL>srotg</a> ( t1, f, cs, sn )
8003:            s(k) = t1
8004: 
8005:            if ( k /= l ) then
8006:              f = - sn * e(k-1)
8007:              e(k-1) = cs * e(k-1)
8008:            end if
8009: 
8010:            if ( wantv ) then
8011:              call <a href="./linpack.f90.html#srot" TARGET=CENT_PANEL>srot</a> ( p, v(1,k), 1, v(1,m), 1, cs, sn )
8012:            end if
8013: 
8014:         end do
8015: !
8016: !  Split at negligible S(L).
8017: !
8018:      else if ( kase == 2 ) then
8019: 
8020:         f = e(l-1)
8021:         e(l-1) = 0.0D+00
8022: 
8023:         do k = l, m
8024: 
8025:            t1 = s(k)
8026:            call <a href="./linpack.f90.html#srotg" TARGET=CENT_PANEL>srotg</a> ( t1, f, cs, sn )
8027:            s(k) = t1
8028:            f = - sn * e(k)
8029:            e(k) = cs * e(k)
8030:            if ( wantu ) then
8031:              call <a href="./linpack.f90.html#srot" TARGET=CENT_PANEL>srot</a> ( n, u(1,k), 1, u(1,l-1), 1, cs, sn )
8032:            end if
8033: 
8034:         end do
8035: !
8036: !  Perform one QR step.
8037: !
8038:      else if ( kase == 3 ) then
8039: !
8040: !  Calculate the shift.
8041: !
8042:         scale = max ( abs ( s(m) ), abs ( s(m-1) ), abs ( e(m-1) ), &
8043:                       abs ( s(l) ), abs ( e(l) ) )
8044: 
8045:         sm = s(m) / scale
8046:         smm1 = s(m-1) / scale
8047:         emm1 = e(m-1) / scale
8048:         sl = s(l) / scale
8049:         el = e(l) / scale
8050:         b = ( ( smm1 + sm ) * ( smm1 - sm ) + emm1**2 ) / 2.0D+00
8051:         c = ( sm * emm1 )**2
8052:         shift = 0.0D+00
8053: 
8054:         if ( b /= 0.0D+00 .or. c /= 0.0D+00 ) then
8055:            shift = sqrt ( b**2 + c )
8056:            if ( b < 0.0D+00 ) then
8057:              shift = - shift
8058:            end if
8059:            shift = c / ( b + shift )
8060:         end if
8061: 
8062:         f = ( sl + sm ) * ( sl - sm ) - shift
8063:         g = sl * el
8064: !
8065: !  Chase zeros.
8066: !
8067:         mm1 = m - 1
8068: 
8069:         do k = l, mm1
8070: 
8071:            call <a href="./linpack.f90.html#srotg" TARGET=CENT_PANEL>srotg</a> ( f, g, cs, sn )
8072: 
8073:            if (k /= l) then
8074:              e(k-1) = f
8075:            end if
8076: 
8077:            f = cs * s(k) + sn * e(k)
8078:            e(k) = cs * e(k) - sn * s(k)
8079:            g = sn * s(k+1)
8080:            s(k+1) = cs * s(k+1)
8081: 
8082:            if ( wantv ) then
8083:              call <a href="./linpack.f90.html#srot" TARGET=CENT_PANEL>srot</a> ( p, v(1,k), 1, v(1,k+1), 1, cs, sn )
8084:            end if
8085: 
8086:            call <a href="./linpack.f90.html#srotg" TARGET=CENT_PANEL>srotg</a> ( f, g, cs, sn )
8087:            s(k) = f
8088:            f = cs * e(k) + sn * s(k+1)
8089:            s(k+1) = -sn * e(k) + cs * s(k+1)
8090:            g = sn * e(k+1)
8091:            e(k+1) = cs * e(k+1)
8092: 
8093:            if ( wantu .and. k < n ) then
8094:              call <a href="./linpack.f90.html#srot" TARGET=CENT_PANEL>srot</a> ( n, u(1,k), 1, u(1,k+1), 1, cs, sn )
8095:            end if
8096: 
8097:         end do
8098: 
8099:         e(m-1) = f
8100:         iter = iter + 1
8101: !
8102: !  Convergence.
8103: !
8104:      else if ( kase == 4 ) then
8105: !
8106: !  Make the singular value nonnegative.
8107: !
8108:         if ( s(l) < 0.0D+00 ) then
8109:            s(l) = -s(l)
8110:            if ( wantv ) then
8111:              call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( p, -1.0D+00, v(1,l), 1 )
8112:            end if
8113:         end if
8114: !
8115: !  Order the singular value.
8116: !
8117: 590     continue
8118: 
8119:         if ( l /= mm ) then
8120: 
8121:           if ( s(l) < s(l+1) ) then
8122: 
8123:             t = s(l)
8124:             s(l) = s(l+1)
8125:             s(l+1) = t
8126: 
8127:             if ( wantv .and. l < p ) then
8128:               call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( p, v(1,l), 1, v(1,l+1), 1 )
8129:             end if
8130: 
8131:             if ( wantu .and. l < n ) then
8132:               call <a href="./linpack.f90.html#sswap" TARGET=CENT_PANEL>sswap</a> ( n, u(1,l), 1, u(1,l+1), 1 )
8133:             end if
8134: 
8135:             l = l + 1
8136: 
8137:             go to 590
8138: 
8139:           end if
8140: 
8141:         end if
8142: 
8143:         iter = 0
8144:         m = m - 1
8145: 
8146:     end if
8147: 
8148:   end do
8149: 
8150:   return
8151: end
<p><a name=sswap><H3>sswap</H3></a></p> Click <a href="./callingtree/sswap_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sswap is used.
<hr>
8152: subroutine sswap ( n, x, incx, y, incy )
8153: !
8154: !*******************************************************************************
8155: !
8156: !! SSWAP interchanges two vectors.
8157: !
8158: !
8159: !  Reference:
8160: !
8161: !    Lawson, Hanson, Kincaid, Krogh,
8162: !    Basic Linear Algebra Subprograms for Fortran Usage,
8163: !    Algorithm 539,
8164: !    ACM Transactions on Mathematical Software,
8165: !    Volume 5, Number 3, September 1979, pages 308-323.
8166: !
8167: !  Modified:
8168: !
8169: !    08 April 1999
8170: !
8171: !  Parameters:
8172: !
8173: !    Input, integer N, the number of entries in the vectors.
8174: !
8175: !    Input/output, real(8) X(*), one of the vectors to swap.
8176: !
8177: !    Input, integer INCX, the increment between successive entries of X.
8178: !
8179: !    Input/output, real(8) Y(*), one of the vectors to swap.
8180: !
8181: !    Input, integer INCY, the increment between successive elements of Y.
8182: !
8183:   implicit none
8184: !
8185:   integer i
8186:   integer incx
8187:   integer incy
8188:   integer ix
8189:   integer iy
8190:   integer m
8191:   integer n
8192:   real(8) stemp
8193:   real(8) x(*)
8194:   real(8) y(*)
8195: !
8196:   if ( n <= 0 ) then
8197: 
8198:   else if ( incx == 1 .and. incy == 1 ) then
8199: 
8200:     m = mod ( n, 3 )
8201: 
8202:     do i = 1, m
8203:       stemp = x(i)
8204:       x(i) = y(i)
8205:       y(i) = stemp
8206:     end do
8207: 
8208:     do i = m+1, n, 3
8209: 
8210:       stemp = x(i)
8211:       x(i) = y(i)
8212:       y(i) = stemp
8213: 
8214:       stemp = x(i + 1)
8215:       x(i + 1) = y(i + 1)
8216:       y(i + 1) = stemp
8217: 
8218:       stemp = x(i + 2)
8219:       x(i + 2) = y(i + 2)
8220:       y(i + 2) = stemp
8221: 
8222:     end do
8223: 
8224:   else
8225: 
8226:     if ( incx >= 0 ) then
8227:       ix = 1
8228:     else
8229:       ix = ( - n + 1 ) * incx + 1
8230:     end if
8231: 
8232:     if ( incy >= 0 ) then
8233:       iy = 1
8234:     else
8235:       iy = ( - n + 1 ) * incy + 1
8236:     end if
8237: 
8238:     do i = 1, n
8239:       stemp = x(ix)
8240:       x(ix) = y(iy)
8241:       y(iy) = stemp
8242:       ix = ix + incx
8243:       iy = iy + incy
8244:     end do
8245: 
8246:   end if
8247: 
8248:   return
8249: end
<p><a name=strco><H3>strco</H3></a></p> Click <a href="./callingtree/strco_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where strco is used.
<hr>
8250: subroutine strco ( t, ldt, n, rcond, z, job )
8251: !
8252: !*******************************************************************************
8253: !
8254: !! STRCO estimates the condition of a real(8) triangular matrix.
8255: !
8256: !
8257: !  Reference:
8258: !
8259: !    Dongarra, Moler, Bunch and Stewart,
8260: !    LINPACK User's Guide,
8261: !    SIAM, (Society for Industrial and Applied Mathematics),
8262: !    3600 University City Science Center,
8263: !    Philadelphia, PA, 19104-2688.
8264: !    ISBN 0-89871-172-X
8265: !
8266: !  Parameters:
8267: !
8268: !    Input, real(8) T(LDT,N), the triangular matrix.  The zero elements of 
8269: !    the matrix are not referenced, and the corresponding elements of the 
8270: !    array can be used to store other information.
8271: !
8272: !    Input, integer LDT, the leading dimension of the array T.
8273: !
8274: !    Input, integer N, the order of the matrix.
8275: !
8276: !    Input, integer JOB, indicates the shape of T:
8277: !    0, T is lower triangular.
8278: !    nonzero, T is upper triangular.
8279: !
8280: !    Output, real(8) RCOND, an estimate of the reciprocal condition of T.
8281: !    For the system T*X = B, relative perturbations in T and B of size  
8282: !    EPSILON may cause relative perturbations in X of size EPSILON/RCOND.
8283: !    If RCOND is so small that the logical expression
8284: !      1.0D+00 + RCOND == 1.0D+00
8285: !    is true, then T may be singular to working precision.  In particular,  
8286: !    RCOND is zero if exact singularity is detected or the estimate underflows.
8287: !
8288: !    Output, real(8) Z(N) a work vector whose contents are usually unimportant.
8289: !    If T is close to a singular matrix, then Z is an approximate null vector 
8290: !    in the sense that
8291: !      norm(A*Z) = RCOND * norm(A) * norm(Z).
8292: !
8293:   implicit none
8294: !
8295:   integer ldt
8296:   integer n
8297: !
8298:   real(8) ek
8299:   integer i1
8300:   integer j
8301:   integer j1
8302:   integer j2
8303:   integer job
8304:   integer k
8305:   integer kk
8306:   integer l
8307:   logical lower
8308:   real(8) rcond
8309:   real(8) s
8310:   real(8) sm
8311:   real(8) t(ldt,n)
8312:   real(8) tnorm
8313:   real(8) w
8314:   real(8) wk
8315:   real(8) wkm
8316:   real(8) ynorm
8317:   real(8) z(n)
8318: !
8319:   lower = job == 0
8320: !
8321: !  Compute the 1-norm of T.
8322: !
8323:   tnorm = 0.0D+00
8324: 
8325:   do j = 1, n
8326: 
8327:     if ( lower ) then
8328:       l = n + 1 - j
8329:       i1 = j
8330:     else
8331:       l = j
8332:       i1 = 1
8333:     end if
8334: 
8335:     tnorm = max ( tnorm, sum ( abs ( t(i1:i1+l-1,j) ) ) )
8336: 
8337:   end do
8338: !
8339: !  RCOND = 1/(norm(T)*(estimate of norm(inverse(T)))).
8340: !
8341: !  Estimate = norm(Z)/norm(Y) where T*Z = Y and T'*Y = E.
8342: !
8343: !  T' is the transpose of T.
8344: !
8345: !  The components of E are chosen to cause maximum local
8346: !  growth in the elements of Y.
8347: !
8348: !  The vectors are frequently rescaled to avoid overflow.
8349: !
8350: !  Solve T'*Y = E.
8351: !
8352:   ek = 1.0D+00
8353:   z(1:n) = 0.0D+00
8354: 
8355:   do kk = 1, n
8356: 
8357:      if ( lower ) then
8358:        k = n + 1 - kk
8359:      else
8360:        k = kk
8361:      end if
8362: 
8363:      if ( z(k) /= 0.0D+00 ) then
8364:        ek = sign ( ek, -z(k) )
8365:      end if
8366: 
8367:      if ( abs ( ek-z(k) ) > abs ( t(k,k) ) ) then
8368:        s = abs ( t(k,k) ) / abs ( ek - z(k) )
8369:        z(1:n) = s * z(1:n)
8370:        ek = s * ek
8371:      end if
8372: 
8373:      wk = ek - z(k)
8374:      wkm = -ek - z(k)
8375:      s = abs ( wk )
8376:      sm = abs ( wkm )
8377: 
8378:      if ( t(k,k) /= 0.0D+00 ) then
8379:        wk = wk / t(k,k)
8380:        wkm = wkm / t(k,k)
8381:      else
8382:        wk = 1.0D+00
8383:        wkm = 1.0D+00
8384:      end if
8385: 
8386:      if ( kk /= n ) then
8387: 
8388:         if ( lower ) then
8389:           j1 = 1
8390:           j2 = k - 1
8391:         else
8392:           j1 = k + 1
8393:           j2 = n
8394:         end if
8395: 
8396:         do j = j1, j2
8397:           sm = sm + abs ( z(j) + wkm * t(k,j) )
8398:           z(j) = z(j) + wk * t(k,j)
8399:           s = s + abs ( z(j) )
8400:         end do
8401: 
8402:         if ( s < sm ) then
8403:           w = wkm - wk
8404:           wk = wkm
8405:           z(j1:j2) = z(j1:j2) + w * t(k,j1:j2)
8406:         end if
8407: 
8408:      end if
8409: 
8410:      z(k) = wk
8411: 
8412:   end do
8413: 
8414:   z(1:n) = z(1:n) / sum ( abs ( z(1:n) ) )
8415: 
8416:   ynorm = 1.0D+00
8417: !
8418: !  Solve T*Z = Y.
8419: !
8420:   do kk = 1, n
8421: 
8422:      if ( lower ) then
8423:        k = kk
8424:      else
8425:        k = n + 1 - kk
8426:      end if
8427: 
8428:      if ( abs ( z(k) ) > abs ( t(k,k) ) ) then
8429:        s = abs ( t(k,k) ) / abs ( z(k) )
8430:        z(1:n) = s * z(1:n)
8431:        ynorm = s * ynorm
8432:      end if
8433: 
8434:      if ( t(k,k) /= 0.0D+00 ) then
8435:        z(k) = z(k) / t(k,k)
8436:      else
8437:        z(k) = 1.0D+00
8438:      end if
8439: 
8440:      if ( lower ) then
8441:        i1 = k + 1
8442:      else
8443:        i1 = 1
8444:      end if
8445: 
8446:      if ( kk < n ) then
8447:        w = -z(k)
8448:        call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-kk, w, t(i1,k), 1, z(i1), 1 )
8449:      end if
8450: 
8451:   end do
8452: !
8453: !  Make ZNORM = 1.0.
8454: !
8455:   s = 1.0D+00 / sum ( abs ( z(1:n) ) )
8456:   z(1:n) = s * z(1:n)
8457:   ynorm = s * ynorm
8458: 
8459:   if ( tnorm /= 0.0D+00 ) then
8460:     rcond = ynorm / tnorm
8461:   else
8462:     rcond = 0.0D+00
8463:   end if
8464: 
8465:   return
8466: end
<p><a name=strdi><H3>strdi</H3></a></p> Click <a href="./callingtree/strdi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where strdi is used.
<hr>
8467: subroutine strdi ( t, ldt, n, det, job, info )
8468: !
8469: !***********************************************************************
8470: !
8471: !! STRDI computes the determinant and inverse of a real(8) triangular matrix.
8472: !
8473: !
8474: !  Modified:
8475: !
8476: !    07 March 2001
8477: !
8478: !  Reference:
8479: !
8480: !    Dongarra, Moler, Bunch and Stewart,
8481: !    LINPACK User's Guide,
8482: !    SIAM, (Society for Industrial and Applied Mathematics),
8483: !    3600 University City Science Center,
8484: !    Philadelphia, PA, 19104-2688.
8485: !    ISBN 0-89871-172-X
8486: !
8487: !  Parameters:
8488: !
8489: !    Input/output, real(8) T(LDT,N).
8490: !    On input, T contains the triangular matrix. The zero elements of the
8491: !    matrix are not referenced, and the corresponding elements of the array
8492: !    can be used to store other information.
8493: !    On output, T contains the inverse matrix, if it was requested.
8494: !
8495: !    Input, integer LDT, the leading dimension of T.
8496: !
8497: !    Input, integer N, the order of the matrix.
8498: !
8499: !    Output, real(8) DET(2), the determinant of the matrix, if requested.
8500: !    The determinant = DET(1) * 10.0**DET(2), with 1.0 <= abs ( DET(1) ) < 10.0,
8501: !    or DET(1) == 0.
8502: !
8503: !    Input, integer JOB, specifies the shape of T, and the task.
8504: !    010, inverse of lower triangular matrix.
8505: !    011, inverse of upper triangular matrix.
8506: !    100, determinant only.
8507: !    110, determinant and inverse of lower triangular.
8508: !    111, determinant and inverse of upper triangular.
8509: !
8510: !    Output, integer INFO.
8511: !    If the inverse was requested, then
8512: !    0, if the system was nonsingular;
8513: !    nonzero, if the system was singular.
8514: !
8515:   implicit none
8516: !
8517:   integer ldt
8518:   integer n
8519: !
8520:   real(8) det(2)
8521:   integer i
8522:   integer info
8523:   integer j
8524:   integer job
8525:   integer k
8526:   real(8) t(ldt,n)
8527:   real(8) temp
8528:   real, parameter :: ten = 10.0D+00
8529: !
8530: !  Determinant.
8531: !
8532:   if ( job / 100 /= 0 ) then
8533: 
8534:     det(1) = 1.0D+00
8535:     det(2) = 0.0D+00
8536: 
8537:     do i = 1, n
8538: 
8539:       det(1) = t(i,i) * det(1)
8540: 
8541:       if ( det(1) == 0.0D+00 ) then
8542:         exit
8543:       end if
8544: 
8545:       do while ( abs ( det(1) ) < 1.0D+00 )
8546:         det(1) = ten * det(1)
8547:         det(2) = det(2) - 1.0D+00
8548:       end do
8549: 
8550:       do while ( abs ( det(1) ) >= ten )
8551:         det(1) = det(1) / ten
8552:         det(2) = det(2) + 1.0D+00
8553:       end do
8554: 
8555:     end do
8556: 
8557:   end if
8558: 
8559:   if ( mod ( job / 10, 10 ) == 0 ) then
8560:     return
8561:   end if
8562: !
8563: !  Inverse of an upper triangular matrix.
8564: !
8565:   if ( mod ( job,10 ) /= 0 ) then
8566: 
8567:     info = 0
8568: 
8569:     do k = 1, n
8570: 
8571:       if ( t(k,k) == 0.0D+00 ) then
8572:         info = k
8573:         exit
8574:       end if
8575: 
8576:       t(k,k) = 1.0D+00 / t(k,k)
8577:       temp = -t(k,k)
8578:       call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( k-1, temp, t(1,k), 1 )
8579: 
8580:       do j = k + 1, n
8581:         temp = t(k,j)
8582:         t(k,j) = 0.0D+00
8583:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( k, temp, t(1,k), 1, t(1,j), 1 )
8584:       end do
8585: 
8586:     end do
8587: !
8588: !  Inverse of a lower triangular matrix.
8589: !
8590:   else
8591: 
8592:     info = 0
8593: 
8594:     do k = n, 1, -1
8595: 
8596:       if ( t(k,k) == 0.0D+00 ) then
8597:         info = k
8598:         exit
8599:       end if
8600: 
8601:       t(k,k) = 1.0D+00 / t(k,k)
8602:       temp = -t(k,k)
8603: 
8604:       if ( k /= n ) then
8605:         call <a href="./linpack.f90.html#sscal" TARGET=CENT_PANEL>sscal</a> ( n-k, temp, t(k+1,k), 1 )
8606:       end if
8607: 
8608:       do j = 1, k-1
8609:         temp = t(k,j)
8610:         t(k,j) = 0.0D+00
8611:         call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-k+1, temp, t(k,k), 1, t(k,j), 1 )
8612:       end do
8613: 
8614:     end do
8615: 
8616:   end if
8617: 
8618:   return
8619: end
<p><a name=strsl><H3>strsl</H3></a></p> Click <a href="./callingtree/strsl_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where strsl is used.
<hr>
8620: subroutine strsl ( t, ldt, n, b, job, info )
8621: !
8622: !*******************************************************************************
8623: !
8624: !! STRSL solves triangular linear systems.
8625: !
8626: !
8627: !  Discussion:
8628: !
8629: !    STRSL can solve T * X = B or T' * X = B where T is a triangular 
8630: !    matrix of order N. 
8631: !
8632: !    Here T' denotes the transpose of the matrix T.
8633: !
8634: !  Reference:
8635: !
8636: !    Dongarra, Moler, Bunch and Stewart,
8637: !    LINPACK User's Guide,
8638: !    SIAM, (Society for Industrial and Applied Mathematics),
8639: !    3600 University City Science Center,
8640: !    Philadelphia, PA, 19104-2688.
8641: !    ISBN 0-89871-172-X
8642: !
8643: !  Parameters:
8644: !
8645: !    Input, real(8) T(LDT,N), the matrix of the system.  The zero elements of 
8646: !    the matrix are not referenced, and the corresponding elements of the 
8647: !    array can be used to store other information.
8648: !
8649: !    Input, integer LDT, the leading dimension of the array T.
8650: !
8651: !    Input, integer N, the order of the matrix.
8652: !
8653: !    Input/output, real(8) B(N).  On input, the right hand side.
8654: !    On output, the solution.
8655: !
8656: !    Input, integer JOB, specifies what kind of system is to be solved:
8657: !
8658: !    00, solve T * X = B, T lower triangular,
8659: !    01, solve T * X = B, T upper triangular,
8660: !    10, solve T'* X = B, T lower triangular,
8661: !    11, solve T'* X = B, T upper triangular.
8662: !
8663: !    Output, integer INFO, singularity indicator.
8664: !    0, the system is nonsingular.
8665: !    nonzero, the index of the first zero diagonal element of T.
8666: !
8667:   implicit none
8668: !
8669:   integer ldt
8670:   integer n
8671: !
8672:   real(8) b(n)
8673:   integer icase
8674:   integer info
8675:   integer j
8676:   integer jj
8677:   integer job
8678:   real(8) sdot
8679:   real(8) t(ldt,n)
8680:   real(8) temp
8681: !
8682: !  Check for zero diagonal elements.
8683: !
8684:   do j = 1, n
8685:     if ( t(j,j) == 0.0D+00 ) then
8686:       info = j
8687:       return
8688:     end if
8689:   end do
8690: 
8691:   info = 0
8692: !
8693: !  Determine the task and go to it.
8694: !
8695:      if ( mod ( job, 10 ) == 0 ) then
8696:        icase = 1
8697:      else
8698:        icase = 2
8699:      end if
8700: 
8701:      if ( mod ( job, 100 ) / 10 /= 0 ) then
8702:        icase = icase + 2
8703:      end if
8704: !
8705: !  Solve T*X=B for T lower triangular.
8706: !
8707:   if ( icase == 1 ) then
8708: 
8709:     b(1) = b(1) / t(1,1)
8710: 
8711:     do j = 2, n
8712:       temp = -b(j-1)
8713:       call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( n-j+1, temp, t(j,j-1), 1, b(j), 1 )
8714:       b(j) = b(j) / t(j,j)
8715:     end do
8716: !
8717: !  Solve T*X=B for T upper triangular.
8718: !
8719:   else if ( icase == 2 ) then
8720: 
8721:     b(n) = b(n) / t(n,n)
8722: 
8723:     do jj = 2, n
8724:       j = n - jj + 1
8725:       temp = -b(j+1)
8726:       call <a href="./linpack.f90.html#saxpy" TARGET=CENT_PANEL>saxpy</a> ( j, temp, t(1,j+1), 1, b(1), 1 )
8727:       b(j) = b(j) / t(j,j)
8728:     end do
8729: !
8730: !  Solve T'*X=B for T lower triangular.
8731: !
8732:   else if ( icase == 3 ) then
8733: 
8734:     b(n) = b(n) / t(n,n)
8735:  
8736:     do jj = 2, n
8737:       j = n - jj + 1
8738:       b(j) = b(j) - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( jj-1, t(j+1,j), 1, b(j+1), 1 )
8739:       b(j) = b(j) / t(j,j)
8740:     end do
8741: !
8742: !  Solve T'*X=B for T upper triangular.
8743: !
8744:   else if ( icase == 4 ) then
8745: 
8746:     b(1) = b(1) / t(1,1)
8747: 
8748:     do j = 2, n
8749:       b(j) = b(j) - <a href="./linpack.f90.html#sdot" TARGET=CENT_PANEL>sdot</a> ( j-1, t(1,j), 1, b(1), 1 )
8750:       b(j) = b(j) / t(j,j)
8751:     end do
8752: 
8753:   end if
8754: 
8755:   return
8756: end
</PRE>

<HR>

</BODY>
</HTML>
