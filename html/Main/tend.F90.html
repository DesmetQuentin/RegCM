<HTML>

<HEAD>
<TITLE>tend.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>tend.F90</H1>
<HR>
<H2 ALIGN=CENTER>tend.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=tend><H3>tend</H3></a></p> Click <a href="./callingtree/tend_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tend is used.
<hr>
20:       subroutine tend(iexec)
21: 
22: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
23: !                                                                     c
24: !     this subroutine computes the tendencies of the prognostic       c
25: !     variables p*, u, v, and t.                                      c
26: !                                                                     c
27: !     p*u, p*v, p*t ,p*qv, and p*qc stored in main common block.      c
28: !                                                                     c
29: !     all the two-dimension arrays stored in main common block.       c
30: !                                                                     c
31: !     east/west boundary conditions stored in common block /bdycod/ . c
32: !                                                                     c
33: !     north/south boundary conditions stored in common block          c
34: !              /bdycod/.                                              c
35: !                                                                     c
36: !     all the integers stored in common block /param1/.               c
37: !                                                                     c
38: !     all the constants stored in common block /param1/.              c
39: !                                                                     c
40: !     iexec  : = 1 ; represents this subroutine is called for the     c
41: !                    first time in this forecast run.                 c
42: !              > 1 ; represents subsequent calls to this subroutine.  c
43: !                                                                     c
44: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
45: !
46:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
47:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a>
48:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a>
49:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : dsigma , a , wgtx , wgtd , r8pt , ispgx , &
50:                    & ispgd , akht1
51:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
52:       use <a href="./mod_mainchem.F90.html#mod_mainchem" TARGET=CENT_PANEL>mod_mainchem</a>
53:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a>
54:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
55:       use <a href="./mod_pmoist.F90.html#mod_pmoist" TARGET=CENT_PANEL>mod_pmoist</a>
56:       use <a href="./mod_rad.F90.html#mod_rad" TARGET=CENT_PANEL>mod_rad</a>
57:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a>
58:       use <a href="./mod_trachem.F90.html#mod_trachem" TARGET=CENT_PANEL>mod_trachem</a>
59:       use <a href="./mod_cu_grell.f90.html#mod_cu_grell" TARGET=CENT_PANEL>mod_cu_grell</a> , only : cuparan
60:       use <a href="./mod_cu_kuo.f90.html#mod_cu_kuo" TARGET=CENT_PANEL>mod_cu_kuo</a> , only : cupara
61:       use <a href="./mod_cu_bm.F90.html#mod_cu_bm" TARGET=CENT_PANEL>mod_cu_bm</a> , only : bmpara
62:       use <a href="./mod_cu_em.f90.html#mod_cu_em" TARGET=CENT_PANEL>mod_cu_em</a> , only : cupemandrv
63:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : dectim , nnnnnn , nstrt0 , lyear , lmonth , &
64:                    & lday , lhour , ldatez , idate0 , idate1 , jyear ,  &
65:                    & jyear0 , ntime , ktau , xtime , finddate
66:       use <a href="./mod_message.F90.html#mod_message" TARGET=CENT_PANEL>mod_message</a>
67:       use <a href="./mod_aerosol.F90.html#mod_aerosol" TARGET=CENT_PANEL>mod_aerosol</a> , only : aermm
68:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgti , rgas , cpd , ep1 , gnu , omu ,  &
69:                    & gnuhf , omuhf , alpha , beta , t00pg , p00pg ,     &
70:                    & pgfaa1
71:       use <a href="./mod_zengocn.F90.html#mod_zengocn" TARGET=CENT_PANEL>mod_zengocn</a> , only : zengocndrv
72: #ifdef MPP1
73:       use <a href="./mod_slice.F90.html#mod_slice" TARGET=CENT_PANEL>mod_slice</a>
74: #ifdef CLM
75:       use <a href="./mod_clm.F90.html#mod_clm" TARGET=CENT_PANEL>mod_clm</a>
76:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a> , only : init_grid
77: #endif
78: #ifndef IBM
79:       use <a href="#" TARGET=CENT_PANEL>mpi</a>
80: #else
81:       include 'mpif.h'
82: #endif
83: #endif
84:       implicit none
85: !
86: ! Dummy arguments
87: !
88:       integer :: iexec
89:       intent (inout) iexec
90: !
91: ! Local variables
92: !
93:       real(8) :: cell , chias , chibs , dto2 , dudx , dudy ,            &
94:                & dvdx , dvdy , psabar , psasum ,                        &
95:                & pt2bar , pt2tot , ptnbar , ptntot , qcas , qcbs ,      &
96:                & qvas , qvbs , rovcpm , rtbar , sigpsa , tv ,           &
97:                & tv1 , tv2 , tv3 , tv4 , tva , tvavg , tvb , tvc ,      &
98:                & xday , xmsf , xtm1
99:       real(8) , dimension(iy,kz) :: divl
100:       integer :: i , icons , iptn , itr , j , k , lev , n
101: #ifdef MPP1
102:       integer :: ierr , icons_mpi , numrec
103:       real(8) , dimension(iy,kz,jxp) :: ttld
104:       real(8) , dimension(iy,kz*16+4) :: bdyewrcv , bdyewsnd
105:       real(8) , dimension(nspgx,kz*16+4) :: bdynsrcv , bdynssnd
106:       real(8) , dimension(iy,4,jxp) :: ps4
107:       real(8) , dimension(iy,4,jx) :: ps_4 
108:       real(8) , dimension(iy,kz*(ntr+5)*2) :: var2rcv , var2snd
109:       real(8) , dimension(iy,kz*(ntr+11)+1) :: tvar1rcv , tvar1snd
110: #else
111:       real(8) , dimension(iy,kz,jx) :: ttld
112: #endif
113: !
114: !----------------------------------------------------------------------
115: !-----fill up the boundary slices:
116: !
117: !     if (iexec .eq. 1) then
118:       if ( .not.ifrest .and. iexec.eq.1 ) then
119:         call <a href="./bdyval.F90.html#bdyval" TARGET=CENT_PANEL>bdyval</a>(xtime,iexec)
120:         iexec = 2
121:       else
122:         iexec = 2
123:       end if
124: !
125: !----------------------------------------------------------------------
126: !*****for large domain, subroutine tend just needed to go through once.
127: !
128: !-----multiply ua and va by inverse of mapscale factor at dot point:
129: !
130: #ifdef MPP1
131:       do j = 1 , jendl
132: #else
133:       do j = 1 , jx
134: #endif
135:         do k = 1 , kz
136:           do i = 1 , iy
137:             ua(i,k,j) = ua(i,k,j)*msfd(i,j)
138:             va(i,k,j) = va(i,k,j)*msfd(i,j)
139:           end do
140:         end do
141:       end do
142: #ifdef MPP1
143:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(psa(1,jxp),iy,mpi_real8,ieast,1,                &
144:                       & psa(1,0),iy,mpi_real8,iwest,1,                  &
145:                       & mpi_comm_world,mpi_status_ignore,ierr)
146:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(psa(1,1),iy,mpi_real8,iwest,2,                  &
147:                       & psa(1,jxp+1),iy,mpi_real8,ieast,2,              &
148:                       & mpi_comm_world,mpi_status_ignore,ierr)
149: #endif
150: !
151: !-----decouple u, v, t, qv, and qc
152: !
153: #ifdef MPP1
154:       do j = 1 , jendl
155:         if ( myid.eq.0 .and. j.eq.1 ) then
156: #else
157:       do j = 1 , jx
158:         if ( j.eq.1 ) then
159: #endif
160: !-----------lateral slices:
161: !-----------west boundary:
162:           do k = 1 , kz
163:             do i = 1 , iy
164:               u(i,k,j) = uj1(i,k)
165:               v(i,k,j) = vj1(i,k)
166:             end do
167:           end do
168:           if ( iboudy.eq.3 .or. iboudy.eq.4 ) then
169: !..............inflow/outflow dependence:
170:             do k = 1 , kz
171:               do i = 1 , iy
172:                 if ( u(i,k,j).lt.0. ) then
173:                   v(i,k,j) = vj2(i,k)
174:                   u(i,k,j) = uj2(i,k)
175:                 end if
176:               end do
177:             end do
178:           end if
179: #ifdef MPP1
180:         else if ( myid.eq.0 .and. j.eq.2 ) then
181: #else
182:         else if ( j.eq.2 ) then
183: #endif
184:           do k = 1 , kz
185:             do i = 1 , iy
186:               u(i,k,j) = uj2(i,k)
187:               v(i,k,j) = vj2(i,k)
188:             end do
189:           end do
190:           if ( iboudy.eq.3 .or. iboudy.eq.4 ) then
191: !..............inflow/outflow dependence:
192:             do k = 1 , kz
193: !.................south boundary:
194:               if ( v(1,k,j).lt.0. ) then
195:                 v(1,k,j) = v(2,k,j)
196:                 u(1,k,j) = u(2,k,j)
197:               end if
198: !.................north boundary:
199:               if ( v(iy,k,j).ge.0. ) then
200:                 v(iy,k,j) = v(iym1,k,j)
201:                 u(iy,k,j) = u(iym1,k,j)
202:               end if
203:             end do
204:           end if
205: #ifdef MPP1
206:         else if ( myid.eq.nproc-1 .and. j.eq.jendl-1 ) then
207: #else
208:         else if ( j.eq.jxm1 ) then
209: #endif
210:           do k = 1 , kz
211:             do i = 1 , iy
212:               u(i,k,j) = ujlx(i,k)
213:               v(i,k,j) = vjlx(i,k)
214:             end do
215:           end do
216:           if ( iboudy.eq.3 .or. iboudy.eq.4 ) then
217: !..............inflow/outflow dependence:
218:             do k = 1 , kz
219: !.................south boundary:
220:               if ( v(1,k,j).lt.0. ) then
221:                 v(1,k,j) = v(2,k,j)
222:                 u(1,k,j) = u(2,k,j)
223:               end if
224: !.................north boundary:
225:               if ( v(iy,k,j).ge.0. ) then
226:                 v(iy,k,j) = v(iym1,k,j)
227:                 u(iy,k,j) = u(iym1,k,j)
228:               end if
229:             end do
230:           end if
231: #ifdef MPP1
232:         else if ( myid.eq.nproc-1 .and. j.eq.jendl ) then
233: #else
234:         else if ( j.eq.jx ) then
235: #endif
236: !-----------east boundary:
237: !
238: !...........no inflow/outflow dependence:
239: !
240:           do k = 1 , kz
241:             do i = 1 , iy
242:               u(i,k,j) = ujl(i,k)
243:               v(i,k,j) = vjl(i,k)
244:             end do
245:           end do
246:           if ( iboudy.eq.3 .or. iboudy.eq.4 ) then
247: !..............inflow/outflow dependence:
248:             do k = 1 , kz
249:               do i = 1 , iy
250:                 if ( u(i,k,j).ge.0. ) then
251:                   v(i,k,j) = vjlx(i,k)
252:                   u(i,k,j) = ujlx(i,k)
253:                 end if
254:               end do
255:             end do
256:           end if
257:         else
258: !
259: !-----interior slice:
260: !-----interior points:
261: !
262:           do k = 1 , kz
263:             do i = 3 , iym2
264:               psabar = 0.25*(psa(i,j)+psa(i,j-1)+                       &
265:                      &       psa(i-1,j)+psa(i-1,j-1))
266:               xmsf = msfd(i,j)
267:               u(i,k,j) = ua(i,k,j)/(psabar*xmsf)
268:               v(i,k,j) = va(i,k,j)/(psabar*xmsf)
269:             end do
270:           end do
271: !
272: !-----------north/south boundary points:
273: !...........no inflow/outflow dependence:
274: !
275:           do k = 1 , kz
276: !..............for i=2 and i=iym1:
277:             u(2,k,j) = ui2(k,j)
278:             u(iym1,k,j) = uilx(k,j)
279:             v(2,k,j) = vi2(k,j)
280:             v(iym1,k,j) = vilx(k,j)
281: !..............for i=1 and i=ix:
282:             u(1,k,j) = ui1(k,j)
283:             u(iy,k,j) = uil(k,j)
284:             v(1,k,j) = vi1(k,j)
285:             v(iy,k,j) = vil(k,j)
286:           end do
287:           if ( iboudy.eq.3 .or. iboudy.eq.4 ) then
288: !..............inflow/outflow dependence:
289:             do k = 1 , kz
290: !.................south boundary:
291:               if ( v(1,k,j).lt.0. ) then
292:                 v(1,k,j) = v(2,k,j)
293:                 u(1,k,j) = u(2,k,j)
294:               end if
295: !.................north boundary:
296:               if ( v(iy,k,j).ge.0. ) then
297:                 v(iy,k,j) = v(iym1,k,j)
298:                 u(iy,k,j) = u(iym1,k,j)
299:               end if
300:             end do
301:           end if
302:         end if
303:       end do
304: !
305: #ifdef MPP1
306:       do j = 1 , jendx
307: #else
308:       do j = 1 , jxm1
309: #endif
310:         do k = 1 , kz
311:           do i = 1 , iym1
312:             t(i,k,j) = ta(i,k,j)/psa(i,j)
313:             qv(i,k,j) = qva(i,k,j)/psa(i,j)
314:             qc(i,k,j) = qca(i,k,j)/psa(i,j)
315:           end do
316:         end do
317:       end do
318: !chem2
319:       if ( ichem.eq.1 ) then
320: !
321: !-----call special tracer decoupling routine for multiple (ntr) species
322: !
323:         do n = 1 , ntr
324: #ifdef MPP1
325:           do j = 1 , jendx
326: #else
327:           do j = 1 , jxm1
328: #endif
329:             do k = 1 , kz
330:               do i = 1 , iym1
331:                 chi(i,k,j,n) = chia(i,k,j,n)/psa(i,j)
332:               end do
333:             end do
334:           end do
335:         end do
336:       end if
337: !chem2_
338: !
339: !=======================================================================
340: #ifdef MPP1
341:       if ( myid.ne.nproc-1 ) then
342:         do i = 1 , iy
343:           tvar1snd(i,1) = psb(i,jxp)
344:         end do
345:         do k = 1 , kz
346:           do i = 1 , iy
347:             tvar1snd(i,1+k) = tb(i,k,jxp)
348:             tvar1snd(i,1+kz+k) = qvb(i,k,jxp)
349:             tvar1snd(i,1+kz*2+k) = ub(i,k,jxp)
350:             tvar1snd(i,1+kz*3+k) = vb(i,k,jxp)
351:             tvar1snd(i,1+kz*4+k) = u(i,k,jxp)
352:             tvar1snd(i,1+kz*5+k) = v(i,k,jxp)
353:             tvar1snd(i,1+kz*6+k) = t(i,k,jxp)
354:             tvar1snd(i,1+kz*7+k) = qv(i,k,jxp)
355:             tvar1snd(i,1+kz*8+k) = qc(i,k,jxp)
356:             tvar1snd(i,1+kz*9+k) = ua(i,k,jxp)
357:             tvar1snd(i,1+kz*10+k) = va(i,k,jxp)
358:           end do
359:         end do
360:         if ( ichem.eq.1 ) then
361:           do n = 1 , ntr
362:             do k = 1 , kz
363:               do i = 1 , iy
364:                 tvar1snd(i,kz*11+1+(n-1)*kz+k) = chi(i,k,jxp,n)
365:               end do
366:             end do
367:           end do
368:         end if
369:       end if
370:       numrec = kz*11 + 1
371:       if ( ichem.eq.1 ) numrec = kz*(ntr+11) + 1
372:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(tvar1snd(1,1),iy*numrec,mpi_real8,              &
373:                       & ieast,1,tvar1rcv(1,1),iy*numrec,                &
374:                       & mpi_real8,iwest,1,mpi_comm_world,               &
375:                       & mpi_status_ignore,ierr)
376:       if ( myid.ne.0 ) then
377:         do i = 1 , iy
378:           psb(i,0) = tvar1rcv(i,1)
379:         end do
380:         do k = 1 , kz
381:           do i = 1 , iy
382:             tb(i,k,0) = tvar1rcv(i,1+k)
383:             qvb(i,k,0) = tvar1rcv(i,1+kz+k)
384:             ub(i,k,0) = tvar1rcv(i,1+kz*2+k)
385:             vb(i,k,0) = tvar1rcv(i,1+kz*3+k)
386:             u(i,k,0) = tvar1rcv(i,1+kz*4+k)
387:             v(i,k,0) = tvar1rcv(i,1+kz*5+k)
388:             t(i,k,0) = tvar1rcv(i,1+kz*6+k)
389:             qv(i,k,0) = tvar1rcv(i,1+kz*7+k)
390:             qc(i,k,0) = tvar1rcv(i,1+kz*8+k)
391:             ua(i,k,0) = tvar1rcv(i,1+kz*9+k)
392:             va(i,k,0) = tvar1rcv(i,1+kz*10+k)
393:           end do
394:         end do
395:         if ( ichem.eq.1 ) then
396:           do n = 1 , ntr
397:             do k = 1 , kz
398:               do i = 1 , iy
399:                 chi(i,k,0,n) = tvar1rcv(i,kz*11+1+(n-1)*kz+k)
400:               end do
401:             end do
402:           end do
403:         end if
404:       end if
405: !
406:       if ( myid.ne.0 ) then
407:         do i = 1 , iy
408:           tvar1snd(i,1) = psb(i,1)
409:         end do
410:         do k = 1 , kz
411:           do i = 1 , iy
412:             tvar1snd(i,1+k) = tb(i,k,1)
413:             tvar1snd(i,1+kz+k) = qvb(i,k,1)
414:             tvar1snd(i,1+kz*2+k) = ub(i,k,1)
415:             tvar1snd(i,1+kz*3+k) = vb(i,k,1)
416:             tvar1snd(i,1+kz*4+k) = u(i,k,1)
417:             tvar1snd(i,1+kz*5+k) = v(i,k,1)
418:             tvar1snd(i,1+kz*6+k) = t(i,k,1)
419:             tvar1snd(i,1+kz*7+k) = qv(i,k,1)
420:             tvar1snd(i,1+kz*8+k) = qc(i,k,1)
421:             tvar1snd(i,1+kz*9+k) = ua(i,k,1)
422:             tvar1snd(i,1+kz*10+k) = va(i,k,1)
423:           end do
424:         end do
425:         if ( ichem.eq.1 ) then
426:           do n = 1 , ntr
427:             do k = 1 , kz
428:               do i = 1 , iy
429:                 tvar1snd(i,kz*11+1+(n-1)*kz+k) = chi(i,k,1,n)
430:               end do
431:             end do
432:           end do
433:         end if
434:       end if
435:       numrec = kz*11 + 1
436:       if ( ichem.eq.1 ) numrec = kz*(ntr+11) + 1
437:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(tvar1snd(1,1),iy*numrec,mpi_real8,              &
438:                       & iwest,2,tvar1rcv(1,1),iy*numrec,                &
439:                       & mpi_real8,ieast,2,mpi_comm_world,               &
440:                       & mpi_status_ignore,ierr)
441:       if ( myid.ne.nproc-1 ) then
442:         do i = 1 , iy
443:           psb(i,jxp+1) = tvar1rcv(i,1)
444:         end do
445:         do k = 1 , kz
446:           do i = 1 , iy
447:             tb(i,k,jxp+1) = tvar1rcv(i,1+k)
448:             qvb(i,k,jxp+1) = tvar1rcv(i,1+kz+k)
449:             ub(i,k,jxp+1) = tvar1rcv(i,1+kz*2+k)
450:             vb(i,k,jxp+1) = tvar1rcv(i,1+kz*3+k)
451:             u(i,k,jxp+1) = tvar1rcv(i,1+kz*4+k)
452:             v(i,k,jxp+1) = tvar1rcv(i,1+kz*5+k)
453:             t(i,k,jxp+1) = tvar1rcv(i,1+kz*6+k)
454:             qv(i,k,jxp+1) = tvar1rcv(i,1+kz*7+k)
455:             qc(i,k,jxp+1) = tvar1rcv(i,1+kz*8+k)
456:             ua(i,k,jxp+1) = tvar1rcv(i,1+kz*9+k)
457:             va(i,k,jxp+1) = tvar1rcv(i,1+kz*10+k)
458:           end do
459:         end do
460:         if ( ichem.eq.1 ) then
461:           do n = 1 , ntr
462:             do k = 1 , kz
463:               do i = 1 , iy
464:                 chi(i,k,jxp+1,n) = tvar1rcv(i,kz*11+1+(n-1)*kz+k)
465:               end do
466:             end do
467:           end do
468:         end if
469:       end if
470: #endif
471: !=======================================================================
472: !
473: !-----interior points:
474: !
475: #ifdef MPP1
476:       do j = jbegin , jendx
477: #else
478:       do j = 2 , jxm1
479: #endif
480:         do i = 2 , iym1
481:           pdotb(i,j) = 0.25*(psb(i,j)+psb(i-1,j)+                       &
482:                      &       psb(i,j-1)+psb(i-1,j-1))
483:         end do
484:       end do
485: !
486: !-----east and west boundaries:
487: !
488:       do i = 2 , iym1
489: #ifdef MPP1
490:         if ( myid.eq.0 ) pdotb(i,1) = 0.5*(psb(i,1)+psb(i-1,1))
491:         if ( myid.eq.nproc-1 )                                          &
492:            & pdotb(i,jendl) = 0.5*(psb(i,jendx)+psb(i-1,jendx))
493: #else
494:         pdotb(i,1) = 0.5*(psb(i,1)+psb(i-1,1))
495:         pdotb(i,jx) = 0.5*(psb(i,jxm1)+psb(i-1,jxm1))
496: #endif
497:       end do
498: !
499: !-----north and south boundaries:
500: !
501: #ifdef MPP1
502:       do j = jbegin , jendx
503: #else
504:       do j = 2 , jxm1
505: #endif
506:         pdotb(1,j) = 0.5*(psb(1,j)+psb(1,j-1))
507:         pdotb(iy,j) = 0.5*(psb(iym1,j)+psb(iym1,j-1))
508:       end do
509: !
510: !-----corner points:
511: !
512: #ifdef MPP1
513:       if ( myid.eq.0 ) then
514:         pdotb(1,1) = psb(1,1)
515:         pdotb(iy,1) = psb(iym1,1)
516:       end if
517:       if ( myid.eq.nproc-1 ) then
518:         pdotb(1,jendl) = psb(1,jendx)
519:         pdotb(iy,jendl) = psb(iym1,jendx)
520:       end if
521: #else
522:       pdotb(1,1) = psb(1,1)
523:       pdotb(iy,1) = psb(iym1,1)
524:       pdotb(1,jx) = psb(1,jxm1)
525:       pdotb(iy,jx) = psb(iym1,jxm1)
526: #endif
527: !
528: !=======================================================================
529: !
530:       call <a href="./slice3D.F90.html#slice3d" TARGET=CENT_PANEL>slice3d</a>
531: 
532: #ifdef CLM
533:       if ( init_grid ) then
534:         call <a href="./initclm.F90.html#initclm" TARGET=CENT_PANEL>initclm</a>(ktau)
535:         init_grid = .false.
536:       end if
537: #endif
538: !
539: !=======================================================================
540: !
541: #ifdef MPP1
542:       if ( myid.ne.nproc-1 ) then
543:         do k = 1 , kz
544:           do i = 1 , iy
545:             var2snd(i,+k) = ubd3d(i,k,jxp-1)
546:             var2snd(i,kz+k) = ubd3d(i,k,jxp)
547:             var2snd(i,kz*2+k) = vbd3d(i,k,jxp-1)
548:             var2snd(i,kz*3+k) = vbd3d(i,k,jxp)
549:             var2snd(i,kz*4+k) = tb3d(i,k,jxp-1)
550:             var2snd(i,kz*5+k) = tb3d(i,k,jxp)
551:             var2snd(i,kz*6+k) = qvb3d(i,k,jxp-1)
552:             var2snd(i,kz*7+k) = qvb3d(i,k,jxp)
553:             var2snd(i,kz*8+k) = qcb3d(i,k,jxp-1)
554:             var2snd(i,kz*9+k) = qcb3d(i,k,jxp)
555:           end do
556:         end do
557:         if ( ichem.eq.1 ) then
558:           do n = 1 , ntr
559:             do k = 1 , kz
560:               do i = 1 , iy
561:                 var2snd(i,kz*10+(n-1)*2*kz+k) = chib3d(i,k,jxp-1,n)
562:                 var2snd(i,kz*10+(n-1)*2*kz+kz+k) = chib3d(i,k,jxp,n)
563:               end do
564:             end do
565:           end do
566:         end if
567:       end if
568:       numrec = kz*5*2
569:       if ( ichem.eq.1 ) numrec = kz*(ntr+5)*2
570:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(var2snd(1,1),iy*numrec,mpi_real8,               &
571:                       & ieast,1,var2rcv(1,1),iy*numrec,                 &
572:                       & mpi_real8,iwest,1,mpi_comm_world,               &
573:                       & mpi_status_ignore,ierr)
574:       if ( myid.ne.0 ) then
575:         do k = 1 , kz
576:           do i = 1 , iy
577:             ubd3d(i,k,-1) = var2rcv(i,+k)
578:             ubd3d(i,k,0) = var2rcv(i,kz+k)
579:             vbd3d(i,k,-1) = var2rcv(i,kz*2+k)
580:             vbd3d(i,k,0) = var2rcv(i,kz*3+k)
581:             tb3d(i,k,-1) = var2rcv(i,kz*4+k)
582:             tb3d(i,k,0) = var2rcv(i,kz*5+k)
583:             qvb3d(i,k,-1) = var2rcv(i,kz*6+k)
584:             qvb3d(i,k,0) = var2rcv(i,kz*7+k)
585:             qcb3d(i,k,-1) = var2rcv(i,kz*8+k)
586:             qcb3d(i,k,0) = var2rcv(i,kz*9+k)
587:           end do
588:         end do
589:         if ( ichem.eq.1 ) then
590:           do n = 1 , ntr
591:             do k = 1 , kz
592:               do i = 1 , iy
593:                 chib3d(i,k,-1,n) = var2rcv(i,kz*10+(n-1)*2*kz+k)
594:                 chib3d(i,k,0,n) = var2rcv(i,kz*10+(n-1)*2*kz+kz+k)
595:               end do
596:             end do
597:           end do
598:         end if
599:       end if
600: !
601:       if ( myid.ne.0 ) then
602:         do k = 1 , kz
603:           do i = 1 , iy
604:             var2snd(i,+k) = ubd3d(i,k,1)
605:             var2snd(i,kz+k) = ubd3d(i,k,2)
606:             var2snd(i,kz*2+k) = vbd3d(i,k,1)
607:             var2snd(i,kz*3+k) = vbd3d(i,k,2)
608:             var2snd(i,kz*4+k) = tb3d(i,k,1)
609:             var2snd(i,kz*5+k) = tb3d(i,k,2)
610:             var2snd(i,kz*6+k) = qvb3d(i,k,1)
611:             var2snd(i,kz*7+k) = qvb3d(i,k,2)
612:             var2snd(i,kz*8+k) = qcb3d(i,k,1)
613:             var2snd(i,kz*9+k) = qcb3d(i,k,2)
614:           end do
615:         end do
616:         if ( ichem.eq.1 ) then
617:           do n = 1 , ntr
618:             do k = 1 , kz
619:               do i = 1 , iy
620:                 var2snd(i,kz*10+(n-1)*2*kz+k) = chib3d(i,k,1,n)
621:                 var2snd(i,kz*10+(n-1)*2*kz+kz+k) = chib3d(i,k,2,n)
622:               end do
623:             end do
624:           end do
625:         end if
626:       end if
627:       numrec = kz*5*2
628:       if ( ichem.eq.1 ) numrec = kz*(ntr+5)*2
629:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(var2snd(1,1),iy*numrec,mpi_real8,               &
630:                       & iwest,2,var2rcv(1,1),iy*numrec,                 &
631:                       & mpi_real8,ieast,2,mpi_comm_world,               &
632:                       & mpi_status_ignore,ierr)
633:       if ( myid.ne.nproc-1 ) then
634:         do k = 1 , kz
635:           do i = 1 , iy
636:             ubd3d(i,k,jxp+1) = var2rcv(i,+k)
637:             ubd3d(i,k,jxp+2) = var2rcv(i,kz+k)
638:             vbd3d(i,k,jxp+1) = var2rcv(i,kz*2+k)
639:             vbd3d(i,k,jxp+2) = var2rcv(i,kz*3+k)
640:             tb3d(i,k,jxp+1) = var2rcv(i,kz*4+k)
641:             tb3d(i,k,jxp+2) = var2rcv(i,kz*5+k)
642:             qvb3d(i,k,jxp+1) = var2rcv(i,kz*6+k)
643:             qvb3d(i,k,jxp+2) = var2rcv(i,kz*7+k)
644:             qcb3d(i,k,jxp+1) = var2rcv(i,kz*8+k)
645:             qcb3d(i,k,jxp+2) = var2rcv(i,kz*9+k)
646:           end do
647:         end do
648:         if ( ichem.eq.1 ) then
649:           do n = 1 , ntr
650:             do k = 1 , kz
651:               do i = 1 , iy
652:                 chib3d(i,k,jxp+1,n) = var2rcv(i,kz*10+(n-1)*2*kz+k)
653:                 chib3d(i,k,jxp+2,n) = var2rcv(i,kz*10+(n-1)*2*kz+kz+k)
654:               end do
655:             end do
656:           end do
657:         end if
658:       end if
659: #endif
660: !
661: !**********************************************************************
662: !***** "j" loop begins here:
663: !
664: #ifdef MPP1
665:       do j = 1 , jendx
666: #else
667:       do j = 1 , jxm1
668: #endif
669: !
670:         icon(j) = 0
671: #ifdef MPP1
672:         if ( (myid.eq.0 .and. j.eq.1) .or.                              &
673:            & (myid.eq.nproc-1 .and. j.eq.jendx) ) then
674: #else
675:         if ( j.eq.1 .or. j.eq.jxm1 ) then
676: #endif
677:           do k = 1 , kzp1
678:             do i = 1 , iym1
679:               qdot(i,k,j) = 0.
680:             end do
681:           end do
682:         else
683: !
684: !----------------------------------------------------------------------
685: !**p**compute the pressure tendency:
686: !
687:           do i = 2 , iym2
688:             pten(i,j) = 0.
689:           end do
690:           do k = 1 , kz
691:             do i = 2 , iym2
692:               divl(i,k) = (ua(i+1,k,j+1)+ua(i,k,j+1)-ua(i+1,k,j)        &
693:                         & -ua(i,k,j))                                   &
694:                         & + (va(i+1,k,j+1)+va(i+1,k,j)-va(i,k,j+1)      &
695:                         & -va(i,k,j))
696:               pten(i,j) = pten(i,j) - divl(i,k)*dsigma(k)               &
697:                         & /(dx2*msfx(i,j)*msfx(i,j))
698:             end do
699:           end do
700: !
701: !..p..compute vertical sigma-velocity (qdot):
702: !
703:           do k = 1 , kzp1
704:             do i = 1 , iym1
705:               qdot(i,k,j) = 0.
706:             end do
707:           end do
708:           do k = 2 , kz
709:             do i = 2 , iym2
710:               qdot(i,k,j) = qdot(i,k-1,j)                               &
711:                           & - (pten(i,j)+divl(i,k-1)/(dx2*msfx(i,j)     &
712:                           & *msfx(i,j)))*dsigma(k-1)/psa(i,j)
713:             end do
714:           end do
715:         end if
716:       end do
717: #ifdef MPP1
718:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(qdot(1,1,jxp),iy*kzp1,mpi_real8,                &
719:                       & ieast,1,qdot(1,1,0),iy*kzp1,                    &
720:                       & mpi_real8,iwest,1,mpi_comm_world,               &
721:                       & mpi_status_ignore,ierr)
722:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(qdot(1,1,1),iy*kzp1,mpi_real8,iwest,            &
723:                       & 2,qdot(1,1,jxp+1),iy*kzp1,mpi_real8,            &
724:                       & ieast,2,mpi_comm_world,mpi_status_ignore,ierr)
725: #endif
726: !
727: !..p..compute omega
728: !
729: #ifdef MPP1
730:       do j = 1 , jendx
731:         if ( (myid.eq.0 .and. j.eq.1) .or.                              &
732:            & (myid.eq.nproc-1 .and. j.eq.jendx) ) then
733: #else
734:       do j = 1 , jxm1
735:         if ( j.eq.1 .or. j.eq.jxm1 ) then
736: #endif
737:           do k = 1 , kz
738:             do i = 1 , iym1
739:               omega(i,k,j) = 0.
740:             end do
741:           end do
742:         else
743:           do k = 1 , kz
744:             do i = 2 , iym2
745:               omega(i,k,j) = 0.5*psa(i,j)*(qdot(i,k+1,j)+qdot(i,k,j))+  &
746:                            & a(k)*(pten(i,j)+((u(i,k,j)+u(i+1,k,j)+     &
747:                            & u(i+1,k,j+1)+u(i,k,j+1))*(psa(i,j+1)-      &
748:                            & psa(i,j-1))+(v(i,k,j)+v(i+1,k,j)+          &
749:                            & v(i+1,k,j+1)+v(i,k,j+1))*                  &
750:                            & (psa(i+1,j)-psa(i-1,j)))/(dx8*msfx(i,j)))
751:             end do
752:           end do
753:         end if
754:       end do
755: #ifdef MPP1
756:       if ( nspgx.ge.jxp ) then
757:         do i = 1 , iy
758:           bdyewsnd(i,1) = peb(i,1)
759:           bdyewsnd(i,2) = pwb(i,jxp)
760:           bdyewsnd(i,3) = pebt(i,1)
761:           bdyewsnd(i,4) = pwbt(i,jxp)
762:         end do
763:         do k = 1 , kz
764:           do i = 1 , iy
765:             bdyewsnd(i,4+k) = teb(i,k,1)
766:             bdyewsnd(i,4+kz+k) = twb(i,k,jxp)
767:             bdyewsnd(i,4+kz*2+k) = tebt(i,k,1)
768:             bdyewsnd(i,4+kz*3+k) = twbt(i,k,jxp)
769:             bdyewsnd(i,4+kz*4+k) = qeb(i,k,1)
770:             bdyewsnd(i,4+kz*5+k) = qwb(i,k,jxp)
771:             bdyewsnd(i,4+kz*6+k) = qebt(i,k,1)
772:             bdyewsnd(i,4+kz*7+k) = qwbt(i,k,jxp)
773:             bdyewsnd(i,4+kz*8+k) = ueb(i,k,1)
774:             bdyewsnd(i,4+kz*9+k) = uwb(i,k,jxp)
775:             bdyewsnd(i,4+kz*10+k) = uebt(i,k,1)
776:             bdyewsnd(i,4+kz*11+k) = uwbt(i,k,jxp)
777:             bdyewsnd(i,4+kz*12+k) = veb(i,k,1)
778:             bdyewsnd(i,4+kz*13+k) = vwb(i,k,jxp)
779:             bdyewsnd(i,4+kz*14+k) = vebt(i,k,1)
780:             bdyewsnd(i,4+kz*15+k) = vwbt(i,k,jxp)
781:           end do
782:         end do
783:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(bdyewsnd(1,1),iy*(kz*16+4),                   &
784:                         & mpi_real8,ieast,1,bdyewrcv(1,1),              &
785:                         & iy*(kz*16+4),mpi_real8,iwest,1,               &
786:                         & mpi_comm_world,mpi_status_ignore,ierr)
787:         do i = 1 , iy
788:           if ( myid.eq.nproc-1 ) then
789:             peb(i,jendl) = bdyewrcv(i,1)
790:             pebt(i,jendl) = bdyewrcv(i,3)
791:           else
792:             peb(i,jxp+1) = bdyewrcv(i,1)
793:             pebt(i,jxp+1) = bdyewrcv(i,3)
794:           end if
795:           pwb(i,0) = bdyewrcv(i,2)
796:           pwbt(i,0) = bdyewrcv(i,4)
797:         end do
798:         do k = 1 , kz
799:           do i = 1 , iy
800:             if ( myid.eq.nproc-1 ) then
801:               teb(i,k,jendl) = bdyewrcv(i,4+k)
802:               tebt(i,k,jendl) = bdyewrcv(i,4+kz*2+k)
803:               qeb(i,k,jendl) = bdyewrcv(i,4+kz*4+k)
804:               qebt(i,k,jendl) = bdyewrcv(i,4+kz*6+k)
805:             else
806:               teb(i,k,jxp+1) = bdyewrcv(i,4+k)
807:               tebt(i,k,jxp+1) = bdyewrcv(i,4+kz*2+k)
808:               qeb(i,k,jxp+1) = bdyewrcv(i,4+kz*4+k)
809:               qebt(i,k,jxp+1) = bdyewrcv(i,4+kz*6+k)
810:             end if
811:             ueb(i,k,jxp+1) = bdyewrcv(i,4+kz*8+k)
812:             uebt(i,k,jxp+1) = bdyewrcv(i,4+kz*10+k)
813:             veb(i,k,jxp+1) = bdyewrcv(i,4+kz*12+k)
814:             vebt(i,k,jxp+1) = bdyewrcv(i,4+kz*14+k)
815:             twb(i,k,0) = bdyewrcv(i,4+kz+k)
816:             twbt(i,k,0) = bdyewrcv(i,4+kz*3+k)
817:             qwb(i,k,0) = bdyewrcv(i,4+kz*5+k)
818:             qwbt(i,k,0) = bdyewrcv(i,4+kz*7+k)
819:             uwb(i,k,0) = bdyewrcv(i,4+kz*9+k)
820:             uwbt(i,k,0) = bdyewrcv(i,4+kz*11+k)
821:             vwb(i,k,0) = bdyewrcv(i,4+kz*13+k)
822:             vwbt(i,k,0) = bdyewrcv(i,4+kz*15+k)
823:           end do
824:         end do
825:         do i = 1 , iy
826:           if ( myid.eq.nproc-1 ) then
827:             bdyewsnd(i,1) = peb(i,jendx)
828:             bdyewsnd(i,3) = pebt(i,jendx)
829:           else
830:             bdyewsnd(i,1) = peb(i,jxp)
831:             bdyewsnd(i,3) = pebt(i,jxp)
832:           end if
833:           bdyewsnd(i,2) = pwb(i,1)
834:           bdyewsnd(i,4) = pwbt(i,1)
835:         end do
836:         do k = 1 , kz
837:           do i = 1 , iy
838:             if ( myid.eq.nproc-1 ) then
839:               bdyewsnd(i,4+k) = teb(i,k,jendx)
840:               bdyewsnd(i,4+kz*2+k) = tebt(i,k,jendx)
841:               bdyewsnd(i,4+kz*4+k) = qeb(i,k,jendx)
842:               bdyewsnd(i,4+kz*6+k) = qebt(i,k,jendx)
843:             else
844:               bdyewsnd(i,4+k) = teb(i,k,jxp)
845:               bdyewsnd(i,4+kz*2+k) = tebt(i,k,jxp)
846:               bdyewsnd(i,4+kz*4+k) = qeb(i,k,jxp)
847:               bdyewsnd(i,4+kz*6+k) = qebt(i,k,jxp)
848:             end if
849:             bdyewsnd(i,4+kz*8+k) = ueb(i,k,jxp)
850:             bdyewsnd(i,4+kz*10+k) = uebt(i,k,jxp)
851:             bdyewsnd(i,4+kz*12+k) = veb(i,k,jxp)
852:             bdyewsnd(i,4+kz*14+k) = vebt(i,k,jxp)
853:             bdyewsnd(i,4+kz+k) = twb(i,k,1)
854:             bdyewsnd(i,4+kz*3+k) = twbt(i,k,1)
855:             bdyewsnd(i,4+kz*5+k) = qwb(i,k,1)
856:             bdyewsnd(i,4+kz*7+k) = qwbt(i,k,1)
857:             bdyewsnd(i,4+kz*9+k) = uwb(i,k,1)
858:             bdyewsnd(i,4+kz*11+k) = uwbt(i,k,1)
859:             bdyewsnd(i,4+kz*13+k) = vwb(i,k,1)
860:             bdyewsnd(i,4+kz*15+k) = vwbt(i,k,1)
861:           end do
862:         end do
863:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(bdyewsnd(1,1),iy*(kz*16+4),                   &
864:                         & mpi_real8,iwest,2,bdyewrcv(1,1),              &
865:                         & iy*(kz*16+4),mpi_real8,ieast,2,               &
866:                         & mpi_comm_world,mpi_status_ignore,ierr)
867:         do i = 1 , iy
868:           peb(i,0) = bdyewrcv(i,1)
869:           pebt(i,0) = bdyewrcv(i,3)
870:           pwb(i,jxp+1) = bdyewrcv(i,2)
871:           pwbt(i,jxp+1) = bdyewrcv(i,4)
872:         end do
873:         do k = 1 , kz
874:           do i = 1 , iy
875:             teb(i,k,0) = bdyewrcv(i,4+k)
876:             twb(i,k,jxp+1) = bdyewrcv(i,4+kz+k)
877:             tebt(i,k,0) = bdyewrcv(i,4+kz*2+k)
878:             twbt(i,k,jxp+1) = bdyewrcv(i,4+kz*3+k)
879:             qeb(i,k,0) = bdyewrcv(i,4+kz*4+k)
880:             qwb(i,k,jxp+1) = bdyewrcv(i,4+kz*5+k)
881:             qebt(i,k,0) = bdyewrcv(i,4+kz*6+k)
882:             qwbt(i,k,jxp+1) = bdyewrcv(i,4+kz*7+k)
883:             ueb(i,k,0) = bdyewrcv(i,4+kz*8+k)
884:             uwb(i,k,jxp+1) = bdyewrcv(i,4+kz*9+k)
885:             uebt(i,k,0) = bdyewrcv(i,4+kz*10+k)
886:             uwbt(i,k,jxp+1) = bdyewrcv(i,4+kz*11+k)
887:             veb(i,k,0) = bdyewrcv(i,4+kz*12+k)
888:             vwb(i,k,jxp+1) = bdyewrcv(i,4+kz*13+k)
889:             vebt(i,k,0) = bdyewrcv(i,4+kz*14+k)
890:             vwbt(i,k,jxp+1) = bdyewrcv(i,4+kz*15+k)
891:           end do
892:         end do
893:       end if
894: !
895:       if ( myid.ne.nproc-1 ) then
896:         do i = 1 , nspgx
897:           bdynssnd(i,1) = pnb(i,jxp)
898:           bdynssnd(i,2) = pnbt(i,jxp)
899:           bdynssnd(i,3) = pss(i,jxp)
900:           bdynssnd(i,4) = psbt(i,jxp)
901:         end do
902:         do k = 1 , kz
903:           do i = 1 , nspgx
904:             bdynssnd(i,4+k) = tnb(i,k,jxp)
905:             bdynssnd(i,4+kz+k) = tnbt(i,k,jxp)
906:             bdynssnd(i,4+kz*2+k) = tsb(i,k,jxp)
907:             bdynssnd(i,4+kz*3+k) = tsbt(i,k,jxp)
908:             bdynssnd(i,4+kz*4+k) = qnb(i,k,jxp)
909:             bdynssnd(i,4+kz*5+k) = qnbt(i,k,jxp)
910:             bdynssnd(i,4+kz*6+k) = qsb(i,k,jxp)
911:             bdynssnd(i,4+kz*7+k) = qsbt(i,k,jxp)
912:             bdynssnd(i,4+kz*8+k) = unb(i,k,jxp)
913:             bdynssnd(i,4+kz*9+k) = unbt(i,k,jxp)
914:             bdynssnd(i,4+kz*10+k) = usb(i,k,jxp)
915:             bdynssnd(i,4+kz*11+k) = usbt(i,k,jxp)
916:             bdynssnd(i,4+kz*12+k) = vnb(i,k,jxp)
917:             bdynssnd(i,4+kz*13+k) = vnbt(i,k,jxp)
918:             bdynssnd(i,4+kz*14+k) = vsb(i,k,jxp)
919:             bdynssnd(i,4+kz*15+k) = vsbt(i,k,jxp)
920:           end do
921:         end do
922:       end if
923:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(bdynssnd(1,1),nspgx*(kz*16+4),                  &
924:                       & mpi_real8,ieast,1,bdynsrcv(1,1),                &
925:                       & nspgx*(kz*16+4),mpi_real8,iwest,1,              &
926:                       & mpi_comm_world,mpi_status_ignore,ierr)
927:       if ( myid.ne.0 ) then
928:         do i = 1 , nspgx
929:           pnb(i,0) = bdynsrcv(i,1)
930:           pnbt(i,0) = bdynsrcv(i,2)
931:           pss(i,0) = bdynsrcv(i,3)
932:           psbt(i,0) = bdynsrcv(i,4)
933:         end do
934:         do k = 1 , kz
935:           do i = 1 , nspgx
936:             tnb(i,k,0) = bdynsrcv(i,4+k)
937:             tnbt(i,k,0) = bdynsrcv(i,4+kz+k)
938:             tsb(i,k,0) = bdynsrcv(i,4+kz*2+k)
939:             tsbt(i,k,0) = bdynsrcv(i,4+kz*3+k)
940:             qnb(i,k,0) = bdynsrcv(i,4+kz*4+k)
941:             qnbt(i,k,0) = bdynsrcv(i,4+kz*5+k)
942:             qsb(i,k,0) = bdynsrcv(i,4+kz*6+k)
943:             qsbt(i,k,0) = bdynsrcv(i,4+kz*7+k)
944:             unb(i,k,0) = bdynsrcv(i,4+kz*8+k)
945:             unbt(i,k,0) = bdynsrcv(i,4+kz*9+k)
946:             usb(i,k,0) = bdynsrcv(i,4+kz*10+k)
947:             usbt(i,k,0) = bdynsrcv(i,4+kz*11+k)
948:             vnb(i,k,0) = bdynsrcv(i,4+kz*12+k)
949:             vnbt(i,k,0) = bdynsrcv(i,4+kz*13+k)
950:             vsb(i,k,0) = bdynsrcv(i,4+kz*14+k)
951:             vsbt(i,k,0) = bdynsrcv(i,4+kz*15+k)
952:           end do
953:         end do
954:       end if
955: !
956:       if ( myid.ne.0 ) then
957:         do i = 1 , nspgx
958:           bdynssnd(i,1) = pnb(i,1)
959:           bdynssnd(i,2) = pnbt(i,1)
960:           bdynssnd(i,3) = pss(i,1)
961:           bdynssnd(i,4) = psbt(i,1)
962:         end do
963:         do k = 1 , kz
964:           do i = 1 , nspgx
965:             bdynssnd(i,4+k) = tnb(i,k,1)
966:             bdynssnd(i,4+kz+k) = tnbt(i,k,1)
967:             bdynssnd(i,4+kz*2+k) = tsb(i,k,1)
968:             bdynssnd(i,4+kz*3+k) = tsbt(i,k,1)
969:             bdynssnd(i,4+kz*4+k) = qnb(i,k,1)
970:             bdynssnd(i,4+kz*5+k) = qnbt(i,k,1)
971:             bdynssnd(i,4+kz*6+k) = qsb(i,k,1)
972:             bdynssnd(i,4+kz*7+k) = qsbt(i,k,1)
973:             bdynssnd(i,4+kz*8+k) = unb(i,k,1)
974:             bdynssnd(i,4+kz*9+k) = unbt(i,k,1)
975:             bdynssnd(i,4+kz*10+k) = usb(i,k,1)
976:             bdynssnd(i,4+kz*11+k) = usbt(i,k,1)
977:             bdynssnd(i,4+kz*12+k) = vnb(i,k,1)
978:             bdynssnd(i,4+kz*13+k) = vnbt(i,k,1)
979:             bdynssnd(i,4+kz*14+k) = vsb(i,k,1)
980:             bdynssnd(i,4+kz*15+k) = vsbt(i,k,1)
981:           end do
982:         end do
983:       end if
984:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(bdynssnd(1,1),nspgx*(kz*16+4),                  &
985:                       & mpi_real8,iwest,2,bdynsrcv(1,1),                &
986:                       & nspgx*(kz*16+4),mpi_real8,ieast,2,              &
987:                       & mpi_comm_world,mpi_status_ignore,ierr)
988:       if ( myid.ne.nproc-1 ) then
989:         do i = 1 , nspgx
990:           pnb(i,jxp+1) = bdynsrcv(i,1)
991:           pnbt(i,jxp+1) = bdynsrcv(i,2)
992:           pss(i,jxp+1) = bdynsrcv(i,3)
993:           psbt(i,jxp+1) = bdynsrcv(i,4)
994:         end do
995:         do k = 1 , kz
996:           do i = 1 , nspgx
997:             tnb(i,k,jxp+1) = bdynsrcv(i,4+k)
998:             tnbt(i,k,jxp+1) = bdynsrcv(i,4+kz+k)
999:             tsb(i,k,jxp+1) = bdynsrcv(i,4+kz*2+k)
1000:             tsbt(i,k,jxp+1) = bdynsrcv(i,4+kz*3+k)
1001:             qnb(i,k,jxp+1) = bdynsrcv(i,4+kz*4+k)
1002:             qnbt(i,k,jxp+1) = bdynsrcv(i,4+kz*5+k)
1003:             qsb(i,k,jxp+1) = bdynsrcv(i,4+kz*6+k)
1004:             qsbt(i,k,jxp+1) = bdynsrcv(i,4+kz*7+k)
1005:             unb(i,k,jxp+1) = bdynsrcv(i,4+kz*8+k)
1006:             unbt(i,k,jxp+1) = bdynsrcv(i,4+kz*9+k)
1007:             usb(i,k,jxp+1) = bdynsrcv(i,4+kz*10+k)
1008:             usbt(i,k,jxp+1) = bdynsrcv(i,4+kz*11+k)
1009:             vnb(i,k,jxp+1) = bdynsrcv(i,4+kz*12+k)
1010:             vnbt(i,k,jxp+1) = bdynsrcv(i,4+kz*13+k)
1011:             vsb(i,k,jxp+1) = bdynsrcv(i,4+kz*14+k)
1012:             vsbt(i,k,jxp+1) = bdynsrcv(i,4+kz*15+k)
1013:           end do
1014:         end do
1015:       end if
1016: #endif
1017: 
1018: #ifdef MPP1
1019:       do j = jbegin , jendx
1020:         if ( myid.ne.nproc-1 .or. j.ne.jendx ) then
1021: #else
1022:       do j = 2 , jxm1
1023:         if ( j.ne.jxm1 ) then
1024: #endif
1025: !EES      omega change: I broke up the write onto two lines
1026: !         and commented out the if statment
1027: !
1028:           if ( iboudy.eq.4 ) then
1029: !..p..apply sponge boundary conditions to pten:
1030:             call <a href="./sponge.F90.html#sponge_p" TARGET=CENT_PANEL>sponge_p</a>(ispgx,wgtx,pten(1,j),j)
1031: !....apply  the nudging boundary conditions:
1032:           else if ( iboudy.eq.1 .or. iboudy.eq.5 ) then
1033:             xtm1 = xtime - dtmin
1034:             if ( dabs(xtime).lt.0.00001 .and. ldatez.gt.idate0 )        &
1035:                & xtm1 = -dtmin
1036:             call <a href="./nudge.F90.html#nudge_p" TARGET=CENT_PANEL>nudge_p</a>(ispgx,fnudge,gnudge,xtm1,pten(1,j),c203,j,     &
1037:                        & iboudy)
1038:           else
1039:           end if
1040:         end if     !end if(j.ne.jxm1) test
1041:       end do
1042: #ifdef MPP1
1043:       do j = 1 , jendx
1044:         if ( myid.eq.0 .and. j.eq.1 ) then
1045: #else
1046:       do j = 1 , jxm1
1047:         if ( j.eq.1 ) then
1048: #endif
1049:           do i = 1 , iym1
1050:             psc(i,j) = psb(i,j) + dt*pwbt(i,j)
1051:             psd(i,j) = psa(i,j)
1052:           end do
1053: #ifdef MPP1
1054:         else if ( myid.eq.nproc-1 .and. j.eq.jendx ) then
1055: #else
1056:         else if ( j.eq.jxm1 ) then
1057: #endif
1058:           do i = 1 , iym1
1059:             psd(i,j) = psa(i,j)
1060:           end do
1061:         else
1062: !
1063: !..p..forecast pressure:
1064: !
1065:           do i = 2 , iym2
1066:             psc(i,j) = psb(i,j) + pten(i,j)*dt
1067:           end do
1068: !
1069: !..p..weighted p* (psd)
1070: !
1071:           do i = 2 , iym2
1072:             psd(i,j) = psa(i,j)
1073:           end do
1074: !
1075:           psc(1,j) = psb(1,j) + dt*psbt(1,j)
1076:           psc(iym1,j) = psb(iym1,j) + dt*pnbt(1,j)
1077:           psd(1,j) = psa(1,j)
1078:           psd(iym1,j) = psa(iym1,j)
1079:         end if
1080:       end do
1081: #ifdef MPP1
1082:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(psd(1,jxp),iy,mpi_real8,ieast,1,                &
1083:                       & psd(1,0),iy,mpi_real8,iwest,1,                  &
1084:                       & mpi_comm_world,mpi_status_ignore,ierr)
1085: #endif
1086: !
1087: !-----compute bleck (1977) noise parameters:
1088: !
1089: #ifdef MPP1
1090:       do j = 1 , jendl
1091:         do i = 1 , iy
1092:           ps4(i,1,j) = pten(i,j)
1093:           ps4(i,2,j) = psc(i,j)
1094:           ps4(i,3,j) = psb(i,j)
1095:           ps4(i,4,j) = psa(i,j)
1096:         end do
1097:       end do
1098:       call <a href="#" TARGET=CENT_PANEL>mpi_gather</a>(ps4(1,1,1),iy*4*jxp,mpi_real8,                    &
1099:                     & ps_4(1,1,1),iy*4*jxp,mpi_real8,0,                 &
1100:                     & mpi_comm_world,ierr)
1101: #endif
1102:       iptn = 0
1103:       ptntot = 0.
1104:       pt2tot = 0.
1105: #ifdef MPP1
1106:       if ( myid.eq.0 ) then
1107:         do j = 2 , jxm2
1108:           if ( jyear.ne.jyear0 .or. ktau.ne.0 ) then
1109:             do i = 2 , iym2
1110:               iptn = iptn + 1
1111:               ptntot = ptntot + dabs(ps_4(i,1,j))
1112:               pt2tot = pt2tot +                                         &
1113:                      & dabs((ps_4(i,2,j)+ps_4(i,3,j)-2.*ps_4(i,4,j))    &
1114:                      & /(0.25*dt*dt))
1115:             end do
1116:           end if
1117:         end do
1118:       end if
1119:       call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(iptn,1,mpi_integer,0,mpi_comm_world,ierr)
1120:       call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ptntot,1,mpi_real8,0,mpi_comm_world,ierr)
1121:       call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(pt2tot,1,mpi_real8,0,mpi_comm_world,ierr)
1122: #else
1123:       do j = 2 , jxm1
1124:         if ( j.ne.jxm1 ) then
1125:           if ( jyear.ne.jyear0 .or. ktau.ne.0 ) then
1126:             do i = 2 , iym2
1127:               iptn = iptn + 1
1128:               ptntot = ptntot + dabs(pten(i,j))
1129:               pt2tot = pt2tot + dabs((psc(i,j)+psb(i,j)-2.*psa(i,j))    &
1130:                      & /(0.25*dt*dt))
1131:             end do
1132:           end if
1133:         end if
1134:       end do
1135: #endif
1136: !
1137: #ifdef MPP1
1138:       do j = jbegin , jendx
1139: #else
1140:       do j = 2 , jxm1
1141: #endif
1142: 
1143: !
1144: !------compute the horizontal diffusion coefficient and stored in xkc:
1145: !       the values are calculated at cross points, but they also used
1146: !       for dot-point variables.
1147:  
1148:         do k = 1 , kz
1149:           do i = 2 , iym1
1150:             dudx = ub(i,k,j+1) + ub(i+1,k,j+1) - ub(i,k,j) - ub(i+1,k,j)
1151:             dvdx = vb(i,k,j+1) + vb(i+1,k,j+1) - vb(i,k,j) - vb(i+1,k,j)
1152:             dudy = ub(i+1,k,j) + ub(i+1,k,j+1) - ub(i,k,j) - ub(i,k,j+1)
1153:             dvdy = vb(i+1,k,j) + vb(i+1,k,j+1) - vb(i,k,j) - vb(i,k,j+1)
1154: !fil        cell=(xkhz*hgfact(i,j)/5.+c200*dsqrt((dudx-dvdy)*(dudx-dvdy)
1155:             cell = (xkhz*hgfact(i,j)                                    &
1156:                  & +c200*dsqrt((dudx-dvdy)*(dudx-dvdy)+(dvdx+dudy)      &
1157:                  & *(dvdx+dudy)))
1158:             xkc(i,k,j) = dmin1(cell,xkhmax)
1159:  
1160:           end do
1161:         end do
1162:       end do
1163: !
1164: 
1165: #ifdef MPP1
1166:       do j = jbegin , jendx
1167:         if ( myid.ne.nproc-1 .or. j.ne.jendx ) then
1168: #else
1169:       do j = 2 , jxm1
1170:         if ( j.ne.jxm1 ) then
1171: #endif
1172: !
1173: !---------------------------------------------------------------------
1174: !**t**compute the temperature tendency:
1175: !
1176:           do k = 1 , kz
1177:             do i = 2 , iym2
1178:               tten(i,k,j) = 0.
1179:               qvten(i,k,j) = 0.
1180:               qcten(i,k,j) = 0.
1181:             end do
1182:           end do
1183:  
1184: !
1185: !..t..compute the horizontal advection term:
1186: !
1187: !         call hadv_T(tten(1,1,j),ua,va,t,msfx,dx4,j,1)
1188:           call <a href="./hadv.F90.html#hadv_t" TARGET=CENT_PANEL>hadv_t</a>(tten(1,1,j),dx4,j,1)
1189: !
1190: !..t..compute the vertical advection term:
1191: !
1192:           call <a href="./vadv.f90.html#vadv" TARGET=CENT_PANEL>vadv</a>(tten(1,1,j),ta(1,1,j),j,1)
1193: !
1194: !..t..compute the adiabatic term:
1195: !
1196:           do k = 1 , kz
1197:             do i = 2 , iym2
1198:               rovcpm = rgas/(cpd*(1.+0.8*(qv(i,k,j))))
1199:               tv = t(i,k,j)*(1.+ep1*(qv(i,k,j)))
1200:               tten(i,k,j) = tten(i,k,j) + (omega(i,k,j)*rovcpm*tv)      &
1201:                           & /(r8pt/psa(i,j)+a(k))
1202:             end do
1203:           end do
1204: !
1205: !..t..compute the diffusion term for t and store in difft:
1206: !
1207:           do k = 1 , kz
1208:             do i = 1 , iym1
1209:               difft(i,k,j) = 0.
1210:               diffq(i,k,j) = 0.
1211:             end do
1212:           end do
1213: !
1214:           call <a href="./diffut.F90.html#diffut_t" TARGET=CENT_PANEL>diffut_t</a>(difft(1,1,j),xkc(1,1,j),c203,j)
1215: !
1216: !**q**compute the moisture tendencies:
1217: !
1218: !....icup = 1 : kuo-anthes cumulus parameterizaion scheme
1219: !....icup = 2 : grell cumulus paramterization scheme
1220: !....icup = 3 : betts-miller (1986)
1221: !....icup = 4 : emanuel (1991)
1222: !
1223:           if ( icup.ne.1 ) then
1224:             call <a href="./hadv.F90.html#hadvqv" TARGET=CENT_PANEL>hadvqv</a>(qvten(1,1,j),dx4,j,1)
1225:             call <a href="./vadv.f90.html#vadv" TARGET=CENT_PANEL>vadv</a>(qvten(1,1,j),qva(1,1,j),j,2)
1226:           end if
1227:  
1228:           if ( icup.eq.1 ) then
1229:             call <a href="./mod_cu_kuo.f90.html#cupara" TARGET=CENT_PANEL>cupara</a>(j)
1230:           else if ( icup.eq.2 ) then
1231:             call <a href="./mod_cu_grell.f90.html#cuparan" TARGET=CENT_PANEL>cuparan</a>(tten(1,1,j),qvten(1,1,j),j)
1232:           else if ( icup.eq.3 ) then
1233:             write (aline,*)                                             &
1234:                 & 'ICTP RegCM team thinks the Betts-Miller code',       &
1235:                 & ' is not ready for Regional Climate Run yet.'
1236:             call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
1237:             call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,                               &
1238:                       &'BETTS MILLER CUMULUS OPTION NOT ALLOWED')
1239:             call <a href="./mod_cu_bm.F90.html#bmpara" TARGET=CENT_PANEL>bmpara</a>(tten(1,1,j),qvten(1,1,j),j)
1240:           else if ( icup.eq.4 ) then
1241:             call <a href="./mod_cu_em.f90.html#cupemandrv" TARGET=CENT_PANEL>cupemandrv</a>(j)
1242:           else
1243:           end if
1244:  
1245:           if ( ipptls.eq.1 ) then
1246:             call <a href="./hadv.F90.html#hadvqc" TARGET=CENT_PANEL>hadvqc</a>(qcten(1,1,j),dx4,j,1)
1247: !           call hadvQC(qcten(1,1,j),dx,j,2)
1248: !fix        call vadv(qcten(1,1,j),qca(1,1,j),j,3)
1249:             call <a href="./vadv.f90.html#vadv" TARGET=CENT_PANEL>vadv</a>(qcten(1,1,j),qca(1,1,j),j,5)
1250:             call <a href="./pcp.f90.html#pcp" TARGET=CENT_PANEL>pcp</a>(j , 2 , iym2 , kz)
1251:             call <a href="./cldfrac.f90.html#cldfrac" TARGET=CENT_PANEL>cldfrac</a>(j)
1252:  
1253: !           need also to set diffq to 0 here before calling diffut
1254:             do k = 1 , kz
1255:               do i = 1 , iym1
1256:                 diffq(i,k,j) = 0.
1257:               end do
1258:             end do
1259:  
1260: !-----compute the diffusion terms:
1261: !           the diffusion term for qv is stored in diffq. before
1262: !           completing qvten computation, do not use diffq for other
1263:  
1264: !           purpose.
1265:             call <a href="./diffut.F90.html#diffutqv" TARGET=CENT_PANEL>diffutqv</a>(diffq(1,1,j),xkc(1,1,j),c203,j)
1266:             call <a href="./diffut.F90.html#diffutqc" TARGET=CENT_PANEL>diffutqc</a>(qcten(1,1,j),xkc(1,1,j),c203,j)
1267:           end if
1268: !
1269: !chem2    compute the tracers tendencies
1270:           if ( ichem.eq.1 ) then
1271:             call <a href="./zenitm.F90.html#zenitm" TARGET=CENT_PANEL>zenitm</a>(coszrs,iy,j)
1272:             call <a href="./tractend2.f90.html#tractend2" TARGET=CENT_PANEL>tractend2</a>(j)
1273:           end if
1274: !chem2_
1275: !
1276:         end if           !end if(j.ne.jxm1) test
1277: !----------------------------------------------------------------------
1278: !*****compute the pbl fluxes:
1279: !       the diffusion and pbl tendencies of t and qv are stored in
1280: !       difft and diffq.
1281: !
1282:         do k = 1 , kz
1283:           do i = 2 , iym1
1284:             uten(i,k,j) = 0.
1285:             vten(i,k,j) = 0.
1286:           end do
1287:         end do
1288:  
1289:  
1290: !       ****** calculate solar zenith angle
1291:         if ( (jyear.eq.jyear0 .and. ktau.eq.0) .or. mod(ktau+1,nbatst)  &
1292:            & .eq.0 .or. mod(ktau+1,ntrad).eq.0 ) then
1293:           call <a href="./zenitm.F90.html#zenitm" TARGET=CENT_PANEL>zenitm</a>(coszrs,iy,j)
1294:           call <a href="./slice1D.f90.html#slice1d" TARGET=CENT_PANEL>slice1D</a>(j)
1295:         end if
1296:  
1297: !       ****** calculate albedo
1298: #ifdef CLM
1299:         if ( (jyear.eq.jyear0 .and. ktau.eq.0) .or. mod(ktau+1,ntrad)   &
1300:            & .eq.0 ) call <a href="./albedoclm.F90.html#albedoclm" TARGET=CENT_PANEL>albedoclm</a>(j,iemiss)
1301: #else
1302:         if ( (jyear.eq.jyear0 .and. ktau.eq.0) .or. mod(ktau+1,ntrad)   &
1303:            & .eq.0 ) call <a href="./albedov.F90.html#albedov" TARGET=CENT_PANEL>albedov</a>(j,iemiss)
1304: #endif
1305:  
1306: !       ****** call ccm3 radiative transfer package
1307:         if ( (jyear.eq.jyear0 .and. ktau.eq.0) .or. mod(ktau+1,ntrad)   &
1308:            & .eq.0 ) call <a href="./colmod3.F90.html#colmod3" TARGET=CENT_PANEL>colmod3</a>(j)
1309:  
1310: #ifndef CLM
1311: !       ****** call vector bats for surface physics calculations
1312:         if ( (jyear.eq.jyear0 .and. ktau.eq.0) .or.                     &
1313:            &  mod(ktau+1,nbatst).eq.0 ) then
1314:           dtbat = dt/2.*nbatst
1315:           if ( jyear.eq.jyear0 .and. ktau.eq.0 ) dtbat = dt
1316:           call <a href="./vecbats.F90.html#vecbats" TARGET=CENT_PANEL>vecbats</a>(j, kz , 2 , iym1 , nnsg)
1317: !         Zeng ocean flux model
1318:           if ( iocnflx.eq.2 ) call <a href="./mod_zengocn.F90.html#zengocndrv" TARGET=CENT_PANEL>zengocndrv</a>(j , nnsg , 2 , iym1 , kz)
1319: !         ****** accumulate quantities for energy and moisture budgets
1320:           call <a href="./mod_bats.F90.html#interf" TARGET=CENT_PANEL>interf</a>(2 , j , kz , 2 , iym1 , nnsg)
1321:         end if
1322: #endif
1323:  
1324:       end do
1325: 
1326: #ifdef CLM
1327:       if ( ( jyear.eq.jyear0 .and. ktau.eq.0 ) .or.                     &
1328:          & mod(ktau+1,ntrad).eq.0 ) then
1329:           r2cdoalb = .true.
1330:       else
1331:           r2cdoalb = .false.
1332:       end if
1333:       if ( (jyear.eq.jyear0 .and. ktau.eq.0 ) .or.                      &
1334:          & mod(ktau+1,nbatst).eq.0 ) then
1335:         ! Timestep used is the same as for bats
1336:         if ( jyear.eq.jyear0 .and. ktau.eq.0 ) then
1337:           r2cnstep = 0
1338:         else
1339:           r2cnstep = (ktau+1)/nbatst
1340:         end if
1341:         dtbat = dt/2.*nbatst
1342:         ! CLM j loop is in mtrxclm
1343:         call <a href="./mtrxclm.F90.html#mtrxclm" TARGET=CENT_PANEL>mtrxclm</a>
1344:       end if
1345: #endif
1346: 
1347:       if ( icup.eq.1 ) then
1348:         dto2 = dt/2
1349:         call <a href="./htdiff.F90.html#htdiff" TARGET=CENT_PANEL>htdiff</a>(dto2,dxsq,akht1)
1350:       end if
1351: !     call medium resolution pbl
1352:       if ( ibltyp.eq.1 ) call <a href="./holtbl.F90.html#holtbl" TARGET=CENT_PANEL>holtbl</a>
1353: !
1354: #ifdef MPP1
1355:       do j = jbegin , jendx
1356: #else
1357:       do j = 2 , jxm1
1358: #endif
1359: !       add ccm radiative transfer package-calculated heating rates to
1360: !       temperature tendency
1361:         do k = 1 , kz
1362:           do i = 2 , iym2
1363:             ! heating rate in deg/sec
1364:             tten(i,k,j) = tten(i,k,j) + psb(i,j)*heatrt(i,k,j)
1365:           end do
1366:         end do
1367: !
1368: #ifdef MPP1
1369:         if ( myid.ne.nproc-1 .or. j.ne.jendx ) then
1370: #else
1371:         if ( j.ne.jxm1 ) then
1372: #endif
1373: !
1374: !..tq.add horizontal diffusion and pbl tendencies for t and qv to tten
1375: !         and qvten for calculating condensational term in subroutine
1376: !         "condtq".
1377: !
1378:           do k = 1 , kz
1379:             do i = 2 , iym2
1380:               tten(i,k,j) = tten(i,k,j) + difft(i,k,j)
1381:             end do
1382:           end do
1383: !
1384:           do k = 1 , kz
1385:             do i = 2 , iym2
1386:               qvten(i,k,j) = qvten(i,k,j) + diffq(i,k,j)
1387:             end do
1388:           end do
1389: !
1390: !..tq.compute the condensation and precipitation terms for explicit
1391: !         moisture scheme:
1392: !
1393:           call <a href="./condtq.f90.html#condtq" TARGET=CENT_PANEL>condtq</a>(j)
1394: !
1395: !..tq.subtract horizontal diffusion and pbl tendencies from tten and
1396: !         qvten for appling the sponge boundary conditions on t and qv:
1397: !
1398:           if ( iboudy.eq.4 ) then
1399:             do k = 1 , kz
1400:               do i = 2 , iym2
1401:                 tten(i,k,j) = tten(i,k,j) - difft(i,k,j)
1402:               end do
1403:             end do
1404:             call <a href="./sponge.F90.html#sponge_t" TARGET=CENT_PANEL>sponge_t</a>(ispgx,wgtx,tten(1,1,j),j)
1405:             do k = 1 , kz
1406:               do i = 2 , iym2
1407:                 tten(i,k,j) = tten(i,k,j) + difft(i,k,j)
1408:               end do
1409:             end do
1410:             do k = 1 , kz
1411:               do i = 2 , iym2
1412:                 qvten(i,k,j) = qvten(i,k,j) - diffq(i,k,j)
1413:               end do
1414:             end do
1415:             call <a href="./sponge.F90.html#spongeqv" TARGET=CENT_PANEL>spongeqv</a>(ispgx,wgtx,qvten(1,1,j),j)
1416:             do k = 1 , kz
1417:               do i = 2 , iym2
1418:                 qvten(i,k,j) = qvten(i,k,j) + diffq(i,k,j)
1419:               end do
1420:             end do
1421:           end if
1422: !
1423: !..tq.apply the nudging boundary conditions:
1424: !
1425:           if ( iboudy.eq.1 .or. iboudy.eq.5 ) then
1426:             xtm1 = xtime - dtmin
1427:             if ( dabs(xtime).lt.0.00001 .and. ldatez.gt.idate0 )        &
1428:                & xtm1 = -dtmin
1429:             call <a href="./nudge.F90.html#nudge_t" TARGET=CENT_PANEL>nudge_t</a>(ispgx,fnudge,gnudge,xtm1,tten(1,1,j),c203,j,   &
1430:                        & iboudy)
1431:             call <a href="./nudge.F90.html#nudgeqv" TARGET=CENT_PANEL>nudgeqv</a>(ispgx,fnudge,gnudge,xtm1,qvten(1,1,j),c203,j,  &
1432:                        & iboudy)
1433:           end if
1434: !
1435: !..tq.forecast t, qv, and qc at tau+1:
1436: !
1437:           do k = 1 , kz
1438:             do i = 2 , iym2
1439:               qvc(i,k,j) = qvb(i,k,j) + dt*qvten(i,k,j)
1440:             end do
1441:           end do
1442: !
1443:           do k = 1 , kz
1444:             do i = 2 , iym2
1445:               qcc(i,k,j) = qcb(i,k,j) + dt*qcten(i,k,j)
1446:             end do
1447:           end do
1448: !
1449:           do k = 1 , kz
1450:             do i = 2 , iym2
1451:               tc(i,k,j) = tb(i,k,j) + dt*tten(i,k,j)
1452:             end do
1453:           end do
1454: !
1455: !chem2
1456: !         forecast tracer chi at at tau+1:
1457:           if ( ichem.eq.1 ) then
1458: !
1459:             do itr = 1 , ntr
1460:               do k = 1 , kz
1461:                 do i = 2 , iym2
1462:                   chic(i,k,j,itr) = chib(i,k,j,itr)                     &
1463:                                   & + dt*chiten(i,k,j,itr)
1464:                 end do
1465:               end do
1466:             end do
1467:           end if
1468: !chem2_
1469:         end if       !end if(j.ne.jxm1),else test
1470:       end do
1471: !
1472: #ifdef MPP1
1473:       do j = 1 , jendx
1474:         if ( myid.eq.0 .and. j.eq.1 ) then
1475: #else
1476:       do j = 1 , jxm1
1477:         if ( j.eq.1 ) then
1478: #endif
1479:           if ( ipgf.eq.1 ) then
1480:             do k = 1 , kz
1481:               do i = 1 , iym1
1482:                 td(i,k,j) = ta(i,k,j)*(1.+ep1*(qv(i,k,j)))
1483:                 ttld(i,k,j) = td(i,k,j) - psa(i,j)                      &
1484:                             & *t00pg*((a(k)*psa(i,j)+r8pt)/p00pg)       &
1485:                             & **pgfaa1
1486:               end do
1487:             end do
1488:           else if ( ipgf.eq.0 ) then
1489:             do k = 1 , kz
1490:               do i = 1 , iym1
1491:                 td(i,k,j) = ta(i,k,j)*(1.+ep1*(qv(i,k,j)))
1492:               end do
1493:             end do
1494:           else
1495:           end if
1496: !
1497: #ifdef MPP1
1498:         else if ( myid.eq.nproc-1 .and. j.eq.jendx ) then
1499: #else
1500:         else if ( j.eq.jxm1 ) then
1501: #endif
1502: !
1503: !-----set td and psd at j=jlx equal to ta and psa:
1504: !
1505:           if ( ipgf.eq.1 ) then
1506:             do k = 1 , kz
1507:               do i = 1 , iym1
1508:                 td(i,k,j) = ta(i,k,j)*(1.+ep1*(qv(i,k,j)))
1509:                 ttld(i,k,j) = td(i,k,j) - psa(i,j)                      &
1510:                             & *t00pg*((a(k)*psa(i,j)+r8pt)/p00pg)       &
1511:                             & **pgfaa1
1512:               end do
1513:             end do
1514:           else if ( ipgf.eq.0 ) then
1515:             do k = 1 , kz
1516:               do i = 1 , iym1
1517:                 td(i,k,j) = ta(i,k,j)*(1.+ep1*(qv(i,k,j)))
1518:               end do
1519:             end do
1520:           else
1521:           end if
1522: !
1523: !
1524: !..t..compute weighted p*t (td) for use in ssi:
1525: !
1526:         else if ( ipgf.eq.1 ) then
1527: !
1528:           do k = 1 , kz
1529:             do i = 2 , iym2
1530:               tvc = tc(i,k,j)*(1.+ep1*(qvc(i,k,j))/psc(i,j))
1531:               tva = ta(i,k,j)*(1.+ep1*(qv(i,k,j)))
1532:               tvb = tb(i,k,j)*(1.+ep1*(qvb(i,k,j))/psb(i,j))
1533:               td(i,k,j) = alpha*(tvc+tvb) + beta*tva
1534:               ttld(i,k,j) = td(i,k,j) - psd(i,j)                        &
1535:                           & *t00pg*((a(k)*psd(i,j)+r8pt)/p00pg)**pgfaa1
1536:             end do
1537:           end do
1538:           do k = 1 , kz
1539:             td(1,k,j) = ta(1,k,j)*(1.+ep1*(qv(1,k,j)))
1540:             ttld(1,k,j) = td(1,k,j) - psa(1,j)                          &
1541:                         & *t00pg*((a(k)*psa(1,j)+r8pt)/p00pg)**pgfaa1
1542:             td(iym1,k,j) = ta(iym1,k,j)*(1.+ep1*(qv(iym1,k,j)))
1543:             ttld(iym1,k,j) = td(iym1,k,j) - psa(iym1,j)                 &
1544:                           & *t00pg*((a(k)*psa(iym1,j)+r8pt)/p00pg)      &
1545:                           & **pgfaa1
1546:           end do
1547: !
1548:         else if ( ipgf.eq.0 ) then
1549: !
1550:           do k = 1 , kz
1551:             do i = 2 , iym2
1552:               tvc = tc(i,k,j)*(1.+ep1*(qvc(i,k,j))/psc(i,j))
1553:               tva = ta(i,k,j)*(1.+ep1*(qv(i,k,j)))
1554:               tvb = tb(i,k,j)*(1.+ep1*(qvb(i,k,j))/psb(i,j))
1555:               td(i,k,j) = alpha*(tvc+tvb) + beta*tva
1556:             end do
1557:           end do
1558:           do k = 1 , kz
1559:             td(1,k,j) = ta(1,k,j)*(1.+ep1*(qv(1,k,j)))
1560:             td(iym1,k,j) = ta(iym1,k,j)*(1.+ep1*(qv(iym1,k,j)))
1561:           end do
1562:  
1563:         else         !end if(j.ne.jxm1),else test
1564:         end if
1565: !
1566:       end do
1567: !----------------------------------------------------------------------
1568: !**uv*compute the u and v tendencies:
1569: #ifdef MPP1
1570:       do j = jbegin , jendx
1571: #else
1572:       do j = 2 , jxm1
1573: #endif
1574: !
1575: !..uv.compute the diffusion terms:
1576: !       put diffusion and pbl tendencies of u and v in difuu and difuv.
1577: !
1578:         do k = 1 , kz
1579:           do i = 2 , iym1
1580:             difuu(i,k,j) = uten(i,k,j)
1581:             difuv(i,k,j) = vten(i,k,j)
1582:           end do
1583:         end do
1584: !
1585:         call <a href="./diffu.F90.html#diffu_u" TARGET=CENT_PANEL>diffu_u</a>(difuu(1,1,j),xkc(1,1,j),c203,j,1)
1586:         call <a href="./diffu.F90.html#diffu_v" TARGET=CENT_PANEL>diffu_v</a>(difuv(1,1,j),xkc(1,1,j),c203,j,1)
1587: !
1588: !..uv.compute the horizontal advection terms for u and v:
1589: !
1590:         do k = 1 , kz
1591:           do i = 2 , iym1
1592:             uten(i,k,j) = 0.
1593:             vten(i,k,j) = 0.
1594:           end do
1595:         end do
1596: !
1597:         call <a href="./hadv.F90.html#hadv_u" TARGET=CENT_PANEL>hadv_u</a>(uten(1,1,j),dx16,j,3)
1598:         call <a href="./hadv.F90.html#hadv_v" TARGET=CENT_PANEL>hadv_v</a>(vten(1,1,j),dx16,j,3)
1599: !
1600: !..uv.compute coriolis terms:
1601: !
1602:         do k = 1 , kz
1603:           do i = 2 , iym1
1604:             uten(i,k,j) = uten(i,k,j) + f(i,j)*va(i,k,j)/msfd(i,j)
1605:             vten(i,k,j) = vten(i,k,j) - f(i,j)*ua(i,k,j)/msfd(i,j)
1606:           end do
1607:         end do
1608:       end do
1609: !
1610: #ifdef MPP1
1611:       do j = jbegin , jendx
1612: #else
1613:       do j = 2 , jxm1
1614: #endif
1615: !
1616: !..uv.compute pressure gradient terms:
1617: !
1618:         if ( ipgf.eq.1 ) then
1619:           do k = 1 , kz
1620:             do i = 2 , iym1
1621:               psasum = psd(i,j) + psd(i-1,j) + psd(i,j-1) + psd(i-1,j-1)
1622:               sigpsa = psasum
1623:               tv1 = t(i-1,k,j-1)*(1.+ep1*(qv(i-1,k,j-1)))
1624:               tv2 = t(i,k,j-1)*(1.+ep1*(qv(i,k,j-1)))
1625:               tv3 = t(i-1,k,j)*(1.+ep1*(qv(i-1,k,j)))
1626:               tv4 = t(i,k,j)*(1.+ep1*(qv(i,k,j)))
1627:               rtbar = tv1 + tv2 + tv3 + tv4 -                           &
1628:                     & 4.*t00pg*((a(k)*psasum/4.+r8pt)/p00pg)**pgfaa1
1629:               rtbar = rgas*rtbar*sigpsa/16.
1630:               uten(i,k,j) = uten(i,k,j)                                 &
1631:                           & - rtbar*(dlog(0.5*(psd(i,j)+psd(i-1,j))*a(k)&
1632:                           & +r8pt)                                      &
1633:                           & -dlog(0.5*(psd(i,j-1)+psd(i-1,j-1))*a(k)    &
1634:                           & +r8pt))/(dx*msfd(i,j))
1635:               vten(i,k,j) = vten(i,k,j)                                 &
1636:                           & - rtbar*(dlog(0.5*(psd(i,j)+psd(i,j-1))*a(k)&
1637:                           & +r8pt)                                      &
1638:                           & -dlog(0.5*(psd(i-1,j-1)+psd(i-1,j))*a(k)    &
1639:                           & +r8pt))/(dx*msfd(i,j))
1640:             end do
1641:           end do
1642:         else if ( ipgf.eq.0 ) then
1643:           do k = 1 , kz
1644:             do i = 2 , iym1
1645:               psasum = psd(i,j) + psd(i-1,j) + psd(i,j-1) + psd(i-1,j-1)
1646:               sigpsa = psasum
1647:               tv1 = t(i-1,k,j-1)*(1.+ep1*(qv(i-1,k,j-1)))
1648:               tv2 = t(i,k,j-1)*(1.+ep1*(qv(i,k,j-1)))
1649:               tv3 = t(i-1,k,j)*(1.+ep1*(qv(i-1,k,j)))
1650:               tv4 = t(i,k,j)*(1.+ep1*(qv(i,k,j)))
1651:               rtbar = rgas*(tv1+tv2+tv3+tv4)*sigpsa/16.
1652:               uten(i,k,j) = uten(i,k,j)                                 &
1653:                           & - rtbar*(dlog(0.5*(psd(i,j)+psd(i-1,j))*a(k)&
1654:                           & +r8pt)                                      &
1655:                           & -dlog(0.5*(psd(i,j-1)+psd(i-1,j-1))*a(k)    &
1656:                           & +r8pt))/(dx*msfd(i,j))
1657:               vten(i,k,j) = vten(i,k,j)                                 &
1658:                           & - rtbar*(dlog(0.5*(psd(i,j)+psd(i,j-1))*a(k)&
1659:                           & +r8pt)                                      &
1660:                           & -dlog(0.5*(psd(i-1,j-1)+psd(i-1,j))*a(k)    &
1661:                           & +r8pt))/(dx*msfd(i,j))
1662:             end do
1663:           end do
1664:         else
1665:         end if
1666:       end do
1667: !
1668: #ifdef MPP1
1669:       do j = 1 , jendx
1670: #else
1671:       do j = 1 , jxm1
1672: #endif
1673: !
1674: !..uv.compute geopotential height at half-k levels, cross points:
1675: !
1676:         if ( ipgf.eq.1 ) then
1677:  
1678:           do i = 1 , iym1
1679:             tv = (ttld(i,kz,j)/psd(i,j))/(1.+qc(i,kz,j)/(1.+qv(i,kz,j)))
1680:             phi(i,kz,j) = ht(i,j)                                       &
1681:                         & + rgas*t00pg/pgfaa1*((psd(i,j)+r8pt)/p00pg)   &
1682:                         & **pgfaa1
1683:             phi(i,kz,j) = phi(i,kz,j)                                   &
1684:                         & - rgas*tv*dlog((a(kz)+r8pt/psd(i,j))/(1.+     &
1685:                         & r8pt/psd(i,j)))
1686:           end do
1687:  
1688:           do k = 1 , kzm1
1689:             lev = kz - k
1690:             do i = 1 , iym1
1691:               tvavg = ((ttld(i,lev,j)*dsigma(lev)+ttld(i,lev+1,j)*      &
1692:                     & dsigma(lev+1))/(psd(i,j)*(dsigma(lev)+            &
1693:                     & dsigma(lev+1))))/(1.+qc(i,lev,j)/(1.+qv(i,lev,j)))
1694:               phi(i,lev,j) = phi(i,lev+1,j)                             &
1695:                            & - rgas*tvavg*dlog((a(lev)+r8pt/psd(i,j))   &
1696:                            & /(a(lev+1)+r8pt/psd(i,j)))
1697:             end do
1698:           end do
1699:  
1700:         else if ( ipgf.eq.0 ) then
1701:  
1702:           do i = 1 , iym1
1703:             tv = (td(i,kz,j)/psd(i,j))/(1.+qc(i,kz,j)/(1.+qv(i,kz,j)))
1704:             phi(i,kz,j) = ht(i,j)                                       &
1705:                         & - rgas*tv*dlog((a(kz)+r8pt/psd(i,j))/         &
1706:                         & (1.+r8pt/psd(i,j)))
1707:           end do
1708:  
1709:           do k = 1 , kzm1
1710:             lev = kz - k
1711:             do i = 1 , iym1
1712:               tvavg = ((td(i,lev,j)*dsigma(lev)+td(i,lev+1,j)*          &
1713:                     & dsigma(lev+1))/(psd(i,j)*(dsigma(lev)+            &
1714:                     & dsigma(lev+1))))/(1.+qc(i,lev,j)/(1.+qv(i,lev,j)))
1715:               phi(i,lev,j) = phi(i,lev+1,j)                             &
1716:                            & - rgas*tvavg*dlog((a(lev)+r8pt/psd(i,j))   &
1717:                            & /(a(lev+1)+r8pt/psd(i,j)))
1718:             end do
1719:           end do
1720:  
1721:         else   ! ipgf if block
1722:         end if
1723:       end do
1724: #ifdef MPP1
1725:       call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(phi(1,1,jxp),iy*kz,mpi_real8,ieast,1,           &
1726:                       & phi(1,1,0),iy*kz,mpi_real8,iwest,1,             &
1727:                       & mpi_comm_world,mpi_status_ignore,ierr)
1728:       do j = jbegin , jendx
1729: #else
1730:       do j = 2 , jxm1
1731: #endif
1732: !
1733: !..uv.compute the geopotential gradient terms:
1734: !
1735:         do k = 1 , kz
1736:           do i = 2 , iym1
1737:             uten(i,k,j) = uten(i,k,j)                                   &
1738:                         & -(psd(i-1,j-1)+psd(i,j-1)+psd(i-1,j)+psd(i,j))&
1739:                         & *(phi(i,k,j)+phi(i-1,k,j)-phi(i,k,j-1)-       &
1740:                         & phi(i-1,k,j-1))/(dx8*msfd(i,j))
1741:             vten(i,k,j) = vten(i,k,j)                                   &
1742:                         & -(psd(i-1,j-1)+psd(i,j-1)+psd(i-1,j)+psd(i,j))&
1743:                         & *(phi(i,k,j)+phi(i,k,j-1)-phi(i-1,k,j)-       &
1744:                         & phi(i-1,k,j-1))/(dx8*msfd(i,j))
1745:           end do
1746:         end do
1747:       end do
1748: !
1749: #ifdef MPP1
1750:       do j = jbegin , jendx
1751: #else
1752:       do j = 2 , jxm1
1753: #endif
1754: !
1755: !..uv.compute teh vertical advection terms:
1756: !
1757:         call <a href="./vadv.f90.html#vadv" TARGET=CENT_PANEL>vadv</a>(uten(1,1,j),ua(1,1,j),j,4)
1758:         call <a href="./vadv.f90.html#vadv" TARGET=CENT_PANEL>vadv</a>(vten(1,1,j),va(1,1,j),j,4)
1759: !
1760: !..uv.apply the sponge boundary condition on u and v:
1761: !
1762:         if ( iboudy.eq.4 ) then
1763:           call <a href="./sponge.F90.html#sponge_u" TARGET=CENT_PANEL>sponge_u</a>(ispgd,wgtd,uten(1,1,j),j)
1764:           call <a href="./sponge.F90.html#sponge_v" TARGET=CENT_PANEL>sponge_v</a>(ispgd,wgtd,vten(1,1,j),j)
1765:         end if
1766: !
1767: !..uv.apply the nudging boundary conditions:
1768: !
1769:         if ( iboudy.eq.1 .or. iboudy.eq.5 ) then
1770:           call <a href="./nudge.F90.html#nudge_u" TARGET=CENT_PANEL>nudge_u</a>(ispgd,fnudge,gnudge,xtm1,uten(1,1,j),c203,j,     &
1771:                      & iboudy)
1772:           call <a href="./nudge.F90.html#nudge_v" TARGET=CENT_PANEL>nudge_v</a>(ispgd,fnudge,gnudge,xtm1,vten(1,1,j),c203,j,     &
1773:                      & iboudy)
1774:         end if
1775: !
1776: !..uv.add the diffusion and pbl tendencies to uten and vten:
1777: !
1778:         do k = 1 , kz
1779:           do i = 2 , iym1
1780:             uten(i,k,j) = uten(i,k,j) + difuu(i,k,j)
1781:             vten(i,k,j) = vten(i,k,j) + difuv(i,k,j)
1782:           end do
1783:         end do
1784: !
1785: !..uv.forecast p*u and p*v at tau+1:
1786: !
1787:         do k = 1 , kz
1788:           do i = 2 , iym1
1789:             uc(i,k,j) = ub(i,k,j) + dt*uten(i,k,j)
1790:             vc(i,k,j) = vb(i,k,j) + dt*vten(i,k,j)
1791:           end do
1792:         end do
1793: !
1794: !*****end of j loop.
1795: !**********************************************************************
1796:       end do
1797: !
1798: !---------------------------------------------------------------------
1799: !-----store the xxa variables in xxb and xxc in xxa:
1800: !     perform time smoothing operations.
1801: !
1802: #ifdef MPP1
1803:       do j = jbegin , jendx
1804: #else
1805:       do j = 2 , jxm1
1806: #endif
1807:         do k = 1 , kz
1808:           do i = 2 , iym1
1809:             ub(i,k,j) = omuhf*ua(i,k,j)/msfd(i,j)                       &
1810:                       & + gnuhf*(ub(i,k,j)+uc(i,k,j))
1811:             vb(i,k,j) = omuhf*va(i,k,j)/msfd(i,j)                       &
1812:                       & + gnuhf*(vb(i,k,j)+vc(i,k,j))
1813:             ua(i,k,j) = uc(i,k,j)
1814:             va(i,k,j) = vc(i,k,j)
1815:           end do
1816:         end do
1817:       end do
1818: !
1819: #ifdef MPP1
1820:       do j = jbegin , jendm
1821: #else
1822:       do j = 2 , jxm2
1823: #endif
1824:         do k = 1 , kz
1825:           do i = 2 , iym2
1826:             tb(i,k,j) = omuhf*ta(i,k,j) + gnuhf*(tb(i,k,j)+tc(i,k,j))
1827:             ta(i,k,j) = tc(i,k,j)
1828:           end do
1829:           do i = 2 , iym2
1830:             qvbs = omuhf*qva(i,k,j) + gnuhf*(qvb(i,k,j)+qvc(i,k,j))
1831:             qvas = qvc(i,k,j)
1832:             qvb(i,k,j) = dmax1(qvbs,1.D-99)
1833:             qva(i,k,j) = dmax1(qvas,1.D-99)
1834:           end do
1835:           do i = 2 , iym2
1836:             qcbs = omu*qca(i,k,j) + gnu*(qcb(i,k,j)+qcc(i,k,j))
1837:             qcb(i,k,j) = dmax1(qcbs,0.D0)
1838:           end do
1839:           do i = 2 , iym2
1840:             qcas = qcc(i,k,j)
1841:             qca(i,k,j) = dmax1(qcas,0.D0)
1842:           end do
1843: !chem2
1844:           if ( ichem.eq.1 ) then
1845:             do itr = 1 , ntr
1846:               do i = 2 , iym2
1847:                 chibs = omu*chia(i,k,j,itr)                             &
1848:                       & + gnu*(chib(i,k,j,itr)+chic(i,k,j,itr))
1849:                 chib(i,k,j,itr) = dmax1(chibs,0.D0)
1850:                 chias = chic(i,k,j,itr)
1851:                 chia(i,k,j,itr) = dmax1(chias,0.D0)
1852:               end do
1853:             end do
1854:           end if
1855: !chem2_
1856:         end do
1857:         do i = 2 , iym2
1858:           psb(i,j) = omuhf*psa(i,j) + gnuhf*(psb(i,j)+psc(i,j))
1859:           psa(i,j) = psc(i,j)
1860:         end do
1861:       end do
1862:       if ( ehso4 ) then
1863:         do k = 1 , kz
1864: #ifdef MPP1
1865:           do j = 1 , jendx
1866: #else
1867:           do j = 1 , jxm1
1868: #endif
1869:             do i = 1 , iym1
1870:               aermm(i,k,j) = so4(i,k,j)
1871:             end do
1872:           end do
1873:         end do
1874:       end if
1875: !
1876: !----------------------------------------------------------------------
1877: !-----increment elapsed forecast time:
1878: !
1879:       ktau = ktau + 1
1880:       xtime = xtime + dtmin
1881:       ntime = ntime + nint(dtmin*60.)
1882:       if ( dabs(xtime-ibdyfrq*60.).lt.0.00001 ) then
1883:         lhour = lhour + ibdyfrq
1884:         if ( lhour.eq.24 ) then
1885:           call <a href="./mod_date.F90.html#finddate" TARGET=CENT_PANEL>finddate</a>(nnnnnn,ldatez)
1886:           ldatez = mdatez(nnnnnn+1)
1887:           lyear = ldatez/1000000
1888:           lmonth = (ldatez-lyear*1000000)/10000
1889:           lday = (ldatez-lyear*1000000-lmonth*10000)/100
1890:           lhour = mod(ldatez,100)
1891:         else
1892:           ldatez = ldatez + ibdyfrq
1893:         end if
1894:         nnnnnn = nnnnnn + 1
1895:         xtime = 0.0
1896:         if ( mod(ldatez,1000000).eq.10100 .and. xtime.lt.0.0001 ) then
1897:           jyear = ldatez/1000000
1898:           ktau = 0
1899:           ntime = 0
1900:         end if
1901:       end if
1902:       if ( jyear.ne.jyear0 .or. ktau.ne.0 ) dt = dt2
1903: !
1904: !-----compute the amounts advected through the lateral boundaries:
1905: !     *** note *** we must calculate the amounts advected through
1906: !     the lateral boundaries before updating the values
1907: !     at boundary slices.
1908: !
1909: #ifdef DIAG
1910:       call <a href="./conadv.F90.html#conadv" TARGET=CENT_PANEL>conadv</a>
1911:       if ( ichem.eq.1 ) call <a href="./tracdiag.F90.html#tracdiag" TARGET=CENT_PANEL>tracdiag</a>(xkc)
1912: #endif
1913:  
1914: !-----fill up the boundary values for xxb and xxa variables:
1915: !
1916:       call <a href="./bdyval.F90.html#bdyval" TARGET=CENT_PANEL>bdyval</a>(xtime,iexec)
1917: !
1918: !-----compute the nonconvective precipitation:
1919: !
1920: !???  call nconvp(psa,psb,ta,tb,qva,qvb,qca,qcb)
1921: !
1922: !chem2_
1923: !     do cumulus transport of tracers
1924:       if ( ichem.eq.1 .and. ichcumtra.eq.1 ) call <a href="./cumtran.F90.html#cumtran" TARGET=CENT_PANEL>cumtran</a>
1925:  
1926: !chem2_
1927:  
1928: !-----trace the mass conservation of dry air and water substance:
1929: !
1930: #ifdef DIAG
1931:       call <a href="./conmas.F90.html#conmas" TARGET=CENT_PANEL>conmas</a>
1932: #endif
1933: !
1934: !
1935: !---- budgets for tracers
1936:       if ( ichem.eq.1 ) call <a href="./tracbud.F90.html#tracbud" TARGET=CENT_PANEL>tracbud</a>
1937: !
1938: !-----print out noise parameter:
1939: !
1940:       if ( jyear.ne.jyear0 .or. ktau.gt.1 ) then
1941:         ptnbar = ptntot/dble(iptn)
1942:         pt2bar = pt2tot/dble(iptn)
1943:         icons = 0
1944: #ifdef MPP1
1945:         icons_mpi = 0
1946:         do j = jbegin , jendm
1947: #else
1948:         do j = 2 , jxm2
1949: #endif
1950:           icons = icons + icon(j)
1951:         end do
1952: #ifdef MPP1
1953:         icons_mpi = 0
1954:         call <a href="#" TARGET=CENT_PANEL>mpi_allreduce</a>(icons,icons_mpi,1,mpi_integer,mpi_sum,       &
1955:                          & mpi_comm_world,ierr)
1956: #endif
1957:         xday = ((nnnnnn-nstrt0)*ibdyfrq*60.+xtime-dtmin)/1440.
1958: #ifdef MPP1
1959:         if ( myid.eq.0 ) then
1960:           if ( mod(ktau,50).eq.0 ) print 99001 , xday , ktau , ptnbar , &
1961:              & pt2bar , icons_mpi
1962:         end if
1963: #else
1964:         if ( mod(ktau,50).eq.0 ) print 99001 , xday , ktau , ptnbar ,   &
1965:                                      & pt2bar , icons
1966: #endif
1967: 99001     format (5x,'at day = ',f9.4,', ktau = ',i10,                  &
1968:                  &' :  1st, 2nd time deriv of ps = ',2E12.5,            &
1969:                  &',  no. of points w/convection = ',i7)
1970:       end if
1971: !
1972: !----------------------------------------------------------------------
1973: !
1974: !-----recalculate solar declination angle if forecast time larger than
1975: !     24 hours:
1976: !
1977:       if ( dabs(xtime).lt.0.00001 .and. ldatez.ne.idate1 ) then
1978: #ifdef CLM
1979:         call <a href="./solar1clm.f90.html#solar1clm" TARGET=CENT_PANEL>solar1clm</a>(xtime)
1980: #else
1981:         call <a href="./solar1.f90.html#solar1" TARGET=CENT_PANEL>solar1</a>(xtime)
1982: #endif
1983:         dectim = anint(1440.+dectim)
1984: #ifdef MPP1
1985:         if ( myid.eq.0 ) write (*,*) ' dectim = ' , dectim
1986: #else
1987:         write (*,*) ' dectim = ' , dectim
1988: #endif
1989:       end if
1990: !
1991:       end subroutine tend
</PRE>

<HR>

</BODY>
</HTML>
