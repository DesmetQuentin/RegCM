<HTML>

<HEAD>
<TITLE>init.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>init.F90</H1>
<HR>
<H2 ALIGN=CENTER>init.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=init><H3>init</H3></a></p> Click <a href="./callingtree/init_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where init is used.
<hr>
20:       subroutine init
21: 
22: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
23: !                                                                     c
24: !     this subroutine reads in the initial and boundary conditions.   c
25: !                                                                     c
26: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
27: 
28:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
29:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : dt , dt2 , dx , ibdyfrq
30:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a> , only : ibltyp , ichem , icup , iemiss , ifrest , &
31:                    & iocnflx , ipptls , lakemod , icnt
32:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : a , dsigma , r8pt
33:       use <a href="./mod_iunits.f90.html#mod_iunits" TARGET=CENT_PANEL>mod_iunits</a>
34:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a> , only : ssw2da , sdeltk2d , sdelqk2d , sfracv2d ,   &
35:                    & sfracb2d , sfracs2d , svegfrac2d , ht1 , satbrt1 , &
36:                    & taf2d , tlef2d , ssw2d , srw2d , sol2d , solvd2d , &
37:                    & solvs2d , flw2d , tgb2d , swt2d , scv2d , gwet2d , &
38:                    & flwd2d , fsw2d, sabv2d , sinc2d , veg2d1 , sag2d , &
39:                    & sice2d , dew2d , pptnc , pptc , prca2d , prnca2d , &
40:                    & ircp2d , text2d , col2d , ocld2d , tg2d , veg2d ,  &
41:                    & emiss2d , psmn_o , t2mn_o , t2mx_o , tgmn_o ,      &
42:                    & tgmx_o , w10x_o , albvgl , albvgs
43:       use <a href="./mod_pmoist.F90.html#mod_pmoist" TARGET=CENT_PANEL>mod_pmoist</a>
44:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
45:       use <a href="./mod_mainchem.F90.html#mod_mainchem" TARGET=CENT_PANEL>mod_mainchem</a>
46:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a>
47:       use <a href="./mod_rad.F90.html#mod_rad" TARGET=CENT_PANEL>mod_rad</a>
48:       use <a href="./mod_trachem.F90.html#mod_trachem" TARGET=CENT_PANEL>mod_trachem</a>
49:       use <a href="./mod_message.F90.html#mod_message" TARGET=CENT_PANEL>mod_message</a>
50:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : dectim , mdate , mdate0 , mmrec , ldatez ,  &
51:                    & idate1 , lyear , lmonth , lday , lhour , ndate0 ,  &
52:                    & ndate1 , nnnchk , jyear , jyear0, jyearr, ntime ,  &
53:                    & ktau , ktaur , xtime , idate0
54:       use <a href="./mod_radbuf.F90.html#mod_radbuf" TARGET=CENT_PANEL>mod_radbuf</a>
55:       use <a href="./mod_tmpsav.F90.html#mod_tmpsav" TARGET=CENT_PANEL>mod_tmpsav</a>
56:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgti
57: #ifdef DIAG
58:       use <a href="./mod_diagnosis.f90.html#mod_diagnosis" TARGET=CENT_PANEL>mod_diagnosis</a>
59: #endif
60: #ifdef MPP1
61:       use <a href="./mod_mppio.F90.html#mod_mppio" TARGET=CENT_PANEL>mod_mppio</a>
62: #ifdef CLM
63:       use <a href="./mod_clm.F90.html#mod_clm" TARGET=CENT_PANEL>mod_clm</a>
64:       use <a href="#" TARGET=CENT_PANEL>clm_varsur</a> , only : init_tgb , init_grid
65:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a> , only : sols2d , soll2d , solsd2d , solld2d ,       &
66:                    &        aldirs2d, aldirl2d , aldifs2d , aldifl2d ,  &
67:                    &        coszrs2d
68: #endif
69: #ifndef IBM
70:       use <a href="#" TARGET=CENT_PANEL>mpi</a>
71: #else
72:       include 'mpif.h'
73: #endif
74: #endif
75:       implicit none
76: !
77: ! Local variables
78: !
79: !----------------------------------------------------------------------
80: !-----dimension the arrays for parameterizing the sfc. variables.
81: !     change the variable surface parameters
82: !
83:       integer :: depth , freeze , i , ibdydiff , ibdyhr0 , nxxx , nyyy ,&
84:                & ibdyhr1 , ibin , ilake , im1h , ip1h , ist , jlake ,   &
85:                & itr , j , jm1h , jp1h , k , kzzz , n 
86:       real(8) :: eta , hg1 , hg2 , hg3 , hg4 , hgmax , hi , hii , hs ,  &
87:                & tlp , ts00
88:       real(4) , dimension(iy,jx) :: io2d
89:       character(256) :: finm
90: #ifdef MPP1
91:       real(8) , dimension(iy,jxp) :: psdot
92:       integer :: allrec , ierr , l
93: #else
94:       real(8) , dimension(iy,jx) :: psdot
95: #endif
96:       real(8) , dimension(400) :: tlake
97:       logical :: existing
98: !
99: #ifdef DIAG
100:       real(8) :: tvmass , tcmass , tttmp
101: #endif
102: !
103: ! absnxt  - Nearest layer absorptivities
104: ! abstot  - Non-adjacent layer absorptivites
105: ! emstot  - Total emissivity
106: !
107:       data tlp , ts00/50.D0 , 288.D0/
108: !
109:       existing = .false.
110: #ifdef MPP1
111:       peb  = 0.0
112:       pwb  = 0.0
113:       pebt = 0.0
114:       pwbt = 0.0
115:       teb  = 0.0
116:       twb  = 0.0
117:       tebt = 0.0
118:       twbt = 0.0
119:       qeb  = 0.0
120:       qwb  = 0.0
121:       qebt = 0.0
122:       qwbt = 0.0
123:       ueb  = 0.0
124:       uwb  = 0.0
125:       uebt = 0.0
126:       uwbt = 0.0
127:       veb  = 0.0
128:       vwb  = 0.0
129:       vebt = 0.0
130:       vwbt = 0.0
131:       pnb  = 0.0
132:       pss  = 0.0
133:       pnbt = 0.0
134:       psbt = 0.0
135:       tnb  = 0.0
136:       tsb  = 0.0
137:       tnbt = 0.0
138:       tsbt = 0.0
139:       qnb  = 0.0
140:       qsb  = 0.0
141:       qnbt = 0.0
142:       qsbt = 0.0
143:       unb  = 0.0
144:       usb  = 0.0
145:       unbt = 0.0
146:       usbt = 0.0
147:       vnb  = 0.0
148:       vsb  = 0.0
149:       vnbt = 0.0
150:       vsbt = 0.0
151: #endif
152:       tgmx_o = -1.E30
153:       t2mx_o = -1.E30
154:       tgmn_o =  1.E30
155:       t2mn_o =  1.E30
156:       w10x_o = -1.E30
157:       psmn_o =  1.E30
158: 
159: #ifdef MPP1
160:       if ( myid.eq.0 ) then
161:         if (ndate0.eq.globidate1 .or.                                   &
162:            (((ndate0/10000)*100+1)*100 .eq.                             &
163:            ((globidate1/10000)*100+1)*100 ) ) then
164:           write (finm,99001) trim(dirglob),pthsep,trim(domname),'_ICBC',&
165:                & globidate1
166:         else
167:           write (finm,99001) trim(dirglob),pthsep,trim(domname),'_ICBC',&
168:                & ((ndate0/10000)*100+1)*100
169:         end if
170:         inquire (file=finm,exist=existing)
171:         if (.not.existing) then
172:           write (aline,*) 'The following ICBC File does not exist: ' ,  &
173:               &            trim(finm), 'please check location'
174:           call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
175:           call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__, 'ICBC FILE NOT FOUND')
176:         else
177:           open (iutbc,file=finm,form='unformatted',status='old',        &
178:           & access='direct',recl=iy*jx*ibyte)
179:         endif  
180:         mmrec = 0
181:       end if
182: #else
183:       if (ndate0.eq.globidate1 .or.                                     &
184:          (((ndate0/10000)*100+1)*100 .eq.                               &
185:          ((globidate1/10000)*100+1)*100 ) ) then
186:         write (finm,99001) trim(dirglob),pthsep,trim(domname),'_ICBC',  &
187:              & globidate1
188:       else
189:         write (finm,99001) trim(dirglob),pthsep,trim(domname),'_ICBC',  &
190:              & ((ndate0/10000)*100+1)*100
191:       end if
192:       inquire(file=finm,exist=existing)
193:         if (.not.existing) then
194:           write (aline,*) 'The following IBC File does not exist: ' ,   &
195:               &            trim(finm), 'please check location'
196:           call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
197:           call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,' ICBC FILE NOT FOUND')
198:         else 
199:            open (iutbc,file=finm,form='unformatted',status='old',       &
200:            &access='direct',recl=iy*jx*ibyte)
201:            mmrec = 0
202:         endif 
203: #endif
204: !
205:       if ( .not.ifrest ) then
206: !-----for initial run--not using restart
207: !
208: !------set rainwater and cloud water equal to zero initially.
209: !
210:         qca = 0.0
211:         qcb = 0.0
212: !
213: #ifdef DIAG
214:         tdini = 0.
215:         tdadv = 0.
216:         tqini = 0.
217:         tqadv = 0.
218:         tqeva = 0.
219:         tqrai = 0.
220: #endif
221: !
222: !chem2
223:         if ( ichem.eq.1 ) then
224: !-----    total tracer concs (initial, emission, advected)
225: #ifdef DIAG
226:           do itr = 1 , ntr
227:             ttrace(itr,1) = 0.
228:             ttrace(itr,2) = 0.
229:             tchie(itr) = 0.
230:             tchiad(itr) = 0.
231:             tchitb(itr) = 0.
232:           end do
233: #endif
234: !qhy      tchie, tchitb(replace tchidp:deposition)
235: !         initialize removal terms
236: !
237:           remlsc = 0.0
238:           remcvc = 0.0
239:           rxsg   = 0.0
240:           rxsaq1 = 0.0
241:           rxsaq2 = 0.0
242:           remdrd = 0.0
243:           wdlsc  = 0.0
244:         end if
245: !chem2_
246: !------set the variables related to blackadar pbl equal to 0 initially.
247: !
248:         if ( ibltyp.ne.0 ) then
249:           hfx = 0.0
250:           qfx = 0.0
251:         end if
252: !
253:         if ( icup.eq.1 ) then
254:           rsheat = 0.0
255:           rswat  = 0.0
256:         end if
257: !
258: !------read in the initial conditions for large domain:
259: !       the initial conditions are the output from PREPROC/ICBC.
260: !
261: #ifdef MPP1
262: #ifdef CLM
263:         if ( .not. allocated(init_tgb) ) allocate(init_tgb(iy,jx))
264: #endif
265:         do
266:           if ( myid.eq.0 ) then
267:             mmrec = mmrec + 1
268:             read (iutbc,rec=mmrec) ndate0 , nxxx , nyyy , kzzz
269:             if ( nyyy.ne.iy .or. nxxx.ne.jx .or. kzzz.ne.kz ) then
270:               write (aline,*) 'SET IN regcm.param: IY=' , iy , ' JX=' , &
271:                             & jx , ' KX=' , kz
272:               call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
273:               write (aline,*) 'SET IN ICBC: NY=' , nyyy , ' NX=' ,      &
274:                             & nxxx , ' NZ=' , kzzz
275:               call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
276:               call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,                             &
277:                         &'IMPROPER DIMENSION SPECIFICATION')
278:             end if
279:             print * , 'READING INITAL CONDITIONS' , ndate0
280:             if ( ndate0.lt.mdatez(nnnchk) ) then
281:               print * , ndate0 , mdatez(nnnchk) , nnnchk
282:               print * , 'read in datasets at :' , ndate0
283:               if ( ehso4 ) then
284:                 if ( lsmtyp.ne.'USGS' ) then
285:                   mmrec = mmrec + kz*5 + 2
286:                 else
287:                   mmrec = mmrec + kz*5 + 2 + 13
288:                 end if
289:               else if ( lsmtyp.ne.'USGS' ) then
290:                 mmrec = mmrec + kz*4 + 2
291:               else
292:                 mmrec = mmrec + kz*4 + 2 + 13
293:               end if
294:               print * , 'Searching for proper date: ' , ndate1 ,        &
295:                   & mdatez(nnnchk+1)
296:               print * , ndate0 , mdatez(nnnchk)
297:               cycle ! Proper date not found
298:             else if ( ndate0.gt.mdatez(nnnchk) ) then
299:               write (aline,*) ndate0 , mdatez(nnnchk)
300:               call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
301:               call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,                             &
302:                         &'DATE IN ICBC FILE EXCEEDED DATE IN RegCM')
303:             else
304:             end if
305:           end if
306:           exit ! Found proper date
307:         end do
308: !
309:         if ( myid.eq.0 ) then
310:           print * , 'U'
311:           do k = kz , 1 , -1
312:             mmrec = mmrec + 1
313:             read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
314:             do j = 1 , jx
315:               do i = 1 , iy
316:                 ub0_io(i,k,j) = dble(io2d(i,j))
317:               end do
318:             end do
319:           end do
320:           print * , 'V'
321:           do k = kz , 1 , -1
322:             mmrec = mmrec + 1
323:             read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
324:             do j = 1 , jx
325:               do i = 1 , iy
326:                 vb0_io(i,k,j) = dble(io2d(i,j))
327:               end do
328:             end do
329:           end do
330:           print * , 'TA'
331:           do k = kz , 1 , -1
332:             mmrec = mmrec + 1
333:             read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
334:             do j = 1 , jx
335:               do i = 1 , iy
336:                 tb0_io(i,k,j) = dble(io2d(i,j))
337:               end do
338:             end do
339:           end do
340:           print * , 'QV'
341:           do k = kz , 1 , -1
342:             mmrec = mmrec + 1
343:             read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
344:             do j = 1 , jx
345:               do i = 1 , iy
346:                 qb0_io(i,k,j) = dble(io2d(i,j))
347:               end do
348:             end do
349:           end do
350:           print * , 'PS'
351:           mmrec = mmrec + 1
352:           read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
353:           do j = 1 , jx
354:             do i = 1 , iy
355:               ps0_io(i,j) = dble(io2d(i,j))
356:             end do
357:           end do
358:           print * , 'TS'
359:           mmrec = mmrec + 1
360:           read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
361:           do j = 1 , jx
362:             do i = 1 , iy
363:               ts0_io(i,j) = dble(io2d(i,j))
364:             end do
365:           end do
366:           if ( ehso4 ) then
367:             print * , 'SO0'
368:             do k = kz , 1 , -1
369:               mmrec = mmrec + 1
370:               read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
371:               do j = 1 , jx
372:                 do i = 1 , iy
373:                   so0_io(i,k,j) = dble(io2d(i,j))
374:                 end do
375:               end do
376:             end do
377:           end if
378:           if ( lsmtyp.eq.'USGS' ) mmrec = mmrec + 13
379: 
380:           do j = 1 , jx
381:             do k = 1 , kz
382:               do i = 1 , iy
383:                 sav_0(i,k,j) = ub0_io(i,k,j)
384:                 sav_0(i,kz+k,j) = vb0_io(i,k,j)
385:                 sav_0(i,kz*2+k,j) = qb0_io(i,k,j)
386:                 sav_0(i,kz*3+k,j) = tb0_io(i,k,j)
387:               end do
388:             end do
389:             do i = 1 , iy
390:               sav_0(i,kz*4+1,j) = ps0_io(i,j)
391:               sav_0(i,kz*4+2,j) = ts0_io(i,j)
392:             end do
393:           end do
394:           if ( ehso4 ) then
395:             do j = 1 , jx
396:               do k = 1 , kz
397:                 do i = 1 , iy
398:                   sav_0s(i,k,j) = so0_io(i,k,j)
399:                 end do
400:               end do
401:             end do
402:           end if
403:         end if ! end if myid=0
404: !
405: !       Start transmission of data to other processors
406: !
407:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ndate0,1,mpi_integer,0,mpi_comm_world,ierr)
408:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(nxxx,1,mpi_integer,0,mpi_comm_world,ierr)
409:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(nyyy,1,mpi_integer,0,mpi_comm_world,ierr)
410:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(kzzz,1,mpi_integer,0,mpi_comm_world,ierr)
411:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0(1,1,1),iy*(kz*4+2)*jxp,mpi_real8,        &
412:                        & sav0(1,1,1), iy*(kz*4+2)*jxp,mpi_real8,        &
413:                        & 0,mpi_comm_world,ierr)
414:         if ( ehso4 )                                                    &
415:           & call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0s(1,1,1),iy*kz*jxp,mpi_real8,         &
416:           &                  sav0s(1,1,1), iy*kz*jxp,mpi_real8,         &
417:           &                  0,mpi_comm_world,ierr)
418:         do j = 1 , jendl
419:           do k = 1 , kz
420:             do i = 1 , iy
421:               ub0(i,k,j) = sav0(i,k,j)
422:               vb0(i,k,j) = sav0(i,kz+k,j)
423:               qb0(i,k,j) = sav0(i,kz*2+k,j)
424:               tb0(i,k,j) = sav0(i,kz*3+k,j)
425:             end do
426:           end do
427:           do i = 1 , iy
428:             ps0(i,j) = sav0(i,kz*4+1,j)
429:             ts0(i,j) = sav0(i,kz*4+2,j)
430:           end do
431:           if ( ehso4 ) then
432:             do k = 1 , kz
433:               do i = 1 , iy
434:                 so0(i,k,j) = sav0s(i,k,j)
435:               end do
436:             end do
437:           end if
438:         end do
439: !
440: !       Convert surface pressure to pstar
441: !
442:         do j = 1 , jendl
443:           do i = 1 , iy
444:             ps0(i,j) = ps0(i,j) - r8pt
445:           end do
446:         end do
447: !=======================================================================
448: !
449: !       this routine determines p(.) from p(x) by a 4-point
450: !       interpolation. on the x-grid, a p(x) point outside the grid
451: !       domain is assumed to satisfy p(0,j)=p(1,j); p(iy,j)=p(iym1,j);
452: !       and similarly for the i's.
453: !
454:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(ps0(1,jxp),iy,mpi_real8,ieast,1,              &
455:                         & ps0(1,0),iy,mpi_real8,iwest,1,                &
456:                         & mpi_comm_world,mpi_status_ignore,ierr)
457:         do j = jbegin , jendx
458:           do i = 2 , iym1
459:             psdot(i,j) = 0.25*(ps0(i,j)   + ps0(i-1,j) +                &
460:                          &     ps0(i,j-1) + ps0(i-1,j-1))
461:           end do
462:         end do
463: !
464:         do i = 2 , iym1
465:           if ( myid.eq.0 ) psdot(i,1) = 0.5*(ps0(i,1)+ps0(i-1,1))
466:           if ( myid.eq.nproc-1 ) psdot(i,jendl)                         &
467:              & = 0.5*(ps0(i,jendx)+ps0(i-1,jendx))
468:         end do
469: !
470:         do j = jbegin , jendx
471:           psdot(1,j) = 0.5*(ps0(1,j)+ps0(1,j-1))
472:           psdot(iy,j) = 0.5*(ps0(iym1,j)+ps0(iym1,j-1))
473:         end do
474: !
475:         if ( myid.eq.0 ) then
476:           psdot(1,1) = ps0(1,1)
477:           psdot(iy,1) = ps0(iym1,1)
478:         end if
479:         if ( myid.eq.nproc-1 ) then
480:           psdot(1,jendl) = ps0(1,jendx)
481:           psdot(iy,jendl) = ps0(iym1,jendx)
482:         end if
483: !
484: !=======================================================================
485: !       Couple pressure u,v,t,q
486:         do k = 1 , kz
487:           do j = 1 , jendl
488:             do i = 1 , iy
489:               ub0(i,k,j) = ub0(i,k,j)*psdot(i,j)
490:               vb0(i,k,j) = vb0(i,k,j)*psdot(i,j)
491:               tb0(i,k,j) = tb0(i,k,j)*ps0(i,j)
492:               qb0(i,k,j) = qb0(i,k,j)*ps0(i,j)
493:             end do
494:          end do
495:         end do
496:         if ( myid.eq.0 ) then
497:           mmrec = mmrec + 1
498:           read (iutbc,rec=mmrec) ndate1
499:           mmrec = mmrec - 1
500:           ibdyhr0 = ndate0 - (ndate0/100)*100
501:           ibdyhr1 = ndate1 - (ndate1/100)*100
502:           if ( ibdyhr1.eq.0 ) ibdyhr1 = 24
503:           ibdydiff = ibdyhr1 - ibdyhr0
504:           if ( ibdydiff.ne.ibdyfrq ) then
505:             write (aline,*) '  ndate0=' , ndate0 , 'ndate1=' , ndate1
506:             call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
507:             write (aline,*) '  ibdyfrq=' , ibdyfrq , 'ibdydiff=' ,    &
508:                           & ibdydiff
509:             call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
510:             write (aline,*) '  ibdyhr0=' , ibdyhr0 , 'ibdyhr1=' ,     &
511:                           & ibdyhr1
512:             call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
513:             call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,                             &
514:                       &'BOUNDARY CONDITION FREQUENCY INCOMPATIBILITY')
515:           end if
516:         end if
517: !
518:         mdate = ndate0
519: !
520: !       Initialize variables and convert to double precision
521: !
522:         do k = 1 , kz
523:           do j = 1 , jendl
524:             do i = 1 , iy
525:               ua(i,k,j) = ub0(i,k,j)
526:               ub(i,k,j) = ub0(i,k,j)
527:               va(i,k,j) = vb0(i,k,j)
528:               vb(i,k,j) = vb0(i,k,j)
529:               qva(i,k,j) = qb0(i,k,j)
530:               qvb(i,k,j) = qb0(i,k,j)
531:               ta(i,k,j) = tb0(i,k,j)
532:               tb(i,k,j) = tb0(i,k,j)
533:             end do
534:           end do
535:         end do
536:         do j = 1 , jendl
537:           do i = 1 , iy
538:             psa(i,j) = ps0(i,j)
539:             psb(i,j) = ps0(i,j)
540:             tga(i,j) = ts0(i,j)
541:             tgb(i,j) = ts0(i,j)
542:           end do
543:         end do
544: #ifdef SEAICE
545:         do j = 1 , jendx
546:           do i = 1 , iym1
547:             if ( veg2d(i,j).le.0.00001 ) then
548:               if ( ts0(i,j).le.271.38 ) then
549:                 tga(i,j) = 271.38
550:                 tgb(i,j) = 271.38
551:                 ts0(i,j) = 271.38
552: !               write(*,*) 'Sea Ice point:', i,j
553:                 do n = 1, nnsg
554:                   ocld2d(n,i,j)=2.
555:                   sice2d(n,i,j)=1000.
556:                 end do
557:               else
558:                 do n = 1, nnsg
559:                   ocld2d(n,i,j)=0.
560:                   sice2d(n,i,j)=0.
561:                 end do
562:               end if
563:             end if
564:           end do
565:         end do
566: #endif
567:         do k = 1 , kz
568:           do j = 1 , jendl
569:             do i = 1 , iy
570:               tbase(i,k,j) = ts00 + tlp*dlog((psa(i,j)*a(k)+r8pt)/100.)
571:             end do
572:           end do
573:         end do
574:         if ( ehso4 ) then
575:           do k = 1 , kz
576:             do j = 1 , jendl
577:               do i = 1 , iy
578:                 so4(i,k,j) = so0(i,k,j)
579:               end do
580:             end do
581:           end do
582:         end if
583: !
584:         do j = 1 , jendx
585:           do i = 1 , iym1
586:             tga(i,j) = ta(i,kz,j)/psa(i,j)
587:             tgb(i,j) = tb(i,kz,j)/psb(i,j)
588:             tgbb(i,j) = tb(i,kz,j)/psb(i,j)
589:             zpbl(i,j) = 500.  ! For Zeng Ocean Flux Scheme
590:           end do
591:         end do
592:         do j = 1 , jendx
593:           do i = 1 , iym1
594:             do k = 1 , nnsg
595:               snowc(k,i,j) = 0.
596:             end do
597:           end do
598:         end do
599:         if ( ichem.eq.1 ) then
600:           ssw2da    = 0.0
601:           sdeltk2d  = 0.0
602:           sdelqk2d  = 0.0
603:           sfracv2d  = 0.5
604:           sfracb2d  = 0.5
605:           sfracs2d  = 0.0
606:           svegfrac2d = 0.0
607:         end if
608: #else
609:         do
610:           mmrec = mmrec + 1
611:           read (iutbc,rec=mmrec) ndate0 , nxxx , nyyy , kzzz
612:           if ( nyyy.ne.iy .or. nxxx.ne.jx .or. kzzz.ne.kz ) then
613:             write (aline,*) 'SET IN regcm.param: IY=' , iy , ' JX=' ,   &
614:                           & jx , ' KX=' , kz
615:             call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
616:             write (aline,*) 'SET IN ICBC: NY=' , nyyy , ' NX=' , nxxx , &
617:                            &' NZ=' , kzzz
618:             call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
619:             call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,                               &
620:                       &'IMPROPER DIMENSION SPECIFICATION')
621:           end if
622:           print * , 'READING INITAL CONDITIONS' , ndate0
623:           if ( ndate0.lt.mdatez(nnnchk) ) then
624:             print * , ndate0 , mdatez(nnnchk) , nnnchk
625:             print * , 'read in datasets at :' , ndate0
626:             if ( ehso4 ) then
627:               if ( lsmtyp.ne.'USGS' ) then
628:                 mmrec = mmrec + kz*5 + 2
629:               else
630:                 mmrec = mmrec + kz*5 + 2 + 13
631:               end if
632:             else if ( lsmtyp.ne.'USGS' ) then
633:               mmrec = mmrec + kz*4 + 2
634:             else
635:               mmrec = mmrec + kz*4 + 2 + 13
636:             end if
637:             print * , 'Searching for proper date: ' , ndate1 ,          &
638:                 & mdatez(nnnchk+1)
639:             print * , ndate0 , mdatez(nnnchk)
640:             cycle ! Proper date still not found
641:           else if ( ndate0.gt.mdatez(nnnchk) ) then
642:             write (aline,*) ndate0 , mdatez(nnnchk)
643:             call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
644:             call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,                               &
645:                       &'DATE IN ICBC FILE EXCEEDED DATE IN RegCM')
646:           else
647:           end if
648:           exit ! Found proper date
649:         end do
650: !
651:         print * , 'U'
652:         do k = kz , 1 , -1
653:           mmrec = mmrec + 1
654:           read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
655:           do j = 1 , jx
656:             do i = 1 , iy
657:               ub0(i,k,j) = dble(io2d(i,j))
658:             end do
659:           end do
660:         end do
661:         print * , 'V'
662:         do k = kz , 1 , -1
663:           mmrec = mmrec + 1
664:           read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
665:           do j = 1 , jx
666:             do i = 1 , iy
667:               vb0(i,k,j) = dble(io2d(i,j))
668:             end do
669:           end do
670:         end do
671:         print * , 'TA'
672:         do k = kz , 1 , -1
673:           mmrec = mmrec + 1
674:           read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
675:           do j = 1 , jx
676:             do i = 1 , iy
677:               tb0(i,k,j) = dble(io2d(i,j))
678:             end do
679:           end do
680:         end do
681:         print * , 'QV'
682:         do k = kz , 1 , -1
683:           mmrec = mmrec + 1
684:           read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
685:           do j = 1 , jx
686:             do i = 1 , iy
687:               qb0(i,k,j) = dble(io2d(i,j))
688:             end do
689:           end do
690:         end do
691:         print * , 'PS'
692:         mmrec = mmrec + 1
693:         read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
694:         do j = 1 , jx
695:           do i = 1 , iy
696:             ps0(i,j) = dble(io2d(i,j))
697:           end do
698:         end do
699:         print * , 'TS'
700:         mmrec = mmrec + 1
701:         read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
702:         do j = 1 , jx
703:           do i = 1 , iy
704:             ts0(i,j) = dble(io2d(i,j))
705:           end do
706:         end do
707:         if ( ehso4 ) then
708:           print * , 'SO0'
709:           do k = kz , 1 , -1
710:             mmrec = mmrec + 1
711:             read (iutbc,rec=mmrec) ((io2d(i,j),j=1,jx),i=1,iy)
712:             do j = 1 , jx
713:               do i = 1 , iy
714:                 so0(i,k,j) = dble(io2d(i,j))
715:               end do
716:             end do
717:           end do
718:         end if
719:         if ( lsmtyp.eq.'USGS' ) mmrec = mmrec + 13
720: !
721: !       Convert surface pressure to pstar
722: !
723:         do j = 1 , jx
724:           do i = 1 , iy
725:             ps0(i,j) = ps0(i,j) - r8pt
726:           end do
727:         end do
728: !=======================================================================
729: !
730: !       this routine determines p(.) from p(x) by a 4-point
731: !       interpolation. on the x-grid, a p(x) point outside the grid
732: !       domain is assumed to satisfy p(0,j)=p(1,j);
733: !       p(iy,j)=p(iym1,j); and similarly for the i's.
734: !
735:         do j = 2 , jxm1
736:           do i = 2 , iym1
737:             psdot(i,j) = 0.25*(ps0(i,j)+ps0(i-1,j)+                     &
738:                        &       ps0(i,j-1)+ps0(i-1,j-1))
739:           end do
740:         end do
741: !
742:         do i = 2 , iym1
743:           psdot(i,1) = 0.5*(ps0(i,1)+ps0(i-1,1))
744:           psdot(i,jx) = 0.5*(ps0(i,jxm1)+ps0(i-1,jxm1))
745:         end do
746: !
747:         do j = 2 , jxm1
748:           psdot(1,j) = 0.5*(ps0(1,j)+ps0(1,j-1))
749:           psdot(iy,j) = 0.5*(ps0(iym1,j)+ps0(iym1,j-1))
750:         end do
751: !
752:         psdot(1,1) = ps0(1,1)
753:         psdot(iy,1) = ps0(iym1,1)
754:         psdot(1,jx) = ps0(1,jxm1)
755:         psdot(iy,jx) = ps0(iym1,jxm1)
756: !
757: !=======================================================================
758: !       Couple pressure u,v,t,q
759: !
760:         do k = 1 , kz
761:           do j = 1 , jx
762:             do i = 1 , iy
763:               ub0(i,k,j) = ub0(i,k,j)*psdot(i,j)
764:               vb0(i,k,j) = vb0(i,k,j)*psdot(i,j)
765:               tb0(i,k,j) = tb0(i,k,j)*ps0(i,j)
766:               qb0(i,k,j) = qb0(i,k,j)*ps0(i,j)
767:             end do
768:           end do
769:         end do
770:         mmrec = mmrec + 1
771:         read (iutbc,rec=mmrec) ndate1
772:         mmrec = mmrec - 1
773:         ibdyhr0 = ndate0 - (ndate0/100)*100
774:         ibdyhr1 = ndate1 - (ndate1/100)*100
775:         if ( ibdyhr1.eq.0 ) ibdyhr1 = 24
776:         ibdydiff = ibdyhr1 - ibdyhr0
777:         if ( ibdydiff.ne.ibdyfrq ) then
778:           write (aline,*) '  ndate0=' , ndate0 , 'ndate1=' , ndate1
779:           call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
780:           write (aline,*) '  ibdyfrq=' , ibdyfrq , 'ibdydiff=' ,      &
781:                         & ibdydiff
782:           call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
783:           write (aline,*) '  ibdyhr0=' , ibdyhr0 , 'ibdyhr1=' ,       &
784:                         & ibdyhr1
785:           call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
786:           call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,                               &
787:                     &'BOUNDARY CONDITION FREQUENCY INCOMPATIBILITY')
788:         end if
789: !
790:         mdate = ndate0
791: !
792: !       Initialize variables and convert to double precision
793: !
794:         do k = 1 , kz
795:           do j = 1 , jx
796:             do i = 1 , iy
797:               ua(i,k,j) = ub0(i,k,j)
798:               ub(i,k,j) = ub0(i,k,j)
799:               va(i,k,j) = vb0(i,k,j)
800:               vb(i,k,j) = vb0(i,k,j)
801:               qva(i,k,j) = qb0(i,k,j)
802:               qvb(i,k,j) = qb0(i,k,j)
803:               ta(i,k,j) = tb0(i,k,j)
804:               tb(i,k,j) = tb0(i,k,j)
805:             end do
806:           end do
807:         end do
808:         do j = 1 , jx
809:           do i = 1 , iy
810:             psa(i,j) = ps0(i,j)
811:             psb(i,j) = ps0(i,j)
812:             tga(i,j) = ts0(i,j)
813:             tgb(i,j) = ts0(i,j)
814:           end do
815:         end do
816: #ifdef SEAICE
817:         do j = 1 , jxm1
818:           do i = 1 , iym1
819:             if ( veg2d(i,j).le.0.00001 ) then
820:               if ( ts0(i,j).le.271.38 ) then
821:                 tga(i,j) = 271.38
822:                 tgb(i,j) = 271.38
823:                 ts0(i,j) = 271.38
824: !               write(*,*) 'Sea Ice point:', i,j
825:                 do n = 1, nnsg
826:                   ocld2d(n,i,j)=2.
827:                   sice2d(n,i,j)=1000.
828:                 end do
829:               else
830:                 do n = 1, nnsg
831:                   ocld2d(n,i,j)=0.
832:                   sice2d(n,i,j)=0.
833:                 end do
834:               end if
835:             end if
836:           end do
837:         end do
838: #endif
839:         do k = 1 , kz
840:           do j = 1 , jx
841:             do i = 1 , iy
842:               tbase(i,k,j) = ts00 + tlp*dlog((psa(i,j)*a(k)+r8pt)/100.)
843:             end do
844:           end do
845:         end do
846:         if ( ehso4 ) then
847:           do k = 1 , kz
848:             do j = 1 , jx
849:               do i = 1 , iy
850:                 so4(i,k,j) = so0(i,k,j)
851:               end do
852:             end do
853:           end do
854:         end if
855: !
856:         do j = 1 , jxm1
857:           do i = 1 , iym1
858:             tga(i,j) = ta(i,kz,j)/psa(i,j)
859:             tgb(i,j) = tb(i,kz,j)/psb(i,j)
860:             tgbb(i,j) = tb(i,kz,j)/psb(i,j)
861:             zpbl(i,j) = 500.
862:                        ! For Zeng Ocean Flux Scheme
863:           end do
864:         end do
865:         do j = 1 , jxm1
866:           do i = 1 , iym1
867:             do k = 1 , nnsg
868:               snowc(k,i,j) = 0.
869:             end do
870:           end do
871:         end do
872:         if ( ichem.eq.1 ) then
873:           ssw2da = 0.0
874:           sdeltk2d = 0.0
875:           sdelqk2d = 0.0
876:           sfracv2d = 0.5
877:           sfracb2d = 0.5
878:           sfracs2d = 0.0
879:           svegfrac2d = 0.0
880:         end if
881: #endif
882: 
883: #ifdef DIAG
884: #ifdef MPP1
885: !=======================================================================
886: !
887: !-----dry air (unit = kg):
888: !
889:         tdini = 0.
890:         call <a href="#" TARGET=CENT_PANEL>mpi_gather</a>(psa(1,1),   iy*jxp,mpi_real8,                   &
891:                       & psa_io(1,1),iy*jxp,mpi_real8,                   &
892:                       & 0,mpi_comm_world,ierr)
893:         if ( myid.eq.0 ) then
894:           do k = 1 , kz
895:             tttmp = 0.
896:             do j = 1 , jxm1
897:               do i = 1 , iym1
898:                 tttmp = tttmp + psa_io(i,j)
899:               end do
900:             end do
901:             tdini = tdini + tttmp*dsigma(k)
902:           end do
903:           tdini = tdini*dx*dx*1000.*rgti
904:         end if
905:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tdini,1,mpi_real8,0,mpi_comm_world,ierr)
906: !
907: !-----water substance (unit = kg):
908: !
909:         tvmass = 0.
910:         call <a href="#" TARGET=CENT_PANEL>mpi_gather</a>(qva(1,1,1),   iy*kz*jxp,mpi_real8,              &
911:                       & qva_io(1,1,1),iy*kz*jxp,mpi_real8,              &
912:                       & 0,mpi_comm_world,ierr)
913:         if ( myid.eq.0 ) then
914:           do k = 1 , kz
915:             tttmp = 0.
916:             do j = 1 , jxm1
917:               do i = 1 , iym1
918:                 tttmp = tttmp + qva_io(i,k,j)
919:               end do
920:             end do
921:             tvmass = tvmass + tttmp*dsigma(k)
922:           end do
923:           tvmass = tvmass*dx*dx*1000.*rgti
924:         end if
925:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tvmass,1,mpi_real8,0,mpi_comm_world,ierr)
926: !
927:         tcmass = 0.
928:         call <a href="#" TARGET=CENT_PANEL>mpi_gather</a>(qca(1,1,1),   iy*kz*jxp,mpi_real8,              &
929:                       & qca_io(1,1,1),iy*kz*jxp,mpi_real8,              &
930:                       & 0,mpi_comm_world,ierr)
931:         if ( myid.eq.0 ) then
932:           do k = 1 , kz
933:             tttmp = 0.
934:             do j = 1 , jxm1
935:               do i = 1 , iym1
936:                 tttmp = tttmp + qca_io(i,k,j)
937:               end do
938:             end do
939:             tcmass = tcmass + tttmp*dsigma(k)
940:           end do
941:           tcmass = tcmass*dx*dx*1000.*rgti
942:         end if
943:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tcmass,1,mpi_real8,0,mpi_comm_world,ierr)
944:         tqini = tvmass + tcmass
945: !=======================================================================
946:         if ( myid.eq.0 ) print 99003 , tdini , tqini
947: #else
948: !=======================================================================
949: !
950: !-----dry air (unit = kg):
951: !
952:         tdini = 0.
953:         do k = 1 , kz
954:           tttmp = 0.
955:           do j = 1 , jxm1
956:             do i = 1 , iym1
957:               tttmp = tttmp + psa(i,j)
958:             end do
959:           end do
960:           tdini = tdini + tttmp*dsigma(k)
961:         end do
962:         tdini = tdini*dx*dx*1000.*rgti
963: !
964: !-----water substance (unit = kg):
965: !
966:         tvmass = 0.
967:         do k = 1 , kz
968:           tttmp = 0.
969:           do j = 1 , jxm1
970:             do i = 1 , iym1
971:               tttmp = tttmp + qva(i,k,j)
972:             end do
973:           end do
974:           tvmass = tvmass + tttmp*dsigma(k)
975:         end do
976:         tvmass = tvmass*dx*dx*1000.*rgti
977: !
978:         tcmass = 0.
979:         do k = 1 , kz
980:           tttmp = 0.
981:           do j = 1 , jxm1
982:             do i = 1 , iym1
983:               tttmp = tttmp + qca(i,k,j)
984:             end do
985:           end do
986:           tcmass = tcmass + tttmp*dsigma(k)
987:         end do
988:         tcmass = tcmass*dx*dx*1000.*rgti
989:         tqini = tvmass + tcmass
990: !=======================================================================
991:         print 99003 , tdini , tqini
992: #endif
993: #endif
994: !
995: !chem2
996:         if ( ichem.eq.1 ) then
997: !-----set tracer concs to 1 (kg/kg) initially. Must convert this to p*
998: !-----mixing ratio to compute tendencies:
999: !US       mass test zero concs init input for advection
1000: !qhy      initial chia is 10ppt
1001: !hy       set the initial tracer concentration 10ppt (1.e-11), 9/4/98
1002:  
1003:           do itr = 1 , ntr
1004:             do k = 1 , kz
1005: #ifdef MPP1
1006:               do j = 1 , jendx
1007:                 do i = 1 , iym1
1008:                   chia(i,k,j,itr) = psa(i,j)*0.0D0
1009:                   chib(i,k,j,itr) = psb(i,j)*0.0D0
1010: !                 chia(i,k,j,itr)=psa(i,j)*1.e-11
1011: !                 chib(i,k,j,itr)=psb(i,j)*1.e-11
1012:                 end do
1013:               end do
1014: #else
1015:               do j = 1 , jxm1
1016:                 do i = 1 , iym1
1017:                   chia(i,k,j,itr) = psa(i,j)*0.0D0
1018:                   chib(i,k,j,itr) = psb(i,j)*0.0D0
1019: !                 chia(i,k,j,itr)=psa(i,j)*1.e-11
1020: !                 chib(i,k,j,itr)=psb(i,j)*1.e-11
1021:                 end do
1022:               end do
1023: #endif
1024:             end do
1025:           end do
1026:  
1027:         end if
1028: !chem2_
1029: !
1030: !------set rainc and rainnc equal to 0. initially
1031: !
1032:         rainc  = 0.0
1033:         rainnc = 0.0
1034:  
1035:         if ( icup.eq.4 ) then
1036:           cbmf2d = 0.0
1037:         end if
1038: !
1039:       else ! ifrest=.true.
1040: !-----when ifrest=.true., read in the data saved from previous run
1041: !       for large domain from unit 14.
1042: !
1043: #ifdef MPP1
1044:         if ( myid.eq.0 ) then
1045:           if (ndate0.eq.idate0 .or.                                     &
1046:              (((ndate0/10000)*100+1)*100 .eq.                           &
1047:              ((idate0/10000)*100+1)*100 ) ) then
1048:             write (finm,99002) trim(dirout),pthsep,'SAV.',idate0
1049:           else
1050:             write (finm,99002) trim(dirout),pthsep,'SAV.',              &
1051:               &    ((ndate0/10000)*100+1)*100
1052:           end if
1053:           inquire (file=finm,exist=existing)
1054:           if ( .not.existing ) then
1055:             write (aline,*) 'The following SAV File does not exist: ' , &
1056:                 &            trim(finm), 'please check location'
1057:             call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
1058:             call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__, 'SAV FILE NOT FOUND')
1059:           else
1060:             open (iutrs,file=finm,form='unformatted',status='old')
1061:           end if
1062:           do ! Loop while ldatez.ne.idate1
1063:             read (iutrs) mdate0
1064:             jyear0 = mdate0/1000000
1065:             read (iutrs) ktau , xtime , ldatez , lyear , lmonth , lday ,&
1066:                        & lhour , ntime
1067:             jyear = lyear
1068:             jyearr = jyear
1069:             ktaur = ktau
1070:             if ( ehso4 ) then
1071:               read (iutrs) ub0_io , vb0_io , qb0_io , tb0_io , ps0_io , &
1072:                          & ts0_io , so0_io
1073:             else
1074:               read (iutrs) ub0_io , vb0_io , qb0_io , tb0_io , ps0_io , &
1075:                          & ts0_io
1076:             end if
1077:             read (iutrs) ua_io
1078:             read (iutrs) ub_io
1079:             read (iutrs) va_io
1080:             read (iutrs) vb_io
1081:             read (iutrs) ta_io
1082:             read (iutrs) tb_io
1083:             read (iutrs) qva_io
1084:             read (iutrs) qvb_io
1085:             read (iutrs) qca_io
1086:             read (iutrs) qcb_io
1087:             read (iutrs) psa_io , psb_io , satbrt_io , satbrt1_io , f_io
1088:             read (iutrs) ht_io , ht1_io , msfx_io , msfd_io , xlat_io , &
1089:                        & xlong_io
1090:             read (iutrs) tga_io , tgb_io , rainc_io , rainnc_io
1091:             if ( icup.eq.1 ) then
1092:               read (iutrs) rsheat_io , rswat_io
1093:             else if ( icup.eq.3 ) then
1094:               read (iutrs) tbase_io , cldefi_io
1095:             else if ( icup.eq.4 ) then
1096:               read (iutrs) cbmf2d_io
1097:             else
1098:             end if
1099:             read (iutrs) hfx_io , qfx_io , snowc_io , uvdrag_io
1100: #ifdef DIAG
1101:             read (iutrs) tdini , tdadv , tqini , tqadv , tqeva , tqrai
1102: #endif
1103:             read (iutrs) absnxt_io , abstot_io , emstot_io
1104:             if ( ipptls.eq.1 ) read (iutrs) fcc_io
1105: #ifdef CLM
1106:             read (iutrs) sols2d_io
1107:             read (iutrs) soll2d_io
1108:             read (iutrs) solsd2d_io
1109:             read (iutrs) solld2d_io
1110:             read (iutrs) flwd2d_io
1111:             read (iutrs) aldirs2d_io
1112:             read (iutrs) aldirl2d_io
1113:             read (iutrs) aldifs2d_io
1114:             read (iutrs) aldifl2d_io
1115:             read (iutrs) coszrs2d_io
1116:             read (iutrs) ocld2d_io
1117:             read (iutrs) heatrt_io
1118:             read (iutrs) o3prof_io
1119:             read (iutrs) tgbb_io
1120:             read (iutrs) flw2d_io
1121:             read (iutrs) swt2d_io
1122:             read (iutrs) sinc2d_io
1123:             read (iutrs) fsw2d_io
1124:             read (iutrs) taf2d_io
1125: #else
1126:             read (iutrs) sol2d_io , solvd2d_io , solvs2d_io , flw2d_io ,&
1127:                        & flwd2d_io , fsw2d_io , sabv2d_io , sinc2d_io
1128:             read (iutrs) taf2d_io , tlef2d_io , tgbb_io , ssw2d_io ,    &
1129:                        & srw2d_io , tg2d_io , tgb2d_io , swt2d_io ,     &
1130:                        & scv2d_io , gwet2d_io , veg2d_io , veg2d1_io ,  &
1131:                        & sag2d_io , sice2d_io , dew2d_io , ircp2d_io ,  &
1132:                        & text2d_io , col2d_io , ocld2d_io , heatrt_io , &
1133:                        & o3prof_io
1134: #endif
1135:             read (iutrs) pptnc_io , pptc_io , prca2d_io , prnca2d_io
1136:             if ( iocnflx.eq.2 ) read (iutrs) zpbl_io
1137: !chem2---
1138:             if ( ichem.eq.1 ) then
1139:               read (iutrs) chia_io
1140:               read (iutrs) chib_io
1141: !             cumul removal terms (3d, 2d)
1142:               read (iutrs) remlsc_io
1143:               read (iutrs) remcvc_io
1144:               read (iutrs) remdrd_io
1145:               read (iutrs) ssw2da_io
1146:               read (iutrs) sdeltk2d_io
1147:               read (iutrs) sdelqk2d_io
1148:               read (iutrs) sfracv2d_io
1149:               read (iutrs) sfracb2d_io
1150:               read (iutrs) sfracs2d_io
1151:               read (iutrs) svegfrac2d_io
1152: !             cumul ad, dif, emis terms ( scalar)
1153: #ifdef DIAG
1154:               read (iutrs) tchiad
1155:               read (iutrs) tchitb
1156:               read (iutrs) tchie
1157: #endif
1158:             end if
1159:  
1160: !------lake model
1161:             if ( lakemod.eq.1 ) then
1162:               lcount = 0
1163:               iin = 41
1164:               iout = 42
1165:               rewind (iin)
1166:               read (iutrs) numpts
1167:               print * , 'reading lake model restart file. numpts = ' ,  &
1168:                   & numpts
1169:               print * , 'jyear, ktau, xtime = ' , jyear , ktau , xtime
1170:               do n = 1 , numpts
1171:                 read (iutrs) ilake , jlake , depth , freeze , hi , hii ,&
1172:                            & hs , eta , (tlake(j),j=1,depth)
1173:                 print * , 'reading restart file at i, j = ' , ilake ,   &
1174:                     & jlake
1175:                 write (iin) ilake , jlake , depth , freeze , hi , hii , &
1176:                           & hs , eta , (tlake(j),j=1,depth)
1177:               end do
1178:               rewind (iin)
1179:             end if
1180: !
1181:             print * , 'ozone profiles restart'
1182:             do k = 1 , kzp1
1183:               write (6,99004) o3prof_io(3,3,k)
1184:             end do
1185:             print 99005 , xtime , ktau , jyear , finm
1186: !
1187:             if ( ldatez.ne.idate1 ) then
1188:               write (*,*) 'INIT: ldatez, idate1=' , ldatez , idate1
1189:               cycle
1190:             end if
1191: 
1192:             exit ! We have ldatez.eq.idate1
1193:           end do
1194:         end if
1195: !
1196: !       Start sending data to all processors : surface data
1197: !
1198:         if ( myid.eq.0 ) then
1199:           do j = 1 , jx
1200:             do i = 1 , iy
1201:               inisrf_0(i,1,j) = ht_io(i,j)
1202:               inisrf_0(i,2,j) = satbrt_io(i,j)
1203:               inisrf_0(i,3,j) = xlat_io(i,j)
1204:               inisrf_0(i,4,j) = xlong_io(i,j)
1205:               inisrf_0(i,5,j) = msfx_io(i,j)
1206:               inisrf_0(i,6,j) = msfd_io(i,j)
1207:               inisrf_0(i,7,j) = f_io(i,j)
1208:             end do
1209:             do n = 1 , nnsg
1210:               do i = 1 , iy
1211:                 inisrf_0(i,7+n,j) = ht1_io(n,i,j)
1212:                 inisrf_0(i,7+nnsg+n,j) = satbrt1_io(n,i,j)
1213:               end do
1214:             end do
1215:           end do
1216:         end if
1217: 
1218:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(inisrf_0(1,1,1),iy*(nnsg*3+8)*jxp,mpi_real8,   &
1219:                        & inisrf0(1,1,1), iy*(nnsg*3+8)*jxp,mpi_real8,   &
1220:                        & 0,mpi_comm_world,ierr)
1221: 
1222:         do j = 1 , jxp
1223:           do i = 1 , iy
1224:             ht(i,j) = inisrf0(i,1,j)
1225:             satbrt(i,j) = inisrf0(i,2,j)
1226:             xlat(i,j) = inisrf0(i,3,j)
1227:             xlong(i,j) = inisrf0(i,4,j)
1228:             msfx(i,j) = inisrf0(i,5,j)
1229:             msfd(i,j) = inisrf0(i,6,j)
1230:             f(i,j) = inisrf0(i,7,j)
1231:           end do
1232:           do n = 1 , nnsg
1233:             do i = 1 , iy
1234:               ht1(n,i,j) = inisrf0(i,7+n,j)
1235:               satbrt1(n,i,j) = inisrf0(i,7+nnsg+n,j)
1236:             end do
1237:           end do
1238:         end do
1239: 
1240:         if ( myid.eq.0 ) then
1241:           do j = 1 , jx
1242:             do k = 1 , kz
1243:               do i = 1 , iy
1244:                 sav_0(i,k,j) = ub0_io(i,k,j)
1245:                 sav_0(i,kz+k,j) = vb0_io(i,k,j)
1246:                 sav_0(i,kz*2+k,j) = qb0_io(i,k,j)
1247:                 sav_0(i,kz*3+k,j) = tb0_io(i,k,j)
1248:               end do
1249:             end do
1250:             do i = 1 , iy
1251:               sav_0(i,kz*4+1,j) = ps0_io(i,j)
1252:               sav_0(i,kz*4+2,j) = ts0_io(i,j)
1253:             end do
1254:             if ( ehso4 ) then
1255:               do k = 1 , kz
1256:                 do i = 1 , iy
1257:                   sav_0s(i,k,j) = so0_io(i,k,j)
1258:                 end do
1259:               end do
1260:             end if
1261:           end do
1262:         end if
1263:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0(1,1,1),iy*(kz*4+2)*jxp,mpi_real8,        &
1264:                        & sav0(1,1,1), iy*(kz*4+2)*jxp,mpi_real8,        &
1265:                        & 0,mpi_comm_world,ierr)
1266:         if ( ehso4 )                                                    &
1267:           &  call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0s(1,1,1),iy*kz*jxp,mpi_real8,        &
1268:           &                   sav0s(1,1,1), iy*kz*jxp,mpi_real8,        &
1269:           &                   0,mpi_comm_world,ierr)
1270:         do j = 1 , jendl
1271:           do k = 1 , kz
1272:             do i = 1 , iy
1273:               ub0(i,k,j) = sav0(i,k,j)
1274:               vb0(i,k,j) = sav0(i,kz+k,j)
1275:               qb0(i,k,j) = sav0(i,kz*2+k,j)
1276:               tb0(i,k,j) = sav0(i,kz*3+k,j)
1277:             end do
1278:           end do
1279:           do i = 1 , iy
1280:             ps0(i,j) = sav0(i,kz*4+1,j)
1281:             ts0(i,j) = sav0(i,kz*4+2,j)
1282:           end do
1283:           if ( ehso4 ) then
1284:             do k = 1 , kz
1285:               do i = 1 , iy
1286:                 so0(i,k,j) = sav0s(i,k,j)
1287:               end do
1288:             end do
1289:           end if
1290:         end do
1291: 
1292:         if ( myid.eq.0 ) then
1293:           do j = 1 , jx
1294:             do k = 1 , kz
1295:               do i = 1 , iy
1296:                 sav_0(i,k,j) = ua_io(i,k,j)
1297:                 sav_0(i,kz+k,j) = ub_io(i,k,j)
1298:                 sav_0(i,kz*2+k,j) = va_io(i,k,j)
1299:                 sav_0(i,kz*3+k,j) = vb_io(i,k,j)
1300:               end do
1301:             end do
1302:             do i = 1 , iy
1303:               sav_0(i,kz*4+1,j) = psa_io(i,j)
1304:               sav_0(i,kz*4+2,j) = psb_io(i,j)
1305:             end do
1306:           end do
1307:         end if
1308:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0(1,1,1),iy*(kz*4+2)*jxp,mpi_real8,        &
1309:                        & sav0(1,1,1), iy*(kz*4+2)*jxp,mpi_real8,        &
1310:                        & 0,mpi_comm_world,ierr)
1311:         do j = 1 , jendl
1312:           do k = 1 , kz
1313:             do i = 1 , iy
1314:               ua(i,k,j) = sav0(i,k,j)
1315:               ub(i,k,j) = sav0(i,kz+k,j)
1316:               va(i,k,j) = sav0(i,kz*2+k,j)
1317:               vb(i,k,j) = sav0(i,kz*3+k,j)
1318:             end do
1319:           end do
1320:           do i = 1 , iy
1321:             psa(i,j) = sav0(i,kz*4+1,j)
1322:             psb(i,j) = sav0(i,kz*4+2,j)
1323:           end do
1324:         end do
1325:         if ( myid.eq.0 ) then
1326:           do j = 1 , jx
1327:             do k = 1 , kz
1328:               do i = 1 , iy
1329:                 sav_0(i,k,j) = ta_io(i,k,j)
1330:                 sav_0(i,kz+k,j) = tb_io(i,k,j)
1331:                 sav_0(i,kz*2+k,j) = qva_io(i,k,j)
1332:                 sav_0(i,kz*3+k,j) = qvb_io(i,k,j)
1333:               end do
1334:             end do
1335:             do i = 1 , iy
1336:               sav_0(i,kz*4+1,j) = tga_io(i,j)
1337:               sav_0(i,kz*4+2,j) = tgb_io(i,j)
1338:             end do
1339:           end do
1340:         end if
1341:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0(1,1,1),iy*(kz*4+2)*jxp,mpi_real8,        &
1342:                        & sav0(1,1,1), iy*(kz*4+2)*jxp,mpi_real8,        &
1343:                        & 0,mpi_comm_world,ierr)
1344:         do j = 1 , jendl
1345:           do k = 1 , kz
1346:             do i = 1 , iy
1347:               ta(i,k,j) = sav0(i,k,j)
1348:               tb(i,k,j) = sav0(i,kz+k,j)
1349:               qva(i,k,j) = sav0(i,kz*2+k,j)
1350:               qvb(i,k,j) = sav0(i,kz*3+k,j)
1351:             end do
1352:           end do
1353:           do i = 1 , iy
1354:             tga(i,j) = sav0(i,kz*4+1,j)
1355:             tgb(i,j) = sav0(i,kz*4+2,j)
1356:           end do
1357:         end do
1358:         if ( myid.eq.0 ) then
1359:           do j = 1 , jx
1360:             do k = 1 , kz
1361:               do i = 1 , iy
1362:                 sav_0(i,k,j) = qca_io(i,k,j)
1363:                 sav_0(i,kz+k,j) = qcb_io(i,k,j)
1364:                 sav_0(i,kz*2+k,j) = fcc_io(i,k,j)
1365:               end do
1366:             end do
1367:             do i = 1 , iy
1368:               sav_0(i,kz*4+1,j) = rainc_io(i,j)
1369:               sav_0(i,kz*4+2,j) = rainnc_io(i,j)
1370:             end do
1371:           end do
1372:           do j = 1 , jxm1
1373:             do k = 1 , kz
1374:               do i = 1 , iym1
1375:                 sav_0(i,kz*3+k,j) = heatrt_io(i,k,j)
1376:               end do
1377:             end do
1378:           end do
1379:         end if
1380:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0(1,1,1),iy*(kz*4+2)*jxp,mpi_real8,        &
1381:                        & sav0(1,1,1), iy*(kz*4+2)*jxp,mpi_real8,        &
1382:                        & 0,mpi_comm_world,ierr)
1383:         do j = 1 , jendl
1384:           do k = 1 , kz
1385:             do i = 1 , iy
1386:               qca(i,k,j) = sav0(i,k,j)
1387:               qcb(i,k,j) = sav0(i,kz+k,j)
1388:               fcc(i,k,j) = sav0(i,kz*2+k,j)
1389:             end do
1390:           end do
1391:           do i = 1 , iy
1392:             rainc(i,j) = sav0(i,kz*4+1,j)
1393:             rainnc(i,j) = sav0(i,kz*4+2,j)
1394:           end do
1395:         end do
1396:         do j = 1 , jendx
1397:           do k = 1 , kz
1398:             do i = 1 , iym1
1399:               heatrt(i,k,j) = sav0(i,kz*3+k,j)
1400:             end do
1401:           end do
1402:         end do
1403:         if ( myid.eq.0 ) then
1404:           do j = 1 , jx
1405:             do i = 1 , iy
1406:               sav_0a(i,1,j) = hfx_io(i,j)
1407:               sav_0a(i,2,j) = qfx_io(i,j)
1408:               sav_0a(i,3,j) = uvdrag_io(i,j)
1409:               sav_0a(i,4,j) = tgbb_io(i,j)
1410:             end do
1411:             do n = 1 , nnsg
1412:               do i = 1 , iy
1413:                 sav_0a(i,4+n,j) = snowc_io(n,i,j)
1414:               end do
1415:             end do
1416:           end do
1417:           do j = 1 , jxm1
1418:             do k = 1 , kzp1
1419:               do i = 1 , iym1
1420:                 sav_0a(i,nnsg+4+k,j) = o3prof_io(i,k,j)
1421:               end do
1422:             end do
1423:           end do
1424:         end if
1425:         allrec = kz + 5 + nnsg
1426:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0a(1,1,1),iy*allrec*jxp,mpi_real8,         &
1427:                        & sav0a(1,1,1), iy*allrec*jxp,mpi_real8,         &
1428:                        & 0,mpi_comm_world,ierr)
1429:         do j = 1 , jendl
1430:           do i = 1 , iy
1431:             hfx(i,j) = sav0a(i,1,j)
1432:             qfx(i,j) = sav0a(i,2,j)
1433:             uvdrag(i,j) = sav0a(i,3,j)
1434:             tgbb(i,j) = sav0a(i,4,j)
1435:           end do
1436:           do n = 1 , nnsg
1437:             do i = 1 , iy
1438:               snowc(n,i,j) = sav0a(i,4+n,j)
1439:             end do
1440:           end do
1441:         end do
1442:         do j = 1 , jendx
1443:           do k = 1 , kzp1
1444:             do i = 1 , iym1
1445:               o3prof(i,k,j) = sav0a(i,nnsg+4+k,j)
1446:             end do
1447:           end do
1448:         end do
1449:         if ( iocnflx.eq.2 )                                             &
1450:           & call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(zpbl_io(1,1),iy*jxp,mpi_real8,             &
1451:           &                  zpbl(1,1),   iy*jxp,mpi_real8,             &
1452:           &                  0,mpi_comm_world,ierr)
1453:         if ( icup.eq.1 ) then
1454:           if ( myid.eq.0 ) then
1455:             do j = 1 , jx
1456:               do k = 1 , kz
1457:                 do i = 1 , iy
1458:                   sav_0c(i,k,j) = rsheat_io(i,k,j)
1459:                   sav_0c(i,kz+k,j) = rswat_io(i,k,j)
1460:                 end do
1461:               end do
1462:             end do
1463:           end if
1464:           call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0c(1,1,1),iy*kz*2*jxp,mpi_real8,         &
1465:                          & sav0c(1,1,1), iy*kz*2*jxp,mpi_real8,         &
1466:                          & 0,mpi_comm_world,ierr)
1467:           do j = 1 , jendl
1468:             do k = 1 , kz
1469:               do i = 1 , iy
1470:                 rsheat(i,k,j) = sav0c(i,k,j)
1471:                 rswat(i,k,j) = sav0c(i,kz+k,j)
1472:               end do
1473:             end do
1474:           end do
1475:         else if ( icup.eq.3 ) then
1476:           if ( myid.eq.0 ) then
1477:             do j = 1 , jx
1478:               do k = 1 , kz
1479:                 do i = 1 , iy
1480:                   sav_0b(i,k,j) = tbase_io(i,k,j)
1481:                 end do
1482:               end do
1483:               do i = 1 , iy
1484:                 sav_0b(i,kzp1,j) = cldefi_io(i,j)
1485:               end do
1486:             end do
1487:           end if
1488:           call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_0b(1,1,1),iy*(kzp1)*jxp,mpi_real8,       &
1489:                          & sav0b(1,1,1), iy*(kzp1)*jxp,mpi_real8,       &
1490:                          & 0,mpi_comm_world,ierr)
1491:           do j = 1 , jendl
1492:             do k = 1 , kz
1493:               do i = 1 , iy
1494:                 tbase(i,k,j) = sav0b(i,k,j)
1495:               end do
1496:             end do
1497:             do i = 1 , iy
1498:               cldefi(i,j) = sav0b(i,kzp1,j)
1499:             end do
1500:           end do
1501:         else if ( icup.eq.4 ) then
1502:           call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(cbmf2d_io(1,1),iy*jxp,mpi_real8,             &
1503:                          & cbmf2d(1,1),   iy*jxp,mpi_real8,             &
1504:                          & 0,mpi_comm_world,ierr)
1505:         else
1506:         end if
1507:         if ( myid.eq.0 ) then
1508:           do j = 1 , jxm1
1509:             do l = 1 , 4
1510:               do k = 1 , kz
1511:                 do i = 1 , iym1
1512:                   sav_1(i,(l-1)*kz+k,j) = absnxt_io(i,k,l,j)
1513:                 end do
1514:               end do
1515:             end do
1516:           end do
1517:           allrec = kz*4
1518:           do j = 1 , jxm1
1519:             do l = 1 , kzp1
1520:               do k = 1 , kzp1
1521:                 do i = 1 , iym1
1522:                   sav_1(i,allrec+(l-1)*(kzp1)+k,j) = abstot_io(i,k,l,j)
1523:                 end do
1524:               end do
1525:             end do
1526:           end do
1527:           allrec = allrec + (kzp1)*(kz+1)
1528:           do j = 1 , jxm1
1529:             do k = 1 , kzp1
1530:               do i = 1 , iym1
1531:                 sav_1(i,allrec+k,j) = emstot_io(i,k,j)
1532:               end do
1533:             end do
1534:           end do
1535:           allrec = allrec + kzp1
1536:         end if
1537:         allrec = kz*4 + (kzp1*kzp2)
1538:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_1(1,1,1),iym1*allrec*jxp,mpi_real8,        &
1539:                        & sav1(1,1,1), iym1*allrec*jxp,mpi_real8,        &
1540:                        & 0,mpi_comm_world,ierr)
1541:         do j = 1 , jendx
1542:           do l = 1 , 4
1543:             do k = 1 , kz
1544:               do i = 1 , iym1
1545:                 absnxt(i,k,l,j) = sav1(i,(l-1)*kz+k,j)
1546:               end do
1547:             end do
1548:           end do
1549:         end do
1550:         allrec = kz*4
1551:         do j = 1 , jendx
1552:           do l = 1 , kzp1
1553:             do k = 1 , kzp1
1554:               do i = 1 , iym1
1555:                 abstot(i,k,l,j) = sav1(i,allrec+(l-1)*(kzp1)+k,j)
1556:               end do
1557:             end do
1558:           end do
1559:         end do
1560:         allrec = allrec + (kzp1)*(kz+1)
1561:         do j = 1 , jendx
1562:           do k = 1 , kzp1
1563:             do i = 1 , iym1
1564:               emstot(i,k,j) = sav1(i,allrec+k,j)
1565:             end do
1566:           end do
1567:         end do
1568:         if ( myid.eq.0 ) then
1569:           do j = 1 , jxm1
1570:             do n = 1 , nnsg
1571:               do i = 1 , iym1
1572:                 sav_2(i,n,j) = taf2d_io(n,i,j)
1573:                 sav_2(i,nnsg+n,j) = tlef2d_io(n,i,j)
1574:                 sav_2(i,nnsg*2+n,j) = ssw2d_io(n,i,j)
1575:                 sav_2(i,nnsg*3+n,j) = srw2d_io(n,i,j)
1576:               end do
1577:             end do
1578:             do i = 1 , iym1
1579:               sav_2(i,nnsg*4+1,j) = sol2d_io(i,j)
1580:               sav_2(i,nnsg*4+2,j) = solvd2d_io(i,j)
1581:               sav_2(i,nnsg*4+3,j) = solvs2d_io(i,j)
1582:               sav_2(i,nnsg*4+4,j) = flw2d_io(i,j)
1583:             end do
1584:           end do
1585:         end if
1586:         allrec = nnsg*4 + 4
1587:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_2(1,1,1),iym1*allrec*jxp,mpi_real8,        &
1588:                        & sav2(1,1,1), iym1*allrec*jxp,mpi_real8,        &
1589:                        & 0,mpi_comm_world,ierr)
1590:         do j = 1 , jendx
1591:           do n = 1 , nnsg
1592:             do i = 1 , iym1
1593:               taf2d(n,i,j) = sav2(i,n,j)
1594:               tlef2d(n,i,j) = sav2(i,nnsg+n,j)
1595:               ssw2d(n,i,j) = sav2(i,nnsg*2+n,j)
1596:               srw2d(n,i,j) = sav2(i,nnsg*3+n,j)
1597:             end do
1598:           end do
1599:           do i = 1 , iym1
1600:             sol2d(i,j) = sav2(i,nnsg*4+1,j)
1601:             solvd2d(i,j) = sav2(i,nnsg*4+2,j)
1602:             solvs2d(i,j) = sav2(i,nnsg*4+3,j)
1603:             flw2d(i,j) = sav2(i,nnsg*4+4,j)
1604:           end do
1605:         end do
1606:         if ( myid.eq.0 ) then
1607:           do j = 1 , jxm1
1608:             do n = 1 , nnsg
1609:               do i = 1 , iym1
1610:                 sav_2(i,n,j) = tgb2d_io(n,i,j)
1611:                 sav_2(i,nnsg+n,j) = swt2d_io(n,i,j)
1612:                 sav_2(i,nnsg*2+n,j) = scv2d_io(n,i,j)
1613:                 sav_2(i,nnsg*3+n,j) = gwet2d_io(n,i,j)
1614:               end do
1615:             end do
1616:             do i = 1 , iym1
1617:               sav_2(i,nnsg*4+1,j) = flwd2d_io(i,j)
1618:               sav_2(i,nnsg*4+2,j) = fsw2d_io(i,j)
1619:               sav_2(i,nnsg*4+3,j) = sabv2d_io(i,j)
1620:               sav_2(i,nnsg*4+4,j) = sinc2d_io(i,j)
1621:             end do
1622:           end do
1623:         end if
1624:         allrec = nnsg*4 + 4
1625:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_2(1,1,1),iym1*allrec*jxp,mpi_real8,        &
1626:                        & sav2(1,1,1), iym1*allrec*jxp,mpi_real8,        &
1627:                        & 0,mpi_comm_world,ierr)
1628:         do j = 1 , jendx
1629:           do n = 1 , nnsg
1630:             do i = 1 , iym1
1631:               tgb2d(n,i,j) = sav2(i,n,j)
1632:               swt2d(n,i,j) = sav2(i,nnsg+n,j)
1633:               scv2d(n,i,j) = sav2(i,nnsg*2+n,j)
1634:               gwet2d(n,i,j) = sav2(i,nnsg*3+n,j)
1635:             end do
1636:           end do
1637:           do i = 1 , iym1
1638:             flwd2d(i,j) = sav2(i,nnsg*4+1,j)
1639:             fsw2d(i,j) = sav2(i,nnsg*4+2,j)
1640:             sabv2d(i,j) = sav2(i,nnsg*4+3,j)
1641:             sinc2d(i,j) = sav2(i,nnsg*4+4,j)
1642:           end do
1643:         end do
1644:         if ( myid.eq.0 ) then
1645:           do j = 1 , jxm1
1646:             do n = 1 , nnsg
1647:               do i = 1 , iym1
1648:                 sav_2(i,n,j) = veg2d1_io(n,i,j)
1649:                 sav_2(i,nnsg+n,j) = sag2d_io(n,i,j)
1650:                 sav_2(i,nnsg*2+n,j) = sice2d_io(n,i,j)
1651:                 sav_2(i,nnsg*3+n,j) = dew2d_io(n,i,j)
1652:               end do
1653:             end do
1654:             do i = 1 , iym1
1655:               sav_2(i,nnsg*4+1,j) = pptnc_io(i,j)
1656:               sav_2(i,nnsg*4+2,j) = pptc_io(i,j)
1657:               sav_2(i,nnsg*4+3,j) = prca2d_io(i,j)
1658:               sav_2(i,nnsg*4+4,j) = prnca2d_io(i,j)
1659:             end do
1660:           end do
1661:         end if
1662:         allrec = nnsg*4 + 4
1663:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_2(1,1,1),iym1*allrec*jxp,mpi_real8,        &
1664:                        & sav2(1,1,1), iym1*allrec*jxp,mpi_real8,        &
1665:                        & 0,mpi_comm_world,ierr)
1666:         do j = 1 , jendx
1667:           do n = 1 , nnsg
1668:             do i = 1 , iym1
1669:               veg2d1(n,i,j) = sav2(i,n,j)
1670:               sag2d(n,i,j) = sav2(i,nnsg+n,j)
1671:               sice2d(n,i,j) = sav2(i,nnsg*2+n,j)
1672:               dew2d(n,i,j) = sav2(i,nnsg*3+n,j)
1673:             end do
1674:           end do
1675:           do i = 1 , iym1
1676:             pptnc(i,j) = sav2(i,nnsg*4+1,j)
1677:             pptc(i,j) = sav2(i,nnsg*4+2,j)
1678:             prca2d(i,j) = sav2(i,nnsg*4+3,j)
1679:             prnca2d(i,j) = sav2(i,nnsg*4+4,j)
1680:           end do
1681:         end do
1682:         if ( myid.eq.0 ) then
1683:           do j = 1 , jxm1
1684:             do n = 1 , nnsg
1685:               do i = 1 , iym1
1686:                 sav_2a(i,n,j) = ircp2d_io(n,i,j)
1687:                 sav_2a(i,nnsg+n,j) = text2d_io(n,i,j)
1688:                 sav_2a(i,nnsg*2+n,j) = col2d_io(n,i,j)
1689:                 sav_2a(i,nnsg*3+n,j) = ocld2d_io(n,i,j)
1690:                 sav_2a(i,nnsg*4+n,j) = tg2d_io(n,i,j)
1691:               end do
1692:             end do
1693:             do i = 1 , iym1
1694:               sav_2a(i,nnsg*5+1,j) = veg2d_io(i,j)
1695:             end do
1696:           end do
1697:         end if
1698:         allrec = nnsg*5 + 1
1699:         call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_2a(1,1,1),iym1*allrec*jxp,mpi_real8,       &
1700:                        & sav2a(1,1,1), iym1*allrec*jxp,mpi_real8,       &
1701:                        & 0,mpi_comm_world,ierr)
1702:         do j = 1 , jendx
1703:           do n = 1 , nnsg
1704:             do i = 1 , iym1
1705:               ircp2d(n,i,j) = sav2a(i,n,j)
1706:               text2d(n,i,j) = sav2a(i,nnsg+n,j)
1707:               col2d(n,i,j) = sav2a(i,nnsg*2+n,j)
1708:               ocld2d(n,i,j) = sav2a(i,nnsg*3+n,j)
1709:               tg2d(n,i,j) = sav2a(i,nnsg*4+n,j)
1710:             end do
1711:           end do
1712:           do i = 1 , iym1
1713:             veg2d(i,j) = sav2a(i,nnsg*5+1,j)
1714:           end do
1715:         end do
1716:         if ( ichem.eq.1 ) then
1717:           if ( myid.eq.0 ) then
1718:             do j = 1 , jx
1719:               do n = 1 , ntr
1720:                 do k = 1 , kz
1721:                   do i = 1 , iy
1722:                     sav_4(i,(n-1)*kz+k,j) = chia_io(i,k,j,n)
1723:                     sav_4(i,ntr*kz+(n-1)*kz+k,j) = chib_io(i,k,j,n)
1724:                     sav_4(i,ntr*kz*2+(n-1)*kz+k,j) = remlsc_io(i,k,j,n)
1725:                     sav_4(i,ntr*kz*3+(n-1)*kz+k,j) = remcvc_io(i,k,j,n)
1726:                   end do
1727:                 end do
1728:               end do
1729:             end do
1730:             allrec = 4*ntr*kz
1731:             do j = 1 , jx
1732:               do n = 1 , ntr
1733:                 do i = 1 , iy
1734:                   sav_4(i,allrec+n,j) = remdrd_io(i,j,n)
1735:                 end do
1736:               end do
1737:             end do
1738:             allrec = allrec + ntr
1739:           end if
1740:           allrec = ntr*(kz*4+1)
1741:           call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_4(1,1,1),iy*allrec*jxp,mpi_real8,        &
1742:                          & sav4(1,1,1), iy*allrec*jxp,mpi_real8,        &
1743:                          & 0,mpi_comm_world,ierr)
1744:           do j = 1 , jendl
1745:             do n = 1 , ntr
1746:               do k = 1 , kz
1747:                 do i = 1 , iy
1748:                   chia(i,k,j,n) = sav4(i,(n-1)*kz+k,j)
1749:                   chib(i,k,j,n) = sav4(i,ntr*kz+(n-1)*kz+k,j)
1750:                   remlsc(i,k,j,n) = sav4(i,ntr*kz*2+(n-1)*kz+k,j)
1751:                   remcvc(i,k,j,n) = sav4(i,ntr*kz*3+(n-1)*kz+k,j)
1752:                 end do
1753:               end do
1754:             end do
1755:           end do
1756:           allrec = 4*ntr*kz
1757:           do j = 1 , jendl
1758:             do n = 1 , ntr
1759:               do i = 1 , iy
1760:                 remdrd(i,j,n) = sav4(i,allrec+n,j)
1761:               end do
1762:             end do
1763:           end do
1764:           if ( myid.eq.0 ) then
1765:             do j = 1 , jxm1
1766:               do i = 1 , iym1
1767:                 sav_4a(i,1,j) = ssw2da_io(i,j)
1768:                 sav_4a(i,2,j) = sdeltk2d_io(i,j)
1769:                 sav_4a(i,3,j) = sdelqk2d_io(i,j)
1770:                 sav_4a(i,4,j) = sfracv2d_io(i,j)
1771:                 sav_4a(i,5,j) = sfracb2d_io(i,j)
1772:                 sav_4a(i,6,j) = sfracs2d_io(i,j)
1773:                 sav_4a(i,7,j) = svegfrac2d_io(i,j)
1774:               end do
1775:             end do
1776:           end if
1777:           call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_4a,iym1*7*jxp,mpi_real8,                 &
1778:                          & sav4a, iym1*7*jxp,mpi_real8,                 &
1779:                          & 0,mpi_comm_world,ierr)
1780:           do j = 1 , jendx
1781:             do i = 1 , iym1
1782:               ssw2da(i,j) = sav4a(i,1,j)
1783:               sdeltk2d(i,j) = sav4a(i,2,j)
1784:               sdelqk2d(i,j) = sav4a(i,3,j)
1785:               sfracv2d(i,j) = sav4a(i,4,j)
1786:               sfracb2d(i,j) = sav4a(i,5,j)
1787:               sfracs2d(i,j) = sav4a(i,6,j)
1788:               svegfrac2d(i,j) = sav4a(i,7,j)
1789:             end do
1790:           end do
1791: #ifdef CLM
1792:           if ( myid.eq.0 ) then
1793:             do j = 1 , jxm1
1794:               do i = 1 , iym1
1795:                 sav_clmout(i,1,j) = sols2d_io(i,j)
1796:                 sav_clmout(i,2,j) = soll2d_io(i,j)
1797:                 sav_clmout(i,3,j) = solsd2d_io(i,j)
1798:                 sav_clmout(i,4,j) = solld2d_io(i,j)
1799:                 sav_clmout(i,5,j) = aldirs2d_io(i,j)
1800:                 sav_clmout(i,6,j) = aldirl2d_io(i,j)
1801:                 sav_clmout(i,7,j) = aldifs2d_io(i,j)
1802:                 sav_clmout(i,8,j) = aldifl2d_io(i,j)
1803:                 sav_clmout(i,9,j) = coszrs2d_io(i,j)
1804:               end do
1805:             end do
1806:           end if
1807:           call <a href="#" TARGET=CENT_PANEL>mpi_scatter</a>(sav_clmout,iym1*9*jxp,mpi_real8,             &
1808:                          & sav_clmin, iym1*9*jxp,mpi_real8,             &
1809:                          & 0,mpi_comm_world,ierr)
1810:           do j = 1 , jendx
1811:             do i = 1 , iym1
1812:               sols2d(i,j) = sav_clmin(i,1,j)
1813:               soll2d(i,j) = sav_clmin(i,2,j)
1814:               solsd2d(i,j) = sav_clmin(i,3,j)
1815:               solld2d(i,j) = sav_clmin(i,4,j)
1816:               aldirs2d(i,j) = sav_clmin(i,5,j)
1817:               aldirl2d(i,j) = sav_clmin(i,6,j)
1818:               aldifs2d(i,j) = sav_clmin(i,7,j)
1819:               aldifl2d(i,j) = sav_clmin(i,8,j)
1820:               coszrs2d(i,j) = sav_clmin(i,9,j)
1821:             end do
1822:           end do
1823: #endif
1824:         end if
1825:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(mdate0,1,mpi_integer,0,mpi_comm_world,ierr)
1826:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(jyear0,1,mpi_integer,0,mpi_comm_world,ierr)
1827:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ktau,1,mpi_integer,0,mpi_comm_world,ierr)
1828:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(jyear,1,mpi_integer,0,mpi_comm_world,ierr)
1829:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(xtime,1,mpi_real8,0,mpi_comm_world,ierr)
1830:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ldatez,1,mpi_integer,0,mpi_comm_world,ierr)
1831:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(lyear,1,mpi_integer,0,mpi_comm_world,ierr)
1832:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(lmonth,1,mpi_integer,0,mpi_comm_world,ierr)
1833:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(lday,1,mpi_integer,0,mpi_comm_world,ierr)
1834:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(lhour,1,mpi_integer,0,mpi_comm_world,ierr)
1835:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ntime,1,mpi_integer,0,mpi_comm_world,ierr)
1836:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(jyearr,1,mpi_integer,0,mpi_comm_world,ierr)
1837:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ktaur,1,mpi_integer,0,mpi_comm_world,ierr)
1838: #ifdef DIAG
1839:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tdini,1,mpi_real8,0,mpi_comm_world,ierr)
1840:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tdadv,1,mpi_real8,0,mpi_comm_world,ierr)
1841:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tqini,1,mpi_real8,0,mpi_comm_world,ierr)
1842:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tqadv,1,mpi_real8,0,mpi_comm_world,ierr)
1843:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tqeva,1,mpi_real8,0,mpi_comm_world,ierr)
1844:         call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tqrai,1,mpi_real8,0,mpi_comm_world,ierr)
1845:         if ( ichem.eq.1 ) then
1846:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tchiad,ntr,mpi_real8,0,mpi_comm_world,ierr)
1847:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tchitb,ntr,mpi_real8,0,mpi_comm_world,ierr)
1848:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tchie,ntr,mpi_real8,0,mpi_comm_world,ierr)
1849:         end if
1850: #endif
1851: !------lake model
1852:         if ( lakemod.eq.1 ) then
1853:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(ilake,1,mpi_integer,0,mpi_comm_world,ierr)
1854:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(jlake,1,mpi_integer,0,mpi_comm_world,ierr)
1855:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(depth,1,mpi_integer,0,mpi_comm_world,ierr)
1856:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(hs,1,mpi_real8,0,mpi_comm_world,ierr)
1857:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(eta,1,mpi_real8,0,mpi_comm_world,ierr)
1858:           call <a href="#" TARGET=CENT_PANEL>mpi_bcast</a>(tlake,depth,mpi_real8,0,mpi_comm_world,ierr)
1859:         end if
1860:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(ht(1,jxp),iy,mpi_real8,ieast,1,               &
1861:                         & ht(1,0),iy,mpi_real8,iwest,1,                 &
1862:                         & mpi_comm_world,mpi_status_ignore,ierr)
1863:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(ht(1,1),iy,mpi_real8,iwest,2,                 &
1864:                         & ht(1,jxp+1),iy,mpi_real8,ieast,2,             &
1865:                         & mpi_comm_world,mpi_status_ignore,ierr)
1866:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(msfx(1,jxp-1),iy*2,mpi_real8,ieast,           &
1867:                         & 1,msfx(1,-1),iy*2,mpi_real8,iwest,            &
1868:                         & 1,mpi_comm_world,mpi_status_ignore,ierr)
1869:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(msfx(1,1),iy*2,mpi_real8,iwest,2,             &
1870:                         & msfx(1,jxp+1),iy*2,mpi_real8,ieast,           &
1871:                         & 2,mpi_comm_world,mpi_status_ignore,ierr)
1872:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(msfd(1,jxp-1),iy*2,mpi_real8,ieast,           &
1873:                         & 1,msfd(1,-1),iy*2,mpi_real8,iwest,            &
1874:                         & 1,mpi_comm_world,mpi_status_ignore,ierr)
1875:         call <a href="#" TARGET=CENT_PANEL>mpi_sendrecv</a>(msfd(1,1),iy*2,mpi_real8,iwest,2,             &
1876:                         & msfd(1,jxp+1),iy*2,mpi_real8,ieast,           &
1877:                         & 2,mpi_comm_world,mpi_status_ignore,ierr)
1878: 
1879:         dt = dt2 ! First timestep successfully read in
1880: 
1881: #else
1882:         write (finm,99002) trim(dirout),pthsep,'SAV.',                  &
1883:           &    ((ndate0/10000)*100+1)*100
1884:         inquire (file=finm,exist=existing)
1885:         if ( .not.existing ) then
1886:           write (aline,*) 'The following SAV File does not exist: ' ,   &
1887:               &            trim(finm), 'please check location'
1888:           call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
1889:           call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__, 'SAV FILE NOT FOUND')
1890:         else
1891:           open (iutrs,file=finm,form='unformatted',status='old')
1892:         end if
1893:         do ! Loop while ldatez.ne.idate1
1894: !
1895: !-----when ifrest=.true., read in the data saved from previous run
1896: !         for large domain from unit 14.
1897: !
1898:           read (iutrs) mdate0
1899:           jyear0 = mdate0/1000000
1900:           read (iutrs) ktau , xtime , ldatez , lyear , lmonth , lday ,  &
1901:                      & lhour , ntime
1902:           jyear = lyear
1903:           jyearr = jyear
1904:           ktaur = ktau
1905:           if ( ehso4 ) then
1906:             read (iutrs) ub0 , vb0 , qb0 , tb0 , ps0 , ts0 , so0
1907:           else
1908:             read (iutrs) ub0 , vb0 , qb0 , tb0 , ps0 , ts0
1909:           end if
1910:           read (iutrs) ua
1911:           read (iutrs) ub
1912:           read (iutrs) va
1913:           read (iutrs) vb
1914:           read (iutrs) ta
1915:           read (iutrs) tb
1916:           read (iutrs) qva
1917:           read (iutrs) qvb
1918:           read (iutrs) qca
1919:           read (iutrs) qcb
1920:           read (iutrs) psa , psb , satbrt , satbrt1 , f
1921:           read (iutrs) ht , ht1 , msfx , msfd , xlat , xlong
1922:           read (iutrs) tga , tgb , rainc , rainnc
1923:           if ( icup.eq.1 ) then
1924:             read (iutrs) rsheat , rswat
1925:           else if ( icup.eq.3 ) then
1926:             read (iutrs) tbase , cldefi
1927:           else if ( icup.eq.4 ) then
1928:             read (iutrs) cbmf2d
1929:           else
1930:           end if
1931:           read (iutrs) hfx , qfx , snowc , uvdrag
1932: #ifdef    DIAG
1933:           read (iutrs) tdini , tdadv , tqini , tqadv , tqeva , tqrai
1934: #endif
1935:           read (iutrs) absnxt , abstot , emstot
1936:           if ( ipptls.eq.1 ) read (iutrs) fcc
1937:           read (iutrs) sol2d , solvd2d , solvs2d , flw2d , flwd2d ,     &
1938:                      & fsw2d , sabv2d , sinc2d
1939:           read (iutrs) taf2d , tlef2d , tgbb , ssw2d , srw2d , tg2d ,   &
1940:                      & tgb2d , swt2d , scv2d , gwet2d , veg2d , veg2d1 ,&
1941:                      & sag2d , sice2d , dew2d , ircp2d , text2d ,       &
1942:                      & col2d , ocld2d , heatrt , o3prof
1943:           read (iutrs) pptnc , pptc , prca2d , prnca2d
1944:           if ( iocnflx.eq.2 ) read (iutrs) zpbl
1945: 
1946: !chem2---
1947:           if ( ichem.eq.1 ) then
1948:             read (iutrs) chia
1949:             read (iutrs) chib
1950: !           cumul removal terms (3d, 2d)
1951:             read (iutrs) remlsc
1952:             read (iutrs) remcvc
1953:             read (iutrs) remdrd
1954:             read (iutrs) ssw2da
1955:             read (iutrs) sdeltk2d
1956:             read (iutrs) sdelqk2d
1957:             read (iutrs) sfracv2d
1958:             read (iutrs) sfracb2d
1959:             read (iutrs) sfracs2d
1960:             read (iutrs) svegfrac2d
1961: !           cumul ad, dif, emis terms ( scalar)
1962: #ifdef DIAG
1963:             read (iutrs) tchiad
1964:             read (iutrs) tchitb
1965:             read (iutrs) tchie
1966: #endif
1967:           end if
1968: !chem2_
1969: !
1970: !------lake model
1971:           if ( lakemod.eq.1 ) then
1972:             lcount = 0
1973:             iin = 41
1974:             iout = 42
1975:             rewind (iin)
1976:             read (iutrs) numpts
1977:             print * , 'reading lake model restart file. numpts = ' ,    &
1978:                 & numpts
1979:             print * , 'jyear, ktau, xtime = ' , jyear , ktau , xtime
1980:             do n = 1 , numpts
1981:               read (iutrs) ilake , jlake , depth , freeze , hi , hii ,  &
1982:                          & hs , eta , (tlake(j),j=1,depth)
1983:               print * , 'reading restart file at i, j = ' , ilake ,     &
1984:                   & jlake
1985:               write (iin) ilake , jlake , depth , freeze , hi , hii ,   &
1986:                         & hs , eta , (tlake(j),j=1,depth)
1987:             end do
1988:             rewind (iin)
1989:           end if
1990: !
1991:           print * , 'ozone profiles restart'
1992:           do k = 1 , kzp1
1993:             write (6,99004) o3prof(3,3,k)
1994:           end do
1995:           print 99005 , xtime , ktau , jyear , iutrs
1996: !
1997:           if ( ldatez.ne.idate1 ) then
1998:             write (*,*) 'INIT: ldatez, idate1=' , ldatez , idate1
1999:             cycle
2000:           end if
2001: 
2002:           exit ! We have now ldatez.eq.idate1
2003: 
2004:         end do
2005: 
2006:         dt = dt2 ! First timestep successfully read in
2007: 
2008: #endif
2009: !
2010: !-----end of initial/restart if test
2011: !
2012:       end if
2013: !
2014: !     Move from param.F to fix the reatart problem found by
2015: !     Zhang DongFeng
2016: !
2017:       if ( ipptls.eq.1 ) then
2018: #ifdef MPP1
2019:         do j = 1 , jendx
2020:           do i = 1 , iym1
2021:             if ( satbrt(i,j).gt.13.9 .and. satbrt(i,j).lt.15.1 ) then
2022:               qck1(i,j) = qck1oce  ! OCEAN
2023:               cgul(i,j) = guloce   ! OCEAN
2024:               rh0(i,j) = rh0oce    ! OCEAN
2025:             else
2026:               qck1(i,j) = qck1land ! LAND
2027:               cgul(i,j) = gulland  ! LAND
2028:               rh0(i,j) = rh0land   ! LAND
2029:             end if
2030:           end do
2031:         end do
2032: #else
2033:         do j = 1 , jxm1
2034:           do i = 1 , iym1
2035:             if ( satbrt(i,j).gt.13.9 .and. satbrt(i,j).lt.15.1 ) then
2036:               qck1(i,j) = qck1oce  ! OCEAN
2037:               cgul(i,j) = guloce   ! OCEAN
2038:               rh0(i,j) = rh0oce    ! OCEAN
2039:             else
2040:               qck1(i,j) = qck1land ! LAND
2041:               cgul(i,j) = gulland  ! LAND
2042:               rh0(i,j) = rh0land   ! LAND
2043:             end if
2044:           end do
2045:         end do
2046: #endif
2047:       end if
2048: !chem2
2049:       if ( ichem.eq.1 ) then
2050:         iso2 = 0
2051:         iso4 = 0
2052:         ibchl = 0
2053:         ibchb = 0
2054:         iochl = 0
2055:         iochb = 0
2056:         ibin = 0
2057:         do itr = 1 , ntr
2058:           if ( chtrname(itr).eq.'SO2' ) iso2 = itr
2059:           if ( chtrname(itr).eq.'SO4' ) iso4 = itr
2060:           if ( chtrname(itr).eq.'BC_HL' ) ibchl = itr
2061:           if ( chtrname(itr).eq.'BC_HB' ) ibchb = itr
2062:           if ( chtrname(itr).eq.'OC_HL' ) iochl = itr
2063:           if ( chtrname(itr).eq.'OC_HB' ) iochb = itr
2064:           if ( chtrname(itr).eq.'DUST' ) then
2065:             ibin = ibin + 1
2066:             idust(ibin) = itr
2067:           end if
2068:         end do
2069:       end if
2070: !chem2_
2071: ! ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2072: !     ****** initialize and define constants for vector bats
2073:  
2074:       if ( jyear.eq.jyear0 .and. ktau.eq.0 ) call <a href="./initb.F90.html#initb" TARGET=CENT_PANEL>initb</a>
2075:       if ( iemiss.eq.1 ) then
2076: #ifdef MPP1
2077:         do j = 1 , jendx
2078:           do i = 1 , iym1
2079:             do n = 1 , nnsg
2080:               ist = nint(veg2d1(n,i,j))
2081:               if ( ist.eq.0 ) then
2082:                 emiss2d(n,i,j) = 0.955D0
2083:               else if ( ist.eq.8 ) then
2084:                 emiss2d(n,i,j) = 0.76D0
2085:               else if ( ist.eq.11 ) then
2086:                 emiss2d(n,i,j) = 0.85D0
2087:               else if ( ist.eq.12 ) then
2088:                 emiss2d(n,i,j) = 0.97D0
2089:               else
2090:                 emiss2d(n,i,j) = 0.99D0 - (albvgs(ist)+albvgl(ist))     &
2091:                                & *0.1D0
2092:               end if
2093: !             emiss2d(n,i,j) = 1.0d0
2094:             end do
2095:           end do
2096:         end do
2097: #else
2098:         do j = 1 , jxm1
2099:           do i = 1 , iym1
2100:             do n = 1 , nnsg
2101:               ist = nint(veg2d1(n,i,j))
2102:               if ( ist.eq.0 ) then
2103:                 emiss2d(n,i,j) = 0.955D0
2104:               else if ( ist.eq.8 ) then
2105:                 emiss2d(n,i,j) = 0.76D0
2106:               else if ( ist.eq.11 ) then
2107:                 emiss2d(n,i,j) = 0.85D0
2108:               else if ( ist.eq.12 ) then
2109:                 emiss2d(n,i,j) = 0.97D0
2110:               else
2111:                 emiss2d(n,i,j) = 0.99D0 - (albvgs(ist)+albvgl(ist))     &
2112:                                & *0.1D0
2113:               end if
2114: !             emiss2d(n,i,j) = 1.0d0
2115:             end do
2116:           end do
2117:         end do
2118: #endif
2119:       end if
2120: ! ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2121: !
2122: !-----read in the boundary conditions for large domain:
2123: !
2124: !-----compute the solar declination angle:
2125: !
2126: #ifdef CLM
2127:       call <a href="./solar1clm.f90.html#solar1clm" TARGET=CENT_PANEL>solar1clm</a>(xtime)
2128:       if ( ( jyear.eq.jyear0 .and. ktau.eq.0 ) .or.                     &
2129:          & ( ktau.eq.ktaur ) ) then
2130:         init_grid = .true.
2131:       else
2132:         init_grid = .false.
2133:       end if
2134: #else
2135:       call <a href="./solar1.f90.html#solar1" TARGET=CENT_PANEL>solar1</a>(xtime)
2136: #endif
2137:       call <a href="./inirad.F90.html#inirad" TARGET=CENT_PANEL>inirad</a>
2138: !
2139: !-----calculating topographical correction to diffusion coefficient
2140: #ifdef MPP1
2141:       do j = 1 , jendl
2142:         do i = 1 , iy
2143:           hgfact(i,j) = 1.
2144:         end do
2145:       end do
2146:       do j = jbegin , jendm
2147:         if ( myid.eq.0 ) then
2148:           jm1h = max0(j-1,2)
2149:         else
2150:           jm1h = j - 1
2151:         end if
2152:         if ( myid.eq.nproc-1 ) then
2153:           jp1h = min0(j+1,jxp-2)
2154:         else
2155:           jp1h = j + 1
2156:         end if
2157:         do i = 2 , iym2
2158:           im1h = max0(i-1,2)
2159:           ip1h = min0(i+1,iym2)
2160:           hg1 = dabs((ht(i,j)-ht(im1h,j))/dx)
2161:           hg2 = dabs((ht(i,j)-ht(ip1h,j))/dx)
2162:           hg3 = dabs((ht(i,j)-ht(i,jm1h))/dx)
2163:           hg4 = dabs((ht(i,j)-ht(i,jp1h))/dx)
2164:           hgmax = dmax1(hg1,hg2,hg3,hg4)*rgti
2165:           hgfact(i,j) = 1./(1.+(hgmax/0.001)**2.)
2166:         end do
2167:       end do
2168: #else
2169:       do j = 1 , jx
2170:         do i = 1 , iy
2171:           hgfact(i,j) = 1.
2172:         end do
2173:       end do
2174:       do j = 2 , jxm2
2175:         jm1h = max0(j-1,2)
2176:         jp1h = min0(j+1,jxm2)
2177:         do i = 2 , iym2
2178:           im1h = max0(i-1,2)
2179:           ip1h = min0(i+1,iym2)
2180:           hg1 = dabs((ht(i,j)-ht(im1h,j))/dx)
2181:           hg2 = dabs((ht(i,j)-ht(ip1h,j))/dx)
2182:           hg3 = dabs((ht(i,j)-ht(i,jm1h))/dx)
2183:           hg4 = dabs((ht(i,j)-ht(i,jp1h))/dx)
2184:           hgmax = dmax1(hg1,hg2,hg3,hg4)*rgti
2185:           hgfact(i,j) = 1./(1.+(hgmax/0.001)**2.)
2186:         end do
2187:       end do
2188: #endif
2189: !
2190: !-----set up output time:
2191: !
2192:       icnt = 11        ! set counter for safety-file moves on cycad
2193:       dectim = anint(xtime+dectim)
2194:       write (aline, *) 'dectim = ' , dectim
2195:       call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
2196: 
2197: 99001 format (a,a,a,a,i0.10)
2198: 99002 format (a,a,a,i0.10)
2199: #ifdef DIAG
2200: 99003 format (' *** initial total air = ',e12.5,' kg, total water = ',  &
2201:             & e12.5,' kg in large domain.')
2202: #endif
2203: 99004 format (1x,7E12.4)
2204: 99005 format (' ***** restart file for large domain at time = ',f8.0,   &
2205:              &' minutes, ktau = ',i7,' in year = ',i4,                  &
2206:              &'  read in from ',a)
2207: !
2208:       end subroutine init
</PRE>

<HR>

</BODY>
</HTML>
