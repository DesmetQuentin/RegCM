<HTML>

<HEAD>
<TITLE>mod_cu_kuo.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_cu_kuo.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_cu_kuo.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=mod_cu_kuo><H3>mod_cu_kuo</H3></a></p>20:       module mod_cu_kuo
21: 
22:       contains
23: 
<p><a name=cupara><H3>cupara</H3></a></p> Click <a href="./callingtree/cupara_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cupara is used.
<hr>
24:       subroutine cupara(j)
25: 
26: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
27: !                                                                     c
28: !     this subroutine performs cumulus parameterization scheme.       c
29: !     the basic method follows anthes and keyser (1979) and           c
30: !     kuo (1983).                                                     c
31: !                                                                     c
32: !     all the other arguments are passed from subroutine "tend" and   c
33: !     explained in "tend".                                            c
34: !                                                                     c
35: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
36:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
37:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : dt , dtmin , dx4 , nbatst
38:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a>
39:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : dsigma , a , qcon , r8pt , k700
40:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
41:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
42:       use <a href="./mod_pmoist.F90.html#mod_pmoist" TARGET=CENT_PANEL>mod_pmoist</a>
43:       use <a href="./mod_rad.F90.html#mod_rad" TARGET=CENT_PANEL>mod_rad</a>
44:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a> , only : pptc
45:       use <a href="./mod_trachem.F90.html#mod_trachem" TARGET=CENT_PANEL>mod_trachem</a>
46:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgas , gti , rgti , rovcp , rcpd ,     &
47:                                & ep2 , wlhv , wlhvocp , tauht
48:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : jyear , jyear0 , ktau
49:       implicit none
50: !
51: ! Dummy arguments
52: !
53:       integer :: j
54: !
55: ! Local variables
56: !
57:       real(8) :: akclth , apcnt , aprdiv , arh , c301 , cdscld , dalr , &
58:                & deqt , dlnp , dlt , dplr , dsc , e1 , eddyf , emax ,   &
59:                & eqt , eqtm , es , perq , pert , plcl , pmax , prainx , &
60:                & psg , psx , pux , q , qmax , qs , rh , rsht , rswt ,   &
61:                & sca , siglcl , suma , sumb , t1 , tdmax , tlcl , tmax ,&
62:                & tmean , ttconv , ttp , ttsum , xsav , zlcl
63:       integer :: i , k , kbase , kbaseb , kclth , kk , ktop
64:       real(8) , dimension(kz) :: seqt
65:       real(8) , dimension(iy,kz) :: tmp3
66: !
67: !
68: !----------------------------------------------------------------------
69: !
70: !     pert   : perturbation temperature
71: !     perq   : perturbation mixing ratio
72: !     dlt    : temperature difference used to allow over shooting.
73: !     cdscld : critical cloud depth in delta sigma.
74: !
75:       data pert , perq/1. , 1.E-3/
76:       data dlt , cdscld/3.0 , 0.3/
77: !
78: !
79:       pmax = 0.0
80:       qmax = 0.0
81:       tmax = 0.0
82:       do k = 1 , kz
83:         do i = 1 , iym1
84:           cldlwc(i,k) = 0.
85:           cldfra(i,k) = 0.
86:         end do
87:       end do
88:       do k = 1 , kz
89:         do i = 1 , iym1
90:           qvten(i,k,j) = 0.
91:         end do
92:       end do
93: !
94: !-----compute the horizontal advection terms:
95: !
96:       call <a href="./hadv.F90.html#hadvqv" TARGET=CENT_PANEL>hadvqv</a>(qvten(1,1,j),dx4,j,1)
97: !---------------
98: !chem2
99:       if ( ichem.eq.1 ) then
100: !
101: !       icumtop = top level of cumulus clouds
102: !       icumbot = bottom level of cumulus clouds
103: !       (calculated in cupara and stored for tractend)
104: !       before do 100 put
105:         do i = 2 , iym2
106:           icumtop(i,j) = 0
107:           icumbot(i,j) = 0
108:         end do
109:       end if
110: !chem2__
111: !
112: !-----compute the moisture convergence in a column:
113: !     at this stage, qvten(i,k,j) only includes horizontal advection.
114: !     sca: is the amount of total moisture convergence
115: !
116:       do i = 2 , iym2
117: !
118:         sca = 0.0
119:         do k = 1 , kz
120:           sca = sca + qvten(i,k,j)*dsigma(k)
121:         end do
122: !
123: !-----determine if moist convection exists:
124: !
125:         if ( sca.ge.qdcrit ) then
126: !
127: !-----check for stability
128: !
129: !--1--compute eqt (equivalent potential temperature)
130: !         between surface and 700 mb, with perturbation temperature
131: !         and moisture added. the maximum eqt will be regarded
132: !         as the origin of air parcel that produce cloud.
133: !
134:           eqtm = 0.0
135:           do k = k700 , kz
136:             ttp = ta(i,k,j)/psa(i,j) + pert
137:             q = qva(i,k,j)/psa(i,j) + perq
138:             psg = psa(i,j)*a(k) + r8pt
139:             t1 = ttp*(100./psg)**rovcp
140:             eqt = t1*dexp(wlhvocp*q/ttp)
141:             if ( eqt.gt.eqtm ) then
142:               eqtm = eqt
143:               tmax = ttp
144:               qmax = q
145:               pmax = psg
146:             end if
147:           end do
148: !
149: !--2--compute lcl, get the sigma and p of lcl
150: !
151:           emax = qmax*pmax/(ep2+qmax)
152:           tdmax = 5418.12/(19.84659-dlog(emax/.611))
153:           dalr = gti*rcpd
154:           dplr = (gti*tdmax*tdmax)/(ep2*wlhv*tmax)
155:           zlcl = (tmax-tdmax)/(dalr-dplr)
156:           tlcl = tmax - dalr*zlcl
157:           tmean = 0.5*(tmax+tlcl)
158:           dlnp = (gti*zlcl)/(rgas*tmean)
159:           plcl = pmax*dexp(-dlnp)
160:           siglcl = (plcl-r8pt)/psa(i,j)
161: !
162: !--3--compute seqt (saturation equivalent potential temperature)
163: !         of all the levels that are above the lcl
164: !
165:           do k = 1 , kz
166:             if ( a(k).ge.siglcl ) exit
167:           end do
168:           kbase = k
169:           if ( kbase.gt.kz ) kbase = kz
170: !
171: !.....kbase is the layer where lcl is located.
172: !
173:           do k = 1 , kbase
174:             ttp = ta(i,k,j)/psa(i,j)
175:             psg = psa(i,j)*a(k) + r8pt
176:             es = .611*dexp(19.84659-5418.12/ttp)
177:             qs = ep2*es/(psg-es)
178:             t1 = ttp*(100./psg)**rovcp
179:             seqt(k) = t1*dexp(wlhvocp*qs/ttp)
180:           end do
181: !
182: !--4--when seqt = eqt + dt, cloud top is reached.
183: !         eqt is the eqt of cloud (same as lcl eqt).
184: !
185:           do kk = 1 , kbase
186:             k = kbase + 1 - kk
187:             deqt = seqt(k) - eqtm
188:             if ( deqt.gt.dlt ) exit
189:           end do
190: !
191: !.....cloud top has been reached
192: !
193:           ktop = k
194: !
195: !--5--check cloud depth
196: !         if cloud depth is less than critical depth (cdscld = 0.3),
197: !         the convection is killed
198: !
199:           dsc = (siglcl-a(ktop))
200:           if ( dsc.ge.cdscld ) then
201: !
202: !--6--check negative area
203: !           if negative area is larger than the positive area
204: !           convection is killed.
205: !
206:             ttsum = 0.
207:             do k = ktop , kbase
208:               ttsum = (eqtm-seqt(k))*dsigma(k) + ttsum
209:             end do
210:             if ( ttsum.ge.0. ) then
211: !
212: !.....you     are here if stability was found.
213: !
214: !.....if      values dont already exist in array twght,vqflx for this
215: !             kbase/ktop, then flag it, and set kbase/ktop to standard
216: !
217:               if ( (kbase.lt.5) .or. (ktop.gt.kbase-3) ) then
218:                 print 99001 , ktau , jyear , i , j , kbase , ktop
219:                 if ( kbase.lt.5 ) kbase = 5
220:                 if ( ktop.gt.kbase-3 ) ktop = kbase - 3
221:               end if
222: !
223: !.....convection exist, compute convective flux of water vapor and
224: !             latent heating
225: !             icon   : is a counter which keep track the total points
226: !             where deep convection occurs.
227: !             c301   : is the 'b' factor in kuo's scheme.
228: !
229:               icon(j) = icon(j) + 1
230:               suma = 0.
231:               sumb = 0.
232:               arh = 0.
233:               psx = psa(i,j)
234:               do k = 1 , kz
235:                 qwght(k) = 0.0
236:               end do
237:               do k = ktop , kz
238:                 pux = psx*a(k) + r8pt
239:                 e1 = .611*dexp(19.84659-5418.12/(ta(i,k,j)/psx))
240:                 qs = ep2*e1/(pux-e1)
241:                 rh = qva(i,k,j)/(qs*psx)
242:                 rh = dmin1(rh,1.D0)
243:                 xsav = (1.0-rh)*qs
244:                 qwght(k) = xsav
245:                 sumb = sumb + qs*dsigma(k)
246:                 arh = arh + rh*qs*dsigma(k)
247:                 suma = suma + xsav*dsigma(k)
248:               end do
249:               arh = arh/sumb
250:               c301 = 2.0*(1.0-arh)
251:               if ( c301.lt.0.0 ) c301 = 0.0
252:               if ( c301.gt.1.0 ) c301 = 1.0
253:               if ( suma.le.0.0 ) then
254:                 c301 = 0.0
255:                 suma = 1.0
256:               end if
257:               do k = ktop , kz
258:                 qwght(k) = qwght(k)/suma
259:               end do
260:               do k = 1 , kz
261:                 ttconv = wlhvocp*(1.0-c301)*twght(k,kbase,ktop)*sca
262:                 rsheat(i,k,j) = rsheat(i,k,j) + ttconv*dt/2.
263: !x              if (ttconv*2. .gt. 0.01) write(18,1234) i,j,k,ttconv*2.
264: !1234           format(1x,'cupara, i=',i4,' j=',i4,' k=',i4,'
265: !               qteva=',e12.4)
266:                 apcnt = (1.0-c301)*sca/4.3E-3
267:                 eddyf = apcnt*vqflx(k,kbase,ktop)
268:                 qvten(i,k,j) = eddyf
269:                 rswat(i,k,j) = rswat(i,k,j) + c301*qwght(k)*sca*dt/2.
270:               end do
271: !
272: !             find cloud fractional cover and liquid water content
273: !
274:               kbaseb = min0(kbase,kzm2)
275:               if ( ktop.le.kbaseb ) then
276:                 kclth = kbaseb - ktop + 1
277:                 akclth = 1./dble(kclth)
278:                 do k = ktop , kbaseb
279:                   cldlwc(i,k) = cllwcv
280:                   cldfra(i,k) = 1. - (1.-clfrcv)**akclth
281:                 end do
282:               end if
283: !.....the     unit for rainfall is mm.
284:               prainx = (1.-c301)*sca*dtmin*60000.*rgti
285:               rainc(i,j) = rainc(i,j) + prainx
286: !             instantaneous precipitation rate for use in bats (mm/s)
287:               aprdiv = dble(nbatst)
288:               if ( jyear.eq.jyear0 .and. ktau.eq.0 ) aprdiv = 1.
289:               pptc(i,j) = pptc(i,j) + prainx/(dtmin*60.)/aprdiv
290: !
291: !chem2
292:               if ( ichem.eq.1 ) then
293: !               before go to 100 put
294:                 icumtop(i,j) = ktop
295:                 icumbot(i,j) = kbaseb
296:               end if
297: !chem2_
298:  
299:               cycle
300:             end if
301:           end if
302:         end if
303: !
304: !.....convection not exist, compute the vertical advection term:
305: !
306:         tmp3(i,1) = 0.
307:         do k = 2 , kz
308:           if ( qva(i,k,j).lt.1.E-15 ) then
309:             tmp3(i,k) = 0.0
310:           else
311:             tmp3(i,k) = qva(i,k,j)*(qva(i,k-1,j)/qva(i,k,j))**qcon(k)
312:           end if
313:         end do
314:         qvten(i,1,j) = qvten(i,1,j) - qdot(i,2,j)*tmp3(i,2)/dsigma(1)
315:         do k = 2 , kzm1
316:           qvten(i,k,j) = qvten(i,k,j)                                   &
317:                        & - (qdot(i,k+1,j)*tmp3(i,k+1)-qdot(i,k,j)       &
318:                        & *tmp3(i,k))/dsigma(k)
319:         end do
320:         qvten(i,kz,j) = qvten(i,kz,j) + qdot(i,kz,j)*tmp3(i,kz)         &
321:                       & /dsigma(kz)
322: !
323:       end do           !end i=2,iym2 loop
324: !
325:       do k = 1 , kz
326:         do i = 2 , iym2
327:           rsheat(i,k,j) = dmax1(rsheat(i,k,j),0.D0)
328:           rswat(i,k,j) = dmax1(rswat(i,k,j),0.D0)
329:           rsht = rsheat(i,k,j)/tauht
330:           rswt = rswat(i,k,j)/tauht
331:           tten(i,k,j) = tten(i,k,j) + rsht
332:           qvten(i,k,j) = qvten(i,k,j) + rswt
333:           rsheat(i,k,j) = rsheat(i,k,j)*(1.-dt/(2.*tauht))
334:           rswat(i,k,j) = rswat(i,k,j)*(1.-dt/(2.*tauht))
335: !bxq if(rsht/psb(i,j).gt..0002)write(18,1222)ktau,jyear,i,j,k,rsht/psb(i
336: !1222     format (1x,'ktau= ',i7,' jyear= ',i5,' i= ',i5,' j= ',i5,
337: !         1        ' k= ',i5,' ttconv =',e15.7)
338:         end do
339:       end do
340: 99001 format (/,' >>in **cupara**: at ktau=',i8,' in year=',i5,         &
341:              &' & (i,j)=(',i2,',',i2,'),   ',                           &
342:              &' kbase/ktop are non-standard:',2I3,                      &
343:              &'  & will be set to closest standard.')
344: !
345:       end subroutine cupara
346: !
347: !
348: !
349:       end module mod_cu_kuo
</PRE>

<HR>

</BODY>
</HTML>
