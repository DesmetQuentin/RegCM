<HTML>

<HEAD>
<TITLE>sponge.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>sponge.F90</H1>
<HR>
<H2 ALIGN=CENTER>sponge.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=sponge_p><H3>sponge_p</H3></a></p> Click <a href="./callingtree/sponge_p_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sponge_p is used.
<hr>
20:       subroutine sponge_p(ip,wg,ften,j)
21: 
22: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
23: !                                                                     c
24: !     this subroutine applies sponge boundary condition to the        c
25: !     tendency term - ften.                                           c
26: !                                                                     c
27: !     ip   : is the number of slices affected by sponge boundary.     c
28: !                                                                     c
29: !     wg   : are the weightings.                                      c
30: !                                                                     c
31: !     ften : is the tendency calculated from the model.               c
32: !                                                                     c
33: !     pebt, pwbt, pnbt, psbt : are the large-scale or observed        c
34: !            tendencies at east, west, north, and south boundaries.   c
35: !                                                                     c
36: !     ie = iy, je = jx for dot-point variables.                       c
37: !     ie = iym1, je = jxm1 for cross-point variables.                 c
38: !                                                                     c
39: !     j    : is the j'th slice of the tendency to be adjusted.        c
40: !                                                                     c
41: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
42:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
43:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a>
44:       implicit none
45: !
46: ! Dummy arguments
47: !
48:       integer :: ip , j
49:       real(8) , dimension(iy) :: ften
50:       real(8) , dimension(ip) :: wg
51:       intent (in) ip , j , wg
52:       intent (inout) ften
53: !
54: ! Local variables
55: !
56:       integer :: i , ibeg , iend , ii , jj , jsls
57: #ifdef MPP1
58:       integer :: jwb , jeb
59: #endif
60: !
61: !----------------------------------------------------------------------
62: !
63: #ifdef MPP1
64:       jsls = j + myid*jxp
65:       jj = jx - jsls
66:       if ( jj.le.ip ) jsls = jj
67:       jwb = jsls
68:       if ( jwb.gt.jxp ) jwb = mod(jwb,jxp)
69:       if ( jwb.eq.0 ) jwb = jxp
70:       if ( myid.eq.nproc-1 ) then
71:         jeb = jsls
72:       else
73:         jeb = jsls + 1
74:       end if
75:       if ( jeb.gt.jxp ) jeb = mod(jeb,jxp)
76:       if ( jeb.eq.0 ) jeb = jxp
77: #else
78:       jsls = j
79:       jj = jx - jsls
80:       if ( jj.le.ip ) jsls = jj
81: #endif
82: !
83:       if ( jsls.gt.ip ) then
84: !-----interior j slices:
85:         do i = 2 , ip
86:           ii = iy - i
87: !.......south boundary:
88:           ften(i) = wg(i)*ften(i) + (1.-wg(i))*psbt(i,j)
89: !.......north boundary:
90:           ften(ii) = wg(i)*ften(ii) + (1.-wg(i))*pnbt(i,j)
91:         end do
92: !
93:       else if ( jsls.le.ip ) then
94:         ibeg = 2
95:         iend = iym1 - 1
96:         if ( jsls.gt.2 ) then
97:           do i = 2 , jsls - 1
98:             ii = iy - i
99: !........south boundary:
100:             ften(i) = wg(i)*ften(i) + (1.-wg(i))*psbt(i,j)
101: !........north boundary:
102:             ften(ii) = wg(i)*ften(ii) + (1.-wg(i))*pnbt(i,j)
103:           end do
104:           ibeg = jsls
105:           iend = iy - jsls
106:         end if
107: !
108:         if ( jj.gt.ip ) then
109: !------west-boundary slice:
110:           do i = ibeg , iend
111: #ifdef MPP1
112:             if ( jsls.le.ip ) ften(i) = wg(jsls)*ften(i) + (1.-wg(jsls))&
113:                                       & *pwbt(i,jwb)
114: #else
115:             ften(i) = wg(jsls)*ften(i) + (1.-wg(jsls))*pwbt(i,jsls)
116: #endif
117:           end do
118:         else if ( jj.le.ip ) then
119: !------east-boundary slice:
120:           do i = ibeg , iend
121: #ifdef MPP1
122:             if ( jsls.le.ip ) ften(i) = wg(jsls)*ften(i) + (1.-wg(jsls))&
123:                                       & *pebt(i,jeb)
124: #else
125:             ften(i) = wg(jsls)*ften(i) + (1.-wg(jsls))*pebt(i,jsls)
126: #endif
127:           end do
128:         else
129:         end if
130: !
131:       else
132:       end if
133: 
134:       end subroutine sponge_p
135: !
136: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
137: !
<p><a name=sponge_t><H3>sponge_t</H3></a></p> Click <a href="./callingtree/sponge_t_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sponge_t is used.
<hr>
138:       subroutine sponge_t(ip,wg,ften,j)
139: 
140: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
141: !                                                                     c
142: !     this subroutine applies sponge boundary condition to the        c
143: !     tendency term - ften.                                           c
144: !                                                                     c
145: !     ip   : is the number of slices affected by sponge boundary.     c
146: !                                                                     c
147: !     wg   : are the weightings.                                      c
148: !                                                                     c
149: !     ften : is the tendency calculated from the model.               c
150: !                                                                     c
151: !     tebt, twbt, tnbt, tsbt : are the large-scale or observed        c
152: !            tendencies at east, west, north, and south boundaries.   c
153: !                                                                     c
154: !     ie = iy, je = jx for dot-point variables.                       c
155: !     ie = iym1, je = jxm1 for cross-point variables.                 c
156: !                                                                     c
157: !     j    : is the j'th slice of the tendency to be adjusted.        c
158: !                                                                     c
159: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
160: 
161:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
162:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a>
163:       implicit none
164: !
165: ! Dummy arguments
166: !
167:       integer :: ip , j
168:       real(8) , dimension(iy,kz) :: ften
169:       real(8) , dimension(ip) :: wg
170:       intent (in) ip , j , wg
171:       intent (inout) ften
172: !
173: ! Local variables
174: !
175:       integer :: i , ibeg , iend , ii , jj , jsls , k
176: #ifdef MPP1
177:       integer :: jwb , jeb
178: #endif
179: !
180: !----------------------------------------------------------------------
181: !
182: #ifdef MPP1
183:       jsls = j + myid*jxp
184:       jj = jx - jsls
185:       if ( jj.le.ip ) jsls = jj
186:       jwb = jsls
187:       if ( jwb.gt.jxp ) jwb = mod(jwb,jxp)
188:       if ( jwb.eq.0 ) jwb = jxp
189:       if ( myid.eq.nproc-1 ) then
190:         jeb = jsls
191:       else
192:         jeb = jsls + 1
193:       end if
194:       if ( jeb.gt.jxp ) jeb = mod(jeb,jxp)
195:       if ( jeb.eq.0 ) jeb = jxp
196: #else
197:       jsls = j
198:       jj = jx - jsls
199:       if ( jj.le.ip ) jsls = jj
200: #endif
201: !
202:       if ( jsls.gt.ip ) then
203: !-----interior j slices:
204:         do i = 2 , ip
205:           ii = iy - i
206:           do k = 1 , kz
207: !.......south boundary:
208:             ften(i,k) = wg(i)*ften(i,k) + (1.-wg(i))*tsbt(i,k,j)
209: !.......north boundary:
210:             ften(ii,k) = wg(i)*ften(ii,k) + (1.-wg(i))*tnbt(i,k,j)
211:           end do
212:         end do
213: !
214:       else if ( jsls.le.ip ) then
215:         ibeg = 2
216:         iend = iym1 - 1
217:         if ( jsls.gt.2 ) then
218:           do i = 2 , jsls - 1
219:             ii = iy - i
220:             do k = 1 , kz
221: !........south boundary:
222:               ften(i,k) = wg(i)*ften(i,k) + (1.-wg(i))*tsbt(i,k,j)
223: !........north boundary:
224:               ften(ii,k) = wg(i)*ften(ii,k) + (1.-wg(i))*tnbt(i,k,j)
225:             end do
226:           end do
227:           ibeg = jsls
228:           iend = iy - jsls
229:         end if
230: !
231:         if ( jj.gt.ip ) then
232: !------west-boundary slice:
233:           do k = 1 , kz
234:             do i = ibeg , iend
235: #ifdef MPP1
236:               if ( jsls.le.ip ) ften(i,k) = wg(jsls)*ften(i,k)          &
237:                  & + (1.-wg(jsls))*twbt(i,k,jwb)
238: #else
239:               ften(i,k) = wg(jsls)*ften(i,k) + (1.-wg(jsls))            &
240:                         & *twbt(i,k,jsls)
241: #endif
242:             end do
243:           end do
244:         else if ( jj.le.ip ) then
245: !------east-boundary slice:
246:           do k = 1 , kz
247:             do i = ibeg , iend
248: #ifdef MPP1
249:               if ( jsls.le.ip ) ften(i,k) = wg(jsls)*ften(i,k)          &
250:                  & + (1.-wg(jsls))*tebt(i,k,jeb)
251: #else
252:               ften(i,k) = wg(jsls)*ften(i,k) + (1.-wg(jsls))            &
253:                         & *tebt(i,k,jsls)
254: #endif
255:             end do
256:           end do
257:         else
258:         end if
259: !
260:       else
261:       end if
262: 
263:       end subroutine sponge_t
264: !
265: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
266: !
<p><a name=spongeqv><H3>spongeqv</H3></a></p> Click <a href="./callingtree/spongeqv_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where spongeqv is used.
<hr>
267:       subroutine spongeqv(ip,wg,ften,j)
268: 
269: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
270: !                                                                     c
271: !     this subroutine applies sponge boundary condition to the        c
272: !     tendency term - ften.                                           c
273: !                                                                     c
274: !     ip   : is the number of slices affected by sponge boundary.     c
275: !                                                                     c
276: !     wg   : are the weightings.                                      c
277: !                                                                     c
278: !     ften : is the tendency calculated from the model.               c
279: !                                                                     c
280: !     qebt, qwbt, qnbt, qsbt : are the large-scale or observed        c
281: !            tendencies at east, west, north, and south boundaries.   c
282: !                                                                     c
283: !     ie = iy, je = jx for dot-point variables.                       c
284: !     ie = iym1, je = jxm1 for cross-point variables.                 c
285: !                                                                     c
286: !     j    : is the j'th slice of the tendency to be adjusted.        c
287: !                                                                     c
288: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
289: 
290:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
291:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a>
292:       implicit none
293: !
294: ! Dummy arguments
295: !
296:       integer :: ip , j
297:       real(8) , dimension(iy,kz) :: ften
298:       real(8) , dimension(ip) :: wg
299:       intent (in) ip , j , wg
300:       intent (inout) ften
301: !
302: ! Local variables
303: !
304:       integer :: i , ibeg , iend , ii , jj , jsls , k
305: #ifdef MPP1
306:       integer :: jwb , jeb
307: #endif
308: !
309: !----------------------------------------------------------------------
310: !
311: #ifdef MPP1
312:       jsls = j + myid*jxp
313:       jj = jx - jsls
314:       if ( jj.le.ip ) jsls = jj
315:       jwb = jsls
316:       if ( jwb.gt.jxp ) jwb = mod(jwb,jxp)
317:       if ( jwb.eq.0 ) jwb = jxp
318:       if ( myid.eq.nproc-1 ) then
319:         jeb = jsls
320:       else
321:         jeb = jsls + 1
322:       end if
323:       if ( jeb.gt.jxp ) jeb = mod(jeb,jxp)
324:       if ( jeb.eq.0 ) jeb = jxp
325: #else
326:       jsls = j
327:       jj = jx - jsls
328:       if ( jj.le.ip ) jsls = jj
329: #endif
330: !
331:       if ( jsls.gt.ip ) then
332: !-----interior j slices:
333:         do i = 2 , ip
334:           ii = iy - i
335:           do k = 1 , kz
336: !.......south boundary:
337:             ften(i,k) = wg(i)*ften(i,k) + (1.-wg(i))*qsbt(i,k,j)
338: !.......north boundary:
339:             ften(ii,k) = wg(i)*ften(ii,k) + (1.-wg(i))*qnbt(i,k,j)
340:           end do
341:         end do
342: !
343:       else if ( jsls.le.ip ) then
344:         ibeg = 2
345:         iend = iym1 - 1
346:         if ( jsls.gt.2 ) then
347:           do i = 2 , jsls - 1
348:             ii = iy - i
349:             do k = 1 , kz
350: !........south boundary:
351:               ften(i,k) = wg(i)*ften(i,k) + (1.-wg(i))*qsbt(i,k,j)
352: !........north boundary:
353:               ften(ii,k) = wg(i)*ften(ii,k) + (1.-wg(i))*qnbt(i,k,j)
354:             end do
355:           end do
356:           ibeg = jsls
357:           iend = iy - jsls
358:         end if
359: !
360:         if ( jj.gt.ip ) then
361: !------west-boundary slice:
362:           do k = 1 , kz
363:             do i = ibeg , iend
364: #ifdef MPP1
365:               if ( jsls.le.ip ) ften(i,k) = wg(jsls)*ften(i,k)          &
366:                  & + (1.-wg(jsls))*qwbt(i,k,jwb)
367: #else
368:               ften(i,k) = wg(jsls)*ften(i,k) + (1.-wg(jsls))            &
369:                         & *qwbt(i,k,jsls)
370: #endif
371:             end do
372:           end do
373:         else if ( jj.le.ip ) then
374: !------east-boundary slice:
375:           do k = 1 , kz
376:             do i = ibeg , iend
377: #ifdef MPP1
378:               if ( jsls.le.ip ) ften(i,k) = wg(jsls)*ften(i,k)          &
379:                  & + (1.-wg(jsls))*qebt(i,k,jeb)
380: #else
381:               ften(i,k) = wg(jsls)*ften(i,k) + (1.-wg(jsls))            &
382:                         & *qebt(i,k,jsls)
383: #endif
384:             end do
385:           end do
386:         else
387:         end if
388: !
389:       else
390:       end if
391:       end subroutine spongeqv
392: !
393: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
394: !
<p><a name=sponge_u><H3>sponge_u</H3></a></p> Click <a href="./callingtree/sponge_u_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sponge_u is used.
<hr>
395:       subroutine sponge_u(ip,wg,ften,j)
396: 
397: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
398: !                                                                     c
399: !     this subroutine applies sponge boundary condition to the        c
400: !     tendency term - ften.                                           c
401: !                                                                     c
402: !     ip   : is the number of slices affected by sponge boundary.     c
403: !                                                                     c
404: !     wg   : are the weightings.                                      c
405: !                                                                     c
406: !     ften : is the tendency calculated from the model.               c
407: !                                                                     c
408: !     uebt, uwbt, unbt, usbt : are the large-scale or observed        c
409: !            tendencies at east, west, north, and south boundaries.   c
410: !                                                                     c
411: !     ie = iy, je = jx for dot-point variables.                       c
412: !     ie = iym1, je = jxm1 for cross-point variables.                 c
413: !                                                                     c
414: !     j    : is the j'th slice of the tendency to be adjusted.        c
415: !                                                                     c
416: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
417: 
418:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
419:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a>
420:       implicit none
421: !
422: ! Dummy arguments
423: !
424:       integer :: ip , j
425:       real(8) , dimension(iy,kz) :: ften
426:       real(8) , dimension(ip) :: wg
427:       intent (in) ip , j , wg
428:       intent (inout) ften
429: !
430: ! Local variables
431: !
432:       integer :: i , ibeg , iend , ii , jj , jsls , k
433: #ifdef MPP1
434:       integer :: jew
435: #endif
436: 
437: !
438: !----------------------------------------------------------------------
439: !
440: #ifdef MPP1
441:       jsls = j + myid*jxp
442:       jj = jxp1 - jsls
443:       if ( jj.le.ip ) jsls = jj
444:       jew = jsls
445:       if ( jew.gt.jxp ) jew = mod(jsls,jxp)
446:       if ( jew.eq.0 ) jew = jxp
447: #else
448:       jsls = j
449:       jj = jxp1 - jsls
450:       if ( jj.le.ip ) jsls = jj
451: #endif
452: !
453:       if ( jsls.gt.ip ) then
454: !-----interior j slices:
455:         do i = 2 , ip
456:           ii = iy - i + 1
457:           do k = 1 , kz
458: !.......south boundary:
459:             ften(i,k) = wg(i)*ften(i,k) + (1.-wg(i))*usbt(i,k,j)
460: !.......north boundary:
461:             ften(ii,k) = wg(i)*ften(ii,k) + (1.-wg(i))*unbt(i,k,j)
462:           end do
463:         end do
464: !
465:       else if ( jsls.le.ip ) then
466:         ibeg = 2
467:         iend = iym1
468:         if ( jsls.gt.2 ) then
469:           do i = 2 , jsls - 1
470:             ii = iy - i + 1
471:             do k = 1 , kz
472: !........south boundary:
473:               ften(i,k) = wg(i)*ften(i,k) + (1.-wg(i))*usbt(i,k,j)
474: !........north boundary:
475:               ften(ii,k) = wg(i)*ften(ii,k) + (1.-wg(i))*unbt(i,k,j)
476:             end do
477:           end do
478:           ibeg = jsls
479:           iend = iy - jsls + 1
480:         end if
481: !
482:         if ( jj.gt.ip ) then
483: !------west-boundary slice:
484:           do k = 1 , kz
485:             do i = ibeg , iend
486: #ifdef MPP1
487:               if ( jsls.le.ip ) ften(i,k) = wg(jsls)*ften(i,k)          &
488:                  & + (1.-wg(jsls))*uwbt(i,k,jew)
489: #else
490:               ften(i,k) = wg(jsls)*ften(i,k) + (1.-wg(jsls))            &
491:                         & *uwbt(i,k,jsls)
492: #endif
493:             end do
494:           end do
495:         else if ( jj.le.ip ) then
496: !------east-boundary slice:
497:           do k = 1 , kz
498:             do i = ibeg , iend
499: #ifdef MPP1
500:               if ( jsls.le.ip ) ften(i,k) = wg(jsls)*ften(i,k)          &
501:                  & + (1.-wg(jsls))*uebt(i,k,jew)
502: #else
503:               ften(i,k) = wg(jsls)*ften(i,k) + (1.-wg(jsls))            &
504:                         & *uebt(i,k,jsls)
505: #endif
506:             end do
507:           end do
508:         else
509:         end if
510: !
511:       else
512:       end if
513:       end subroutine sponge_u
514: !
515: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
516: !
<p><a name=sponge_v><H3>sponge_v</H3></a></p> Click <a href="./callingtree/sponge_v_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where sponge_v is used.
<hr>
517:       subroutine sponge_v(ip,wg,ften,j)
518: 
519: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
520: !                                                                     c
521: !     this subroutine applies sponge boundary condition to the        c
522: !     tendency term - ften.                                           c
523: !                                                                     c
524: !     ip   : is the number of slices affected by sponge boundary.     c
525: !                                                                     c
526: !     wg   : are the weightings.                                      c
527: !                                                                     c
528: !     ften : is the tendency calculated from the model.               c
529: !                                                                     c
530: !     vebt, vwbt, vnbt, vsbt : are the large-scale or observed        c
531: !            tendencies at east, west, north, and south boundaries.   c
532: !                                                                     c
533: !     ie = iy, je = jx for dot-point variables.                       c
534: !     ie = iym1, je = jxm1 for cross-point variables.                 c
535: !                                                                     c
536: !     j    : is the j'th slice of the tendency to be adjusted.        c
537: !                                                                     c
538: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
539: 
540:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
541:       use <a href="./mod_bdycod.F90.html#mod_bdycod" TARGET=CENT_PANEL>mod_bdycod</a>
542:       implicit none
543: !
544: ! Dummy arguments
545: !
546:       integer :: ip , j
547:       real(8) , dimension(iy,kz) :: ften
548:       real(8) , dimension(ip) :: wg
549:       intent (in) ip , j , wg
550:       intent (inout) ften
551: !
552: ! Local variables
553: !
554:       integer :: i , ibeg , iend , ii , jj , jsls , k
555: #ifdef MPP1
556:       integer :: jew
557: #endif
558: !
559: !----------------------------------------------------------------------
560: !
561: #ifdef MPP1
562:       jsls = j + myid*jxp
563:       jj = jxp1 - jsls
564:       if ( jj.le.ip ) jsls = jj
565:       jew = jsls
566:       if ( jew.gt.jxp ) jew = mod(jsls,jxp)
567:       if ( jew.eq.0 ) jew = jxp
568: #else
569:       jsls = j
570:       jj = jxp1 - jsls
571:       if ( jj.le.ip ) jsls = jj
572: #endif
573: !
574:       if ( jsls.gt.ip ) then
575: !-----interior j slices:
576:         do i = 2 , ip
577:           ii = iy - i + 1
578:           do k = 1 , kz
579: !.......south boundary:
580:             ften(i,k) = wg(i)*ften(i,k) + (1.-wg(i))*vsbt(i,k,j)
581: !.......north boundary:
582:             ften(ii,k) = wg(i)*ften(ii,k) + (1.-wg(i))*vnbt(i,k,j)
583:           end do
584:         end do
585: !
586:       else if ( jsls.le.ip ) then
587:         ibeg = 2
588:         iend = iym1
589:         if ( jsls.gt.2 ) then
590:           do i = 2 , jsls - 1
591:             ii = iy - i + 1
592:             do k = 1 , kz
593: !........south boundary:
594:               ften(i,k) = wg(i)*ften(i,k) + (1.-wg(i))*vsbt(i,k,j)
595: !........north boundary:
596:               ften(ii,k) = wg(i)*ften(ii,k) + (1.-wg(i))*vnbt(i,k,j)
597:             end do
598:           end do
599:           ibeg = jsls
600:           iend = iy - jsls + 1
601:         end if
602: !
603:         if ( jj.gt.ip ) then
604: !------west-boundary slice:
605:           do k = 1 , kz
606:             do i = ibeg , iend
607: #ifdef MPP1
608:               if ( jsls.le.ip ) ften(i,k) = wg(jsls)*ften(i,k)          &
609:                  & + (1.-wg(jsls))*vwbt(i,k,jew)
610: #else
611:               ften(i,k) = wg(jsls)*ften(i,k) + (1.-wg(jsls))            &
612:                         & *vwbt(i,k,jsls)
613: #endif
614:             end do
615:           end do
616:         else if ( jj.le.ip ) then
617: !------east-boundary slice:
618:           do k = 1 , kz
619:             do i = ibeg , iend
620: #ifdef MPP1
621:               if ( jsls.le.ip ) ften(i,k) = wg(jsls)*ften(i,k)          &
622:                  & + (1.-wg(jsls))*vebt(i,k,jew)
623: #else
624:               ften(i,k) = wg(jsls)*ften(i,k) + (1.-wg(jsls))            &
625:                         & *vebt(i,k,jsls)
626: #endif
627:             end do
628:           end do
629:         else
630:         end if
631: !
632:       else
633:       end if
634:       end subroutine sponge_v
</PRE>

<HR>

</BODY>
</HTML>
