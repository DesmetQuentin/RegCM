<HTML>

<HEAD>
<TITLE>eispack.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>eispack.f90</H1>
<HR>
<H2 ALIGN=CENTER>eispack.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
<p><a name=bakvec><H3>bakvec</H3></a></p> Click <a href="./callingtree/bakvec_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where bakvec is used.
<hr>
1: subroutine bakvec ( n, t, e, m, z, ierr )
2: 
3: !*****************************************************************************80
4: !
5: !! BAKVEC determines eigenvectors by reversing the FIGI transformation.
6: !
7: !  Discussion:
8: !
9: !    This subroutine forms the eigenvectors of a nonsymmetric tridiagonal 
10: !    matrix by back transforming those of the corresponding symmetric 
11: !    matrix determined by FIGI.
12: !
13: !  Licensing:
14: !
15: !    This code is distributed under the GNU LGPL license.
16: !
17: !  Modified:
18: !
19: !    18 October 2009
20: !
21: !  Author:
22: !
23: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
24: !    Klema, Moler.
25: !    FORTRAN90 version by John Burkardt.
26: !
27: !  Reference:
28: !
29: !    James Wilkinson, Christian Reinsch,
30: !    Handbook for Automatic Computation,
31: !    Volume II, Linear Algebra, Part 2,
32: !    Springer, 1971,
33: !    ISBN: 0387054146,
34: !    LC: QA251.W67.
35: !
36: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
37: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
38: !    Matrix Eigensystem Routines, EISPACK Guide,
39: !    Lecture Notes in Computer Science, Volume 6,
40: !    Springer Verlag, 1976,
41: !    ISBN13: 978-3540075462,
42: !    LC: QA193.M37.
43: !
44: !  Parameters:
45: !
46: !    Input, integer ( kind = 4 ) N, the order of the matrix.
47: !
48: !    Input, real ( kind = 8 ) T(N,3), contains the nonsymmetric matrix.  Its 
49: !    subdiagonal is stored in the positions 2:N of the first column,
50: !    its diagonal in positions 1:N of the second column,
51: !    and its superdiagonal in positions 1:N-1 of the third column.  
52: !    T(1,1) and T(N,3) are arbitrary.
53: !
54: !    Input/output, real ( kind = 8 ) E(N).  On input, E(2:N) contains the 
55: !    subdiagonal elements of the symmetric matrix.  E(1) is arbitrary.
56: !    On output, the contents of E have been destroyed.
57: !
58: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back 
59: !    transformed.
60: !
61: !    Input/output, real ( kind = 8 ) Z(N,M), contains the eigenvectors.  
62: !    On output, they have been transformed as requested.
63: !
64: !    Output, integer ( kind = 4 ) IERR, an error flag.
65: !    0, for normal return,
66: !    2*N+I, if E(I) is zero with T(I,1) or T(I-1,3) non-zero.
67: !    In this case, the symmetric matrix is not similar
68: !    to the original matrix, and the eigenvectors
69: !    cannot be found by this program.
70: !
71:   implicit none
72: 
73:   integer ( kind = 4 ) m
74:   integer ( kind = 4 ) n
75: 
76:   real    ( kind = 8 ) e(n)
77:   integer ( kind = 4 ) i
78:   integer ( kind = 4 ) ierr
79:   integer ( kind = 4 ) j
80:   real    ( kind = 8 ) t(n,3)
81:   real    ( kind = 8 ) z(n,m)
82: 
83:   ierr = 0
84: 
85:   if ( m == 0 ) then
86:     return
87:   end if
88: 
89:   e(1) = 1.0D+00
90:   if ( n == 1 ) then
91:     return
92:   end if
93: 
94:   do i = 2, n
95:     if ( e(i) == 0.0D+00 ) then
96:       if ( t(i,1) /= 0.0D+00 .or. t(i-1,3) /= 0.0D+00 ) then
97:         ierr = 2 * n + i
98:         return
99:       end if
100:       e(i) = 1.0D+00
101:     else
102:       e(i) = e(i-1) * e(i) / t(i-1,3)
103:     end if
104:   end do
105: 
106:   do j = 1, m
107:     z(2:n,j) = z(2:n,j) * e(2:n)
108:   end do
109: 
110:   return
111: end
<p><a name=balanc><H3>balanc</H3></a></p> Click <a href="./callingtree/balanc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where balanc is used.
<hr>
112: subroutine balanc ( n, a, low, igh, xscale )
113: 
114: !*****************************************************************************80
115: !
116: !! BALANC balances a real matrix before eigenvalue calculations.
117: !
118: !  Discussion:
119: !
120: !    This subroutine balances a real matrix and isolates eigenvalues 
121: !    whenever possible.
122: !
123: !    Suppose that the principal submatrix in rows LOW through IGH
124: !    has been balanced, that P(J) denotes the index interchanged
125: !    with J during the permutation step, and that the elements
126: !    of the diagonal matrix used are denoted by D(I,J).  Then
127: !
128: !      SCALE(J) = P(J),    J = 1,...,LOW-1,
129: !               = D(J,J),  J = LOW,...,IGH,
130: !               = P(J)     J = IGH+1,...,N.
131: !
132: !    The order in which the interchanges are made is N to IGH+1,
133: !    then 1 to LOW-1.
134: !
135: !    Note that 1 is returned for LOW if IGH is zero formally.
136: !
137: !  Licensing:
138: !
139: !    This code is distributed under the GNU LGPL license.
140: !
141: !  Modified:
142: !
143: !    18 October 2009
144: !
145: !  Author:
146: !
147: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
148: !    Klema, Moler.
149: !    FORTRAN90 version by John Burkardt.
150: !
151: !  Reference:
152: !
153: !    James Wilkinson, Christian Reinsch,
154: !    Handbook for Automatic Computation,
155: !    Volume II, Linear Algebra, Part 2,
156: !    Springer, 1971,
157: !    ISBN: 0387054146,
158: !    LC: QA251.W67.
159: !
160: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
161: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
162: !    Matrix Eigensystem Routines, EISPACK Guide,
163: !    Lecture Notes in Computer Science, Volume 6,
164: !    Springer Verlag, 1976,
165: !    ISBN13: 978-3540075462,
166: !    LC: QA193.M37.
167: !
168: !  Parameters:
169: !
170: !    Input, integer ( kind = 4 ) N, the order of the matrix.
171: !
172: !    Input/output, real ( kind = 8 ) A(N,N), the N by N matrix.  On output,
173: !    the matrix has been balanced.
174: !
175: !    Output, integer ( kind = 4 ) LOW, IGH, indicate that A(I,J) is equal to 
176: !    zero if
177: !    (1) I is greater than J and
178: !    (2) J=1,...,LOW-1 or I=IGH+1,...,N.
179: !
180: !    Output, real ( kind = 8 ) SCALE(N), contains information determining the
181: !    permutations and scaling factors used.
182: !
183:   implicit none
184: 
185:   integer ( kind = 4 ) n
186: 
187:   real    ( kind = 8 ) a(n,n)
188:   real    ( kind = 8 ) b2
189:   real    ( kind = 8 ) c
190:   real    ( kind = 8 ) f
191:   real    ( kind = 8 ) g
192:   integer ( kind = 4 ) i
193:   integer ( kind = 4 ) iexc
194:   integer ( kind = 4 ) igh
195:   integer ( kind = 4 ) j
196:   integer ( kind = 4 ) k
197:   integer ( kind = 4 ) l
198:   integer ( kind = 4 ) low
199:   integer ( kind = 4 ) m
200:   logical              noconv
201:   real    ( kind = 8 ) r
202:   real    ( kind = 8 ) rdx
203:   real    ( kind = 8 ) s
204:   real    ( kind = 8 ) xscale(n)
205: 
206:   rdx = 16.0D+00
207: 
208:   iexc = 0
209:   j = 0
210:   m = 0
211: 
212:   b2 = rdx**2
213:   k = 1
214:   l = n
215:   go to 100
216: 
217: 20 continue
218: 
219:   xscale(m) = j
220: 
221:   if ( j /= m ) then
222: 
223:     do i = 1, l
224:       call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( a(i,j), a(i,m) )
225:     end do
226: 
227:     do i = k, n
228:       call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( a(j,i), a(m,i) )
229:     end do
230: 
231:   end if
232: 
233:   if ( iexc == 2 ) then
234:     go to 130
235:   end if
236: !
237: !  Search for rows isolating an eigenvalue and push them down.
238: !
239:   if ( l == 1 ) then
240:     low = k
241:     igh = l
242:     return
243:   end if
244: 
245:   l = l - 1
246: 
247: 100 continue
248: 
249:   do j = l, 1, -1
250: 
251:      do i = 1, l
252:        if ( i /= j ) then
253:          if ( a(j,i) /= 0.0D+00 ) then
254:            go to 120
255:          end if
256:        end if
257:      end do
258: 
259:      m = l
260:      iexc = 1
261:      go to 20
262: 
263: 120  continue
264: 
265:   end do
266: 
267:   go to 140
268: !
269: !  Search for columns isolating an eigenvalue and push them left.
270: !
271: 130 continue
272: 
273:   k = k + 1
274: 
275: 140 continue
276: 
277:   do j = k, l
278: 
279:     do i = k, l
280:       if ( i /= j ) then
281:         if ( a(i,j) /= 0.0D+00 ) then
282:           go to 170
283:         end if
284:       end if
285:     end do
286: 
287:     m = k
288:     iexc = 2
289:     go to 20
290: 
291: 170 continue
292: 
293:   end do
294: !
295: !  Balance the submatrix in rows K to L.
296: !
297:   xscale(k:l) = 1.0D+00
298: !
299: !  Iterative loop for norm reduction.
300: !
301:   noconv = .true.
302: 
303:   do while ( noconv )
304: 
305:     noconv = .false.
306: 
307:     do i = k, l
308: 
309:       c = 0.0D+00
310:       r = 0.0D+00
311: 
312:       do j = k, l
313:         if ( j /= i ) then
314:           c = c + abs ( a(j,i) )
315:           r = r + abs ( a(i,j) )
316:         end if
317:       end do
318: !
319: !  Guard against zero C or R due to underflow.
320: !
321:       if ( c /= 0.0D+00 .and. r /= 0.0D+00 ) then
322: 
323:         g = r / rdx
324:         f = 1.0D+00
325:         s = c + r
326: 
327:         do while ( c < g ) 
328:           f = f * rdx
329:           c = c * b2
330:         end do
331: 
332:         g = r * rdx
333: 
334:         do while ( g <= c ) 
335:           f = f / rdx
336:           c = c / b2
337:         end do
338: !
339: !  Balance.
340: !
341:         if ( ( c + r ) / f < 0.95D+00 * s ) then
342: 
343:           g = 1.0D+00 / f
344:           xscale(i) = xscale(i) * f
345:           noconv = .true.
346: 
347:           a(i,k:n) = a(i,k:n) * g
348:           a(1:l,i) = a(1:l,i) * f
349: 
350:         end if
351: 
352:       end if
353: 
354:     end do
355: 
356:   end do
357: 
358:   low = k
359:   igh = l
360: 
361:   return
362: end
<p><a name=balbak><H3>balbak</H3></a></p> Click <a href="./callingtree/balbak_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where balbak is used.
<hr>
363: subroutine balbak ( n, low, igh, xscale, m, z )
364: 
365: !*****************************************************************************80
366: !
367: !! BALBAK determines eigenvectors by undoing the BALANC transformation.
368: !
369: !  Discussion:
370: !
371: !    This subroutine forms the eigenvectors of a real general matrix by 
372: !    back transforming those of the corresponding balanced matrix 
373: !    determined by BALANC.
374: !
375: !  Licensing:
376: !
377: !    This code is distributed under the GNU LGPL license.
378: !
379: !  Modified:
380: !
381: !    18 October 2009
382: !
383: !  Author:
384: !
385: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
386: !    Klema, Moler.
387: !    FORTRAN90 version by John Burkardt.
388: !
389: !  Reference:
390: !
391: !    Parlett and Reinsch,
392: !    Numerische Mathematik,
393: !    Volume 13, pages 293-304, 1969.
394: !
395: !    James Wilkinson, Christian Reinsch,
396: !    Handbook for Automatic Computation,
397: !    Volume II, Linear Algebra, Part 2,
398: !    Springer, 1971,
399: !    ISBN: 0387054146,
400: !    LC: QA251.W67.
401: !
402: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
403: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
404: !    Matrix Eigensystem Routines, EISPACK Guide,
405: !    Lecture Notes in Computer Science, Volume 6,
406: !    Springer Verlag, 1976,
407: !    ISBN13: 978-3540075462,
408: !    LC: QA193.M37.
409: !
410: !  Parameters:
411: !
412: !    Input, integer ( kind = 4 ) N, the order of the matrix.
413: !
414: !    Input, integer ( kind = 4 ) LOW, IGH, column indices determined by BALANC.
415: !
416: !    Input, real ( kind = 8 ) SCALE(N), contains information determining
417: !    the permutations and scaling factors used by BALANC.
418: !
419: !    Input, integer ( kind = 4 ) M, the number of columns of Z to be 
420: !    back-transformed.
421: !
422: !    Input/output, real ( kind = 8 ) Z(N,M), contains the real and imaginary parts 
423: !    of the eigenvectors, which, on return, have been back-transformed.
424: !
425:   implicit none
426: 
427:   integer ( kind = 4 ) m
428:   integer ( kind = 4 ) n
429: 
430:   integer ( kind = 4 ) i
431:   integer ( kind = 4 ) igh
432:   integer ( kind = 4 ) ii
433:   integer ( kind = 4 ) j
434:   integer ( kind = 4 ) k
435:   integer ( kind = 4 ) low
436:   real    ( kind = 8 ) xscale(n)
437:   real    ( kind = 8 ) z(n,m)
438: 
439:   if ( m <= 0 ) then
440:     return
441:   end if
442: 
443:   if ( igh /= low ) then
444:     do i = low, igh
445:       z(i,1:m) = z(i,1:m) * xscale(i)
446:     end do
447:   end if
448: 
449:    do ii = 1, n
450: 
451:      i = ii
452: 
453:      if ( i < low .or. igh < i ) then
454: 
455:        if ( i < low ) then
456:          i = low - ii
457:        end if
458: 
459:        k = int ( xscale(i) )
460: 
461:        if ( k /= i ) then
462: 
463:          do j = 1, m
464:            call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( z(i,j), z(k,j) )
465:          end do
466: 
467:         end if
468: 
469:       end if
470: 
471:   end do
472: 
473:   return
474: end
<p><a name=bandr><H3>bandr</H3></a></p> Click <a href="./callingtree/bandr_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where bandr is used.
<hr>
475: subroutine bandr ( n, mb, a, d, e, e2, matz, z )
476: 
477: !*****************************************************************************80
478: !
479: !! BANDR reduces a symmetric band matrix to symmetric tridiagonal form.
480: !
481: !  Discussion:
482: !
483: !    This subroutine reduces a real symmetric band matrix
484: !    to a symmetric tridiagonal matrix using and optionally
485: !    accumulating orthogonal similarity transformations.
486: !
487: !  Licensing:
488: !
489: !    This code is distributed under the GNU LGPL license.
490: !
491: !  Modified:
492: !
493: !    18 October 2009
494: !
495: !  Author:
496: !
497: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
498: !    Klema, Moler.
499: !    FORTRAN90 version by John Burkardt.
500: !
501: !  Reference:
502: !
503: !    James Wilkinson, Christian Reinsch,
504: !    Handbook for Automatic Computation,
505: !    Volume II, Linear Algebra, Part 2,
506: !    Springer, 1971,
507: !    ISBN: 0387054146,
508: !    LC: QA251.W67.
509: !
510: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
511: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
512: !    Matrix Eigensystem Routines, EISPACK Guide,
513: !    Lecture Notes in Computer Science, Volume 6,
514: !    Springer Verlag, 1976,
515: !    ISBN13: 978-3540075462,
516: !    LC: QA193.M37.
517: !
518: !  Parameters:
519: !
520: !    Input, integer ( kind = 4 ) N, the order of the matrix.
521: !
522: !    Input, integer ( kind = 4 ) MB, is the (half) band width of the matrix, 
523: !    defined as the number of adjacent diagonals, including the principal
524: !    diagonal, required to specify the non-zero portion of the
525: !    lower triangle of the matrix.
526: !
527: !    Input/output, real ( kind = 8 ) A(N,MB).  On input, contains the lower triangle of 
528: !    the symmetric band input matrix stored as an N by MB array.  Its lowest 
529: !    subdiagonal is stored in the last N+1-MB positions of the first column,
530: !    its next subdiagonal in the last N+2-MB positions of the second column, 
531: !    further subdiagonals similarly, and finally its principal diagonal in 
532: !    the N positions of the last column.  Contents of storages not part of 
533: !    the matrix are arbitrary.  On output, A has been destroyed, except for 
534: !    its last two columns which contain a copy of the tridiagonal matrix.
535: !
536: !    Output, real ( kind = 8 ) D(N), the diagonal elements of the tridiagonal matrix.
537: !
538: !    Output, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal
539: !    matrix in E(2:N).  E(1) is set to zero.
540: !
541: !    Output, real ( kind = 8 ) E2(N), contains the squares of the corresponding elements 
542: !    of E.  E2 may coincide with E if the squares are not needed.
543: !
544: !    Input, logical MATZ, should be set to TRUE if the transformation matrix is
545: !    to be accumulated, and to FALSE otherwise.
546: !
547: !    Output, real ( kind = 8 ) Z(N,N), the orthogonal transformation matrix produced in
548: !    the reduction if MATZ has been set to TRUE.  Otherwise, Z is not
549: !    referenced.
550: !
551:   implicit none
552: 
553:   integer ( kind = 4 ) mb
554:   integer ( kind = 4 ) n
555: 
556:   real    ( kind = 8 ) a(n,mb)
557:   real    ( kind = 8 ) b1
558:   real    ( kind = 8 ) b2
559:   real    ( kind = 8 ) c2
560:   real    ( kind = 8 ) d(n)
561:   real    ( kind = 8 ) dmin
562:   real    ( kind = 8 ) dminrt
563:   real    ( kind = 8 ) e(n)
564:   real    ( kind = 8 ) e2(n)
565:   real    ( kind = 8 ) f1
566:   real    ( kind = 8 ) f2
567:   real    ( kind = 8 ) g
568:   integer ( kind = 4 ) i
569:   integer ( kind = 4 ) i1
570:   integer ( kind = 4 ) i2
571:   integer ( kind = 4 ) j
572:   integer ( kind = 4 ) j1
573:   integer ( kind = 4 ) j2
574:   integer ( kind = 4 ) k
575:   integer ( kind = 4 ) kr
576:   integer ( kind = 4 ) l
577:   integer ( kind = 4 ) m1
578:   logical              matz
579:   integer ( kind = 4 ) maxl
580:   integer ( kind = 4 ) maxr
581:   integer ( kind = 4 ) mr
582:   integer ( kind = 4 ) r
583:   integer ( kind = 4 ) r1
584:   real    ( kind = 8 ) s2
585:   real    ( kind = 8 ) u
586:   integer ( kind = 4 ) ugl
587:   real    ( kind = 8 ) z(n,n)
588: 
589:   dmin = epsilon ( dmin )
590:   dminrt = sqrt ( dmin )
591: !
592: !  Initialize the diagonal scaling matrix.
593: !
594:   d(1:n) = 1.0D+00
595: 
596:   if ( matz ) then
597: 
598:     a(1:n,1:n) = 0.0D+00
599: 
600:     do i = 1, n
601:       z(i,i) = 1.0D+00
602:     end do
603: 
604:   end if
605: 
606:   m1 = mb - 1
607: 
608:   if ( m1 < 1 ) then
609:     d(1:n) = a(1:n,mb)
610:     e(1:n) = 0.0D+00
611:     e2(1:n) = 0.0D+00
612:     return
613:   end if
614: 
615:   if ( m1 == 1 ) then
616:     go to 800
617:   end if
618: 
619:   do k = 1, n - 2
620: 
621:     maxr = min ( m1, n-k )
622: 
623:     do r1 = 2, maxr
624: 
625:       r = maxr + 2 - r1
626:       kr = k + r
627:       mr = mb - r
628:       g = a(kr,mr)
629:       a(kr-1,1) = a(kr-1,mr+1)
630:       ugl = k
631: 
632:       do j = kr, n, m1
633: 
634:         j1 = j - 1
635:         j2 = j1 - 1
636: 
637:         if ( g == 0.0D+00 ) then
638:           go to 600
639:         end if
640: 
641:         b1 = a(j1,1) / g
642:         b2 = b1 * d(j1) / d(j)
643:         s2 = 1.0D+00 / ( 1.0D+00 + b1 * b2 )
644: 
645:         if ( s2 < 0.5D+00 ) then
646: 
647:           b1 = g / a(j1,1)
648:           b2 = b1 * d(j) / d(j1)
649:           c2 = 1.0D+00 - s2
650:           d(j1) = c2 * d(j1)
651:           d(j) = c2 * d(j)
652:           f1 = 2.0D+00 * a(j,m1)
653:           f2 = b1 * a(j1,mb)
654:           a(j,m1) = -b2 * ( b1 * a(j,m1) - a(j,mb) ) - f2 + a(j,m1)
655:           a(j1,mb) = b2 * ( b2 * a(j,mb) + f1 ) + a(j1,mb)
656:           a(j,mb) = b1 * ( f2 - f1 ) + a(j,mb)
657: 
658:           do l = ugl, j2
659:             i2 = mb - j + l
660:             u = a(j1,i2+1) + b2 * a(j,i2)
661:             a(j,i2) = -b1 * a(j1,i2+1) + a(j,i2)
662:             a(j1,i2+1) = u
663:           end do
664: 
665:           ugl = j
666:           a(j1,1) = a(j1,1) + b2 * g
667: 
668:           if ( j /= n ) then
669: 
670:             maxl = min ( m1, n-j1 )
671: 
672:             do l = 2, maxl
673:               i1 = j1 + l
674:               i2 = mb - l
675:               u = a(i1,i2) + b2 * a(i1,i2+1)
676:               a(i1,i2+1) = -b1 * a(i1,i2) + a(i1,i2+1)
677:               a(i1,i2) = u
678:             end do
679: 
680:             i1 = j + m1
681: 
682:             if ( i1 <= n ) then
683:               g = b2 * a(i1,1)
684:             end if
685: 
686:           end if
687: 
688:           if ( matz ) then
689: 
690:             do l = 1, n
691:               u = z(l,j1) + b2 * z(l,j)
692:               z(l,j) = -b1 * z(l,j1) + z(l,j)
693:               z(l,j1) = u
694:             end do
695: 
696:           end if
697: 
698:         else
699: 
700:           u = d(j1)
701:           d(j1) = s2 * d(j)
702:           d(j) = s2 * u
703:           f1 = 2.0D+00 * a(j,m1)
704:           f2 = b1 * a(j,mb)
705:           u = b1 * ( f2 - f1 ) + a(j1,mb)
706:           a(j,m1) = b2 * ( b1 * a(j,m1) - a(j1,mb) ) + f2 - a(j,m1)
707:           a(j1,mb) = b2 * ( b2 * a(j1,mb) + f1 ) + a(j,mb)
708:           a(j,mb) = u
709: 
710:           do l = ugl, j2
711:             i2 = mb - j + l
712:             u = b2 * a(j1,i2+1) + a(j,i2)
713:             a(j,i2) = -a(j1,i2+1) + b1 * a(j,i2)
714:             a(j1,i2+1) = u
715:           end do
716: 
717:           ugl = j
718:           a(j1,1) = b2 * a(j1,1) + g
719: 
720:           if ( j /= n ) then
721: 
722:             maxl = min ( m1, n-j1 )
723: 
724:             do l = 2, maxl
725:               i1 = j1 + l
726:               i2 = mb - l
727:               u = b2 * a(i1,i2) + a(i1,i2+1)
728:               a(i1,i2+1) = -a(i1,i2) + b1 * a(i1,i2+1)
729:               a(i1,i2) = u
730:             end do
731: 
732:             i1 = j + m1
733: 
734:             if ( i1 <= n ) then
735:               g = a(i1,1)
736:               a(i1,1) = b1 * a(i1,1)
737:             end if
738: 
739:           end if
740: 
741:           if ( matz ) then
742: 
743:             do l = 1, n
744:               u = b2 * z(l,j1) + z(l,j)
745:               z(l,j) = -z(l,j1) + b1 * z(l,j)
746:               z(l,j1) = u
747:             end do
748: 
749:           end if
750: 
751:         end if
752: 
753:       end do
754: 
755: 600   continue
756: 
757:     end do
758: !
759: !  Rescale to avoid underflow or overflow.
760: !
761:     if ( mod ( k, 64 ) == 0 ) then
762: 
763:       do j = k, n
764: 
765:         if ( d(j) < dmin ) then
766: 
767:           maxl = max ( 1, mb+1-j )
768: 
769:           a(j,maxl:m1) = dminrt * a(j,maxl:m1)
770: 
771:           if ( j /= n ) then
772: 
773:             maxl = min ( m1, n-j )
774: 
775:             do l = 1, maxl
776:               i1 = j + l
777:               i2 = mb - l
778:               a(i1,i2) = dminrt * a(i1,i2)
779:             end do
780: 
781:           end if
782: 
783:           if ( matz ) then
784:             z(1:n,j) = dminrt * z(1:n,j)
785:           end if
786: 
787:           a(j,mb) = dmin * a(j,mb)
788:           d(j) = d(j) / dmin
789:  
790:         end if
791: 
792:       end do
793: 
794:     end if
795: 
796:   end do
797: !
798: !   Form square root of scaling matrix.
799: !
800: 800 continue
801: 
802:   e(2:n) = sqrt ( d(2:n) )
803: 
804:   if ( matz ) then
805: 
806:     do k = 2, n
807:       z(1:n,k) = z(1:n,k) * e(k)
808:     end do
809: 
810:   end if
811: 
812:   u = 1.0D+00
813: 
814:   do j = 2, n
815:     a(j,m1) = u * e(j) * a(j,m1)
816:     u = e(j)
817:     e2(j) = a(j,m1)**2
818:     a(j,mb) = d(j) * a(j,mb)
819:     d(j) = a(j,mb)
820:     e(j) = a(j,m1)
821:   end do
822: 
823:   d(1) = a(1,mb)
824:   e(1) = 0.0D+00
825:   e2(1) = 0.0D+00
826: 
827:   return
828: end
<p><a name=bandv><H3>bandv</H3></a></p> Click <a href="./callingtree/bandv_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where bandv is used.
<hr>
829: subroutine bandv ( n, mbw, a, e21, m, w, z, ierr )
830: 
831: !*****************************************************************************80
832: !
833: !! BANDV finds eigenvectors from eigenvalues, for a real symmetric band matrix.
834: !
835: !  Discussion:
836: !
837: !    This subroutine finds those eigenvectors of a real symmetric
838: !    band matrix corresponding to specified eigenvalues, using inverse
839: !    iteration.  The subroutine may also be used to solve systems
840: !    of linear equations with a symmetric or non-symmetric band
841: !    coefficient matrix.
842: !
843: !  Licensing:
844: !
845: !    This code is distributed under the GNU LGPL license.
846: !
847: !  Modified:
848: !
849: !    18 October 2009
850: !
851: !  Author:
852: !
853: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
854: !    Klema, Moler.
855: !    FORTRAN90 version by John Burkardt.
856: !
857: !  Reference:
858: !
859: !    James Wilkinson, Christian Reinsch,
860: !    Handbook for Automatic Computation,
861: !    Volume II, Linear Algebra, Part 2,
862: !    Springer, 1971,
863: !    ISBN: 0387054146,
864: !    LC: QA251.W67.
865: !
866: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
867: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
868: !    Matrix Eigensystem Routines, EISPACK Guide,
869: !    Lecture Notes in Computer Science, Volume 6,
870: !    Springer Verlag, 1976,
871: !    ISBN13: 978-3540075462,
872: !    LC: QA193.M37.
873: !
874: !  Parameters:
875: !
876: !    Input, integer ( kind = 4 ) N, the order of the matrix.
877: !
878: !    Input, integer ( kind = 4 ) MBW, the number of columns of the array A used 
879: !    to store the band matrix.  If the matrix is symmetric, MBW is its (half)
880: !    band width, denoted MB and defined as the number of adjacent
881: !    diagonals, including the principal diagonal, required to
882: !    specify the non-zero portion of the lower triangle of the
883: !    matrix.  If the subroutine is being used to solve systems
884: !    of linear equations and the coefficient matrix is not
885: !    symmetric, it must however have the same number of adjacent
886: !    diagonals above the main diagonal as below, and in this
887: !    case, MBW=2*MB-1.
888: !
889: !    Input, real ( kind = 8 ) A(N,MBW), the lower triangle of the symmetric band input
890: !    atrix stored as an N by MB array.  Its lowest subdiagonal is stored 
891: !    in the last N+1-MB positions of the first column, its next subdiagonal 
892: !    in the last N+2-MB positions of the second column, further subdiagonals 
893: !    similarly, and finally its principal diagonal in the N positions of 
894: !    column MB.  If the subroutine is being used to solve systems of linear
895: !    equations, and the coefficient matrix is not symmetric, A is
896: !    N by 2*MB-1 instead, with lower triangle as above and with its first 
897: !    superdiagonal stored in the first N-1 positions of column MB+1, its 
898: !    second superdiagonal in the first N-2 positions of column MB+2, further
899: !    superdiagonals similarly, and finally its highest superdiagonal in 
900: !    the first N+1-MB positions of the last column.  Contents of storages 
901: !    not part of the matrix are arbitrary.
902: !
903: !    Input, real ( kind = 8 ) E21, specifies the ordering of the eigenvalues and contains
904: !    0.0D+00 if the eigenvalues are in ascending order, or 2.0D+00 if the 
905: !    eigenvalues are in descending order.  If the subroutine is being used 
906: !    to solve systems of linear equations, E21 should be set to 1.0D+00 
907: !    if the coefficient matrix is symmetric and to -1.0D+00 if not.
908: !
909: !    Input, integer ( kind = 4 ) M, the number of specified eigenvalues or the number of
910: !    systems of linear equations.
911: !
912: !    Input, real ( kind = 8 ) W(M), contains the M eigenvalues in ascending or descending 
913: !    order.  If the subroutine is being used to solve systems of linear
914: !    equations (A-W(1:M)*I) * X(1:M) = B(1:M), where I is the identity matrix, 
915: !    W should be set accordingly.
916: !
917: !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the constant matrix 
918: !    columns B(1:M), if the subroutine is used to solve systems of linear 
919: !    equations.  On output, the associated set of orthogonal eigenvectors.
920: !    Any vector which fails to converge is set to zero.  If the
921: !    routine is used to solve systems of linear equations,
922: !    Z contains the solution matrix columns X(1:M).
923: !
924: !    Output, integer ( kind = 4 ) IERR, error flag.
925: !    0, for normal return,
926: !    -R, if the eigenvector corresponding to the R-th eigenvalue fails to
927: !    converge, or if the R-th system of linear equations is nearly singular.
928: !
929:   implicit none
930: 
931:   integer ( kind = 4 ) mbw
932:   integer ( kind = 4 ) n
933: 
934:   real    ( kind = 8 ) a(n,mbw)
935:   real    ( kind = 8 ) e21
936:   real    ( kind = 8 ) eps2
937:   real    ( kind = 8 ) eps3
938:   real    ( kind = 8 ) eps4
939:   integer ( kind = 4 ) group
940:   integer ( kind = 4 ) i
941:   integer ( kind = 4 ) ierr
942:   integer ( kind = 4 ) ii
943:   integer ( kind = 4 ) ij
944:   integer ( kind = 4 ) ij1
945:   integer ( kind = 4 ) its
946:   integer ( kind = 4 ) j
947:   integer ( kind = 4 ) jj
948:   integer ( kind = 4 ) k
949:   integer ( kind = 4 ) kj
950:   integer ( kind = 4 ) kj1
951:   integer ( kind = 4 ) m
952:   integer ( kind = 4 ) m1
953:   integer ( kind = 4 ) m21
954:   integer ( kind = 4 ) maxj
955:   integer ( kind = 4 ) maxk
956:   integer ( kind = 4 ) mb
957:   real    ( kind = 8 ) norm
958:   real    ( kind = 8 ) order
959:   real    ( kind = 8 ) pythag
960:   integer ( kind = 4 ) r
961:   real    ( kind = 8 ) rv(n*(2*mbw-1))
962:   real    ( kind = 8 ) rv6(n)
963:   real    ( kind = 8 ) u
964:   real    ( kind = 8 ) uk
965:   real    ( kind = 8 ) v
966:   real    ( kind = 8 ) w(m)
967:   real    ( kind = 8 ) x0
968:   real    ( kind = 8 ) x1
969:   real    ( kind = 8 ) xu
970:   real    ( kind = 8 ) z(n,m)
971: 
972:   ierr = 0
973: 
974:   if ( m == 0 ) then
975:     return
976:   end if
977: 
978:   x0 = 0.0D+00
979: 
980:   if ( e21 < 0.0D+00 ) then
981:     mb = ( mbw + 1 ) / 2
982:   else
983:     mb = mbw
984:   end if
985: 
986:   m1 = mb - 1
987:   m21 = m1 + mb
988:   order = 1.0D+00 - abs ( e21 )
989: !
990: !  Find vectors by inverse iteration.
991: !
992:   do r = 1, m
993: 
994:      its = 1
995:      x1 = w(r)
996:      if ( r /= 1 ) go to 100
997: !
998: !  Compute norm of matrix.
999: !
1000:      norm = 0.0D+00
1001: 
1002:      do j = 1, mb
1003: 
1004:         jj = mb + 1 - j
1005:         kj = jj + m1
1006:         ij = 1
1007:         v = 0.0D+00
1008: 
1009:         do i = jj, n
1010: 
1011:           v = v + abs ( a(i,j) )
1012: 
1013:           if ( e21 < 0.0D+00 ) then
1014:             v = v + abs ( a(ij,kj) )
1015:             ij = ij + 1
1016:           end if
1017: 
1018:         end do
1019: 
1020:         norm = max ( norm, v )
1021: 
1022:      end do
1023: 
1024:      if ( e21 < 0.0D+00 ) then
1025:        norm = 0.5D+00 * norm
1026:      end if
1027: !
1028: !  EPS2 is the criterion for grouping,
1029: !  EPS3 replaces zero pivots and equal roots are modified by eps3,
1030: !  EPS4 is taken very small to avoid overflow.
1031: !
1032:      if ( norm == 0.0D+00 ) then
1033:        norm = 1.0D+00
1034:      end if
1035: 
1036:      eps2 = 0.001D+00 * norm * abs ( order)
1037:      eps3 = abs ( norm ) * epsilon ( norm )
1038:      uk = n
1039:      uk = sqrt ( uk )
1040:      eps4 = uk * eps3
1041: 
1042: 80   continue
1043: 
1044:      group = 0
1045:      go to 120
1046: !
1047: !  Look for close or coincident roots.
1048: !
1049: 100  continue
1050: 
1051:      if ( eps2 <= abs ( x1 - x0 ) ) then
1052:        go to 80
1053:      end if
1054: 
1055:      group = group + 1
1056: 
1057:      if ( order * ( x1 - x0 ) <= 0.0D+00 ) then
1058:        x1 = x0 + order * eps3
1059:      end if
1060: !
1061: !  Expand matrix, subtract eigenvalue, and initialize vector.
1062: !
1063: 120  continue
1064: 
1065:      do i = 1, n
1066: 
1067:         ij = i + min ( 0, i-m1 ) * n
1068:         kj = ij + mb * n
1069:         ij1 = kj + m1 * n
1070: 
1071:         if ( m1 == 0 ) go to 180
1072: 
1073:         do j = 1, m1
1074: 
1075:           if ( ij <= m1 ) then
1076:             if ( ij <= 0 ) then
1077:               rv(ij1) = 0.0D+00
1078:               ij1 = ij1 + n
1079:             end if
1080:           else
1081:             rv(ij) = a(i,j)
1082:           end if
1083: 
1084:           ij = ij + n
1085:           ii = i + j
1086: 
1087:           if ( ii <= n ) then
1088: 
1089:             jj = mb - j
1090: 
1091:             if ( e21 < 0.0D+00 ) then
1092:               ii = i
1093:               jj = mb + j
1094:             end if
1095: 
1096:             rv(kj) = a(ii,jj)
1097:             kj = kj + n
1098: 
1099:           end if
1100: 
1101:         end do
1102: 
1103:   180   continue
1104: 
1105:         rv(ij) = a(i,mb) - x1
1106:         rv6(i) = eps4
1107:         if ( order == 0.0D+00 ) then
1108:           rv6(i) = z(i,r)
1109:         end if
1110: 
1111:      end do
1112: 
1113:      if ( m1 /= 0 ) then
1114: !
1115: !  Elimination with interchanges.
1116: !
1117:      do i = 1, n
1118: 
1119:         ii = i + 1
1120:         maxk = min ( i+m1-1, n )
1121:         maxj = min ( n-i, m21-2 ) * n
1122: 
1123:         do k = i, maxk
1124: 
1125:            kj1 = k
1126:            j = kj1 + n
1127:            jj = j + maxj
1128: 
1129:            do kj = j, jj, n
1130:              rv(kj1) = rv(kj)
1131:              kj1 = kj
1132:            end do
1133: 
1134:            rv(kj1) = 0.0D+00
1135: 
1136:         end do
1137: 
1138:         if ( i /= n ) then
1139: 
1140:         u = 0.0D+00
1141:         maxk = min ( i+m1, n )
1142:         maxj = min ( n-ii, m21-2 ) * n
1143: 
1144:         do j = i, maxk
1145:           if ( abs ( u ) <= abs ( rv(j) ) ) then
1146:             u = rv(j)
1147:             k = j
1148:           end if
1149:         end do
1150: 
1151:         j = i + n
1152:         jj = j + maxj
1153: 
1154:         if ( k /= i ) then
1155: 
1156:           kj = k
1157: 
1158:           do ij = i, jj, n
1159:             call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( rv(ij), rv(kj) )
1160:             kj = kj + n
1161:           end do
1162: 
1163:           if ( order == 0.0D+00 ) then
1164:             call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( rv6(i), rv6(k) )
1165:           end if
1166: 
1167:         end if
1168: 
1169:         if ( u /= 0.0D+00 ) then
1170: 
1171:         do k = ii, maxk
1172: 
1173:            v = rv(k) / u
1174:            kj = k
1175: 
1176:            do ij = j, jj, n
1177:              kj = kj + n
1178:              rv(kj) = rv(kj) - v * rv(ij)
1179:            end do
1180: 
1181:            if ( order == 0.0D+00 ) then
1182:              rv6(k) = rv6(k) - v * rv6(i)
1183:            end if
1184: 
1185:         end do
1186: 
1187:        end if
1188: 
1189:       end if
1190: 
1191:       end do
1192: 
1193:      end if
1194: !
1195: !  Back substitution.
1196: !
1197: 600  continue
1198: 
1199:      do ii = 1, n
1200: 
1201:         i = n + 1 - ii
1202:         maxj = min ( ii, m21 )
1203: 
1204:         if ( maxj /= 1 ) then
1205: 
1206:           ij1 = i
1207:           j = ij1 + n
1208:           jj = j + (maxj - 2) * n
1209: 
1210:           do ij = j, jj, n
1211:             ij1 = ij1 + 1
1212:             rv6(i) = rv6(i) - rv(ij) * rv6(ij1)
1213:           end do
1214: 
1215:         end if
1216: 
1217:         v = rv(i)
1218: !
1219: !  Error: nearly singular linear system.
1220: !
1221:         if ( abs ( v ) < eps3) then
1222:           if ( order == 0.0D+00 ) then
1223:             ierr = -r
1224:           end if
1225:           v = sign ( eps3, v )
1226:         end if
1227: 
1228:         rv6(i) = rv6(i) / v
1229: 
1230:      end do
1231: 
1232:      xu = 1.0D+00
1233: 
1234:      if ( order == 0.0D+00 ) go to 870
1235: !
1236: !  Orthogonalize with respect to previous members of group.
1237: !
1238:      do jj = 1, group
1239: 
1240:         j = r - group - 1 + jj
1241: 
1242:         xu = dot_product ( rv6(1:n), z(1:n,j) )
1243: 
1244:         rv6(1:n) = rv6(1:n) - xu * z(1:n,j)
1245: 
1246:      end do
1247: 
1248:      norm = sum ( abs ( rv6(1:n) ) )
1249: !
1250: !  Choose a new starting vector.
1251: !
1252:      if ( norm < 0.1D+00 ) then
1253: 
1254:        if ( its < n ) then
1255:          its = its + 1
1256:          xu = eps4 / ( uk + 1.0D+00 )
1257:          rv6(1) = eps4
1258:          rv6(2:n) = xu
1259:          rv6(its) = rv6(its) - eps4 * uk
1260:          go to 600
1261:        else
1262:          ierr = -r
1263:          xu = 0.0D+00
1264:          go to 870
1265:        end if
1266: 
1267:      end if
1268: !
1269: !   Normalize so that sum of squares is 1 and expand to full order.
1270: !
1271:      u = 0.0D+00
1272:      do i = 1, n
1273:        u = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( u, rv6(i) )
1274:      end do
1275: 
1276:      xu = 1.0D+00 / u
1277: 
1278:  870 continue
1279: 
1280:      z(1:n,r) = rv6(1:n) * xu
1281: 
1282:      x0 = x1
1283: 
1284:   end do
1285: 
1286:   return
1287: end
<p><a name=bisect><H3>bisect</H3></a></p> Click <a href="./callingtree/bisect_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where bisect is used.
<hr>
1288: subroutine bisect ( n, eps1, d, e, e2, lb, ub, mm, m, w, ind, ierr )
1289: 
1290: !*****************************************************************************80
1291: !
1292: !! BISECT computes some eigenvalues of a real symmetric tridiagonal matrix.
1293: !
1294: !  Discussion:
1295: !
1296: !    This subroutine finds those eigenvalues of a real symmetric
1297: !    tridiagonal matrix which lie in a specified interval, using bisection.
1298: !
1299: !  Licensing:
1300: !
1301: !    This code is distributed under the GNU LGPL license.
1302: !
1303: !  Modified:
1304: !
1305: !    18 October 2009
1306: !
1307: !  Author:
1308: !
1309: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
1310: !    Klema, Moler.
1311: !    FORTRAN90 version by John Burkardt.
1312: !
1313: !  Reference:
1314: !
1315: !    James Wilkinson, Christian Reinsch,
1316: !    Handbook for Automatic Computation,
1317: !    Volume II, Linear Algebra, Part 2,
1318: !    Springer, 1971,
1319: !    ISBN: 0387054146,
1320: !    LC: QA251.W67.
1321: !
1322: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
1323: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
1324: !    Matrix Eigensystem Routines, EISPACK Guide,
1325: !    Lecture Notes in Computer Science, Volume 6,
1326: !    Springer Verlag, 1976,
1327: !    ISBN13: 978-3540075462,
1328: !    LC: QA193.M37.
1329: !
1330: !  Parameters:
1331: !
1332: !    Input, integer ( kind = 4 ) N, the order of the matrix.
1333: !
1334: !    Input/output, real ( kind = 8 ) EPS1, is an absolute error tolerance for the computed
1335: !    eigenvalues.  If the input EPS1 is non-positive, it is reset for each 
1336: !    submatrix to a default value, namely, minus the product of the relative 
1337: !    machine precision and the 1-norm of the submatrix.
1338: !
1339: !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix.
1340: !
1341: !    Input, real ( kind = 8 ) E(N), contains in E(2:N) the subdiagonal elements of the
1342: !    matrix.  E(1) is arbitrary.
1343: !
1344: !    Input/output, real ( kind = 8 ) E2(N).  On input, the squares of the corresponding 
1345: !    elements of E.  E2(1) is arbitrary.  On output, elements of E2, 
1346: !    corresponding to elements of E regarded as negligible, have been 
1347: !    replaced by zero, causing the matrix to split into a direct sum of 
1348: !    submatrices.  E2(1) is also set to zero.
1349: !
1350: !    Input, real ( kind = 8 ) LB, UB, define the interval to be searched for eigenvalues.
1351: !    If LB is not less than UB, no eigenvalues will be found.
1352: !
1353: !    Input, integer ( kind = 4 ) MM, an upper bound for the number of eigenvalues in the 
1354: !    interval.  Warning: if more than MM eigenvalues are determined to lie 
1355: !    in the interval, an error return is made with no eigenvalues found.
1356: !
1357: !    Output, integer ( kind = 4 ) M, the number of eigenvalues determined to lie 
1358: !    in (LB,UB).
1359: !
1360: !    Output, real ( kind = 8 ) W(M), the eigenvalues in ascending order.
1361: !
1362: !    Output, integer ( kind = 4 ) IND(MM), contains in its first M positions the submatrix 
1363: !    indices associated with the corresponding eigenvalues in W:
1364: !    1 for eigenvalues belonging to the first submatrix from the top, 2 for 
1365: !    those belonging to the second submatrix, and so on.
1366: !
1367: !    Output, integer ( kind = 4 ) IERR, error flag.
1368: !    0, for normal return,
1369: !    3*N+1, if M exceeds MM.
1370: !
1371:   implicit none
1372: 
1373:   integer ( kind = 4 ) mm
1374:   integer ( kind = 4 ) n
1375: 
1376:   real    ( kind = 8 ) d(n)
1377:   real    ( kind = 8 ) e(n)
1378:   real    ( kind = 8 ) e2(n)
1379:   real    ( kind = 8 ) eps1
1380:   integer ( kind = 4 ) i
1381:   integer ( kind = 4 ) ierr
1382:   integer ( kind = 4 ) ii
1383:   integer ( kind = 4 ) ind(mm)
1384:   integer ( kind = 4 ) isturm
1385:   integer ( kind = 4 ) j
1386:   integer ( kind = 4 ) k
1387:   integer ( kind = 4 ) l
1388:   real    ( kind = 8 ) lb
1389:   integer ( kind = 4 ) m
1390:   integer ( kind = 4 ) m1
1391:   integer ( kind = 4 ) m2
1392:   integer ( kind = 4 ) p
1393:   integer ( kind = 4 ) q
1394:   integer ( kind = 4 ) r
1395:   real    ( kind = 8 ) rv4(n)
1396:   real    ( kind = 8 ) rv5(n)
1397:   integer ( kind = 4 ) s
1398:   real    ( kind = 8 ) t1
1399:   real    ( kind = 8 ) t2
1400:   integer ( kind = 4 ) tag
1401:   real    ( kind = 8 ) tst1
1402:   real    ( kind = 8 ) tst2
1403:   real    ( kind = 8 ) u
1404:   real    ( kind = 8 ) ub
1405:   real    ( kind = 8 ) v
1406:   real    ( kind = 8 ) w(mm)
1407:   real    ( kind = 8 ) x0
1408:   real    ( kind = 8 ) x1
1409:   real    ( kind = 8 ) xu
1410: 
1411:   ierr = 0
1412:   s = 0
1413:   tag = 0
1414:   t1 = lb
1415:   t2 = ub
1416: !
1417: !  Look for small sub-diagonal entries.
1418: !
1419:   e2(1) = 0.0D+00
1420: 
1421:   do i = 2, n
1422:     
1423:     tst1 = abs ( d(i) ) + abs ( d(i-1) )
1424:     tst2 = tst1 + abs ( e(i) )
1425: 
1426:     if ( tst2 <= tst1 ) then
1427:       e2(i) = 0.0D+00
1428:     end if
1429: 
1430:   end do
1431: !
1432: !  Determine the number of eigenvalues in the interval.
1433: !
1434:   p = 1
1435:   q = n
1436:   x1 = ub
1437:   isturm = 1
1438:   go to 320
1439: 
1440: 60 continue
1441: 
1442:   m = s
1443:   x1 = lb
1444:   isturm = 2
1445:   go to 320
1446: 
1447: 80 continue
1448: 
1449:   m = m - s
1450: 
1451:   if ( mm < m ) then
1452:     go to 980
1453:   end if
1454: 
1455:   q = 0
1456:   r = 0
1457: !
1458: !  Establish and process next submatrix, refining
1459: !  interval by the Gerschgorin bounds.
1460: !
1461: 100 continue
1462: 
1463:   if ( r == m ) go to 1001
1464: 
1465:   tag = tag + 1
1466:   p = q + 1
1467:   xu = d(p)
1468:   x0 = d(p)
1469:   u = 0.0D+00
1470: 
1471:   do q = p, n
1472: 
1473:     x1 = u
1474:     u = 0.0D+00
1475:     v = 0.0D+00
1476: 
1477:     if ( q /= n ) then
1478:       u = abs ( e(q+1) )
1479:       v = e2(q+1)
1480:     end if
1481: 
1482:     xu = min ( d(q) - ( x1 + u ), xu )
1483:     x0 = max ( d(q) + ( x1 + u ), x0 )
1484: 
1485:     if ( v == 0.0D+00 ) then
1486:       exit
1487:     end if
1488: 
1489:   end do
1490: 
1491:   x1 = max ( abs ( xu ), abs ( x0 ) ) * epsilon ( x1 )
1492:   if ( eps1 <= 0.0D+00 ) then
1493:     eps1 = -x1
1494:   end if
1495: 
1496:   if ( p /= q ) go to 180
1497: !
1498: !  Check for an isolated root within interval.
1499: !
1500:   if ( d(p) < t1 .or. t2 <= d(p) ) then
1501:     go to 940
1502:   end if
1503: 
1504:   m1 = p
1505:   m2 = p
1506:   rv5(p) = d(p)
1507:   go to 900
1508: 
1509:   180 continue
1510: 
1511:   x1 = x1 * ( q - p + 1 )
1512:   lb = max ( t1, xu - x1 )
1513:   ub = min ( t2, x0 + x1 )
1514:   x1 = lb
1515:   isturm = 3
1516:   go to 320
1517: 
1518:   200 continue
1519: 
1520:   m1 = s + 1
1521:   x1 = ub
1522:   isturm = 4
1523:   go to 320
1524: 
1525:   220 continue
1526: 
1527:   m2 = s
1528:   if ( m2 < m1 ) then
1529:     go to 940
1530:   end if
1531: !
1532: !  Find roots by bisection.
1533: !
1534:   x0 = ub
1535:   isturm = 5
1536:   rv5(m1:m2) = ub
1537:   rv4(m1:m2) = lb
1538: !
1539: !  Loop for the K-th eigenvalue.
1540: !
1541:   k = m2
1542: 
1543: 250 continue
1544: 
1545:      xu = lb
1546: 
1547:      do ii = m1, k
1548:        i = m1 + k - ii
1549:        if ( xu < rv4(i) ) then
1550:          xu = rv4(i)
1551:          go to 280
1552:        end if
1553:      end do
1554: 
1555:   280 continue
1556: 
1557:    x0 = min ( x0, rv5(k) )
1558: !
1559: !  Next bisection step.
1560: !
1561:   300    continue
1562: 
1563:      x1 = ( xu + x0 ) * 0.5D+00
1564: 
1565:      if ( (x0 - xu) <= abs ( eps1 ) ) go to 420
1566: 
1567:      tst1 = 2.0D+00 * ( abs ( xu ) + abs ( x0 ) )
1568:      tst2 = tst1 + ( x0 - xu )
1569:      if ( tst2 == tst1 ) go to 420
1570: !
1571: !  Sturm sequence.
1572: !
1573: 320  continue
1574: 
1575:      s = p - 1
1576:      u = 1.0D+00
1577: 
1578:      do i = p, q
1579: 
1580:         if ( u == 0.0D+00 ) then
1581:           v = abs ( e(i) ) / epsilon ( v )
1582:           if ( e2(i) == 0.0D+00 ) v = 0.0D+00
1583:         else
1584:           v = e2(i) / u
1585:         end if
1586: 
1587:         u = d(i) - x1 - v
1588:         if ( u < 0.0D+00 ) then
1589:           s = s + 1
1590:         end if
1591: 
1592:      end do
1593: 
1594:      go to (60,80,200,220,360), isturm
1595: !
1596: !  Refine intervals.
1597: !
1598:   360 continue
1599: 
1600:      if ( k <= s ) then
1601:        go to 400
1602:      end if
1603: 
1604:      xu = x1
1605: 
1606:      if ( s < m1 ) then
1607:        rv4(m1) = x1
1608:        go to 300
1609:      end if
1610: 
1611:      rv4(s+1) = x1
1612: 
1613:      if ( x1 < rv5(s) ) then
1614:        rv5(s) = x1
1615:      end if
1616: 
1617:      go to 300
1618: 400  continue
1619:      x0 = x1
1620:      go to 300
1621: !
1622: !  K-th eigenvalue found.
1623: !
1624: 420 continue
1625: 
1626:   rv5(k) = x1
1627:   k = k - 1
1628:   if ( k >= m1 ) go to 250
1629: !
1630: !  Order eigenvalues tagged with their submatrix associations.
1631: !
1632: 900 continue
1633: 
1634:   s = r
1635:   r = r + m2 - m1 + 1
1636:   j = 1
1637:   k = m1
1638: 
1639:   do l = 1, r
1640: 
1641:     if ( j <= s ) then
1642: 
1643:       if ( k > m2 ) then
1644:         exit
1645:       end if
1646: 
1647:       if ( rv5(k) >= w(l) ) then
1648:         j = j + 1
1649:         cycle
1650:       end if
1651: 
1652:       do ii = j, s
1653:         i = l + s - ii
1654:         w(i+1) = w(i)
1655:         ind(i+1) = ind(i)
1656:       end do
1657: 
1658:     end if
1659: 
1660:     w(l) = rv5(k)
1661:     ind(l) = tag
1662:     k = k + 1
1663: 
1664:   end do
1665: 
1666: 940 continue
1667: 
1668:   if ( q < n ) then
1669:     go to 100
1670:   end if
1671: 
1672:   go to 1001
1673: !
1674: !  Set error: underestimate of number of eigenvalues in interval.
1675: !
1676: 980 continue
1677: 
1678:   ierr = 3 * n + 1
1679: 
1680:  1001 continue
1681: 
1682:   lb = t1
1683:   ub = t2
1684: 
1685:   return
1686: end
<p><a name=bqr><H3>bqr</H3></a></p> Click <a href="./callingtree/bqr_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where bqr is used.
<hr>
1687: subroutine bqr ( n, mb, a, t, r, ierr )
1688: 
1689: !*****************************************************************************80
1690: !
1691: !! BQR finds the smallest eigenvalue of a real symmetric band matrix.
1692: !
1693: !  Discussion:
1694: !
1695: !    This subroutine finds the eigenvalue of smallest magnitude of a real 
1696: !    symmetric band matrix using the QR algorithm with shifts of origin.  
1697: !    Consecutive calls can be made to find further eigenvalues.
1698: !
1699: !    Note that for a subsequent call, N should be replaced by N-1, but
1700: !    MB should not be altered even when it exceeds the current N.
1701: !
1702: !  Licensing:
1703: !
1704: !    This code is distributed under the GNU LGPL license.
1705: !
1706: !  Modified:
1707: !
1708: !    18 October 2009
1709: !
1710: !  Author:
1711: !
1712: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
1713: !    Klema, Moler.
1714: !    FORTRAN90 version by John Burkardt.
1715: !
1716: !  Reference:
1717: !
1718: !    James Wilkinson, Christian Reinsch,
1719: !    Handbook for Automatic Computation,
1720: !    Volume II, Linear Algebra, Part 2,
1721: !    Springer, 1971,
1722: !    ISBN: 0387054146,
1723: !    LC: QA251.W67.
1724: !
1725: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
1726: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
1727: !    Matrix Eigensystem Routines, EISPACK Guide,
1728: !    Lecture Notes in Computer Science, Volume 6,
1729: !    Springer Verlag, 1976,
1730: !    ISBN13: 978-3540075462,
1731: !    LC: QA193.M37.
1732: !
1733: !  Parameters:
1734: !
1735: !    Input, integer ( kind = 4 ) N, the order of the matrix.
1736: !
1737: !    Input, integer ( kind = 4 ) MB, the (half) band width of the matrix, defined as the
1738: !    number of adjacent diagonals, including the principal
1739: !    diagonal, required to specify the non-zero portion of the
1740: !    lower triangle of the matrix.
1741: !
1742: !    Input/output, real ( kind = 8 ) A(N,MB).  On input, A contains the lower triangle 
1743: !    of the symmetric band input matrix stored as an N by MB array.  Its 
1744: !    lowest subdiagonal is stored in the last N+1-MB positions of the first 
1745: !    column, its next subdiagonal in the last N+2-MB positions of the
1746: !    second column, further subdiagonals similarly, and finally its principal 
1747: !    diagonal in the N positions of the last column.  Contents of storages 
1748: !    not part of the matrix are arbitrary.  On a subsequent call, its output
1749: !    contents from the previous call should be passed.  On output, A contains 
1750: !    the transformed band matrix.  The matrix A+T*I derived from the output 
1751: !    parameters is similar to the input A+T*I to within rounding errors.  
1752: !    Its last row and column are null as long as IERR is zero.
1753: !
1754: !    Input/output, real ( kind = 8 ) T.  On input, T specifies the shift (of eigenvalues) 
1755: !    applied to the diagonal of A in forming the input matrix.  What is 
1756: !    actually determined is the eigenvalue nearest to T of A+T*I, where I 
1757: !    is the identity matrix.  On a subsequent call, the output value of T 
1758: !    from the previous call should be passed if the next nearest eigenvalue
1759: !    is sought.  On output, T contains the computed eigenvalue of A+T*I,
1760: !    as long as IERR is zero.
1761: !
1762: !    Input/output, real ( kind = 8 ) R.  On input for the first call, R should be 
1763: !    specified as zero, and as its output value from the previous call 
1764: !    on a subsequent call.  It is used to determine when the last row and 
1765: !    column of the transformed band matrix can be regarded as negligible.
1766: !    On output, R contains the maximum of its input value and the norm of the
1767: !    last column of the input matrix A.
1768: !
1769: !    Output, integer ( kind = 4 ) IERR, error flag.
1770: !    0, normal return.
1771: !    N, if the eigenvalue has not been determined after 30 iterations.
1772: !
1773:   implicit none
1774: 
1775:   integer ( kind = 4 ) mb
1776:   integer ( kind = 4 ) n
1777: 
1778:   real    ( kind = 8 ) a(n,mb)
1779:   real    ( kind = 8 ) f
1780:   real    ( kind = 8 ) g
1781:   integer ( kind = 4 ) i
1782:   integer ( kind = 4 ) ierr
1783:   integer ( kind = 4 ) ii
1784:   integer ( kind = 4 ) ik
1785:   integer ( kind = 4 ) imult
1786:   integer ( kind = 4 ) its
1787:   integer ( kind = 4 ) j
1788:   integer ( kind = 4 ) jk
1789:   integer ( kind = 4 ) jm
1790:   integer ( kind = 4 ) k
1791:   integer ( kind = 4 ) kj
1792:   integer ( kind = 4 ) kj1
1793:   integer ( kind = 4 ) kk
1794:   integer ( kind = 4 ) km
1795:   integer ( kind = 4 ) l
1796:   integer ( kind = 4 ) ll
1797:   integer ( kind = 4 ) m
1798:   integer ( kind = 4 ) m1
1799:   integer ( kind = 4 ) m2
1800:   integer ( kind = 4 ) m21
1801:   integer ( kind = 4 ) m3
1802:   integer ( kind = 4 ) m31
1803:   integer ( kind = 4 ) m4
1804:   integer ( kind = 4 ) mk
1805:   integer ( kind = 4 ) mn
1806:   integer ( kind = 4 ) mz
1807:   integer ( kind = 4 ) ni
1808:   real    ( kind = 8 ) pythag
1809:   real    ( kind = 8 ) q
1810:   real    ( kind = 8 ) r
1811:   real    ( kind = 8 ) rv(2*mb*mb+4*mb-3)
1812:   real    ( kind = 8 ) s
1813:   real    ( kind = 8 ) xscale
1814:   real    ( kind = 8 ) t
1815:   real    ( kind = 8 ) tst1
1816:   real    ( kind = 8 ) tst2
1817: 
1818:   ierr = 0
1819:   m1 = min ( mb, n )
1820:   m = m1 - 1
1821:   m2 = m + m
1822:   m21 = m2 + 1
1823:   m3 = m21 + m
1824:   m31 = m3 + 1
1825:   m4 = m31 + m2
1826:   mn = m + n
1827:   mz = mb - m1
1828:   its = 0
1829: !
1830: !  Test for convergence.
1831: !
1832: 40 continue
1833: 
1834:   g = a(n,mb)
1835: 
1836:   if ( m == 0 ) go to 360
1837: 
1838:   f = 0.0D+00
1839:   do k = 1, m
1840:     mk = k + mz
1841:     f = f + abs ( a(n,mk) )
1842:   end do
1843: 
1844:   if ( its == 0 .and. r < f ) then
1845:     r = f
1846:   end if
1847: 
1848:   tst1 = r
1849:   tst2 = tst1 + f
1850: 
1851:   if ( tst2 <= tst1 ) go to 360
1852: 
1853:   if ( 30 <= its ) then
1854:     ierr = n
1855:     return
1856:   end if
1857: 
1858:   its = its + 1
1859: !
1860: !  Form shift from bottom 2 by 2 minor.
1861: !
1862:   if ( f <= 0.25D+00 * r .or. its >= 5 ) then
1863: 
1864:     f = a(n,mb-1)
1865: 
1866:     if ( f /= 0.0D+00 ) then
1867:       q = ( a(n-1,mb) - g ) / ( 2.0D+00 * f )
1868:       s = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( q, 1.0D+00 )
1869:       g = g - f / ( q + sign ( s, q ) )
1870:     end if
1871: 
1872:     t = t + g
1873: 
1874:     a(1:n,mb) = a(1:n,mb) - g
1875: 
1876:   end if
1877: 
1878:   rv(m31:m4) = 0.0D+00
1879: 
1880:   do ii = 1, mn
1881: 
1882:      i = ii - m
1883:      ni = n - ii
1884: 
1885:      if ( ni < 0 ) go to 230
1886: !
1887: !  Form column of shifted matrix A-G*I.
1888: !
1889:      l = max ( 1, 2-i )
1890: 
1891:      rv(1:m3) = 0.0D+00
1892: 
1893:      do k = l, m1
1894:        km = k + m
1895:        mk = k + mz
1896:        rv(km) = a(ii,mk)
1897:      end do
1898: 
1899:      ll = min ( m, ni )
1900: 
1901:      do k = 1, ll
1902:        km = k + m21
1903:        ik = ii + k
1904:        mk = mb - k
1905:        rv(km) = a(ik,mk)
1906:      end do
1907: !
1908: !  Pre-multiply with Householder reflections.
1909: !
1910:      ll = m2
1911:      imult = 0
1912: !
1913: !  Multiplication procedure.
1914: !
1915: 140  continue
1916: 
1917:      kj = m4 - m1
1918: 
1919:      do j = 1, ll
1920: 
1921:         kj = kj + m1
1922:         jm = j + m3
1923: 
1924:         if ( rv(jm) /= 0.0D+00 ) then
1925: 
1926:           f = 0.0D+00
1927: 
1928:           do k = 1, m1
1929:             kj = kj + 1
1930:             jk = j + k - 1
1931:             f = f + rv(kj) * rv(jk)
1932:           end do
1933: 
1934:           f = f / rv(jm)
1935:           kj = kj - m1
1936: 
1937:           do k = 1, m1
1938:             kj = kj + 1
1939:             jk = j + k - 1
1940:             rv(jk) = rv(jk) - rv(kj) * f
1941:           end do
1942: 
1943:           kj = kj - m1
1944: 
1945:         end if
1946: 
1947:      end do
1948: 
1949:      if ( imult /= 0 ) go to 280
1950: !
1951: !  Householder reflection.
1952: !
1953:      f = rv(m21)
1954:      s = 0.0D+00
1955:      rv(m4) = 0.0D+00
1956:      xscale = sum ( abs ( rv(m21:m3) ) )
1957: 
1958:      if ( xscale == 0.0D+00 ) then
1959:        go to 210
1960:      end if
1961: 
1962:      do k = m21, m3
1963:        s = s + ( rv(k) / xscale )**2
1964:      end do
1965: 
1966:      s = xscale * xscale * s
1967:      g = - sign ( sqrt ( s ), f )
1968:      rv(m21) = g
1969:      rv(m4) = s - f * g
1970:      kj = m4 + m2 * m1 + 1
1971:      rv(kj) = f - g
1972: 
1973:      do k = 2, m1
1974:        kj = kj + 1
1975:        km = k + m2
1976:        rv(kj) = rv(km)
1977:      end do
1978: !
1979: !  Save column of triangular factor R.
1980: !
1981: 210  continue
1982: 
1983:      do k = l, m1
1984:        km = k + m
1985:        mk = k + mz
1986:        a(ii,mk) = rv(km)
1987:      end do
1988: 
1989: 230  continue
1990: 
1991:      l = max ( 1, m1+1-i )
1992:      if ( i <= 0 ) go to 300
1993: !
1994: !  Perform additional steps.
1995: !
1996:      rv(1:m21) = 0.0D+00
1997:      ll = min ( m1, ni+m1 )
1998: !
1999: !  Get row of triangular factor R.
2000: !
2001:      do kk = 1, ll
2002:        k = kk - 1
2003:        km = k + m1
2004:        ik = i + k
2005:        mk = mb - k
2006:        rv(km) = a(ik,mk)
2007:      end do
2008: !
2009: !  Post-multiply with Householder reflections.
2010: !
2011:      ll = m1
2012:      imult = 1
2013:      go to 140
2014: !
2015: !  Store column of new a matrix.
2016: !
2017: 280  continue
2018: 
2019:      do k = l, m1
2020:        mk = k + mz
2021:        a(i,mk) = rv(k)
2022:      end do
2023: !
2024: !  Update Householder reflections.
2025: !
2026: 300  continue
2027: 
2028:      if ( 1 < l ) then
2029:        l = l - 1
2030:      end if
2031: 
2032:      kj1 = m4 + l * m1
2033: 
2034:      do j = l, m2
2035: 
2036:        jm = j + m3
2037:        rv(jm) = rv(jm+1)
2038: 
2039:        do k = 1, m1
2040:          kj1 = kj1 + 1
2041:          kj = kj1 - m1
2042:          rv(kj) = rv(kj1)
2043:        end do
2044: 
2045:      end do
2046: 
2047:   end do
2048: 
2049:   go to 40
2050: !
2051: !  Convergence.
2052: !
2053: 360 continue
2054: 
2055:   t = t + g
2056:   a(1:n,mb) = a(1:n,mb) - g
2057: 
2058:   do k = 1, m1
2059:     mk = k + mz
2060:     a(n,mk) = 0.0D+00
2061:   end do
2062: 
2063:   return
2064: end
<p><a name=cbabk2><H3>cbabk2</H3></a></p> Click <a href="./callingtree/cbabk2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cbabk2 is used.
<hr>
2065: subroutine cbabk2 ( n, low, igh, xscale, m, zr, zi )
2066: 
2067: !*****************************************************************************80
2068: !
2069: !! CBABK2 finds eigenvectors by undoing the CBAL transformation.
2070: !
2071: !  Discussion:
2072: !
2073: !    This subroutine forms the eigenvectors of a complex general
2074: !    matrix by back transforming those of the corresponding
2075: !    balanced matrix determined by CBAL.
2076: !
2077: !  Licensing:
2078: !
2079: !    This code is distributed under the GNU LGPL license.
2080: !
2081: !  Modified:
2082: !
2083: !    18 October 2009
2084: !
2085: !  Author:
2086: !
2087: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
2088: !    Klema, Moler.
2089: !    FORTRAN90 version by John Burkardt.
2090: !
2091: !  Reference:
2092: !
2093: !    James Wilkinson, Christian Reinsch,
2094: !    Handbook for Automatic Computation,
2095: !    Volume II, Linear Algebra, Part 2,
2096: !    Springer, 1971,
2097: !    ISBN: 0387054146,
2098: !    LC: QA251.W67.
2099: !
2100: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
2101: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
2102: !    Matrix Eigensystem Routines, EISPACK Guide,
2103: !    Lecture Notes in Computer Science, Volume 6,
2104: !    Springer Verlag, 1976,
2105: !    ISBN13: 978-3540075462,
2106: !    LC: QA193.M37.
2107: !
2108: !  Parameters:
2109: !
2110: !    Input, integer ( kind = 4 ) N, the order of the matrix.
2111: !
2112: !    Input, integer ( kind = 4 ) LOW, IGH, values determined by CBAL.
2113: !
2114: !    Input, real ( kind = 8 ) SCALE(N), information determining the permutations
2115: !    and scaling factors used by CBAL.
2116: !
2117: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed.
2118: !
2119: !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, the real and imaginary 
2120: !    parts, respectively, of the eigenvectors to be back transformed in 
2121: !    their first M columns.  On output, the transformed eigenvectors.
2122: !
2123:   implicit none
2124: 
2125:   integer ( kind = 4 ) m
2126:   integer ( kind = 4 ) n
2127: 
2128:   integer ( kind = 4 ) i
2129:   integer ( kind = 4 ) igh
2130:   integer ( kind = 4 ) ii
2131:   integer ( kind = 4 ) j
2132:   integer ( kind = 4 ) k
2133:   integer ( kind = 4 ) low
2134:   real    ( kind = 8 ) s
2135:   real    ( kind = 8 ) xscale(n)
2136:   real    ( kind = 8 ) zi(n,m)
2137:   real    ( kind = 8 ) zr(n,m)
2138: 
2139:   if ( m == 0 ) then
2140:     return
2141:   end if
2142: 
2143:   if ( igh /= low ) then
2144: 
2145:     do i = low, igh
2146: 
2147:       s = xscale(i)
2148: 
2149:       zr(i,1:m) = zr(i,1:m) * s
2150:       zi(i,1:m) = zi(i,1:m) * s
2151: 
2152:     end do
2153: 
2154:   end if
2155: 
2156:   do ii = 1, n
2157: 
2158:     i = ii
2159: 
2160:     if ( i < low .or. i > igh ) then
2161: 
2162:       if ( i < low ) then
2163:         i = low - ii
2164:       end if
2165: 
2166:       k = xscale(i)
2167: 
2168:       if ( k /= i ) then
2169: 
2170:         do j = 1, m
2171:           call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( zr(i,j), zr(k,j) )
2172:           call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( zi(i,j), zi(k,j) )
2173:         end do
2174: 
2175:       end if
2176: 
2177:     end if
2178: 
2179:   end do
2180: 
2181:   return
2182: end
<p><a name=cbal><H3>cbal</H3></a></p> Click <a href="./callingtree/cbal_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cbal is used.
<hr>
2183: subroutine cbal ( n, ar, ai, low, igh, xscale )
2184: 
2185: !*****************************************************************************80
2186: !
2187: !! CBAL balances a complex matrix before eigenvalue calculations.
2188: !
2189: !  Discussion:
2190: !
2191: !    This subroutine balances a complex matrix and isolates
2192: !    eigenvalues whenever possible.
2193: !
2194: !    Suppose that the principal submatrix in rows low through igh
2195: !    has been balanced, that P(J) denotes the index interchanged
2196: !    with J during the permutation step, and that the elements
2197: !    of the diagonal matrix used are denoted by D(I,J).  Then
2198: !      SCALE(J) = P(J),    for J = 1,...,LOW-1
2199: !               = D(J,J)       J = LOW,...,IGH
2200: !               = P(J)         J = IGH+1,...,N.
2201: !    The order in which the interchanges are made is N to IGH+1,
2202: !    then 1 to LOW-1.
2203: !
2204: !    Note that 1 is returned for IGH if IGH is zero formally.
2205: !
2206: !  Licensing:
2207: !
2208: !    This code is distributed under the GNU LGPL license.
2209: !
2210: !  Modified:
2211: !
2212: !    18 October 2009
2213: !
2214: !  Author:
2215: !
2216: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
2217: !    Klema, Moler.
2218: !    FORTRAN90 version by John Burkardt.
2219: !
2220: !  Reference:
2221: !
2222: !    James Wilkinson, Christian Reinsch,
2223: !    Handbook for Automatic Computation,
2224: !    Volume II, Linear Algebra, Part 2,
2225: !    Springer, 1971,
2226: !    ISBN: 0387054146,
2227: !    LC: QA251.W67.
2228: !
2229: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
2230: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
2231: !    Matrix Eigensystem Routines, EISPACK Guide,
2232: !    Lecture Notes in Computer Science, Volume 6,
2233: !    Springer Verlag, 1976,
2234: !    ISBN13: 978-3540075462,
2235: !    LC: QA193.M37.
2236: !
2237: !  Parameters:
2238: !
2239: !    Input, integer ( kind = 4 ) N, the order of the matrix.
2240: !
2241: !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and 
2242: !    imaginary parts of the complex matrix to be balanced.  On output,
2243: !    the real and imaginary parts of the balanced matrix.
2244: !
2245: !    Output, integer ( kind = 4 ) LOW, IGH, are values such that AR(I,J) and AI(I,J)
2246: !    are zero if I is greater than J and either J=1,...,LOW-1 or 
2247: !    I=IGH+1,...,N.
2248: !
2249: !    Output, real ( kind = 8 ) SCALE(N), information determining the
2250: !    permutations and scaling factors used.
2251: !
2252:   implicit none
2253: 
2254:   integer ( kind = 4 ) n
2255: 
2256:   real    ( kind = 8 ) ai(n,n)
2257:   real    ( kind = 8 ) ar(n,n)
2258:   real    ( kind = 8 ) b2
2259:   real    ( kind = 8 ) c
2260:   real    ( kind = 8 ) f
2261:   real    ( kind = 8 ) g
2262:   integer ( kind = 4 ) i
2263:   integer ( kind = 4 ) iexc
2264:   integer ( kind = 4 ) igh
2265:   integer ( kind = 4 ) j
2266:   integer ( kind = 4 ) jj
2267:   integer ( kind = 4 ) k
2268:   integer ( kind = 4 ) l
2269:   integer ( kind = 4 ) low
2270:   integer ( kind = 4 ) m
2271:   logical              noconv
2272:   real    ( kind = 8 ) r
2273:   real    ( kind = 8 ) rdx
2274:   real    ( kind = 8 ) s
2275:   real    ( kind = 8 ) xscale(n)
2276: 
2277:   rdx = 16.0D+00
2278: 
2279:   iexc = 0
2280:   j = 0
2281:   m = 0
2282: 
2283:   b2 = rdx * rdx
2284:   k = 1
2285:   l = n
2286:   go to 100
2287: 
2288: 20 continue
2289: 
2290:   xscale(m) = j
2291: 
2292:   if ( j /= m ) then
2293: 
2294:     do i = 1, l
2295:       call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( ar(i,j), ar(i,m) )
2296:       call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( ai(i,j), ai(i,m) )
2297:     end do
2298: 
2299:     do i = k, n
2300:       call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( ar(j,i), ar(m,i) )
2301:       call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( ai(j,i), ai(m,i) )
2302:     end do
2303: 
2304:   end if
2305: 
2306:   if ( iexc == 2 ) then
2307:     go to 130
2308:   end if
2309: !
2310: !  Search for rows isolating an eigenvalue and push them down.
2311: !
2312:   if ( l == 1 ) then
2313:     go to 280
2314:   end if
2315: 
2316:   l = l - 1
2317: 
2318: 100 continue
2319: 
2320:   do jj = 1, l
2321: 
2322:      j = l + 1 - jj
2323: 
2324:      do i = 1, l
2325:        if ( i /= j ) then
2326:          if ( ar(j,i) /= 0.0D+00 .or. ai(j,i) /= 0.0D+00 ) go to 120
2327:        end if
2328:      end do
2329: 
2330:      m = l
2331:      iexc = 1
2332:      go to 20
2333: 
2334: 120  continue
2335: 
2336:   end do
2337: 
2338:   go to 140
2339: !
2340: !  Search for columns isolating an eigenvalue and push them left.
2341: !
2342: 130 continue
2343: 
2344:   k = k + 1
2345: 
2346: 140 continue
2347: 
2348:    do j = k, l
2349: 
2350:      do i = k, l
2351:        if ( i /= j ) then
2352:          if ( ar(i,j) /= 0.0D+00 .or. ai(i,j) /= 0.0D+00 ) go to 170
2353:        end if
2354:      end do
2355: 
2356:      m = k
2357:      iexc = 2
2358:      go to 20
2359: 170  continue
2360: 
2361:   end do
2362: !
2363: !  Now balance the submatrix in rows k to l.
2364: !
2365:   xscale(k:l) = 1.0D+00
2366: !
2367: !  Iterative loop for norm reduction.
2368: !
2369: 190 continue
2370: 
2371:   noconv = .false.
2372: 
2373:   do i = k, l
2374: 
2375:     c = 0.0D+00
2376:     r = 0.0D+00
2377: 
2378:     do j = k, l
2379:       if ( j /= i ) then
2380:         c = c + abs ( ar(j,i) ) + abs ( ai(j,i) )
2381:         r = r + abs ( ar(i,j) ) + abs ( ai(i,j) )
2382:       end if
2383:     end do
2384: !
2385: !  Guard against zero C or R due to underflow.
2386: !
2387:      if ( c == 0.0D+00 .or. r == 0.0D+00 ) go to 270
2388: 
2389:      g = r / rdx
2390:      f = 1.0D+00
2391:      s = c + r
2392: 
2393:      do while ( c < g )
2394:        f = f * rdx
2395:        c = c * b2
2396:      end do
2397: 
2398:      g = r * rdx
2399: 
2400:      do while  ( c >= g )
2401:        f = f / rdx
2402:        c = c / b2
2403:      end do
2404: !
2405: !  Now balance.
2406: !
2407:      if ( ( c + r ) / f < 0.95D+00 * s ) then
2408: 
2409:        g = 1.0D+00 / f
2410:        xscale(i) = xscale(i) * f
2411:        noconv = .true.
2412: 
2413:        ar(i,k:n) = ar(i,k:n) * g
2414:        ai(i,k:n) = ai(i,k:n) * g
2415: 
2416:        ar(1:l,i) = ar(1:l,i) * f
2417:        ai(1:l,i) = ai(1:l,i) * f
2418: 
2419:      end if
2420: 
2421: 270  continue
2422: 
2423:   end do
2424: 
2425:   if ( noconv ) go to 190
2426: 
2427:   280 continue
2428: 
2429:   low = k
2430:   igh = l
2431: 
2432:   return
2433: end
<p><a name=cdiv><H3>cdiv</H3></a></p> Click <a href="./callingtree/cdiv_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cdiv is used.
<hr>
2434: subroutine cdiv ( ar, ai, br, bi, cr, ci )
2435: 
2436: !*****************************************************************************80
2437: !
2438: !! CDIV emulates complex division, using real arithmetic.
2439: !
2440: !  Discussion:
2441: !
2442: !    This routine performs complex division:
2443: !
2444: !      (CR,CI) = (AR,AI) / (BR,BI)
2445: !
2446: !  Licensing:
2447: !
2448: !    This code is distributed under the GNU LGPL license.
2449: !
2450: !  Modified:
2451: !
2452: !    18 October 2009
2453: !
2454: !  Author:
2455: !
2456: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
2457: !    Klema, Moler.
2458: !    FORTRAN90 version by John Burkardt.
2459: !
2460: !  Reference:
2461: !
2462: !    James Wilkinson, Christian Reinsch,
2463: !    Handbook for Automatic Computation,
2464: !    Volume II, Linear Algebra, Part 2,
2465: !    Springer, 1971,
2466: !    ISBN: 0387054146,
2467: !    LC: QA251.W67.
2468: !
2469: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
2470: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
2471: !    Matrix Eigensystem Routines, EISPACK Guide,
2472: !    Lecture Notes in Computer Science, Volume 6,
2473: !    Springer Verlag, 1976,
2474: !    ISBN13: 978-3540075462,
2475: !    LC: QA193.M37.
2476: !
2477: !  Parameters:
2478: !
2479: !    Input, real ( kind = 8 ) AR, AI, the real and imaginary parts of the numerator.
2480: !
2481: !    Input, real ( kind = 8 ) BR, BI, the real and imaginary parts of the denominator.
2482: !
2483: !    Output, real ( kind = 8 ) CR, CI, the real and imaginary parts of the result.
2484: !
2485:   implicit none
2486: 
2487:   real    ( kind = 8 ) ai
2488:   real    ( kind = 8 ) ais
2489:   real    ( kind = 8 ) ar
2490:   real    ( kind = 8 ) ars
2491:   real    ( kind = 8 ) bi
2492:   real    ( kind = 8 ) bis
2493:   real    ( kind = 8 ) br
2494:   real    ( kind = 8 ) brs
2495:   real    ( kind = 8 ) ci
2496:   real    ( kind = 8 ) cr
2497:   real    ( kind = 8 ) s
2498: 
2499:   s = abs ( br ) + abs ( bi )
2500: 
2501:   ars = ar / s
2502:   ais = ai / s
2503:   brs = br / s
2504:   bis = bi / s
2505: 
2506:   s = brs**2 + bis**2
2507:   cr = ( ars * brs + ais * bis ) / s
2508:   ci = ( ais * brs - ars * bis ) / s
2509: 
2510:   return
2511: end
<p><a name=cg><H3>cg</H3></a></p> Click <a href="./callingtree/cg_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cg is used.
<hr>
2512: subroutine cg ( n, ar, ai, wr, wi, matz, zr, zi, ierr )
2513: 
2514: !*****************************************************************************80
2515: !
2516: !! CG gets eigenvalues and eigenvectors of a complex general matrix.
2517: !
2518: !  Discussion:
2519: !
2520: !    This subroutine calls the recommended sequence of EISPACK subroutines 
2521: !    to find the eigenvalues and eigenvectors (if desired)
2522: !    of a complex general matrix.
2523: !
2524: !  Licensing:
2525: !
2526: !    This code is distributed under the GNU LGPL license.
2527: !
2528: !  Modified:
2529: !
2530: !    18 October 2009
2531: !
2532: !  Author:
2533: !
2534: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
2535: !    Klema, Moler.
2536: !    FORTRAN90 version by John Burkardt.
2537: !
2538: !  Reference:
2539: !
2540: !    James Wilkinson, Christian Reinsch,
2541: !    Handbook for Automatic Computation,
2542: !    Volume II, Linear Algebra, Part 2,
2543: !    Springer, 1971,
2544: !    ISBN: 0387054146,
2545: !    LC: QA251.W67.
2546: !
2547: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
2548: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
2549: !    Matrix Eigensystem Routines, EISPACK Guide,
2550: !    Lecture Notes in Computer Science, Volume 6,
2551: !    Springer Verlag, 1976,
2552: !    ISBN13: 978-3540075462,
2553: !    LC: QA193.M37.
2554: !
2555: !  Parameters:
2556: !
2557: !    Input, integer ( kind = 4 ) N, the order of the matrix.
2558: !
2559: !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and 
2560: !    imaginary parts of the complex matrix.  On output, AR and AI
2561: !    have been overwritten by other information.
2562: !
2563: !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts
2564: !    of the eigenvalues.
2565: !
2566: !    Input, integer ( kind = 4 ) MATZ, is 0 if only eigenvalues are desired, and
2567: !    nonzero if both eigenvalues and eigenvectors are to be computed.
2568: !
2569: !    Output, real ( kind = 8 ) ZR(N,N), ZI(N,N), the real and imaginary parts,
2570: !    respectively, of the eigenvectors, if MATZ is not zero.
2571: !
2572: !    Output, integer ( kind = 4 ) IERR, an error completion code described in the 
2573: !    documentation for COMQR and COMQR2.  The normal completion code is zero.
2574: !
2575:   implicit none
2576: 
2577:   integer ( kind = 4 ) n
2578: 
2579:   real    ( kind = 8 ) ai(n,n)
2580:   real    ( kind = 8 ) ar(n,n)
2581:   real    ( kind = 8 ) fv1(n)
2582:   real    ( kind = 8 ) fv2(n)
2583:   real    ( kind = 8 ) fv3(n)
2584:   integer ( kind = 4 ) ierr
2585:   integer ( kind = 4 ) is1
2586:   integer ( kind = 4 ) is2
2587:   integer ( kind = 4 ) matz
2588:   real    ( kind = 8 ) wi(n)
2589:   real    ( kind = 8 ) wr(n)
2590:   real    ( kind = 8 ) zi(n,n)
2591:   real    ( kind = 8 ) zr(n,n)
2592: 
2593:   call <a href="./eispack.f90.html#cbal" TARGET=CENT_PANEL>cbal</a> ( n, ar, ai, is1, is2, fv1 )
2594: 
2595:   call <a href="./eispack.f90.html#corth" TARGET=CENT_PANEL>corth</a> ( n, is1, is2, ar, ai, fv2, fv3 )
2596: 
2597:   if ( matz == 0 ) then
2598: 
2599:     call <a href="./eispack.f90.html#comqr" TARGET=CENT_PANEL>comqr</a> ( n, is1, is2, ar, ai, wr, wi, ierr )
2600: 
2601:     if ( ierr /= 0 ) then
2602:       return
2603:     end if
2604:   
2605:   else
2606: 
2607:     call <a href="./eispack.f90.html#comqr2" TARGET=CENT_PANEL>comqr2</a> ( n, is1, is2, fv2, fv3, ar, ai, wr, wi, zr, zi, ierr )
2608: 
2609:     if ( ierr /= 0 ) then
2610:       write ( *, '(a)' ) ' '
2611:       write ( *, '(a)' ) 'CG - Fatal error!'
2612:       write ( *, '(a)' ) '  Nonzero error return from COMQR2.'
2613:       return
2614:     end if
2615: 
2616:     call <a href="./eispack.f90.html#cbabk2" TARGET=CENT_PANEL>cbabk2</a> ( n, is1, is2, fv1, n, zr, zi )
2617: 
2618:   end if
2619: 
2620:   return
2621: end
<p><a name=ch><H3>ch</H3></a></p> Click <a href="./callingtree/ch_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ch is used.
<hr>
2622: subroutine ch ( n, ar, ai, w, matz, zr, zi, ierr )
2623: 
2624: !*****************************************************************************80
2625: !
2626: !! CH gets eigenvalues and eigenvectors of a complex Hermitian matrix.
2627: !
2628: !  Discussion:
2629: !
2630: !    This subroutine calls the recommended sequence of subroutines from the 
2631: !    EISPACK eigensystem package to find the eigenvalues and eigenvectors 
2632: !    of a complex hermitian matrix.
2633: !
2634: !  Licensing:
2635: !
2636: !    This code is distributed under the GNU LGPL license.
2637: !
2638: !  Modified:
2639: !
2640: !    18 October 2009
2641: !
2642: !  Author:
2643: !
2644: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
2645: !    Klema, Moler.
2646: !    FORTRAN90 version by John Burkardt.
2647: !
2648: !  Reference:
2649: !
2650: !    James Wilkinson, Christian Reinsch,
2651: !    Handbook for Automatic Computation,
2652: !    Volume II, Linear Algebra, Part 2,
2653: !    Springer, 1971,
2654: !    ISBN: 0387054146,
2655: !    LC: QA251.W67.
2656: !
2657: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
2658: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
2659: !    Matrix Eigensystem Routines, EISPACK Guide,
2660: !    Lecture Notes in Computer Science, Volume 6,
2661: !    Springer Verlag, 1976,
2662: !    ISBN13: 978-3540075462,
2663: !    LC: QA193.M37.
2664: !
2665: !  Parameters:
2666: !
2667: !    Input, integer ( kind = 4 ) N, the order of the matrix.
2668: !
2669: !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and 
2670: !    imaginary parts of the complex matrix.  On output, AR and AI
2671: !    have been overwritten by other information.
2672: !
2673: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
2674: !
2675: !    Input, integer ( kind = 4 ) MATZ, is 0 if only eigenvalues are desired, and
2676: !    nonzero if both eigenvalues and eigenvectors are to be computed.
2677: !
2678: !    Output, real ( kind = 8 ) ZR(N,N), ZI(N,N), the real and imaginary parts,
2679: !    respectively, of the eigenvectors, if MATZ is not zero.
2680: !
2681: !    Output, integer ( kind = 4 ) IERR, an error completion code described in the 
2682: !    documentation for TQLRAT and TQL2.  The normal completion code is zero.
2683: !
2684:   implicit none
2685: 
2686:   integer ( kind = 4 ) n
2687: 
2688:   real    ( kind = 8 ) ai(n,n)
2689:   real    ( kind = 8 ) ar(n,n)
2690:   real    ( kind = 8 ) fm1(2,n)
2691:   real    ( kind = 8 ) fv1(n)
2692:   real    ( kind = 8 ) fv2(n)
2693:   integer ( kind = 4 ) i
2694:   integer ( kind = 4 ) ierr
2695:   integer ( kind = 4 ) matz
2696:   real    ( kind = 8 ) w(n)
2697:   real    ( kind = 8 ) zi(n,n)
2698:   real    ( kind = 8 ) zr(n,n)
2699: 
2700:   call <a href="./eispack.f90.html#htridi" TARGET=CENT_PANEL>htridi</a> ( n, ar, ai, w, fv1, fv2, fm1 )
2701: 
2702:   if ( matz == 0 ) then
2703: 
2704:     call <a href="./eispack.f90.html#tqlrat" TARGET=CENT_PANEL>tqlrat</a> ( n, w, fv2, ierr )
2705: 
2706:   else
2707: 
2708:     zr(1:n,1:n) = 0.0D+00
2709: 
2710:     do i = 1, n
2711:       zr(i,i) = 1.0D+00
2712:     end do
2713: 
2714:     call <a href="./eispack.f90.html#tql2" TARGET=CENT_PANEL>tql2</a> ( n, w, fv1, zr, ierr )
2715: 
2716:     if ( ierr /= 0 ) then
2717:       return
2718:     end if
2719: 
2720:     call <a href="./eispack.f90.html#htribk" TARGET=CENT_PANEL>htribk</a> ( n, ar, ai, fm1, n, zr, zi )
2721: 
2722:   end if
2723: 
2724:   return
2725: end
<p><a name=cinvit><H3>cinvit</H3></a></p> Click <a href="./callingtree/cinvit_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cinvit is used.
<hr>
2726: subroutine cinvit ( n, ar, ai, wr, wi, select, mm, m, zr, zi, ierr )
2727: 
2728: !*****************************************************************************80
2729: !
2730: !! CINVIT gets eigenvectors from eigenvalues, for a complex Hessenberg matrix.
2731: !
2732: !  Discussion:
2733: !
2734: !    This subroutine finds those eigenvectors of a complex upper
2735: !    Hessenberg matrix corresponding to specified eigenvalues,
2736: !    using inverse iteration.
2737: !
2738: !  Licensing:
2739: !
2740: !    This code is distributed under the GNU LGPL license.
2741: !
2742: !  Modified:
2743: !
2744: !    18 October 2009
2745: !
2746: !  Author:
2747: !
2748: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
2749: !    Klema, Moler.
2750: !    FORTRAN90 version by John Burkardt.
2751: !
2752: !  Reference:
2753: !
2754: !    James Wilkinson, Christian Reinsch,
2755: !    Handbook for Automatic Computation,
2756: !    Volume II, Linear Algebra, Part 2,
2757: !    Springer, 1971,
2758: !    ISBN: 0387054146,
2759: !    LC: QA251.W67.
2760: !
2761: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
2762: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
2763: !    Matrix Eigensystem Routines, EISPACK Guide,
2764: !    Lecture Notes in Computer Science, Volume 6,
2765: !    Springer Verlag, 1976,
2766: !    ISBN13: 978-3540075462,
2767: !    LC: QA193.M37.
2768: !
2769: !  Parameters:
2770: !
2771: !    Input, integer ( kind = 4 ) N, the order of the matrix.
2772: !
2773: !    Input, real ( kind = 8 ) AR(N,N), AI(N,N), the real and imaginary parts of 
2774: !    the complex Hessenberg matrix.  
2775: !
2776: !    Input/output, real ( kind = 8 ) WR(N), WI(N).  On input, the real and imaginary parts
2777: !    of the eigenvalues of the matrix.  The eigenvalues must be stored in a 
2778: !    manner identical to that of subroutine COMLR, which recognizes possible 
2779: !    splitting of the matrix.  On output, WR may have been altered since 
2780: !    close eigenvalues are perturbed slightly in searching for independent 
2781: !    eigenvectors.
2782: !
2783: !    Input, logical SELECT(N), specifies the eigenvectors to be found.  The
2784: !    eigenvector corresponding to the J-th eigenvalue is specified by 
2785: !    setting SELECT(J) to TRUE.
2786: !
2787: !    Input, integer ( kind = 4 ) MM, an upper bound for the number of eigenvectors 
2788: !    to be found.
2789: !
2790: !    Output, integer ( kind = 4 ) M, the number of eigenvectors actually found.
2791: !
2792: !    Output, real ( kind = 8 ) ZR(N,MM), ZI(N,MM), the real and imaginary parts
2793: !    of the eigenvectors.  The eigenvectors are normalized so that the 
2794: !    component of largest magnitude is 1.
2795: !    Any vector which fails the acceptance test is set to zero.
2796: !
2797: !    Output, integer ( kind = 4 ) IERR, error flag.
2798: !    0, for normal return,
2799: !    -(2*N+1), if more than MM eigenvectors have been specified,
2800: !    -K, if the iteration corresponding to the K-th value fails,
2801: !    -(N+K), if both error situations occur.
2802: !
2803:   implicit none
2804: 
2805:   integer ( kind = 4 ) mm
2806:   integer ( kind = 4 ) n
2807: 
2808:   real    ( kind = 8 ) ai(n,n)
2809:   real    ( kind = 8 ) ar(n,n)
2810:   real    ( kind = 8 ) eps3
2811:   real    ( kind = 8 ) growto
2812:   integer ( kind = 4 ) i
2813:   integer ( kind = 4 ) ierr
2814:   integer ( kind = 4 ) ii
2815:   real    ( kind = 8 ) ilambd
2816:   integer ( kind = 4 ) its
2817:   integer ( kind = 4 ) j
2818:   integer ( kind = 4 ) k
2819:   integer ( kind = 4 ) km1
2820:   integer ( kind = 4 ) m
2821:   integer ( kind = 4 ) mp
2822:   real    ( kind = 8 ) norm
2823:   real    ( kind = 8 ) normv
2824:   real    ( kind = 8 ) pythag
2825:   real    ( kind = 8 ) rlambd
2826:   real    ( kind = 8 ) rm1(n,n)
2827:   real    ( kind = 8 ) rm2(n,n)
2828:   real    ( kind = 8 ) rv1(n)
2829:   real    ( kind = 8 ) rv2(n)
2830:   integer ( kind = 4 ) s
2831:   logical              select(n)
2832:   integer ( kind = 4 ) uk
2833:   real    ( kind = 8 ) ukroot
2834:   real    ( kind = 8 ) wi(n)
2835:   real    ( kind = 8 ) wr(n)
2836:   real    ( kind = 8 ) x
2837:   real    ( kind = 8 ) y
2838:   real    ( kind = 8 ) zi(n,mm)
2839:   real    ( kind = 8 ) zr(n,mm)
2840: 
2841:   ierr = 0
2842:   uk = 0
2843:   s = 1
2844: 
2845:   do k = 1, n
2846: 
2847:     if ( .not. select(k) ) then
2848:       cycle
2849:     end if
2850: 
2851:     if ( s > mm ) go to 1000
2852: 
2853:     if ( uk >= k ) go to 200
2854: !
2855: !  Check for possible splitting.
2856: !
2857:      do uk = k, n - 1
2858: 
2859:        if ( ar(uk+1,uk) == 0.0D+00 .and. ai(uk+1,uk) == 0.0D+00 ) then
2860:          exit
2861:        end if
2862: 
2863:      end do
2864: !
2865: !  Compute infinity norm of leading UK by UK (Hessenberg) matrix.
2866: !   
2867:      norm = 0.0D+00
2868:      mp = 1
2869: 
2870:      do i = 1, uk
2871: 
2872:        x = 0.0D+00
2873:        do j = mp, uk
2874:          x = x + <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( ar(i,j), ai(i,j) )
2875:        end do
2876: 
2877:        norm = max ( norm, x )
2878:        mp = i
2879: 
2880:      end do
2881: !
2882: !  EPS3 replaces zero pivot in decomposition
2883: !  and close roots are modified by EPS3.
2884: !
2885:      if ( norm == 0.0D+00 ) norm = 1.0D+00
2886:      eps3 = abs ( norm ) * epsilon ( eps3 )
2887: !
2888: !  GROWTO is the criterion for growth.
2889: !
2890:      ukroot = uk
2891:      ukroot = sqrt ( ukroot )
2892:      growto = 0.1D+00 / ukroot
2893: 
2894: 200  continue
2895: 
2896:      rlambd = wr(k)
2897:      ilambd = wi(k)
2898:      if ( k == 1 ) go to 280
2899:      km1 = k - 1
2900:      go to 240
2901: !
2902: !  Perturb eigenvalue if it is close to any previous eigenvalue.
2903: !
2904: 220  continue
2905: 
2906:      rlambd = rlambd + eps3
2907: 
2908: 240  continue
2909: 
2910:      do ii = 1, km1
2911:         i = k - ii
2912:         if ( select(i) .and. abs ( wr(i)-rlambd) < eps3 .and. &
2913:             abs ( wi(i)-ilambd) < eps3 ) then
2914:           go to 220
2915:         end if
2916:      end do
2917: 
2918:      wr(k) = rlambd
2919: !
2920: !  Form upper Hessenberg (ar,ai)-(rlambd,ilambd) * I
2921: !  and initial complex vector.
2922: !
2923: 280  continue
2924: 
2925:      mp = 1
2926: 
2927:      do i = 1, uk
2928: 
2929:         do j = mp, uk
2930:           rm1(i,j) = ar(i,j)
2931:           rm2(i,j) = ai(i,j)
2932:         end do
2933: 
2934:         rm1(i,i) = rm1(i,i) - rlambd
2935:         rm2(i,i) = rm2(i,i) - ilambd
2936:         mp = i
2937:         rv1(i) = eps3
2938: 
2939:      end do
2940: !
2941: !  Triangular decomposition with interchanges, replacing zero pivots by eps3.
2942: !
2943:      do i = 2, uk
2944: 
2945:         mp = i - 1
2946: 
2947:         if ( <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( rm1(i,mp), rm2(i,mp) ) > &
2948:              pythag ( rm1(mp,mp),rm2(mp,mp) ) ) then
2949: 
2950:           do j = mp, uk
2951:             call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( rm1(i,j), rm1(mp,j) )
2952:             call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( rm2(i,j), rm2(mp,j) )
2953:           end do
2954: 
2955:         end if
2956: 
2957:         if ( rm1(mp,mp) == 0.0D+00 .and. rm2(mp,mp) == 0.0D+00 ) then
2958:           rm1(mp,mp) = eps3
2959:         end if
2960: 
2961:         call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( rm1(i,mp), rm2(i,mp), rm1(mp,mp), rm2(mp,mp), x, y )
2962: 
2963:         if ( x /= 0.0D+00 .or. y /= 0.0D+00 ) then
2964: 
2965:           do j = i, uk
2966:             rm1(i,j) = rm1(i,j) - x * rm1(mp,j) + y * rm2(mp,j)
2967:             rm2(i,j) = rm2(i,j) - x * rm2(mp,j) - y * rm1(mp,j)
2968:           end do
2969: 
2970:         end if
2971: 
2972:      end do
2973: 
2974:      if ( rm1(uk,uk) == 0.0D+00 .and. rm2(uk,uk) == 0.0D+00 ) then
2975:        rm1(uk,uk) = eps3
2976:      end if
2977: 
2978:      its = 0
2979: !
2980: !  Back substitution.
2981: !
2982:   660   continue
2983: 
2984:     do ii = 1, uk
2985: 
2986:         i = uk + 1 - ii
2987:         x = rv1(i)
2988:         y = 0.0D+00
2989: 
2990:         do j = i+1, uk
2991:           x = x - rm1(i,j) * rv1(j) + rm2(i,j) * rv2(j)
2992:           y = y - rm1(i,j) * rv2(j) - rm2(i,j) * rv1(j)
2993:         end do
2994: 
2995:         call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( x, y, rm1(i,i), rm2(i,i), rv1(i), rv2(i) )
2996: 
2997:      end do
2998: !
2999: !  Acceptance test for eigenvector and normalization.
3000: !
3001:      its = its + 1
3002:      norm = 0.0D+00
3003:      normv = 0.0D+00
3004: 
3005:      do i = 1, uk
3006:         x = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( rv1(i), rv2(i) )
3007:         if ( normv < x ) then
3008:           normv = x
3009:           j = i
3010:         end if
3011:         norm = norm + x
3012:      end do
3013: 
3014:      if ( norm < growto ) go to 840
3015: !
3016: !  Accept vector.
3017: !
3018:      x = rv1(j)
3019:      y = rv2(j)
3020: 
3021:      do i = 1, uk
3022:        call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( rv1(i), rv2(i), x, y, zr(i,s), zi(i,s) )
3023:      end do
3024: 
3025:      if ( uk == n ) then
3026:        go to 940
3027:      end if
3028: 
3029:      j = uk + 1
3030:      go to 900
3031: !
3032: !  Choose a new starting vector.
3033: !
3034:   840    continue
3035: 
3036:      if ( its < uk ) then
3037: 
3038:        x = ukroot
3039:        y = eps3 / ( x + 1.0D+00 )
3040: 
3041:        rv1(1) = eps3
3042:        rv1(2:uk) = y
3043: 
3044:        j = uk - its + 1
3045:        rv1(j) = rv1(j) - eps3 * x
3046:        go to 660
3047: 
3048:      end if
3049: !
3050: !  Error: unaccepted eigenvector.
3051: !
3052:      j = 1
3053:      ierr = -k
3054: !
3055: !  Set remaining vector components to zero.
3056: !
3057: 900    continue
3058: 
3059:        zr(j:n,s) = 0.0D+00
3060:        zi(j:n,s) = 0.0D+00
3061: 
3062: 940    continue
3063: 
3064:        s = s + 1
3065: 
3066:   end do
3067: 
3068:   go to 1001
3069: !
3070: !  Set error: underestimate of eigenvector space required.
3071: !
3072:  1000 continue
3073:   if ( ierr /= 0 ) ierr = ierr - n
3074:   if ( ierr == 0 ) ierr = -(2 * n + 1)
3075:  1001 continue
3076:   m = s - 1
3077:   return
3078: end
<p><a name=combak><H3>combak</H3></a></p> Click <a href="./callingtree/combak_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where combak is used.
<hr>
3079: subroutine combak ( n, low, igh, ar, ai, ia, m, zr, zi )
3080: 
3081: !*****************************************************************************80
3082: !
3083: !! COMBAK determines eigenvectors by undoing the COMHES transformation.
3084: !
3085: !  Discussion:
3086: !
3087: !    This subroutine forms the eigenvectors of a complex general
3088: !    matrix by back transforming those of the corresponding
3089: !    upper Hessenberg matrix determined by COMHES.
3090: !
3091: !  Licensing:
3092: !
3093: !    This code is distributed under the GNU LGPL license.
3094: !
3095: !  Modified:
3096: !
3097: !    18 October 2009
3098: !
3099: !  Author:
3100: !
3101: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
3102: !    Klema, Moler.
3103: !    FORTRAN90 version by John Burkardt.
3104: !
3105: !  Reference:
3106: !
3107: !    James Wilkinson, Christian Reinsch,
3108: !    Handbook for Automatic Computation,
3109: !    Volume II, Linear Algebra, Part 2,
3110: !    Springer, 1971,
3111: !    ISBN: 0387054146,
3112: !    LC: QA251.W67.
3113: !
3114: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
3115: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
3116: !    Matrix Eigensystem Routines, EISPACK Guide,
3117: !    Lecture Notes in Computer Science, Volume 6,
3118: !    Springer Verlag, 1976,
3119: !    ISBN13: 978-3540075462,
3120: !    LC: QA193.M37.
3121: !
3122: !  Parameters:
3123: !
3124: !    Input, integer ( kind = 4 ) N, the order of the matrix.
3125: !
3126: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL.
3127: !    If CBAL is not used, set LOW = 1 and IGH = to the order of the matrix.
3128: !
3129: !    Input, real ( kind = 8 ) AR(N,IGH), AI(N,IGH), the multipliers which were used in the
3130: !    reduction by COMHES in their lower triangles below the subdiagonal.
3131: !
3132: !    Input, integer ( kind = 4 ) INT(IGH), information on the rows and columns interchanged 
3133: !    in the reduction by COMHES.
3134: !
3135: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed.
3136: !
3137: !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, the real and imaginary 
3138: !    parts of the eigenvectors to be back transformed.  On output, the real 
3139: !    and imaginary parts of the transformed eigenvectors.
3140: !
3141:   implicit none
3142: 
3143:   integer ( kind = 4 ) igh
3144:   integer ( kind = 4 ) m
3145:   integer ( kind = 4 ) n
3146: 
3147:   real    ( kind = 8 ) ai(n,igh)
3148:   real    ( kind = 8 ) ar(n,igh)
3149:   integer ( kind = 4 ) i
3150:   integer ( kind = 4 ) ia(igh)
3151:   integer ( kind = 4 ) j
3152:   integer ( kind = 4 ) la
3153:   integer ( kind = 4 ) low
3154:   integer ( kind = 4 ) mm
3155:   integer ( kind = 4 ) mp
3156:   real    ( kind = 8 ) xi
3157:   real    ( kind = 8 ) xr
3158:   real    ( kind = 8 ) zi(n,m)
3159:   real    ( kind = 8 ) zr(n,m)
3160: 
3161:   if ( m == 0 ) then
3162:     return
3163:   end if
3164: 
3165:   la = igh - 1
3166: 
3167:   if ( igh - 1 < low + 1 ) then
3168:     return
3169:   end if
3170: 
3171:   do mm = low + 1, la
3172: 
3173:      mp = low + igh - mm
3174: 
3175:      do i = mp+1, igh
3176: 
3177:         xr = ar(i,mp-1)
3178:         xi = ai(i,mp-1)
3179: 
3180:         if ( xr /= 0.0D+00 .or. xi /= 0.0D+00 ) then
3181:           zr(i,1:m) = zr(i,1:m) + xr * zr(mp,1:m) - xi * zi(mp,1:m)
3182:           zi(i,1:m) = zi(i,1:m) + xr * zi(mp,1:m) + xi * zr(mp,1:m)
3183:        end if
3184: 
3185:      end do
3186: 
3187:      i = ia(mp)
3188: 
3189:      if ( i /= mp ) then
3190: 
3191:        do j = 1, m
3192:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( zr(i,j), zr(mp,j) )
3193:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( zi(i,j), zi(mp,j) )
3194:        end do
3195: 
3196:      end if
3197: 
3198:   end do
3199: 
3200:   return
3201: end
<p><a name=comhes><H3>comhes</H3></a></p> Click <a href="./callingtree/comhes_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where comhes is used.
<hr>
3202: subroutine comhes ( n, low, igh, ar, ai, ia )
3203: 
3204: !*****************************************************************************80
3205: !
3206: !! COMHES transforms a complex general matrix to upper Hessenberg form.
3207: !
3208: !  Discussion:
3209: !
3210: !    Given a complex general matrix, this subroutine
3211: !    reduces a submatrix situated in rows and columns
3212: !    LOW through IGH to upper Hessenberg form by
3213: !    stabilized elementary similarity transformations.
3214: !
3215: !  Licensing:
3216: !
3217: !    This code is distributed under the GNU LGPL license.
3218: !
3219: !  Modified:
3220: !
3221: !    18 October 2009
3222: !
3223: !  Author:
3224: !
3225: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
3226: !    Klema, Moler.
3227: !    FORTRAN90 version by John Burkardt.
3228: !
3229: !  Reference:
3230: !
3231: !    James Wilkinson, Christian Reinsch,
3232: !    Handbook for Automatic Computation,
3233: !    Volume II, Linear Algebra, Part 2,
3234: !    Springer, 1971,
3235: !    ISBN: 0387054146,
3236: !    LC: QA251.W67.
3237: !
3238: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
3239: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
3240: !    Matrix Eigensystem Routines, EISPACK Guide,
3241: !    Lecture Notes in Computer Science, Volume 6,
3242: !    Springer Verlag, 1976,
3243: !    ISBN13: 978-3540075462,
3244: !    LC: QA193.M37.
3245: !
3246: !  Parameters:
3247: !
3248: !    Input, integer ( kind = 4 ) N, the order of the matrix.
3249: !
3250: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL.
3251: !    If CBAL is not used, set LOW = 1 and IGH = N.
3252: !
3253: !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and imaginary 
3254: !    parts of the complex input matrix.  On output, the real and imaginary 
3255: !    parts of the Hessenberg matrix.  The multipliers which were used in the 
3256: !    reduction are stored in the remaining triangles under the
3257: !    Hessenberg matrix.
3258: !
3259: !    Output, integer ( kind = 4 ) INT(IGH), information on the rows and columns
3260: !    interchanged in the reduction.
3261: !
3262:   implicit none
3263: 
3264:   integer ( kind = 4 ) igh
3265:   integer ( kind = 4 ) n
3266: 
3267:   real    ( kind = 8 ) ai(n,n)
3268:   real    ( kind = 8 ) ar(n,n)
3269:   integer ( kind = 4 ) i
3270:   integer ( kind = 4 ) ia(igh)
3271:   integer ( kind = 4 ) j
3272:   integer ( kind = 4 ) la
3273:   integer ( kind = 4 ) low
3274:   integer ( kind = 4 ) m
3275:   real    ( kind = 8 ) xi
3276:   real    ( kind = 8 ) xr
3277:   real    ( kind = 8 ) yi
3278:   real    ( kind = 8 ) yr
3279: 
3280:   la = igh - 1
3281: 
3282:   do m = low + 1, la
3283: 
3284:      xr = 0.0D+00
3285:      xi = 0.0D+00
3286:      i = m
3287: 
3288:      do j = m, igh
3289: 
3290:        if ( abs ( ar(j,m-1) ) + abs ( ai(j,m-1) ) > &
3291:          abs ( xr ) + abs ( xi ) ) then
3292:          xr = ar(j,m-1)
3293:          xi = ai(j,m-1)
3294:          i = j
3295:        end if
3296: 
3297:      end do
3298: 
3299:      ia(m) = i
3300: !
3301: !  Interchange rows and columns of AR and AI.
3302: !
3303:      if ( i /= m ) then
3304: 
3305:        do j = m-1, n
3306:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( ar(i,j), ar(m,j) )
3307:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( ai(i,j), ai(m,j) )
3308:        end do
3309: 
3310:        do j = 1, igh
3311:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( ar(j,i), ar(j,m) )
3312:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( ai(j,i), ai(j,m) )
3313:        end do
3314: 
3315:      end if
3316: 
3317:     if ( xr /= 0.0D+00 .or. xi /= 0.0D+00 ) then
3318: 
3319:       do i = m+1, igh
3320: 
3321:         yr = ar(i,m-1)
3322:         yi = ai(i,m-1)
3323: 
3324:         if ( yr /= 0.0D+00 .or. yi /= 0.0D+00 ) then
3325: 
3326:           call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( yr, yi, xr, xi, yr, yi )
3327:           ar(i,m-1) = yr
3328:           ai(i,m-1) = yi
3329: 
3330:           do j = m, n
3331:             ar(i,j) = ar(i,j) - yr * ar(m,j) + yi * ai(m,j)
3332:             ai(i,j) = ai(i,j) - yr * ai(m,j) - yi * ar(m,j)
3333:           end do
3334: 
3335:           ar(1:igh,m) = ar(1:igh,m) + yr * ar(1:igh,i) - yi * ai(1:igh,i)
3336:           ai(1:igh,m) = ai(1:igh,m) + yr * ai(1:igh,i) + yi * ar(1:igh,i)
3337: 
3338:         end if
3339: 
3340:       end do
3341: 
3342:     end if
3343: 
3344:   end do
3345: 
3346:   return
3347: end
<p><a name=comlr><H3>comlr</H3></a></p> Click <a href="./callingtree/comlr_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where comlr is used.
<hr>
3348: subroutine comlr ( n, low, igh, hr, hi, wr, wi, ierr )
3349: 
3350: !*****************************************************************************80
3351: !
3352: !! COMLR gets all eigenvalues of a complex upper Hessenberg matrix.
3353: !
3354: !  Discussion:
3355: !
3356: !    This subroutine finds the eigenvalues of a complex upper Hessenberg 
3357: !    matrix by the modified LR method.
3358: !
3359: !  Licensing:
3360: !
3361: !    This code is distributed under the GNU LGPL license.
3362: !
3363: !  Modified:
3364: !
3365: !    18 October 2009
3366: !
3367: !  Author:
3368: !
3369: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
3370: !    Klema, Moler.
3371: !    FORTRAN90 version by John Burkardt.
3372: !
3373: !  Reference:
3374: !
3375: !    James Wilkinson, Christian Reinsch,
3376: !    Handbook for Automatic Computation,
3377: !    Volume II, Linear Algebra, Part 2,
3378: !    Springer, 1971,
3379: !    ISBN: 0387054146,
3380: !    LC: QA251.W67.
3381: !
3382: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
3383: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
3384: !    Matrix Eigensystem Routines, EISPACK Guide,
3385: !    Lecture Notes in Computer Science, Volume 6,
3386: !    Springer Verlag, 1976,
3387: !    ISBN13: 978-3540075462,
3388: !    LC: QA193.M37.
3389: !
3390: !  Parameters:
3391: !
3392: !    Input, integer ( kind = 4 ) N, the order of the matrix.
3393: !
3394: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL.
3395: !    If CBAL is not used, set LOW = 1 and IGH = N.
3396: !
3397: !    Input/output, real ( kind = 8 ) HR(N,N), HI(N,N).  On input, the real and imaginary 
3398: !    parts of the complex upper Hessenberg matrix.  Their lower triangles 
3399: !    below the subdiagonal contain the multipliers which were used in the 
3400: !    reduction by COMHES if performed.  On output, the upper Hessenberg 
3401: !    portions of HR and HI have been destroyed.  Therefore, they must be 
3402: !    saved before calling COMLR if subsequent calculation of eigenvectors 
3403: !    is to be performed.
3404: !
3405: !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the 
3406: !    eigenvalues.  If an error exit is made, the eigenvalues should be correct
3407: !    for indices IERR+1,...,N.
3408: !
3409: !    Output, integer ( kind = 4 ) IERR, error flag.
3410: !    0, for normal return,
3411: !    J, if the limit of 30*N iterations is exhausted while the J-th 
3412: !      eigenvalue is being sought.
3413: !
3414:   implicit none
3415: 
3416:   integer ( kind = 4 ) n
3417: 
3418:   integer ( kind = 4 ) en
3419:   integer ( kind = 4 ) enm1
3420:   real    ( kind = 8 ) hi(n,n)
3421:   real    ( kind = 8 ) hr(n,n)
3422:   integer ( kind = 4 ) i
3423:   integer ( kind = 4 ) ierr
3424:   integer ( kind = 4 ) igh
3425:   integer ( kind = 4 ) itn
3426:   integer ( kind = 4 ) its
3427:   integer ( kind = 4 ) j
3428:   integer ( kind = 4 ) l
3429:   integer ( kind = 4 ) ll
3430:   integer ( kind = 4 ) low
3431:   integer ( kind = 4 ) m
3432:   integer ( kind = 4 ) mm
3433:   real    ( kind = 8 ) si
3434:   real    ( kind = 8 ) sr
3435:   real    ( kind = 8 ) ti
3436:   real    ( kind = 8 ) tr
3437:   real    ( kind = 8 ) tst1
3438:   real    ( kind = 8 ) tst2
3439:   real    ( kind = 8 ) wi(n)
3440:   real    ( kind = 8 ) wr(n)
3441:   real    ( kind = 8 ) xi
3442:   real    ( kind = 8 ) xr
3443:   real    ( kind = 8 ) yi
3444:   real    ( kind = 8 ) yr
3445:   real    ( kind = 8 ) zzi
3446:   real    ( kind = 8 ) zzr
3447: 
3448:   ierr = 0
3449: !
3450: !  Store roots isolated by CBAL.
3451: !
3452:   do i = 1, n
3453:     if ( i < low .or. i > igh ) then
3454:       wr(i) = hr(i,i)
3455:       wi(i) = hi(i,i)
3456:     end if
3457:   end do
3458: 
3459:   en = igh
3460:   tr = 0.0D+00
3461:   ti = 0.0D+00
3462:   itn = 30 * n
3463: !
3464: !  Search for next eigenvalue.
3465: !
3466:   220 continue
3467: 
3468:   if ( en < low ) then
3469:     return
3470:   end if
3471: 
3472:   its = 0
3473:   enm1 = en - 1
3474: !
3475: !  Look for single small sub-diagonal element.
3476: !
3477:   240 continue
3478: 
3479:   do ll = low, en
3480:      l = en + low - ll
3481:      if ( l == low ) go to 300
3482:      tst1 = abs ( hr(l-1,l-1) ) + abs ( hi(l-1,l-1) ) + abs ( hr(l,l) ) & 
3483:        + abs ( hi(l,l) )
3484:      tst2 = tst1 + abs ( hr(l,l-1) ) + abs ( hi(l,l-1) )
3485:      if ( tst2 == tst1) go to 300
3486:   end do
3487: !
3488: !  Form shift.
3489: !
3490: 300 continue
3491: 
3492:   if ( l == en ) then
3493:     go to 660
3494:   end if
3495: 
3496:   if ( itn == 0 ) then
3497:     ierr = en
3498:     return
3499:   end if
3500: 
3501:   if ( its == 10 .or. its == 20 ) go to 320
3502:   sr = hr(en,en)
3503:   si = hi(en,en)
3504:   xr = hr(enm1,en) * hr(en,enm1) - hi(enm1,en) * hi(en,enm1)
3505:   xi = hr(enm1,en) * hi(en,enm1) + hi(enm1,en) * hr(en,enm1)
3506:   if ( xr == 0.0D+00 .and. xi == 0.0D+00 ) go to 340
3507:   yr = ( hr(enm1,enm1) - sr) / 2.0D+00
3508:   yi = ( hi(enm1,enm1) - si) / 2.0D+00
3509:   call <a href="./eispack.f90.html#csroot" TARGET=CENT_PANEL>csroot</a> ( yr**2-yi**2+xr, 2.0D+00*yr*yi+xi, zzr, zzi )
3510: 
3511:   if ( yr * zzr + yi * zzi < 0.0D+00 ) then
3512:     zzr = -zzr
3513:     zzi = -zzi
3514:   end if
3515: 
3516:   call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( xr, xi, yr+zzr, yi+zzi, xr, xi )
3517:   sr = sr - xr
3518:   si = si - xi
3519:   go to 340
3520: !
3521: !  Form exceptional shift.
3522: !
3523:   320 continue
3524: 
3525:   sr = abs ( hr(en,enm1) ) + abs ( hr(enm1,en-2) )
3526:   si = abs ( hi(en,enm1) ) + abs ( hi(enm1,en-2) )
3527: 
3528:   340 continue
3529: 
3530:   do i = low, en
3531:     hr(i,i) = hr(i,i) - sr
3532:     hi(i,i) = hi(i,i) - si
3533:   end do
3534: 
3535:   tr = tr + sr
3536:   ti = ti + si
3537:   its = its + 1
3538:   itn = itn - 1
3539: !
3540: !  Look for two consecutive small sub-diagonal elements.
3541: !
3542:   xr = abs ( hr(enm1,enm1) ) + abs ( hi(enm1,enm1) )
3543:   yr = abs ( hr(en,enm1) ) + abs ( hi(en,enm1) )
3544:   zzr = abs ( hr(en,en) ) + abs ( hi(en,en) )
3545: 
3546:   do mm = l, enm1
3547:     m = enm1 + l - mm
3548:     if ( m == l ) then
3549:       exit
3550:     end if
3551:     yi = yr
3552:     yr = abs ( hr(m,m-1) ) + abs ( hi(m,m-1) )
3553:     xi = zzr
3554:     zzr = xr
3555:     xr = abs ( hr(m-1,m-1) ) + abs ( hi(m-1,m-1) )
3556:     tst1 = zzr / yi * (zzr + xr + xi)
3557:     tst2 = tst1 + yr
3558:     if ( tst2 == tst1 ) then
3559:       exit
3560:     end if
3561:   end do
3562: !
3563: !  Triangular decomposition H=L*R.
3564: !
3565:   do i = m+1, en
3566: 
3567:      xr = hr(i-1,i-1)
3568:      xi = hi(i-1,i-1)
3569:      yr = hr(i,i-1)
3570:      yi = hi(i,i-1)
3571:      if ( abs ( xr ) + abs ( xi ) >= abs ( yr ) + abs ( yi ) ) go to 460
3572: !
3573: !  Interchange rows of HR and HI.
3574: !
3575:      do j = i-1, en
3576:        call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( hr(i-1,j), hr(i,j) )
3577:        call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( hi(i-1,j), hi(i,j) )
3578:      end do
3579: 
3580:      call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( xr, xi, yr, yi, zzr, zzi )
3581:      wr(i) = 1.0D+00
3582:      go to 480
3583: 
3584: 460 continue
3585: 
3586:      call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( yr, yi, xr, xi, zzr, zzi )
3587:      wr(i) = -1.0D+00
3588: 
3589: 480  continue
3590: 
3591:      hr(i,i-1) = zzr
3592:      hi(i,i-1) = zzi
3593: 
3594:      do j = i, en
3595:         hr(i,j) = hr(i,j) - zzr * hr(i-1,j) + zzi * hi(i-1,j)
3596:         hi(i,j) = hi(i,j) - zzr * hi(i-1,j) - zzi * hr(i-1,j)
3597:      end do
3598: 
3599:   end do
3600: !
3601: !  Composition R*L=H.
3602: !
3603:   do j = m+1, en
3604: 
3605:     xr = hr(j,j-1)
3606:     xi = hi(j,j-1)
3607:     hr(j,j-1) = 0.0D+00
3608:     hi(j,j-1) = 0.0D+00
3609: !
3610: !  Interchange columns of HR and HI, if necessary.
3611: !
3612:     if ( wr(j) > 0.0D+00 ) then
3613: 
3614:       do i = l, j
3615:         call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( hr(i,j-1), hr(i,j) )
3616:         call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( hi(i,j-1), hi(i,j) )
3617:       end do
3618: 
3619:     end if
3620: 
3621:     do i = l, j
3622:       hr(i,j-1) = hr(i,j-1) + xr * hr(i,j) - xi * hi(i,j)
3623:       hi(i,j-1) = hi(i,j-1) + xr * hi(i,j) + xi * hr(i,j)
3624:     end do
3625: 
3626:   end do
3627: 
3628:   go to 240
3629: !
3630: !  A root found.
3631: !
3632:   660 continue
3633: 
3634:   wr(en) = hr(en,en) + tr
3635:   wi(en) = hi(en,en) + ti
3636:   en = enm1
3637:   go to 220
3638: end
<p><a name=comlr2><H3>comlr2</H3></a></p> Click <a href="./callingtree/comlr2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where comlr2 is used.
<hr>
3639: subroutine comlr2 ( n, low, igh, ia, hr, hi, wr, wi, zr, zi, ierr )
3640: 
3641: !*****************************************************************************80
3642: !
3643: !! COMLR2 gets eigenvalues/vectors of a complex upper Hessenberg matrix.
3644: !
3645: !  Discussion:
3646: !
3647: !    This subroutine finds the eigenvalues and eigenvectors of a complex 
3648: !    upper Hessenberg matrix by the modified LR method.  The eigenvectors 
3649: !    of a complex general matrix can also be found if COMHES has been used 
3650: !    to reduce this general matrix to Hessenberg form.
3651: !
3652: !  Licensing:
3653: !
3654: !    This code is distributed under the GNU LGPL license.
3655: !
3656: !  Modified:
3657: !
3658: !    18 October 2009
3659: !
3660: !  Author:
3661: !
3662: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
3663: !    Klema, Moler.
3664: !    FORTRAN90 version by John Burkardt.
3665: !
3666: !  Reference:
3667: !
3668: !    James Wilkinson, Christian Reinsch,
3669: !    Handbook for Automatic Computation,
3670: !    Volume II, Linear Algebra, Part 2,
3671: !    Springer, 1971,
3672: !    ISBN: 0387054146,
3673: !    LC: QA251.W67.
3674: !
3675: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
3676: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
3677: !    Matrix Eigensystem Routines, EISPACK Guide,
3678: !    Lecture Notes in Computer Science, Volume 6,
3679: !    Springer Verlag, 1976,
3680: !    ISBN13: 978-3540075462,
3681: !    LC: QA193.M37.
3682: !
3683: !  Parameters:
3684: !
3685: !    Input, integer ( kind = 4 ) N, the order of the matrix.
3686: !
3687: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL.
3688: !    If CBAL is not used, set LOW = 1 and IGH = N.
3689: !
3690: !    Input, integer ( kind = 4 ) INT(IGH), information on the rows and columns interchanged
3691: !    in the reduction by COMHES, if performed.  If the eigenvectors of the 
3692: !    Hessenberg matrix are desired, set INT(J)=J for these elements.
3693: !
3694: !    Input/output, real ( kind = 8 ) HR(N,N), HI(N,N).  On input, the real and imaginary
3695: !    parts of the complex upper Hessenberg matrix.  Their lower triangles 
3696: !    below the subdiagonal contain the multipliers which were used in the 
3697: !    reduction by COMHES, if performed.  If the eigenvectors of the Hessenberg
3698: !    matrix are desired, these elements must be set to zero.  On output,
3699: !    the upper Hessenberg portions of HR and HI have been destroyed, but the
3700: !    location HR(1,1) contains the norm of the triangularized matrix.
3701: !
3702: !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the 
3703: !    eigenvalues.  If an error exit is made, the eigenvalues should be 
3704: !    correct for indices IERR+1,...,N.
3705: !
3706: !    Output, real ( kind = 8 ) ZR(N,N), ZI(N,N), the real and imaginary parts of the
3707: !    eigenvectors.  The eigenvectors are unnormalized.  If an error exit 
3708: !    is made, none of the eigenvectors has been found.
3709: !
3710: !    Output, integer ( kind = 4 ) IERR, error flag.
3711: !    0, for normal return,
3712: !    J, if the limit of 30*N iterations is exhausted while the J-th 
3713: !      eigenvalue is being sought.
3714: !
3715:   implicit none
3716: 
3717:   integer ( kind = 4 ) n
3718: 
3719:   integer ( kind = 4 ) en
3720:   integer ( kind = 4 ) enm1
3721:   real    ( kind = 8 ) hi(n,n)
3722:   real    ( kind = 8 ) hr(n,n)
3723:   integer ( kind = 4 ) i
3724:   integer ( kind = 4 ) iend
3725:   integer ( kind = 4 ) ierr
3726:   integer ( kind = 4 ) igh
3727:   integer ( kind = 4 ) ii
3728:   integer ( kind = 4 ) ia(igh)
3729:   integer ( kind = 4 ) itn
3730:   integer ( kind = 4 ) its
3731:   integer ( kind = 4 ) j
3732:   integer ( kind = 4 ) jj
3733:   integer ( kind = 4 ) k
3734:   integer ( kind = 4 ) l
3735:   integer ( kind = 4 ) ll
3736:   integer ( kind = 4 ) low
3737:   integer ( kind = 4 ) m
3738:   integer ( kind = 4 ) mm
3739:   integer ( kind = 4 ) nn
3740:   real    ( kind = 8 ) norm
3741:   real    ( kind = 8 ) si
3742:   real    ( kind = 8 ) sr
3743:   real    ( kind = 8 ) ti
3744:   real    ( kind = 8 ) tr
3745:   real    ( kind = 8 ) tst1
3746:   real    ( kind = 8 ) tst2
3747:   real    ( kind = 8 ) wi(n)
3748:   real    ( kind = 8 ) wr(n)
3749:   real    ( kind = 8 ) xi
3750:   real    ( kind = 8 ) xr
3751:   real    ( kind = 8 ) yi
3752:   real    ( kind = 8 ) yr
3753:   real    ( kind = 8 ) zi(n,n)
3754:   real    ( kind = 8 ) zr(n,n)
3755:   real    ( kind = 8 ) zzi
3756:   real    ( kind = 8 ) zzr
3757: 
3758:   ierr = 0
3759: !
3760: !  Initialize the eigenvector matrix.
3761: !
3762:   zr(1:n,1:n) = 0.0D+00
3763: 
3764:   do i = 1, n
3765:     zr(i,i) = 1.0D+00
3766:   end do
3767: 
3768:   zi(1:n,1:n) = 0.0D+00
3769: !
3770: !  Form the matrix of accumulated transformations from the information left 
3771: !  by COMHES.
3772: !
3773:   iend = igh - low - 1
3774: 
3775:   do ii = 1, iend
3776: 
3777:     i = igh - ii
3778: 
3779:     do k = i+1, igh
3780:       zr(k,i) = hr(k,i-1)
3781:       zi(k,i) = hi(k,i-1)
3782:     end do
3783: 
3784:     j = ia(i)
3785: 
3786:     if ( i /= j ) then
3787: 
3788:       do k = i, igh
3789:         zr(i,k) = zr(j,k)
3790:         zi(i,k) = zi(j,k)
3791:         zr(j,k) = 0.0D+00
3792:         zi(j,k) = 0.0D+00
3793:       end do
3794: 
3795:       zr(j,i) = 1.0D+00
3796: 
3797:     end if
3798: 
3799:   end do
3800: !
3801: !  Store roots isolated by CBAL.
3802: !
3803:   do i = 1, n
3804:     if ( i < low .or. i > igh ) then
3805:       wr(i) = hr(i,i)
3806:       wi(i) = hi(i,i)
3807:     end if
3808:   end do
3809: 
3810:   en = igh
3811:   tr = 0.0D+00
3812:   ti = 0.0D+00
3813:   itn = 30 * n
3814: !
3815: !  Search for next eigenvalue.
3816: !
3817: 220 continue
3818: 
3819:   if ( en < low ) then
3820:     go to 680
3821:   end if
3822: 
3823:   its = 0
3824:   enm1 = en - 1
3825: !
3826: !  Look for single small sub-diagonal element.
3827: !
3828:   240 continue
3829: 
3830:   do ll = low, en
3831: 
3832:      l = en + low - ll
3833: 
3834:      if ( l == low ) then
3835:        exit
3836:      end if
3837: 
3838:      tst1 = abs ( hr(l-1,l-1) ) + abs ( hi(l-1,l-1) ) + abs ( hr(l,l) ) &
3839:        + abs ( hi(l,l) )
3840:      tst2 = tst1 + abs ( hr(l,l-1) ) + abs ( hi(l,l-1) )
3841: 
3842:      if ( tst2 == tst1 ) then
3843:        exit
3844:      end if
3845: 
3846:   end do
3847: !
3848: !  Form shift.
3849: !
3850:   if ( l == en ) go to 660
3851:   if ( itn == 0 ) go to 1000
3852:   if ( its == 10 .or. its == 20 ) go to 320
3853:   sr = hr(en,en)
3854:   si = hi(en,en)
3855:   xr = hr(enm1,en) * hr(en,enm1) - hi(enm1,en) * hi(en,enm1)
3856:   xi = hr(enm1,en) * hi(en,enm1) + hi(enm1,en) * hr(en,enm1)
3857:   if ( xr == 0.0D+00 .and. xi == 0.0D+00 ) go to 340
3858:   yr = (hr(enm1,enm1) - sr) / 2.0D+00
3859:   yi = (hi(enm1,enm1) - si) / 2.0D+00
3860:   call <a href="./eispack.f90.html#csroot" TARGET=CENT_PANEL>csroot</a> ( yr**2-yi**2+xr, 2.0D+00*yr*yi+xi, zzr, zzi )
3861: 
3862:   if ( yr * zzr + yi * zzi < 0.0D+00 ) then
3863:     zzr = -zzr
3864:     zzi = -zzi
3865:   end if
3866: 
3867:   call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( xr, xi, yr+zzr, yi+zzi, xr, xi )
3868:   sr = sr - xr
3869:   si = si - xi
3870:   go to 340
3871: !
3872: !  Form exceptional shift.
3873: !
3874:   320 continue
3875: 
3876:   sr = abs ( hr(en,enm1) ) + abs ( hr(enm1,en-2) )
3877:   si = abs ( hi(en,enm1) ) + abs ( hi(enm1,en-2) )
3878: 
3879:   340 continue
3880: 
3881:   do i = low, en
3882:     hr(i,i) = hr(i,i) - sr
3883:     hi(i,i) = hi(i,i) - si
3884:   end do
3885: 
3886:   tr = tr + sr
3887:   ti = ti + si
3888:   its = its + 1
3889:   itn = itn - 1
3890: !
3891: !  Look for two consecutive small sub-diagonal elements.
3892: !
3893:   xr = abs ( hr(enm1,enm1) ) + abs ( hi(enm1,enm1) )
3894:   yr = abs ( hr(en,enm1) ) + abs ( hi(en,enm1) )
3895:   zzr = abs ( hr(en,en) ) + abs ( hi(en,en) )
3896: 
3897:   do mm = l, enm1
3898:      m = enm1 + l - mm
3899:      if ( m == l ) then
3900:        exit
3901:      end if
3902:      yi = yr
3903:      yr = abs ( hr(m,m-1) ) + abs ( hi(m,m-1) )
3904:      xi = zzr
3905:      zzr = xr
3906:      xr = abs ( hr(m-1,m-1) ) + abs ( hi(m-1,m-1) )
3907:      tst1 = zzr / yi * (zzr + xr + xi)
3908:      tst2 = tst1 + yr
3909:      if ( tst2 == tst1 ) then
3910:        exit
3911:      end if
3912:   end do
3913: !
3914: !  Triangular decomposition H=L*R.
3915: !
3916:   do i = m+1, en
3917: 
3918:      xr = hr(i-1,i-1)
3919:      xi = hi(i-1,i-1)
3920:      yr = hr(i,i-1)
3921:      yi = hi(i,i-1)
3922:      if ( abs ( xr ) + abs ( xi) >= abs ( yr ) + abs ( yi ) ) go to 460
3923: !
3924: !  Interchange rows of HR and HI.
3925: !
3926:      do j = i-1, n
3927:        call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( hr(i-1,j), hr(i,j) )
3928:        call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( hi(i-1,j), hi(i,j) )
3929:     end do
3930: 
3931:      call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( xr, xi, yr, yi, zzr, zzi )
3932:      wr(i) = 1.0D+00
3933:      go to 480
3934: 460  continue
3935: 
3936:      call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( yr, yi, xr, xi, zzr, zzi )
3937:      wr(i) = -1.0D+00
3938: 
3939: 480  continue
3940: 
3941:      hr(i,i-1) = zzr
3942:      hi(i,i-1) = zzi
3943: 
3944:      do j = i, n
3945:        hr(i,j) = hr(i,j) - zzr * hr(i-1,j) + zzi * hi(i-1,j)
3946:        hi(i,j) = hi(i,j) - zzr * hi(i-1,j) - zzi * hr(i-1,j)
3947:      end do
3948: 
3949:   end do
3950: !
3951: !  Composition R*L=H.
3952: !
3953:   do j = m+1, en
3954: 
3955:      xr = hr(j,j-1)
3956:      xi = hi(j,j-1)
3957:      hr(j,j-1) = 0.0D+00
3958:      hi(j,j-1) = 0.0D+00
3959: !
3960: !  Interchange columns of HR, HI, ZR, and ZI.
3961: !
3962:      if ( wr(j) > 0.0D+00 ) then
3963: 
3964:        do i = 1, j
3965:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( hr(i,j-1), hr(i,j) )
3966:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( hi(i,j-1), hi(i,j) )
3967:        end do
3968: 
3969:        do i = low, igh
3970:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( zr(i,j-1), zr(i,j) )
3971:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( zi(i,j-1), zi(i,j) )
3972:        end do
3973: 
3974:     end if
3975: 
3976:     do i = 1, j
3977:       hr(i,j-1) = hr(i,j-1) + xr * hr(i,j) - xi * hi(i,j)
3978:       hi(i,j-1) = hi(i,j-1) + xr * hi(i,j) + xi * hr(i,j)
3979:     end do
3980: !
3981: !  Accumulate transformations.
3982: !
3983:     do i = low, igh
3984:       zr(i,j-1) = zr(i,j-1) + xr * zr(i,j) - xi * zi(i,j)
3985:       zi(i,j-1) = zi(i,j-1) + xr * zi(i,j) + xi * zr(i,j)
3986:     end do
3987: 
3988:   end do
3989: 
3990:   go to 240
3991: !
3992: !  A root found.
3993: !
3994:   660 continue
3995: 
3996:   hr(en,en) = hr(en,en) + tr
3997:   wr(en) = hr(en,en)
3998:   hi(en,en) = hi(en,en) + ti
3999:   wi(en) = hi(en,en)
4000:   en = enm1
4001:   go to 220
4002: !
4003: !  All roots found.  
4004: !  Backsubstitute to find vectors of upper triangular form.
4005: !
4006:   680 continue
4007: 
4008:   norm = 0.0D+00
4009: 
4010:   do i = 1, n
4011:     do j = i, n
4012:       tr = abs ( hr(i,j) ) + abs ( hi(i,j) )
4013:       if ( tr > norm ) norm = tr
4014:     end do
4015:   end do
4016: 
4017:   hr(1,1) = norm
4018:   if ( n == 1 ) then
4019:     return
4020:   end if
4021: 
4022:   if ( norm == 0.0D+00 ) then
4023:     return
4024:   end if
4025: 
4026:   do nn = 2, n
4027: 
4028:      en = n + 2 - nn
4029:      xr = wr(en)
4030:      xi = wi(en)
4031:      hr(en,en) = 1.0D+00
4032:      hi(en,en) = 0.0D+00
4033:      enm1 = en - 1
4034: 
4035:      do ii = 1, enm1
4036: 
4037:         i = en - ii
4038:         zzr = 0.0D+00
4039:         zzi = 0.0D+00
4040: 
4041:         do j = i+1, en
4042:           zzr = zzr + hr(i,j) * hr(j,en) - hi(i,j) * hi(j,en)
4043:           zzi = zzi + hr(i,j) * hi(j,en) + hi(i,j) * hr(j,en)
4044:         end do
4045: 
4046:         yr = xr - wr(i)
4047:         yi = xi - wi(i)
4048: 
4049:         if ( yr == 0.0D+00 .and. yi == 0.0D+00 ) then
4050: 
4051:           tst1 = norm
4052:           yr = tst1
4053: 
4054:           do
4055:             yr = 0.01D+00 * yr
4056:             tst2 = norm + yr
4057:             if ( tst2 <=  tst1 ) then
4058:               exit
4059:             end if
4060:           end do
4061: 
4062:         end if
4063: 
4064:         call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( zzr, zzi, yr, yi, hr(i,en), hi(i,en) )
4065: !
4066: !  Overflow control.
4067: !
4068:         tr = abs ( hr(i,en) ) + abs ( hi(i,en) )
4069: 
4070:         if ( tr /= 0.0D+00 ) then
4071: 
4072:           tst1 = tr
4073:           tst2 = tst1 + 1.0D+00 / tst1
4074: 
4075:           if ( tst2 <= tst1 ) then
4076: 
4077:             hr(i:en,en) = hr(i:en,en) / tr
4078:             hi(i:en,en) = hi(i:en,en) / tr
4079: 
4080:           end if
4081: 
4082:         end if
4083: 
4084:       end do
4085: 
4086:   end do
4087: !
4088: !  End backsubstitution.
4089: !
4090:   enm1 = n - 1
4091: !
4092: !  Vectors of isolated roots.
4093: !
4094:   do i = 1, n - 1
4095: 
4096:     if ( i < low .or. i > igh ) then
4097: 
4098:       zr(i,i+1:n) = hr(i,i+1:n)
4099:       zi(i,i+1:n) = hi(i,i+1:n)
4100: 
4101:     end if
4102: 
4103:   end do
4104: !
4105: !  Multiply by transformation matrix to give vectors of original full matrix.
4106: !
4107:   do jj = low, n - 1
4108: 
4109:     j = n + low - jj
4110:     m = min ( j, igh )
4111: 
4112:     do i = low, igh
4113:       zzr = 0.0D+00
4114:       zzi = 0.0D+00
4115:       do k = low, m
4116:         zzr = zzr + zr(i,k) * hr(k,j) - zi(i,k) * hi(k,j)
4117:         zzi = zzi + zr(i,k) * hi(k,j) + zi(i,k) * hr(k,j)
4118:       end do
4119:       zr(i,j) = zzr
4120:       zi(i,j) = zzi
4121:     end do
4122: 
4123:   end do
4124: 
4125:   return
4126: !
4127: !  Set error: all eigenvalues have not converged after 30*N iterations.
4128: !
4129:  1000 continue
4130: 
4131:   ierr = en
4132:   return
4133: end
<p><a name=comqr><H3>comqr</H3></a></p> Click <a href="./callingtree/comqr_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where comqr is used.
<hr>
4134: subroutine comqr ( n, low, igh, hr, hi, wr, wi, ierr )
4135: 
4136: !*****************************************************************************80
4137: !
4138: !! COMQR gets eigenvalues of a complex upper Hessenberg matrix.
4139: !
4140: !  Discussion:
4141: !
4142: !    This subroutine finds the eigenvalues of a complex
4143: !    upper Hessenberg matrix by the QR method.
4144: !
4145: !  Licensing:
4146: !
4147: !    This code is distributed under the GNU LGPL license.
4148: !
4149: !  Modified:
4150: !
4151: !    18 October 2009
4152: !
4153: !  Author:
4154: !
4155: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
4156: !    Klema, Moler.
4157: !    FORTRAN90 version by John Burkardt.
4158: !
4159: !  Reference:
4160: !
4161: !    James Wilkinson, Christian Reinsch,
4162: !    Handbook for Automatic Computation,
4163: !    Volume II, Linear Algebra, Part 2,
4164: !    Springer, 1971,
4165: !    ISBN: 0387054146,
4166: !    LC: QA251.W67.
4167: !
4168: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
4169: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
4170: !    Matrix Eigensystem Routines, EISPACK Guide,
4171: !    Lecture Notes in Computer Science, Volume 6,
4172: !    Springer Verlag, 1976,
4173: !    ISBN13: 978-3540075462,
4174: !    LC: QA193.M37.
4175: !
4176: !  Parameters:
4177: !
4178: !    Input, integer ( kind = 4 ) N, the order of the matrix.
4179: !
4180: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL.
4181: !    If CBAL is not used, set LOW = 1 and IGH = N.
4182: !
4183: !    Input/output, real ( kind = 8 ) HR(N,N), HI(N,N).  On input, the real and imaginary 
4184: !    parts of the complex upper Hessenberg matrix.  Their lower triangles 
4185: !    below the subdiagonal contain information about the unitary 
4186: !    transformations used in the reduction by CORTH, if performed.  On output,
4187: !    the upper Hessenberg portions of HR and HI have been destroyed.  
4188: !    Therefore, they must be saved before calling COMQR if subsequent 
4189: !    calculation of eigenvectors is to be performed.
4190: !
4191: !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the 
4192: !    eigenvalues.  If an error exit is made, the eigenvalues should be 
4193: !    correct for indices IERR+1,...,N.
4194: !
4195: !    Output, integer ( kind = 4 ) IERR, error flag.
4196: !    0, for normal return,
4197: !    J, if the limit of 30*N iterations is exhausted while the J-th 
4198: !       eigenvalue is being sought.
4199: !
4200:   implicit none
4201: 
4202:   integer ( kind = 4 ) n
4203: 
4204:   integer ( kind = 4 ) en
4205:   integer ( kind = 4 ) enm1
4206:   real    ( kind = 8 ) hi(n,n)
4207:   real    ( kind = 8 ) hr(n,n)
4208:   integer ( kind = 4 ) i
4209:   integer ( kind = 4 ) ierr
4210:   integer ( kind = 4 ) igh
4211:   integer ( kind = 4 ) itn
4212:   integer ( kind = 4 ) its
4213:   integer ( kind = 4 ) j
4214:   integer ( kind = 4 ) l
4215:   integer ( kind = 4 ) ll
4216:   integer ( kind = 4 ) low
4217:   real    ( kind = 8 ) norm
4218:   real    ( kind = 8 ) pythag
4219:   real    ( kind = 8 ) si
4220:   real    ( kind = 8 ) sr
4221:   real    ( kind = 8 ) ti
4222:   real    ( kind = 8 ) tr
4223:   real    ( kind = 8 ) tst1
4224:   real    ( kind = 8 ) tst2
4225:   real    ( kind = 8 ) wi(n)
4226:   real    ( kind = 8 ) wr(n)
4227:   real    ( kind = 8 ) xi
4228:   real    ( kind = 8 ) xr
4229:   real    ( kind = 8 ) yi
4230:   real    ( kind = 8 ) yr
4231:   real    ( kind = 8 ) zzi
4232:   real    ( kind = 8 ) zzr
4233: 
4234:   ierr = 0
4235: !
4236: !  Create real subdiagonal elements.
4237: !
4238:   l = low + 1
4239: 
4240:   do i = l, igh
4241: 
4242:      ll = min ( i+1, igh )
4243: 
4244:      if ( hi(i,i-1) /= 0.0D+00 ) then
4245: 
4246:      norm = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( hr(i,i-1), hi(i,i-1) )
4247:      yr = hr(i,i-1) / norm
4248:      yi = hi(i,i-1) / norm
4249:      hr(i,i-1) = norm
4250:      hi(i,i-1) = 0.0D+00
4251: 
4252:      do j = i, igh
4253:        si = yr * hi(i,j) - yi * hr(i,j)
4254:        hr(i,j) = yr * hr(i,j) + yi * hi(i,j)
4255:        hi(i,j) = si
4256:      end do
4257: 
4258:      do j = low, ll
4259:        si = yr * hi(j,i) + yi * hr(j,i)
4260:        hr(j,i) = yr * hr(j,i) - yi * hi(j,i)
4261:        hi(j,i) = si
4262:      end do
4263: 
4264:     end if
4265: 
4266:   end do
4267: !
4268: !  Store roots isolated by CBAL.
4269: !
4270:   do i = 1, n
4271:     if ( i < low .or. i > igh ) then
4272:       wr(i) = hr(i,i)
4273:       wi(i) = hi(i,i)
4274:     end if
4275:   end do
4276: 
4277:   en = igh
4278:   tr = 0.0D+00
4279:   ti = 0.0D+00
4280:   itn = 30 * n
4281: !
4282: !  Search for next eigenvalue.
4283: !
4284:   220 continue
4285: 
4286:   if ( en < low ) then
4287:     return
4288:   end if
4289: 
4290:   its = 0
4291:   enm1 = en - 1
4292: !
4293: !  Look for single small sub-diagonal element.
4294: !
4295:   240 continue
4296: 
4297:   do ll = low, en
4298:     l = en + low - ll
4299:     if ( l == low ) then
4300:       exit
4301:     end if
4302:     tst1 = abs ( hr(l-1,l-1) ) + abs ( hi(l-1,l-1) ) + abs ( hr(l,l) ) &
4303:       + abs ( hi(l,l) )
4304:     tst2 = tst1 + abs ( hr(l,l-1) )
4305:     if ( tst2 == tst1 ) then
4306:       exit
4307:     end if
4308:   end do
4309: !
4310: !  Form shift.
4311: !
4312:   if ( l == en ) then
4313:     go to 660
4314:   end if
4315: 
4316:   if ( itn == 0 ) go to 1000
4317: 
4318:   if ( its == 10 .or. its == 20 ) go to 320
4319:   sr = hr(en,en)
4320:   si = hi(en,en)
4321:   xr = hr(enm1,en) * hr(en,enm1)
4322:   xi = hi(enm1,en) * hr(en,enm1)
4323:   if ( xr == 0.0D+00 .and. xi == 0.0D+00 ) go to 340
4324:   yr = (hr(enm1,enm1) - sr) / 2.0D+00
4325:   yi = (hi(enm1,enm1) - si) / 2.0D+00
4326: 
4327:   call <a href="./eispack.f90.html#csroot" TARGET=CENT_PANEL>csroot</a> ( yr**2-yi**2+xr, 2.0D+00*yr*yi+xi, zzr, zzi )
4328: 
4329:   if ( yr * zzr + yi * zzi < 0.0D+00 ) then
4330:     zzr = -zzr
4331:     zzi = -zzi
4332:   end if
4333: 
4334:   call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( xr, xi, yr+zzr, yi+zzi, xr, xi )
4335:   sr = sr - xr
4336:   si = si - xi
4337:   go to 340
4338: !
4339: !  Form exceptional shift.
4340: !
4341: 320 continue
4342: 
4343:   sr = abs ( hr(en,enm1) ) + abs ( hr(enm1,en-2) )
4344:   si = 0.0D+00
4345: 
4346: 340 continue
4347: 
4348:   do i = low, en
4349:     hr(i,i) = hr(i,i) - sr
4350:     hi(i,i) = hi(i,i) - si
4351:   end do
4352: 
4353:   tr = tr + sr
4354:   ti = ti + si
4355:   its = its + 1
4356:   itn = itn - 1
4357: !
4358: !  Reduce to triangle (rows).
4359: !
4360:   do i = l+1, en
4361: 
4362:      sr = hr(i,i-1)
4363:      hr(i,i-1) = 0.0D+00
4364:      norm = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( hr(i-1,i-1), hi(i-1,i-1) ), sr )
4365:      xr = hr(i-1,i-1) / norm
4366:      wr(i-1) = xr
4367:      xi = hi(i-1,i-1) / norm
4368:      wi(i-1) = xi
4369:      hr(i-1,i-1) = norm
4370:      hi(i-1,i-1) = 0.0D+00
4371:      hi(i,i-1) = sr / norm
4372: 
4373:      do j = i, en
4374:         yr = hr(i-1,j)
4375:         yi = hi(i-1,j)
4376:         zzr = hr(i,j)
4377:         zzi = hi(i,j)
4378:         hr(i-1,j) = xr * yr + xi * yi + hi(i,i-1) * zzr
4379:         hi(i-1,j) = xr * yi - xi * yr + hi(i,i-1) * zzi
4380:         hr(i,j) = xr * zzr - xi * zzi - hi(i,i-1) * yr
4381:         hi(i,j) = xr * zzi + xi * zzr - hi(i,i-1) * yi
4382:     end do
4383: 
4384:   end do
4385: 
4386:   si = hi(en,en)
4387: 
4388:   if ( si /= 0.0D+00 ) then
4389:     norm = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( hr(en,en), si )
4390:     sr = hr(en,en) / norm
4391:     si = si / norm
4392:     hr(en,en) = norm
4393:     hi(en,en) = 0.0D+00
4394:   end if
4395: !
4396: !  Inverse operation (columns).
4397: !
4398:   do j = l+1, en
4399: 
4400:      xr = wr(j-1)
4401:      xi = wi(j-1)
4402: 
4403:      do i = l, j
4404: 
4405:         yr = hr(i,j-1)
4406:         yi = 0.0D+00
4407:         zzr = hr(i,j)
4408:         zzi = hi(i,j)
4409:         if ( i /= j ) then
4410:           yi = hi(i,j-1)
4411:           hi(i,j-1) = xr * yi + xi * yr + hi(j,j-1) * zzi
4412:         end if
4413:         hr(i,j-1) = xr * yr - xi * yi + hi(j,j-1) * zzr
4414:         hr(i,j) = xr * zzr + xi * zzi - hi(j,j-1) * yr
4415:         hi(i,j) = xr * zzi - xi * zzr - hi(j,j-1) * yi
4416: 
4417:      end do
4418: 
4419:   end do
4420: 
4421:   if ( si /= 0.0D+00 ) then
4422: 
4423:     do i = l, en
4424:       yr = hr(i,en)
4425:       yi = hi(i,en)
4426:       hr(i,en) = sr * yr - si * yi
4427:       hi(i,en) = sr * yi + si * yr
4428:     end do
4429: 
4430:   end if
4431: 
4432:   go to 240
4433: !
4434: !  A root found.
4435: !
4436: 660 continue
4437: 
4438:   wr(en) = hr(en,en) + tr
4439:   wi(en) = hi(en,en) + ti
4440:   en = enm1
4441:   go to 220
4442: !
4443: !  Set error: all eigenvalues have not converged after 30*n iterations.
4444: !
4445: 1000 continue
4446: 
4447:   ierr = en
4448:   return
4449: end
<p><a name=comqr2><H3>comqr2</H3></a></p> Click <a href="./callingtree/comqr2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where comqr2 is used.
<hr>
4450: subroutine comqr2 ( n, low, igh, ortr, orti, hr, hi, wr, wi, zr, zi, ierr )
4451: 
4452: !*****************************************************************************80
4453: !
4454: !! COMQR2 gets eigenvalues/vectors of a complex upper Hessenberg matrix.
4455: !
4456: !  Discussion:
4457: !
4458: !    This subroutine finds the eigenvalues and eigenvectors
4459: !    of a complex upper Hessenberg matrix by the QR
4460: !    method.  The eigenvectors of a complex general matrix
4461: !    can also be found if CORTH has been used to reduce
4462: !    this general matrix to Hessenberg form.
4463: !
4464: !  Licensing:
4465: !
4466: !    This code is distributed under the GNU LGPL license.
4467: !
4468: !  Modified:
4469: !
4470: !    18 October 2009
4471: !
4472: !  Author:
4473: !
4474: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
4475: !    Klema, Moler.
4476: !    FORTRAN90 version by John Burkardt.
4477: !
4478: !  Reference:
4479: !
4480: !    James Wilkinson, Christian Reinsch,
4481: !    Handbook for Automatic Computation,
4482: !    Volume II, Linear Algebra, Part 2,
4483: !    Springer, 1971,
4484: !    ISBN: 0387054146,
4485: !    LC: QA251.W67.
4486: !
4487: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
4488: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
4489: !    Matrix Eigensystem Routines, EISPACK Guide,
4490: !    Lecture Notes in Computer Science, Volume 6,
4491: !    Springer Verlag, 1976,
4492: !    ISBN13: 978-3540075462,
4493: !    LC: QA193.M37.
4494: !
4495: !  Parameters:
4496: !
4497: !    Input, integer ( kind = 4 ) N, the order of the matrix.
4498: !
4499: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL.
4500: !    If CBAL is not used, set LOW = 1 and IGH = N.
4501: !
4502: !    Input/output, real ( kind = 8 ) ORTR(N), ORTI(N).  On input, information about the 
4503: !    unitary transformations used in the reduction by CORTH, if performed.
4504: !    If the eigenvectors of the Hessenberg matrix are desired, set ORTR(J) and
4505: !    ORTI(J) to 0.0D+00 for these elements.  On output, these arrays
4506: !    have been overwritten.
4507: !
4508: !    Input/output, real ( kind = 8 ) HR(N,N), HI(N,N).  On input, the real and imaginary 
4509: !    parts of the complex upper Hessenberg matrix.  Their lower triangles 
4510: !    below the subdiagonal contain further information about the 
4511: !    transformations which were used in the reduction by CORTH, if performed.  
4512: !    If the eigenvectors of the Hessenberg matrix are desired, these elements 
4513: !    may be arbitrary.
4514: !
4515: !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the 
4516: !    eigenvalues.  If an error exit is made, the eigenvalues should be 
4517: !    correct for indices IERR+1,...,N.
4518: !
4519: !    Output, real ( kind = 8 ) ZR(N,N), ZI(N,N), the real and imaginary parts of the 
4520: !    eigenvectors.  The eigenvectors are unnormalized.  If an error exit 
4521: !    is made, none of the eigenvectors has been found.
4522: !
4523: !    Output, integer ( kind = 4 ) IERR, error flag.
4524: !    0, for normal return,
4525: !    J, if the limit of 30*N iterations is exhausted while the J-th 
4526: !      eigenvalue is being sought.
4527: !
4528:   implicit none
4529: 
4530:   integer ( kind = 4 ) igh
4531:   integer ( kind = 4 ) n
4532: 
4533:   integer ( kind = 4 ) en
4534:   integer ( kind = 4 ) enm1
4535:   real    ( kind = 8 ) hi(n,n)
4536:   real    ( kind = 8 ) hr(n,n)
4537:   integer ( kind = 4 ) i
4538:   integer ( kind = 4 ) iend
4539:   integer ( kind = 4 ) ierr
4540:   integer ( kind = 4 ) ii
4541:   integer ( kind = 4 ) itn
4542:   integer ( kind = 4 ) its
4543:   integer ( kind = 4 ) j
4544:   integer ( kind = 4 ) jj
4545:   integer ( kind = 4 ) k
4546:   integer ( kind = 4 ) l
4547:   integer ( kind = 4 ) ll
4548:   integer ( kind = 4 ) low
4549:   integer ( kind = 4 ) m
4550:   integer ( kind = 4 ) nn
4551:   real    ( kind = 8 ) norm
4552:   real    ( kind = 8 ) orti(igh)
4553:   real    ( kind = 8 ) ortr(igh)
4554:   real    ( kind = 8 ) pythag
4555:   real    ( kind = 8 ) si
4556:   real    ( kind = 8 ) sr
4557:   real    ( kind = 8 ) ti
4558:   real    ( kind = 8 ) tr
4559:   real    ( kind = 8 ) tst1
4560:   real    ( kind = 8 ) tst2
4561:   real    ( kind = 8 ) wi(n)
4562:   real    ( kind = 8 ) wr(n)
4563:   real    ( kind = 8 ) xi
4564:   real    ( kind = 8 ) xr
4565:   real    ( kind = 8 ) yi
4566:   real    ( kind = 8 ) yr
4567:   real    ( kind = 8 ) zi(n,n)
4568:   real    ( kind = 8 ) zr(n,n)
4569:   real    ( kind = 8 ) zzi 
4570:   real    ( kind = 8 ) zzr
4571: 
4572:   ierr = 0
4573: !
4574: !  Initialize eigenvector matrix.
4575: !
4576:   zr(1:n,1:n) = 0.0D+00
4577: 
4578:   do i = 1, n
4579:     zr(i,i) = 1.0D+00
4580:   end do
4581: 
4582:   zi(1:n,1:n) = 0.0D+00
4583: !
4584: !  Form the matrix of accumulated transformations from the information 
4585: !  left by CORTH.
4586: !
4587:   iend = igh - low - 1
4588:   if ( iend < 0 ) then
4589:     go to 180
4590:   else if ( iend == 0 ) then
4591:     go to 150
4592:   else
4593:     go to 105
4594:   end if
4595: 
4596: 105 continue
4597: 
4598:   do ii = 1, iend
4599: 
4600:      i = igh - ii
4601:      if ( ortr(i) == 0.0D+00 .and. orti(i) == 0.0D+00 ) go to 140
4602:      if ( hr(i,i-1) == 0.0D+00 .and. hi(i,i-1) == 0.0D+00 ) go to 140
4603: !
4604: !  Norm below is negative of H formed in CORTH.
4605: !
4606:      norm = hr(i,i-1) * ortr(i) + hi(i,i-1) * orti(i)
4607: 
4608:      do k = i+1, igh
4609:        ortr(k) = hr(k,i-1)
4610:        orti(k) = hi(k,i-1)
4611:      end do
4612: 
4613:      do j = i, igh
4614: 
4615:         sr = 0.0D+00
4616:         si = 0.0D+00
4617: 
4618:         do k = i, igh
4619:           sr = sr + ortr(k) * zr(k,j) + orti(k) * zi(k,j)
4620:           si = si + ortr(k) * zi(k,j) - orti(k) * zr(k,j)
4621:         end do
4622: 
4623:         sr = sr / norm
4624:         si = si / norm
4625: 
4626:         do k = i, igh
4627:           zr(k,j) = zr(k,j) + sr * ortr(k) - si * orti(k)
4628:           zi(k,j) = zi(k,j) + sr * orti(k) + si * ortr(k)
4629:         end do
4630: 
4631:       end do
4632: 
4633: 140 continue
4634: 
4635:   end do
4636: !
4637: !  Create real subdiagonal elements.
4638: !
4639: 150 continue
4640: 
4641:   l = low + 1
4642: 
4643:   do i = l, igh
4644: 
4645:      ll = min ( i+1, igh )
4646: 
4647:      if ( hi(i,i-1) == 0.0D+00 ) then
4648:        go to 170
4649:      end if
4650: 
4651:      norm = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( hr(i,i-1), hi(i,i-1) )
4652:      yr = hr(i,i-1) / norm
4653:      yi = hi(i,i-1) / norm
4654:      hr(i,i-1) = norm
4655:      hi(i,i-1) = 0.0D+00
4656: 
4657:      do j = i, n
4658:        si = yr * hi(i,j) - yi * hr(i,j)
4659:        hr(i,j) = yr * hr(i,j) + yi * hi(i,j)
4660:        hi(i,j) = si
4661:      end do
4662: 
4663:      do j = 1, ll
4664:        si = yr * hi(j,i) + yi * hr(j,i)
4665:        hr(j,i) = yr * hr(j,i) - yi * hi(j,i)
4666:        hi(j,i) = si
4667:      end do
4668: 
4669:      do j = low, igh
4670:        si = yr * zi(j,i) + yi * zr(j,i)
4671:        zr(j,i) = yr * zr(j,i) - yi * zi(j,i)
4672:        zi(j,i) = si
4673:      end do
4674: 
4675: 170 continue
4676: 
4677:   end do
4678: !
4679: !  Store roots isolated by CBAL.
4680: !
4681: 180 continue
4682: 
4683:   do i = 1, n
4684:     if ( i < low .or. i > igh) then
4685:       wr(i) = hr(i,i)
4686:       wi(i) = hi(i,i)
4687:     end if
4688:   end do
4689: 
4690:   en = igh
4691:   tr = 0.0D+00
4692:   ti = 0.0D+00
4693:   itn = 30 * n
4694: !
4695: !  Search for next eigenvalue.
4696: !
4697: 220 continue
4698: 
4699:   if ( en < low ) go to 680
4700:   its = 0
4701:   enm1 = en - 1
4702: !
4703: !  Look for single small sub-diagonal element.
4704: !
4705: 240 continue
4706: 
4707:   do ll = low, en
4708:     l = en + low - ll
4709:     if ( l == low ) then
4710:       exit
4711:     end if
4712:     tst1 = abs ( hr(l-1,l-1) ) + abs ( hi(l-1,l-1) ) + abs ( hr(l,l) ) &
4713:       + abs ( hi(l,l) )
4714:     tst2 = tst1 + abs ( hr(l,l-1) )
4715:     if ( tst2 == tst1 ) then
4716:       exit
4717:     end if
4718:   end do
4719: !
4720: !  Form shift.
4721: !
4722:   if ( l == en ) go to 660
4723:   if ( itn == 0 ) go to 1000
4724:   if ( its == 10 .or. its == 20 ) go to 320
4725:   sr = hr(en,en)
4726:   si = hi(en,en)
4727:   xr = hr(enm1,en) * hr(en,enm1)
4728:   xi = hi(enm1,en) * hr(en,enm1)
4729:   if ( xr == 0.0D+00 .and. xi == 0.0D+00 ) go to 340
4730:   yr = ( hr(enm1,enm1) - sr ) / 2.0D+00
4731:   yi = ( hi(enm1,enm1) - si ) / 2.0D+00
4732: 
4733:   call <a href="./eispack.f90.html#csroot" TARGET=CENT_PANEL>csroot</a> ( yr**2-yi**2+xr, 2.0D+00*yr*yi+xi, zzr, zzi )
4734: 
4735:   if ( yr * zzr + yi * zzi < 0.0D+00 ) then
4736:     zzr = -zzr
4737:     zzi = -zzi
4738:   end if
4739: 
4740:   call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( xr, xi, yr+zzr, yi+zzi, xr, xi )
4741:   sr = sr - xr
4742:   si = si - xi
4743:   go to 340
4744: !
4745: !  Form exceptional shift.
4746: !
4747: 320 continue
4748: 
4749:   sr = abs ( hr(en,enm1) ) + abs ( hr(enm1,en-2) )
4750:   si = 0.0D+00
4751: 
4752: 340 continue
4753: 
4754:   do i = low, en
4755:     hr(i,i) = hr(i,i) - sr
4756:     hi(i,i) = hi(i,i) - si
4757:   end do
4758: 
4759:   tr = tr + sr
4760:   ti = ti + si
4761:   its = its + 1
4762:   itn = itn - 1
4763: !
4764: !  Reduce to triangle (rows).
4765: !
4766:   do i = l+1, en
4767: 
4768:      sr = hr(i,i-1)
4769:      hr(i,i-1) = 0.0D+00
4770:      norm = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( hr(i-1,i-1), hi(i-1,i-1) ), sr )
4771:      xr = hr(i-1,i-1) / norm
4772:      wr(i-1) = xr
4773:      xi = hi(i-1,i-1) / norm
4774:      wi(i-1) = xi
4775:      hr(i-1,i-1) = norm
4776:      hi(i-1,i-1) = 0.0D+00
4777:      hi(i,i-1) = sr / norm
4778: 
4779:      do j = i, n
4780:         yr = hr(i-1,j)
4781:         yi = hi(i-1,j)
4782:         zzr = hr(i,j)
4783:         zzi = hi(i,j)
4784:         hr(i-1,j) = xr * yr + xi * yi + hi(i,i-1) * zzr
4785:         hi(i-1,j) = xr * yi - xi * yr + hi(i,i-1) * zzi
4786:         hr(i,j) = xr * zzr - xi * zzi - hi(i,i-1) * yr
4787:         hi(i,j) = xr * zzi + xi * zzr - hi(i,i-1) * yi
4788:      end do
4789: 
4790:   end do
4791: 
4792:   si = hi(en,en)
4793: 
4794:   if ( si /= 0.0D+00 ) then
4795: 
4796:     norm = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( hr(en,en), si )
4797:     sr = hr(en,en) / norm
4798:     si = si / norm
4799:     hr(en,en) = norm
4800:     hi(en,en) = 0.0D+00
4801: 
4802:     do j = en+1, n
4803:       yr = hr(en,j)
4804:       yi = hi(en,j)
4805:       hr(en,j) = sr * yr + si * yi
4806:       hi(en,j) = sr * yi - si * yr
4807:     end do
4808: 
4809:   end if
4810: !
4811: !  Inverse operation (columns).
4812: !
4813:   do j = l+1, en
4814: 
4815:      xr = wr(j-1)
4816:      xi = wi(j-1)
4817: 
4818:      do i = 1, j
4819: 
4820:        yr = hr(i,j-1)
4821:        yi = 0.0D+00
4822:        zzr = hr(i,j)
4823:        zzi = hi(i,j)
4824: 
4825:        if ( i /= j ) then
4826:          yi = hi(i,j-1)
4827:          hi(i,j-1) = xr * yi + xi * yr + hi(j,j-1) * zzi
4828:        end if
4829: 
4830:        hr(i,j-1) = xr * yr - xi * yi + hi(j,j-1) * zzr
4831:        hr(i,j) = xr * zzr + xi * zzi - hi(j,j-1) * yr
4832:        hi(i,j) = xr * zzi - xi * zzr - hi(j,j-1) * yi
4833: 
4834:      end do
4835: 
4836:      do i = low, igh
4837:        yr = zr(i,j-1)
4838:        yi = zi(i,j-1)
4839:        zzr = zr(i,j)
4840:        zzi = zi(i,j)
4841:        zr(i,j-1) = xr * yr - xi * yi + hi(j,j-1) * zzr
4842:        zi(i,j-1) = xr * yi + xi * yr + hi(j,j-1) * zzi
4843:        zr(i,j) = xr * zzr + xi * zzi - hi(j,j-1) * yr
4844:        zi(i,j) = xr * zzi - xi * zzr - hi(j,j-1) * yi
4845:      end do
4846: 
4847:   end do
4848: 
4849:   if ( si /= 0.0D+00 ) then
4850: 
4851:     do i = 1, en
4852:       yr = hr(i,en)
4853:       yi = hi(i,en)
4854:       hr(i,en) = sr * yr - si * yi
4855:       hi(i,en) = sr * yi + si * yr
4856:     end do
4857: 
4858:     do i = low, igh
4859:       yr = zr(i,en)
4860:       yi = zi(i,en)
4861:       zr(i,en) = sr * yr - si * yi
4862:       zi(i,en) = sr * yi + si * yr
4863:     end do
4864: 
4865:   end if
4866: 
4867:   go to 240
4868: !
4869: !  A root found.
4870: !
4871: 660 continue
4872: 
4873:   hr(en,en) = hr(en,en) + tr
4874:   wr(en) = hr(en,en)
4875:   hi(en,en) = hi(en,en) + ti
4876:   wi(en) = hi(en,en)
4877:   en = enm1
4878:   go to 220
4879: !
4880: !  All roots found.  
4881: !  Backsubstitute to find vectors of upper triangular form.
4882: !
4883: 680 continue
4884: 
4885:   norm = 0.0D+00
4886: 
4887:   do i = 1, n
4888:     do j = i, n
4889:       tr = abs ( hr(i,j) ) + abs ( hi(i,j) )
4890:       norm = max ( norm, tr )
4891:     end do
4892:   end do
4893: 
4894:   if ( n == 1 ) then
4895:     return
4896:   end if
4897: 
4898:   if ( norm == 0.0D+00 ) then
4899:     return
4900:   end if
4901: 
4902:   do nn = 2, n
4903: 
4904:      en = n + 2 - nn
4905:      xr = wr(en)
4906:      xi = wi(en)
4907:      hr(en,en) = 1.0D+00
4908:      hi(en,en) = 0.0D+00
4909:      enm1 = en - 1
4910: 
4911:      do ii = 1, enm1
4912: 
4913:         i = en - ii
4914:         zzr = 0.0D+00
4915:         zzi = 0.0D+00
4916: 
4917:         do j = i+1, en
4918:           zzr = zzr + hr(i,j) * hr(j,en) - hi(i,j) * hi(j,en)
4919:           zzi = zzi + hr(i,j) * hi(j,en) + hi(i,j) * hr(j,en)
4920:         end do
4921: 
4922:         yr = xr - wr(i)
4923:         yi = xi - wi(i)
4924: 
4925:         if ( yr == 0.0D+00 .and. yi == 0.0D+00 ) then
4926: 
4927:            tst1 = norm
4928:            yr = tst1
4929:            do
4930:              yr = 0.01D+00 * yr
4931:              tst2 = norm + yr
4932:              if ( tst2 <= tst1 ) then
4933:                exit
4934:              end if
4935:            end do
4936: 
4937:         end if
4938: 
4939:         call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( zzr, zzi, yr, yi, hr(i,en), hi(i,en) )
4940: !
4941: !  Overflow control.
4942: !
4943:         tr = abs ( hr(i,en) ) + abs ( hi(i,en) )
4944: 
4945:         if ( tr /= 0.0D+00 ) then
4946: 
4947:           tst1 = tr
4948:           tst2 = tst1 + 1.0D+00 / tst1
4949: 
4950:           if ( tst2 <= tst1 ) then
4951: 
4952:             do j = i, en
4953:               hr(j,en) = hr(j,en)/tr
4954:               hi(j,en) = hi(j,en)/tr
4955:             end do
4956: 
4957:           end if
4958: 
4959:        end if
4960: 
4961:      end do
4962: 
4963:   end do
4964: !
4965: !  End backsubstitution.
4966: !
4967:   enm1 = n - 1
4968: !
4969: !  Vectors of isolated roots.
4970: !
4971:   do i = 1, n - 1
4972: 
4973:     if ( i < low .or. i > igh ) then
4974: 
4975:       do j = i+1, n
4976:         zr(i,j) = hr(i,j)
4977:         zi(i,j) = hi(i,j)
4978:       end do
4979: 
4980:     end if
4981: 
4982:   end do
4983: !
4984: !  Multiply by transformation matrix to give vectors of original full matrix.
4985: !
4986:   do jj = low, n - 1
4987: 
4988:      j = n + low - jj
4989:      m = min ( j, igh )
4990: 
4991:      do i = low, igh
4992: 
4993:         zzr = 0.0D+00
4994:         zzi = 0.0D+00
4995:         do k = low, m
4996:           zzr = zzr + zr(i,k) * hr(k,j) - zi(i,k) * hi(k,j)
4997:           zzi = zzi + zr(i,k) * hi(k,j) + zi(i,k) * hr(k,j)
4998:         end do
4999: 
5000:         zr(i,j) = zzr
5001:         zi(i,j) = zzi
5002: 
5003:       end do
5004: 
5005:   end do
5006: 
5007:   return
5008: !
5009: !  Set error: all eigenvalues have not converged after 30*n iterations.
5010: !
5011: 1000 continue
5012: 
5013:   ierr = en
5014:   return
5015: end
<p><a name=cortb><H3>cortb</H3></a></p> Click <a href="./callingtree/cortb_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cortb is used.
<hr>
5016: subroutine cortb ( n, low, igh, ar, ai, ortr, orti, m, zr, zi )
5017: 
5018: !*****************************************************************************80
5019: !
5020: !! CORTB determines eigenvectors by undoing the CORTH transformation.
5021: !
5022: !  Discussion:
5023: !
5024: !    This subroutine forms the eigenvectors of a complex general
5025: !    matrix by back transforming those of the corresponding
5026: !    upper Hessenberg matrix determined by CORTH.
5027: !
5028: !  Licensing:
5029: !
5030: !    This code is distributed under the GNU LGPL license.
5031: !
5032: !  Modified:
5033: !
5034: !    18 October 2009
5035: !
5036: !  Author:
5037: !
5038: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
5039: !    Klema, Moler.
5040: !    FORTRAN90 version by John Burkardt.
5041: !
5042: !  Reference:
5043: !
5044: !    James Wilkinson, Christian Reinsch,
5045: !    Handbook for Automatic Computation,
5046: !    Volume II, Linear Algebra, Part 2,
5047: !    Springer, 1971,
5048: !    ISBN: 0387054146,
5049: !    LC: QA251.W67.
5050: !
5051: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
5052: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
5053: !    Matrix Eigensystem Routines, EISPACK Guide,
5054: !    Lecture Notes in Computer Science, Volume 6,
5055: !    Springer Verlag, 1976,
5056: !    ISBN13: 978-3540075462,
5057: !    LC: QA193.M37.
5058: !
5059: !  Parameters:
5060: !
5061: !    Input, integer ( kind = 4 ) N, the order of the matrix.
5062: !
5063: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL.
5064: !    If CBAL is not used, set LOW = 1 and IGH to the order of the matrix.
5065: !
5066: !    Input, real ( kind = 8 ) AR(N,IGH), AI(N,IGH), information about the unitary
5067: !    transformations used in the reduction by CORTH in their strict lower 
5068: !    triangles.
5069: !
5070: !    Input/output, real ( kind = 8 ) ORTR(IGH), ORTI(IGH).  On input, further information 
5071: !    about the transformations used in the reduction by CORTH.  On output,
5072: !    ORTR and ORTI have been further altered.
5073: !
5074: !    Input, integer ( kind = 4 ) M, the number of columns of ZR and ZI to be back
5075: !    transformed.
5076: !
5077: !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, the real and imaginary 
5078: !    parts of the eigenvectors to be back transformed.  On output, the real 
5079: !    and imaginary parts of the transformed eigenvectors.
5080: !
5081:   implicit none
5082: 
5083:   integer ( kind = 4 ) igh
5084:   integer ( kind = 4 ) m
5085:   integer ( kind = 4 ) n
5086: 
5087:   real    ( kind = 8 ) ai(n,igh)
5088:   real    ( kind = 8 ) ar(n,igh)
5089:   real    ( kind = 8 ) gi
5090:   real    ( kind = 8 ) gr
5091:   real    ( kind = 8 ) h
5092:   integer ( kind = 4 ) i
5093:   integer ( kind = 4 ) j
5094:   integer ( kind = 4 ) la
5095:   integer ( kind = 4 ) low
5096:   integer ( kind = 4 ) mm
5097:   integer ( kind = 4 ) mp
5098:   real    ( kind = 8 ) orti(igh)
5099:   real    ( kind = 8 ) ortr(igh)
5100:   real    ( kind = 8 ) zi(n,m)
5101:   real    ( kind = 8 ) zr(n,m)
5102: 
5103:   if ( m == 0 ) then
5104:     return
5105:   end if
5106: 
5107:   la = igh - 1
5108: 
5109:   if ( igh - 1 < low + 1 ) then
5110:     return
5111:   end if
5112: 
5113:   do mm = low + 1, la
5114: 
5115:     mp = low + igh - mm
5116: 
5117:     if ( ar(mp,mp-1) /= 0.0D+00 .or. ai(mp,mp-1) /= 0.0D+00 ) then
5118: 
5119:       h = ar(mp,mp-1) * ortr(mp) + ai(mp,mp-1) * orti(mp)
5120: 
5121:       ortr(mp+1:igh) = ar(mp+1:igh,mp-1)
5122:       orti(mp+1:igh) = ai(mp+1:igh,mp-1)
5123: 
5124:       do j = 1, m
5125: 
5126:         gr = ( dot_product ( ortr(mp:igh), zr(mp:igh,j) ) &
5127:              + dot_product ( orti(mp:igh), zi(mp:igh,j) ) ) / h
5128: 
5129:         gi = ( dot_product ( ortr(mp:igh), zi(mp:igh,j) ) &
5130:              - dot_product ( orti(mp:igh), zr(mp:igh,j) ) ) / h
5131: 
5132:         do i = mp, igh
5133:           zr(i,j) = zr(i,j) + gr * ortr(i) - gi * orti(i)
5134:           zi(i,j) = zi(i,j) + gr * orti(i) + gi * ortr(i)
5135:         end do
5136: 
5137:       end do
5138: 
5139:     end if
5140: 
5141:   end do
5142: 
5143:   return
5144: end
<p><a name=corth><H3>corth</H3></a></p> Click <a href="./callingtree/corth_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where corth is used.
<hr>
5145: subroutine corth ( n, low, igh, ar, ai, ortr, orti )
5146: 
5147: !*****************************************************************************80
5148: !
5149: !! CORTH transforms a complex general matrix to upper Hessenberg form.
5150: !
5151: !  Discussion:
5152: !
5153: !    Given a complex general matrix, this subroutine
5154: !    reduces a submatrix situated in rows and columns
5155: !    LOW through IGH to upper Hessenberg form by
5156: !    unitary similarity transformations.
5157: !
5158: !  Licensing:
5159: !
5160: !    This code is distributed under the GNU LGPL license.
5161: !
5162: !  Modified:
5163: !
5164: !    18 October 2009
5165: !
5166: !  Author:
5167: !
5168: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
5169: !    Klema, Moler.
5170: !    FORTRAN90 version by John Burkardt.
5171: !
5172: !  Reference:
5173: !
5174: !    James Wilkinson, Christian Reinsch,
5175: !    Handbook for Automatic Computation,
5176: !    Volume II, Linear Algebra, Part 2,
5177: !    Springer, 1971,
5178: !    ISBN: 0387054146,
5179: !    LC: QA251.W67.
5180: !
5181: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
5182: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
5183: !    Matrix Eigensystem Routines, EISPACK Guide,
5184: !    Lecture Notes in Computer Science, Volume 6,
5185: !    Springer Verlag, 1976,
5186: !    ISBN13: 978-3540075462,
5187: !    LC: QA193.M37.
5188: !
5189: !  Parameters:
5190: !
5191: !    Input, integer ( kind = 4 ) N, the order of the matrix.
5192: !
5193: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL.
5194: !    If CBAL is not used, set LOW = 1 and IGH = N.
5195: !
5196: !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and imaginary 
5197: !    parts of the complex input matrix.  On output, the real and imaginary
5198: !    parts of the Hessenberg matrix.  Information about the unitary 
5199: !    transformations used in the reduction is stored in the remaining 
5200: !    triangles under the Hessenberg matrix.
5201: !
5202: !    Output, real ( kind = 8 ) ORTR(IGH), ORTI(IGH), further information about the
5203: !    transformations.
5204: !
5205:   implicit none
5206: 
5207:   integer ( kind = 4 ) igh
5208:   integer ( kind = 4 ) n
5209: 
5210:   real    ( kind = 8 ) ai(n,n)
5211:   real    ( kind = 8 ) ar(n,n)
5212:   real    ( kind = 8 ) f
5213:   real    ( kind = 8 ) fi
5214:   real    ( kind = 8 ) fr
5215:   real    ( kind = 8 ) g
5216:   real    ( kind = 8 ) h
5217:   integer ( kind = 4 ) i
5218:   integer ( kind = 4 ) ii
5219:   integer ( kind = 4 ) j
5220:   integer ( kind = 4 ) jj
5221:   integer ( kind = 4 ) la
5222:   integer ( kind = 4 ) m,mp,low
5223:   real    ( kind = 8 ) orti(igh)
5224:   real    ( kind = 8 ) ortr(igh)
5225:   real    ( kind = 8 ) pythag
5226:   real    ( kind = 8 ) xscale
5227: 
5228:   la = igh - 1
5229: 
5230:   if ( igh - 1 < low + 1 ) then
5231:     return
5232:   end if
5233: 
5234:   do m = low + 1, la
5235: 
5236:     h = 0.0D+00
5237:     ortr(m) = 0.0D+00
5238:     orti(m) = 0.0D+00
5239:     xscale = 0.0D+00
5240: !
5241: !  Scale column.
5242: !
5243:     do i = m, igh
5244:       xscale = xscale + abs ( ar(i,m-1) ) + abs ( ai(i,m-1) )
5245:     end do
5246: 
5247:     if ( xscale == 0.0D+00 ) then
5248:       cycle
5249:     end if
5250: 
5251:     mp = m + igh
5252: 
5253:     do ii = m, igh
5254:       i = mp - ii
5255:       ortr(i) = ar(i,m-1) / xscale
5256:       orti(i) = ai(i,m-1) / xscale
5257:       h = h + ortr(i) * ortr(i) + orti(i) * orti(i)
5258:     end do
5259: 
5260:     g = sqrt ( h )
5261:     f = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( ortr(m), orti(m) )
5262: 
5263:     if ( f /= 0.0D+00 ) then
5264:       h = h + f * g
5265:       g = g / f
5266:       ortr(m) = ( 1.0D+00 + g ) * ortr(m)
5267:       orti(m) = ( 1.0D+00 + g ) * orti(m)
5268:     else
5269:       ortr(m) = g
5270:       ar(m,m-1) = xscale
5271:     end if
5272: !
5273: !  Form (I-(U*Ut)/h) * A.
5274: !
5275:     do j = m, n
5276: 
5277:       fr = 0.0D+00
5278:       fi = 0.0D+00
5279: 
5280:       do ii = m, igh
5281:         i = mp - ii
5282:         fr = fr + ortr(i) * ar(i,j) + orti(i) * ai(i,j)
5283:         fi = fi + ortr(i) * ai(i,j) - orti(i) * ar(i,j)
5284:       end do
5285: 
5286:       fr = fr / h
5287:       fi = fi / h
5288: 
5289:       ar(m:igh,j) = ar(m:igh,j) - fr * ortr(m:igh) + fi * orti(m:igh)
5290:       ai(m:igh,j) = ai(m:igh,j) - fr * orti(m:igh) - fi * ortr(m:igh)
5291: 
5292:     end do
5293: !
5294: !  Form (I-(U*Ut)/h) * A * (I-(U*Ut)/h)
5295: !
5296:     do i = 1, igh
5297: 
5298:       fr = 0.0D+00
5299:       fi = 0.0D+00
5300: 
5301:       do jj = m, igh
5302:         j = mp - jj
5303:         fr = fr + ortr(j) * ar(i,j) - orti(j) * ai(i,j)
5304:         fi = fi + ortr(j) * ai(i,j) + orti(j) * ar(i,j)
5305:       end do
5306: 
5307:       fr = fr / h
5308:       fi = fi / h
5309: 
5310:       ar(i,m:igh) = ar(i,m:igh) - fr * ortr(m:igh) - fi * orti(m:igh)
5311:       ai(i,m:igh) = ai(i,m:igh) + fr * orti(m:igh) - fi * ortr(m:igh)
5312: 
5313:     end do
5314: 
5315:     ortr(m) = xscale * ortr(m)
5316:     orti(m) = xscale * orti(m)
5317:     ar(m,m-1) = - g * ar(m,m-1)
5318:     ai(m,m-1) = - g * ai(m,m-1)
5319: 
5320:   end do
5321: 
5322:   return
5323: end
<p><a name=csroot><H3>csroot</H3></a></p> Click <a href="./callingtree/csroot_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where csroot is used.
<hr>
5324: subroutine csroot ( xr, xi, yr, yi )
5325: 
5326: !*****************************************************************************80
5327: !
5328: !! CSROOT computes the complex square root of a complex quantity.
5329: !
5330: !  Discussion:
5331: !
5332: !    The branch of the square function is chosen so that 
5333: !      YR >= 0.0D+00 
5334: !    and 
5335: !      sign ( YI ) == sign ( XI )
5336: !
5337: !  Licensing:
5338: !
5339: !    This code is distributed under the GNU LGPL license.
5340: !
5341: !  Modified:
5342: !
5343: !    18 October 2009
5344: !
5345: !  Author:
5346: !
5347: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
5348: !    Klema, Moler.
5349: !    FORTRAN90 version by John Burkardt.
5350: !
5351: !  Reference:
5352: !
5353: !    James Wilkinson, Christian Reinsch,
5354: !    Handbook for Automatic Computation,
5355: !    Volume II, Linear Algebra, Part 2,
5356: !    Springer, 1971,
5357: !    ISBN: 0387054146,
5358: !    LC: QA251.W67.
5359: !
5360: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
5361: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
5362: !    Matrix Eigensystem Routines, EISPACK Guide,
5363: !    Lecture Notes in Computer Science, Volume 6,
5364: !    Springer Verlag, 1976,
5365: !    ISBN13: 978-3540075462,
5366: !    LC: QA193.M37.
5367: !
5368: !  Parameters:
5369: !
5370: !    Input, real ( kind = 8 ) XR, XI, the real and imaginary parts of the quantity
5371: !    whose square root is desired.
5372: !
5373: !    Output, real ( kind = 8 ) YR, YI, the real and imaginary parts of the square root.
5374: !
5375:   implicit none
5376: 
5377:   real    ( kind = 8 ) pythag
5378:   real    ( kind = 8 ) s
5379:   real    ( kind = 8 ) ti
5380:   real    ( kind = 8 ) tr
5381:   real    ( kind = 8 ) xi
5382:   real    ( kind = 8 ) xr
5383:   real    ( kind = 8 ) yi
5384:   real    ( kind = 8 ) yr
5385: 
5386:   tr = xr
5387:   ti = xi
5388:   s = sqrt ( 0.5D+00 * ( <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( tr, ti ) + abs ( tr ) ) )
5389: 
5390:   if ( tr >= 0.0D+00 ) yr = s
5391:   if ( ti < 0.0D+00 ) s = -s
5392:   if ( tr <= 0.0D+00 ) yi = s
5393: 
5394:   if ( tr < 0.0D+00 ) then
5395:     yr = 0.5D+00 * ( ti / yi )
5396:   else if ( tr > 0.0D+00 ) then
5397:     yi = 0.5D+00 * ( ti / yr )
5398:   end if
5399: 
5400:   return
5401: end
<p><a name=elmbak><H3>elmbak</H3></a></p> Click <a href="./callingtree/elmbak_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where elmbak is used.
<hr>
5402: subroutine elmbak ( n, low, igh, a, ind, m, z )
5403: 
5404: !*****************************************************************************80
5405: !
5406: !! ELMBAK determines eigenvectors by undoing the ELMHES transformation.
5407: !
5408: !  Discussion:
5409: !
5410: !    This subroutine forms the eigenvectors of a real general
5411: !    matrix by back transforming those of the corresponding
5412: !    upper Hessenberg matrix determined by ELMHES.
5413: !
5414: !  Licensing:
5415: !
5416: !    This code is distributed under the GNU LGPL license.
5417: !
5418: !  Modified:
5419: !
5420: !    18 October 2009
5421: !
5422: !  Author:
5423: !
5424: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
5425: !    Klema, Moler.
5426: !    FORTRAN90 version by John Burkardt.
5427: !
5428: !  Reference:
5429: !
5430: !    James Wilkinson, Christian Reinsch,
5431: !    Handbook for Automatic Computation,
5432: !    Volume II, Linear Algebra, Part 2,
5433: !    Springer, 1971,
5434: !    ISBN: 0387054146,
5435: !    LC: QA251.W67.
5436: !
5437: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
5438: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
5439: !    Matrix Eigensystem Routines, EISPACK Guide,
5440: !    Lecture Notes in Computer Science, Volume 6,
5441: !    Springer Verlag, 1976,
5442: !    ISBN13: 978-3540075462,
5443: !    LC: QA193.M37.
5444: !
5445: !  Parameters:
5446: !
5447: !    Input, integer ( kind = 4 ) N, the order of the matrix.
5448: !
5449: !    Input, integer ( kind = 4 ) LOW, IGH, integers determined by the balancing
5450: !    routine BALANC.  If BALANC has not been used, set LOW = 1 and 
5451: !    IGH equal to the order of the matrix.
5452: !
5453: !    Input, real ( kind = 8 ) A(N,IGH), the multipliers which were used in the
5454: !    reduction by ELMHES in its lower triangle below the subdiagonal.
5455: !
5456: !    Input, integer ( kind = 4 ) IND(IGH), information on the rows and columns
5457: !    interchanged in the reduction by ELMHES.
5458: !
5459: !    Input, integer ( kind = 4 ) M, the number of columns of Z to be back transformed.
5460: !
5461: !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the real and imaginary parts 
5462: !    of the eigenvectors to be back transformed.  On output, the real and 
5463: !    imaginary parts of the transformed eigenvectors.
5464: !
5465:   implicit none
5466: 
5467:   integer ( kind = 4 ) igh
5468:   integer ( kind = 4 ) m
5469:   integer ( kind = 4 ) n
5470: 
5471:   real    ( kind = 8 ) a(n,igh)
5472:   integer ( kind = 4 ) i
5473:   integer ( kind = 4 ) ind(igh)
5474:   integer ( kind = 4 ) j
5475:   integer ( kind = 4 ) la
5476:   integer ( kind = 4 ) low
5477:   integer ( kind = 4 ) mm
5478:   integer ( kind = 4 ) mp
5479:   real    ( kind = 8 ) x
5480:   real    ( kind = 8 ) z(n,m)
5481: 
5482:   if ( m == 0 ) then
5483:     return
5484:   end if
5485: 
5486:   la = igh - 1
5487: 
5488:   if ( la < low + 1 ) then
5489:     return
5490:   end if
5491: 
5492:   do mm = low + 1, la
5493: 
5494:      mp = low + igh - mm
5495: 
5496:      do i = mp+1, igh
5497: 
5498:        x = a(i,mp-1)
5499:        if ( x /= 0.0D+00 ) then
5500:          do j = 1, m
5501:            z(i,j) = z(i,j) + x * z(mp,j)
5502:          end do
5503:        end if
5504: 
5505:      end do
5506: 
5507:      i = ind(mp)
5508: 
5509:      if ( i /= mp ) then
5510: 
5511:        do j = 1, m
5512:          call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( z(i,j), z(mp,j) )
5513:        end do
5514: 
5515:      end if
5516: 
5517:   end do
5518: 
5519:   return
5520: end
<p><a name=elmhes><H3>elmhes</H3></a></p> Click <a href="./callingtree/elmhes_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where elmhes is used.
<hr>
5521: subroutine elmhes ( n, low, igh, a, ind )
5522: 
5523: !*****************************************************************************80
5524: !
5525: !! ELMHES transforms a real general matrix to upper Hessenberg form.
5526: !
5527: !  Discussion:
5528: !
5529: !    Given a real general matrix, this subroutine reduces a submatrix 
5530: !    situated in rows and columns LOW through IGH to upper Hessenberg 
5531: !    form by stabilized elementary similarity transformations.
5532: !
5533: !  Licensing:
5534: !
5535: !    This code is distributed under the GNU LGPL license.
5536: !
5537: !  Modified:
5538: !
5539: !    18 October 2009
5540: !
5541: !  Author:
5542: !
5543: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
5544: !    Klema, Moler.
5545: !    FORTRAN90 version by John Burkardt.
5546: !
5547: !  Reference:
5548: !
5549: !    Martin and Wilkinson,
5550: !    ELMHES,
5551: !    Numerische Mathematik,
5552: !    Volume 12, pages 349-368, 1968.
5553: !
5554: !    James Wilkinson, Christian Reinsch,
5555: !    Handbook for Automatic Computation,
5556: !    Volume II, Linear Algebra, Part 2,
5557: !    Springer, 1971,
5558: !    ISBN: 0387054146,
5559: !    LC: QA251.W67.
5560: !
5561: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
5562: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
5563: !    Matrix Eigensystem Routines, EISPACK Guide,
5564: !    Lecture Notes in Computer Science, Volume 6,
5565: !    Springer Verlag, 1976,
5566: !    ISBN13: 978-3540075462,
5567: !    LC: QA193.M37.
5568: !
5569: !  Parameters:
5570: !
5571: !    Input, integer ( kind = 4 ) N, the order of the matrix.
5572: !
5573: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine  
5574: !    BALANC.  If BALANC has not been used, set LOW = 1, IGH = N.
5575: !
5576: !    Input/output, real ( kind = 8 ) A(N,N).  On input, the matrix to be reduced.
5577: !    On output, the Hessenberg matrix.  The multipliers
5578: !    which were used in the reduction are stored in the
5579: !    remaining triangle under the Hessenberg matrix.
5580: !
5581: !    Output, integer ( kind = 4 ) IND(N), contains information on the rows and columns
5582: !    interchanged in the reduction.  Only elements LOW through IGH are used.
5583: !
5584:   implicit none
5585: 
5586:   integer ( kind = 4 ) igh
5587:   integer ( kind = 4 ) n
5588: 
5589:   real    ( kind = 8 ) a(n,n)
5590:   integer ( kind = 4 ) i
5591:   integer ( kind = 4 ) ind(igh)
5592:   integer ( kind = 4 ) j
5593:   integer ( kind = 4 ) la
5594:   integer ( kind = 4 ) low
5595:   integer ( kind = 4 ) m
5596:   real    ( kind = 8 ) x
5597:   real    ( kind = 8 ) y
5598: 
5599:   la = igh - 1
5600: 
5601:   do m = low + 1, la
5602: 
5603:     x = 0.0D+00
5604:     i = m
5605: 
5606:     do j = m, igh
5607:       if ( abs ( a(j,m-1) ) > abs ( x ) ) then
5608:         x = a(j,m-1)
5609:         i = j
5610:       end if
5611:     end do
5612: 
5613:     ind(m) = i
5614: !
5615: !  Interchange rows and columns of the matrix.
5616: !
5617:     if ( i /= m ) then
5618: 
5619:       do j = m-1, n
5620:         call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( a(i,j), a(m,j) )
5621:       end do
5622: 
5623:       do j = 1, igh
5624:         call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( a(j,i), a(j,m) )
5625:       end do
5626: 
5627:     end if
5628: 
5629:     if ( x /= 0.0D+00 ) then
5630: 
5631:       do i = m+1, igh
5632: 
5633:         y = a(i,m-1)
5634: 
5635:         if ( y /= 0.0D+00 ) then
5636: 
5637:           y = y / x
5638:           a(i,m-1) = y
5639: 
5640:           do j = m, n
5641:             a(i,j) = a(i,j) - y * a(m,j)
5642:           end do
5643: 
5644:           a(1:igh,m) = a(1:igh,m) + y * a(1:igh,i)
5645: 
5646:         end if
5647: 
5648:       end do
5649: 
5650:     end if
5651: 
5652:   end do
5653: 
5654:   return
5655: end
<p><a name=eltran><H3>eltran</H3></a></p> Click <a href="./callingtree/eltran_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where eltran is used.
<hr>
5656: subroutine eltran ( n, low, igh, a, ind, z )
5657: 
5658: !*****************************************************************************80
5659: !
5660: !! ELTRAN accumulates similarity transformations used by ELMHES.
5661: !
5662: !  Discussion:
5663: !
5664: !    This subroutine accumulates the stabilized elementary
5665: !    similarity transformations used in the reduction of a
5666: !    real general matrix to upper Hessenberg form by ELMHES.
5667: !
5668: !  Licensing:
5669: !
5670: !    This code is distributed under the GNU LGPL license.
5671: !
5672: !  Modified:
5673: !
5674: !    18 October 2009
5675: !
5676: !  Author:
5677: !
5678: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
5679: !    Klema, Moler.
5680: !    FORTRAN90 version by John Burkardt.
5681: !
5682: !  Reference:
5683: !
5684: !    Peters and WIlkinson,
5685: !    ELMTRANS,
5686: !    Numerische Mathematik,
5687: !    Volume 16, pages 181-204, 1970.
5688: !
5689: !    James Wilkinson, Christian Reinsch,
5690: !    Handbook for Automatic Computation,
5691: !    Volume II, Linear Algebra, Part 2,
5692: !    Springer, 1971,
5693: !    ISBN: 0387054146,
5694: !    LC: QA251.W67.
5695: !
5696: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
5697: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
5698: !    Matrix Eigensystem Routines, EISPACK Guide,
5699: !    Lecture Notes in Computer Science, Volume 6,
5700: !    Springer Verlag, 1976,
5701: !    ISBN13: 978-3540075462,
5702: !    LC: QA193.M37.
5703: !
5704: !  Parameters:
5705: !
5706: !    Input, integer ( kind = 4 ) N, the order of the matrix.
5707: !
5708: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine  
5709: !    BALANC.  If BALANC has not been used, set LOW = 1, IGH = N.
5710: !
5711: !    Input, real ( kind = 8 ) A(N,IGH), the multipliers which were used in the
5712: !    reduction by ELMHES in its lower triangle below the subdiagonal.
5713: !
5714: !    Input, integer ( kind = 4 ) IND(IGH), information on the rows and columns
5715: !    interchanged in the reduction by ELMHES.
5716: !
5717: !    Output, real ( kind = 8 ) Z(N,N), the transformation matrix produced in the
5718: !    reduction by ELMHES.
5719: !
5720:   implicit none
5721: 
5722:   integer ( kind = 4 ) igh
5723:   integer ( kind = 4 ) n
5724: 
5725:   real    ( kind = 8 ) a(n,igh)
5726:   integer ( kind = 4 ) i
5727:   integer ( kind = 4 ) ind(igh)
5728:   integer ( kind = 4 ) kl
5729:   integer ( kind = 4 ) low
5730:   integer ( kind = 4 ) mm
5731:   integer ( kind = 4 ) mp
5732:   real    ( kind = 8 ) z(n,n)
5733: !
5734: !  Initialize Z to the identity matrix.
5735: !
5736:   z(1:n,1:n) = 0.0D+00
5737: 
5738:   do i = 1, n
5739:     z(i,i) = 1.0D+00
5740:   end do
5741: 
5742:   kl = igh - low - 1
5743: 
5744:   if ( kl < 1 ) then
5745:     return
5746:   end if
5747: 
5748:   do mm = 1, kl
5749: 
5750:      mp = igh - mm
5751: 
5752:      do i = mp+1, igh
5753:        z(i,mp) = a(i,mp-1)
5754:      end do
5755: 
5756:      i = ind(mp)
5757: 
5758:      if ( i /= mp ) then
5759: 
5760:        z(mp,mp:igh) = z(i,mp:igh)
5761: 
5762:        z(i,mp) = 1.0D+00
5763:        z(i,mp+1:igh) = 0.0D+00
5764: 
5765:      end if
5766: 
5767:   end do
5768: 
5769:   return
5770: end
<p><a name=figi><H3>figi</H3></a></p> Click <a href="./callingtree/figi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where figi is used.
<hr>
5771: subroutine figi ( n, t, d, e, e2, ierr )
5772: 
5773: !*****************************************************************************80
5774: !
5775: !! FIGI transforms a real nonsymmetric tridiagonal matrix to symmetric form.
5776: !
5777: !  Discussion:
5778: !
5779: !    Given a nonsymmetric tridiagonal matrix such that the products
5780: !    of corresponding pairs of off-diagonal elements are all
5781: !    non-negative, this subroutine reduces it to a symmetric
5782: !    tridiagonal matrix with the same eigenvalues.  If, further,
5783: !    a zero product only occurs when both factors are zero,
5784: !    the reduced matrix is similar to the original matrix.
5785: !
5786: !  Licensing:
5787: !
5788: !    This code is distributed under the GNU LGPL license.
5789: !
5790: !  Modified:
5791: !
5792: !    18 October 2009
5793: !
5794: !  Author:
5795: !
5796: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
5797: !    Klema, Moler.
5798: !    FORTRAN90 version by John Burkardt.
5799: !
5800: !  Reference:
5801: !
5802: !    James Wilkinson, Christian Reinsch,
5803: !    Handbook for Automatic Computation,
5804: !    Volume II, Linear Algebra, Part 2,
5805: !    Springer, 1971,
5806: !    ISBN: 0387054146,
5807: !    LC: QA251.W67.
5808: !
5809: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
5810: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
5811: !    Matrix Eigensystem Routines, EISPACK Guide,
5812: !    Lecture Notes in Computer Science, Volume 6,
5813: !    Springer Verlag, 1976,
5814: !    ISBN13: 978-3540075462,
5815: !    LC: QA193.M37.
5816: !
5817: !  Parameters:
5818: !
5819: !    Input, integer ( kind = 4 ) N, the order of the matrix.
5820: !
5821: !    Input, real ( kind = 8 ) T(N,3) contains the input matrix.  Its subdiagonal is
5822: !    stored in the last N-1 positions of the first column, its diagonal in 
5823: !    the N positions of the second column, and its superdiagonal in the 
5824: !    first N-1 positions of the third column.  T(1,1) and T(N,3) are arbitrary.
5825: !
5826: !    Output, real ( kind = 8 ) D(N), the diagonal elements of the symmetric matrix.
5827: !
5828: !    Output, real ( kind = 8 ) E(N), contains the subdiagonal elements of the symmetric
5829: !    matrix in E(2:N).  E(1) is not set.
5830: !
5831: !    Output, real ( kind = 8 ) E2(N), the squares of the corresponding elements of E.
5832: !    E2 may coincide with E if the squares are not needed.
5833: !
5834: !    Output, integer ( kind = 4 ) IERR, error flag.
5835: !    0, for normal return,
5836: !    N+I, if T(I,1) * T(I-1,3) is negative,
5837: !    -(3*N+I), if T(I,1) * T(I-1,3) is zero with one factor non-zero.  In 
5838: !      this case, the eigenvectors of the symmetric matrix are not simply 
5839: !      related to those of T and should not be sought.
5840: !
5841:   implicit none
5842: 
5843:   integer ( kind = 4 ) n
5844: 
5845:   real    ( kind = 8 ) d(n)
5846:   real    ( kind = 8 ) e(n)
5847:   real    ( kind = 8 ) e2(n)
5848:   integer ( kind = 4 ) i
5849:   integer ( kind = 4 ) ierr
5850:   real    ( kind = 8 ) t(n,3)
5851: 
5852:   ierr = 0
5853: 
5854:   do i = 1, n
5855: 
5856:     if ( i >= 1 ) then
5857: 
5858:       e2(i) = t(i,1) * t(i-1,3)
5859: 
5860:       if ( e2(i) < 0.0D+00 ) then
5861: 
5862:         ierr = n + i
5863:         return
5864: 
5865:       else if ( e2(i) == 0.0D+00 ) then
5866: 
5867:         if ( t(i,1) /= 0.0D+00 .or. t(i-1,3) /= 0.0D+00 ) then
5868:           ierr = - 3 * n - i
5869:           return
5870:         end if
5871: 
5872:         e(i) = 0.0D+00
5873: 
5874:       else
5875: 
5876:         e(i) = sqrt ( e2(i) )
5877: 
5878:       end if
5879: 
5880:     end if
5881: 
5882:     d(i) = t(i,2)
5883: 
5884:   end do
5885: 
5886:   return
5887: end
<p><a name=figi2><H3>figi2</H3></a></p> Click <a href="./callingtree/figi2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where figi2 is used.
<hr>
5888: subroutine figi2 ( n, t, d, e, z, ierr )
5889: 
5890: !*****************************************************************************80
5891: !
5892: !! FIGI2 transforms a real nonsymmetric tridiagonal matrix to symmetric form.
5893: !
5894: !  Discussion:
5895: !
5896: !    Given a nonsymmetric tridiagonal matrix such that the products
5897: !    of corresponding pairs of off-diagonal elements are all
5898: !    non-negative, and zero only when both factors are zero, this
5899: !    subroutine reduces it to a symmetric tridiagonal matrix
5900: !    using and accumulating diagonal similarity transformations.
5901: !
5902: !  Licensing:
5903: !
5904: !    This code is distributed under the GNU LGPL license.
5905: !
5906: !  Modified:
5907: !
5908: !    18 October 2009
5909: !
5910: !  Author:
5911: !
5912: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
5913: !    Klema, Moler.
5914: !    FORTRAN90 version by John Burkardt.
5915: !
5916: !  Reference:
5917: !
5918: !    James Wilkinson, Christian Reinsch,
5919: !    Handbook for Automatic Computation,
5920: !    Volume II, Linear Algebra, Part 2,
5921: !    Springer, 1971,
5922: !    ISBN: 0387054146,
5923: !    LC: QA251.W67.
5924: !
5925: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
5926: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
5927: !    Matrix Eigensystem Routines, EISPACK Guide,
5928: !    Lecture Notes in Computer Science, Volume 6,
5929: !    Springer Verlag, 1976,
5930: !    ISBN13: 978-3540075462,
5931: !    LC: QA193.M37.
5932: !
5933: !  Parameters:
5934: !
5935: !    Input, integer ( kind = 4 ) N, the order of the matrix.
5936: !
5937: !    Input, real ( kind = 8 ) T(N,3) contains the input matrix.  Its subdiagonal is
5938: !    stored in the last N-1 positions of the first column, its diagonal in 
5939: !    the N positions of the second column, and its superdiagonal in the 
5940: !    first N-1 positions of the third column.  T(1,1) and T(N,3) are arbitrary.
5941: !
5942: !    Output, real ( kind = 8 ) D(N), the diagonal elements of the symmetric matrix.
5943: !
5944: !    Output, real ( kind = 8 ) E(N), contains the subdiagonal elements of the symmetric
5945: !    matrix in E(2:N).  E(1) is not set.
5946: !
5947: !    Output, real ( kind = 8 ) Z(N,N), contains the transformation matrix produced in
5948: !    the reduction.
5949: !
5950: !    Output, integer ( kind = 4 ) IERR, error flag.
5951: !    0, for normal return,
5952: !    N+I, if T(I,1) * T(I-1,3) is negative,
5953: !    2*N+I, if T(I,1) * T(I-1,3) is zero with one factor non-zero.
5954: !
5955:   implicit none
5956: 
5957:   integer ( kind = 4 ) n
5958: 
5959:   real    ( kind = 8 ) d(n)
5960:   real    ( kind = 8 ) e(n)
5961:   real    ( kind = 8 ) h
5962:   integer ( kind = 4 ) i
5963:   integer ( kind = 4 ) ierr
5964:   real    ( kind = 8 ) t(n,3)
5965:   real    ( kind = 8 ) z(n,n)
5966: 
5967:   ierr = 0
5968: 
5969:   do i = 1, n
5970: 
5971:     z(i,1:n) = 0.0D+00
5972: 
5973:     if ( i == 1 ) then
5974: 
5975:       z(i,i) = 1.0D+00
5976: 
5977:     else
5978: 
5979:       h = t(i,1) * t(i-1,3)
5980: 
5981:       if ( h < 0.0D+00 ) then
5982: 
5983:         ierr = n + i
5984:         return
5985: 
5986:       else if ( h == 0 ) then
5987: 
5988:         if ( t(i,1) /= 0.0D+00 .or. t(i-1,3) /= 0.0D+00 ) then
5989:           ierr = 2 * n + i
5990:           return
5991:         end if
5992: 
5993:         e(i) = 0.0D+00
5994:         z(i,i) = 1.0D+00
5995: 
5996:       else
5997: 
5998:         e(i) = sqrt ( h )
5999:         z(i,i) = z(i-1,i-1) * e(i) / t(i-1,3)
6000: 
6001:       end if
6002: 
6003:     end if
6004: 
6005:     d(i) = t(i,2)
6006: 
6007:   end do
6008: 
6009:   return
6010: end
<p><a name=hqr><H3>hqr</H3></a></p> Click <a href="./callingtree/hqr_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where hqr is used.
<hr>
6011: subroutine hqr ( n, low, igh, h, wr, wi, ierr )
6012: 
6013: !*****************************************************************************80
6014: !
6015: !! HQR computes all eigenvalues of a real upper Hessenberg matrix.
6016: !
6017: !  Discussion:
6018: !
6019: !    This subroutine finds the eigenvalues of a real
6020: !    upper Hessenberg matrix by the QR method.
6021: !
6022: !  Licensing:
6023: !
6024: !    This code is distributed under the GNU LGPL license.
6025: !
6026: !  Modified:
6027: !
6028: !    18 October 2009
6029: !
6030: !  Author:
6031: !
6032: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
6033: !    Klema, Moler.
6034: !    FORTRAN90 version by John Burkardt.
6035: !
6036: !  Reference:
6037: !
6038: !    Martin, Peters, and Wilkinson,
6039: !    HQR,
6040: !    Numerische Mathematik,
6041: !    Volume 14, pages 219-231, 1970.
6042: !
6043: !    James Wilkinson, Christian Reinsch,
6044: !    Handbook for Automatic Computation,
6045: !    Volume II, Linear Algebra, Part 2,
6046: !    Springer, 1971,
6047: !    ISBN: 0387054146,
6048: !    LC: QA251.W67.
6049: !
6050: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
6051: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
6052: !    Matrix Eigensystem Routines, EISPACK Guide,
6053: !    Lecture Notes in Computer Science, Volume 6,
6054: !    Springer Verlag, 1976,
6055: !    ISBN13: 978-3540075462,
6056: !    LC: QA193.M37.
6057: !
6058: !  Parameters:
6059: !
6060: !    Input, integer ( kind = 4 ) N, the order of the matrix.
6061: !
6062: !    Input, integer ( kind = 4 ) LOW, IGH, two integers determined by the routine
6063: !    BALANC.  If BALANC is not used, set LOW=1, IGH=N.
6064: !
6065: !    Input/output, real ( kind = 8 ) H(N,N), the N by N upper Hessenberg matrix.
6066: !    Information about the transformations used in the reduction to 
6067: !    Hessenberg form by ELMHES or ORTHES, if performed, is stored
6068: !    in the remaining triangle under the Hessenberg matrix.
6069: !    On output, the information in H has been destroyed.
6070: !
6071: !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the
6072: !    eigenvalues.  The eigenvalues are unordered, except that complex
6073: !    conjugate pairs of values appear consecutively, with the eigenvalue
6074: !    having positive imaginary part listed first.  If an error exit
6075: !    occurred, then the eigenvalues should be correct for indices
6076: !    IERR+1 through N.
6077: !
6078: !    Output, integer ( kind = 4 ) IERR, error flag.
6079: !    0, no error.
6080: !    J, the limit of 30*N iterations was reached while searching for
6081: !      the J-th eigenvalue.
6082: !
6083:   implicit none
6084: 
6085:   integer ( kind = 4 ) n
6086: 
6087:   integer ( kind = 4 ) en
6088:   integer ( kind = 4 ) enm2
6089:   real    ( kind = 8 ) h(n,n)
6090:   integer ( kind = 4 ) i
6091:   integer ( kind = 4 ) ierr
6092:   integer ( kind = 4 ) igh
6093:   integer ( kind = 4 ) itn
6094:   integer ( kind = 4 ) its
6095:   integer ( kind = 4 ) j
6096:   integer ( kind = 4 ) k
6097:   integer ( kind = 4 ) l
6098:   integer ( kind = 4 ) ll
6099:   integer ( kind = 4 ) low
6100:   integer ( kind = 4 ) m
6101:   integer ( kind = 4 ) mm
6102:   integer ( kind = 4 ) na
6103:   real    ( kind = 8 ) norm
6104:   logical              notlas
6105:   real    ( kind = 8 ) p
6106:   real    ( kind = 8 ) q
6107:   real    ( kind = 8 ) r
6108:   real    ( kind = 8 ) s
6109:   real    ( kind = 8 ) t
6110:   real    ( kind = 8 ) tst1
6111:   real    ( kind = 8 ) tst2
6112:   real    ( kind = 8 ) w
6113:   real    ( kind = 8 ) wi(n)
6114:   real    ( kind = 8 ) wr(n)
6115:   real    ( kind = 8 ) x
6116:   real    ( kind = 8 ) y
6117:   real    ( kind = 8 ) zz
6118: 
6119:   ierr = 0
6120:   norm = 0.0D+00
6121:   k = 1
6122: !
6123: !  Store roots isolated by BALANC and compute matrix norm.
6124: !
6125:   do i = 1, n
6126: 
6127:     do j = k, n
6128:       norm = norm + abs ( h(i,j) )
6129:     end do
6130: 
6131:     k = i
6132:     if ( i < low .or. i > igh ) then
6133:       wr(i) = h(i,i)
6134:       wi(i) = 0.0D+00
6135:     end if
6136: 
6137:   end do
6138: 
6139:   en = igh
6140:   t = 0.0D+00
6141:   itn = 30 * n
6142: !
6143: !  Search for next eigenvalues.
6144: !
6145: 60 continue
6146: 
6147:   if ( en < low ) then
6148:     return
6149:   end if
6150: 
6151:   its = 0
6152:   na = en - 1
6153:   enm2 = na - 1
6154: !
6155: !  Look for a single small sub-diagonal element.
6156: !
6157: 70 continue
6158: 
6159:   do ll = low, en
6160:     l = en + low - ll
6161:     if ( l == low ) then
6162:       exit
6163:     end if
6164:     s = abs ( h(l-1,l-1) ) + abs ( h(l,l) )
6165:     if ( s == 0.0D+00 ) then
6166:       s = norm
6167:     end if
6168:     tst1 = s
6169:     tst2 = tst1 + abs ( h(l,l-1) )
6170:     if ( tst2 == tst1 ) then
6171:       exit
6172:     end if
6173:   end do
6174: !
6175: !  Form shift.
6176: !
6177:   x = h(en,en)
6178:   if ( l == en ) then
6179:     go to 270
6180:   end if
6181: 
6182:   y = h(na,na)
6183:   w = h(en,na) * h(na,en)
6184: 
6185:   if ( l == na ) then
6186:     go to 280
6187:   end if
6188: 
6189:   if ( itn == 0 ) then
6190:     ierr = en
6191:     return
6192:   end if
6193: !
6194: !  Form an exceptional shift.
6195: !
6196:   if ( its == 10 .or. its == 20 ) then
6197: 
6198:     t = t + x
6199: 
6200:     do i = low, en
6201:       h(i,i) = h(i,i) - x
6202:     end do
6203: 
6204:     s = abs ( h(en,na) ) + abs ( h(na,enm2) )
6205:     x = 0.75D+00 * s
6206:     y = x
6207:     w = -0.4375D+00 * s * s
6208: 
6209:   end if
6210: 
6211:   its = its + 1
6212:   itn = itn - 1
6213: !
6214: !  Look for two consecutive small sub-diagonal elements.
6215: !
6216:   do mm = l, enm2
6217: 
6218:     m = enm2 + l - mm
6219:     zz = h(m,m)
6220:     r = x - zz
6221:     s = y - zz
6222:     p = ( r * s - w ) / h(m+1,m) + h(m,m+1)
6223:     q = h(m+1,m+1) - zz - r - s
6224:     r = h(m+2,m+1)
6225:     s = abs ( p ) + abs ( q ) + abs ( r )
6226:     p = p / s
6227:     q = q / s
6228:     r = r / s
6229: 
6230:     if ( m == l ) then
6231:       exit
6232:     end if
6233: 
6234:     tst1 = abs ( p ) * ( abs ( h(m-1,m-1) ) + abs ( zz ) + abs ( h(m+1,m+1) ) )
6235:     tst2 = tst1 + abs ( h(m,m-1) ) * ( abs ( q ) + abs ( r ) )
6236: 
6237:     if ( tst2 == tst1 ) then
6238:       exit
6239:     end if
6240: 
6241:   end do
6242: 
6243:   do i = m+2, en
6244:     h(i,i-2) = 0.0D+00
6245:     if ( i /= m+2 ) then
6246:       h(i,i-3) = 0.0D+00
6247:     end if
6248:   end do
6249: !
6250: !  Double QR step involving rows l to EN and columns M to EN.
6251: !
6252:   do k = m, na
6253: 
6254:     notlas = k /= na
6255: 
6256:     if ( k /= m ) then
6257: 
6258:       p = h(k,k-1)
6259:       q = h(k+1,k-1)
6260: 
6261:       if ( notlas ) then
6262:         r = h(k+2,k-1)
6263:       else
6264:         r = 0.0D+00
6265:       end if
6266: 
6267:       x = abs ( p ) + abs ( q ) + abs ( r )
6268: 
6269:       if ( x == 0.0D+00 ) then
6270:         cycle
6271:       end if
6272: 
6273:       p = p / x
6274:       q = q / x
6275:       r = r / x
6276: 
6277:     end if
6278: 
6279:     s = sign ( sqrt ( p**2 + q**2 + r**2 ), p )
6280: 
6281:     if ( k /= m ) then
6282:       h(k,k-1) = - s * x
6283:     else if ( l /= m ) then
6284:       h(k,k-1) = - h(k,k-1)
6285:     end if
6286: 
6287:     p = p + s
6288:     x = p / s
6289:     y = q / s
6290:     zz = r / s
6291:     q = q / p
6292:     r = r / p
6293: 
6294:     if ( .not. notlas ) then
6295: !
6296: !  Row modification.
6297: !
6298:       do j = k, n
6299:         p = h(k,j) + q * h(k+1,j)
6300:         h(k,j) = h(k,j) - p * x
6301:         h(k+1,j) = h(k+1,j) - p * y
6302:       end do
6303: 
6304:       j = min ( en, k+3 )
6305: !
6306: !  Column modification.
6307: !
6308:       do i = 1, j
6309:         p = x * h(i,k) + y * h(i,k+1)
6310:         h(i,k) = h(i,k) - p
6311:         h(i,k+1) = h(i,k+1) - p * q
6312:       end do
6313: 
6314:     else
6315: !
6316: !  Row modification.
6317: !
6318:       do j = k, n
6319:         p = h(k,j) + q * h(k+1,j) + r * h(k+2,j)
6320:         h(k,j) = h(k,j) - p * x
6321:         h(k+1,j) = h(k+1,j) - p * y
6322:         h(k+2,j) = h(k+2,j) - p * zz
6323:       end do
6324: 
6325:       j = min ( en, k+3 )
6326: !
6327: !  Column modification.
6328: !
6329:       do i = 1, j
6330:         p = x * h(i,k) + y * h(i,k+1) + zz * h(i,k+2)
6331:         h(i,k) = h(i,k) - p
6332:         h(i,k+1) = h(i,k+1) - p * q
6333:         h(i,k+2) = h(i,k+2) - p * r
6334:       end do
6335: 
6336:     end if
6337: 
6338:   end do
6339: 
6340:   go to 70
6341: !
6342: !  One root found.
6343: !
6344: 270 continue
6345: 
6346:   wr(en) = x + t
6347:   wi(en) = 0.0D+00
6348:   en = na
6349:   go to 60
6350: !
6351: !  Two roots found.
6352: !
6353: 280 continue
6354: 
6355:   p = ( y - x ) / 2.0D+00
6356:   q = p * p + w
6357:   zz = sqrt ( abs ( q ) )
6358:   x = x + t
6359: !
6360: !  Real root, or complex pair.
6361: !
6362:   if ( q >= 0.0D+00 ) then
6363: 
6364:     zz = p + sign ( zz, p )
6365:     wr(na) = x + zz
6366:     if ( zz == 0.0D+00 ) then
6367:       wr(en) = wr(na)
6368:     else
6369:       wr(en) = x - w / zz
6370:     end if
6371:     wi(na) = 0.0D+00
6372:     wi(en) = 0.0D+00
6373: 
6374:   else
6375: 
6376:     wr(na) = x + p
6377:     wr(en) = x + p
6378:     wi(na) = zz
6379:     wi(en) = -zz
6380: 
6381:   end if
6382: 
6383:   en = enm2
6384:   go to 60
6385: end
<p><a name=hqr2><H3>hqr2</H3></a></p> Click <a href="./callingtree/hqr2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where hqr2 is used.
<hr>
6386: subroutine hqr2 ( n, low, igh, h, wr, wi, z, ierr )
6387: 
6388: !*****************************************************************************80
6389: !
6390: !! HQR2 computes eigenvalues and eigenvectors of a real upper Hessenberg matrix.
6391: !
6392: !  Discussion:
6393: !
6394: !    This subroutine finds the eigenvalues and eigenvectors
6395: !    of a real upper Hessenberg matrix by the qr method.  the
6396: !    eigenvectors of a real general matrix can also be found
6397: !    if ELMHES and ELTRAN or ORTHES and ORTRAN have
6398: !    been used to reduce this general matrix to Hessenberg form
6399: !    and to accumulate the similarity transformations.
6400: !
6401: !  Licensing:
6402: !
6403: !    This code is distributed under the GNU LGPL license.
6404: !
6405: !  Modified:
6406: !
6407: !    18 October 2009
6408: !
6409: !  Author:
6410: !
6411: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
6412: !    Klema, Moler.
6413: !    FORTRAN90 version by John Burkardt.
6414: !
6415: !  Reference:
6416: !
6417: !    James Wilkinson, Christian Reinsch,
6418: !    Handbook for Automatic Computation,
6419: !    Volume II, Linear Algebra, Part 2,
6420: !    Springer, 1971,
6421: !    ISBN: 0387054146,
6422: !    LC: QA251.W67.
6423: !
6424: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
6425: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
6426: !    Matrix Eigensystem Routines, EISPACK Guide,
6427: !    Lecture Notes in Computer Science, Volume 6,
6428: !    Springer Verlag, 1976,
6429: !    ISBN13: 978-3540075462,
6430: !    LC: QA193.M37.
6431: !
6432: !  Parameters:
6433: !
6434: !    Input, integer ( kind = 4 ) N, the order of the matrix.
6435: !
6436: !    Input, integer ( kind = 4 ) LOW, IGH, determined by the balancing routine BALANC.  
6437: !    If BALANC has not been used, set LOW = 1, IGH = N.
6438: !
6439: !    Input/output, real ( kind = 8 ) H(N,N), the N by N upper Hessenberg matrix.
6440: !    On output, the information in H has been destroyed.
6441: !
6442: !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the
6443: !    eigenvalues.  The eigenvalues are unordered, except that complex
6444: !    conjugate pairs of values appear consecutively, with the eigenvalue
6445: !    having positive imaginary part listed first.  If an error exit
6446: !    occurred, then the eigenvalues should be correct for indices
6447: !    IERR+1 through N.
6448: !
6449: !    Input/output, real ( kind = 8 ) Z(N,N).  On input, the transformation matrix 
6450: !    produced by ELTRAN after the reduction by ELMHES, or by ORTRAN after the
6451: !    reduction by ORTHES, if performed.  If the eigenvectors of the Hessenberg 
6452: !    matrix are desired, Z must contain the identity matrix.  On output,
6453: !    Z contains the real and imaginary parts of the eigenvectors.
6454: !    If the I-th eigenvalue is real, the I-th column of Z contains its 
6455: !    eigenvector.  If the I-th eigenvalue is complex with positive imaginary 
6456: !    part, the I-th and (I+1)-th columns of Z contain the real and imaginary 
6457: !    parts of its eigenvector.  The eigenvectors are unnormalized.  If an
6458: !    error exit is made, none of the eigenvectors has been found.
6459: !
6460: !    Output, integer ( kind = 4 ) IERR, error flag.
6461: !    0, for normal return,
6462: !    J, if the limit of 30*N iterations is exhausted while the J-th 
6463: !      eigenvalue is being sought.
6464: !
6465:   implicit none
6466: 
6467:   integer ( kind = 4 ) n
6468: 
6469:   integer ( kind = 4 ) en
6470:   integer ( kind = 4 ) enm2
6471:   real    ( kind = 8 ) h(n,n)
6472:   integer ( kind = 4 ) i
6473:   integer ( kind = 4 ) ierr
6474:   integer ( kind = 4 ) igh
6475:   integer ( kind = 4 ) ii
6476:   integer ( kind = 4 ) itn
6477:   integer ( kind = 4 ) its
6478:   integer ( kind = 4 ) j
6479:   integer ( kind = 4 ) jj
6480:   integer ( kind = 4 ) k
6481:   integer ( kind = 4 ) l
6482:   integer ( kind = 4 ) ll
6483:   integer ( kind = 4 ) low
6484:   integer ( kind = 4 ) m
6485:   integer ( kind = 4 ) mm
6486:   integer ( kind = 4 ) na
6487:   integer ( kind = 4 ) nn
6488:   real    ( kind = 8 ) norm
6489:   logical              notlas
6490:   real    ( kind = 8 ) p
6491:   real    ( kind = 8 ) q
6492:   real    ( kind = 8 ) r
6493:   real    ( kind = 8 ) ra
6494:   real    ( kind = 8 ) s
6495:   real    ( kind = 8 ) sa
6496:   real    ( kind = 8 ) t
6497:   real    ( kind = 8 ) tst1
6498:   real    ( kind = 8 ) tst2
6499:   real    ( kind = 8 ) vi
6500:   real    ( kind = 8 ) vr
6501:   real    ( kind = 8 ) w
6502:   real    ( kind = 8 ) wi(n)
6503:   real    ( kind = 8 ) wr(n)
6504:   real    ( kind = 8 ) x
6505:   real    ( kind = 8 ) y
6506:   real    ( kind = 8 ) z(n,n)
6507:   real    ( kind = 8 ) zz
6508: 
6509:   ierr = 0
6510:   norm = 0.0D+00
6511:   k = 1
6512: !
6513: !  Store roots isolated by BALANC and compute the matrix norm.
6514: !
6515:   do i = 1, n
6516: 
6517:     do j = k, n
6518:       norm = norm + abs ( h(i,j) )
6519:     end do
6520: 
6521:     k = i
6522:     if ( i < low .or. i > igh ) then
6523:       wr(i) = h(i,i)
6524:       wi(i) = 0.0D+00
6525:     end if
6526: 
6527:   end do
6528: 
6529:   en = igh
6530:   t = 0.0D+00
6531:   itn = 30 * n
6532: !
6533: !  Search for next eigenvalues.
6534: !
6535: 60 continue
6536: 
6537:   if ( en < low ) then
6538:     go to 340
6539:   end if
6540: 
6541:   its = 0
6542:   na = en - 1
6543:   enm2 = na - 1
6544: !
6545: !  Look for single small sub-diagonal element.
6546: !
6547: 70 continue
6548: 
6549:   do ll = low, en
6550: 
6551:     l = en + low - ll
6552: 
6553:     if ( l == low ) then
6554:       exit
6555:     end if
6556: 
6557:     s = abs ( h(l-1,l-1) ) + abs ( h(l,l) )
6558:     if ( s == 0.0D+00 ) then
6559:       s = norm
6560:     end if
6561: 
6562:     tst1 = s
6563:     tst2 = tst1 + abs ( h(l,l-1) )
6564: 
6565:     if ( tst2 == tst1 ) then
6566:       exit
6567:     end if
6568: 
6569:   end do
6570: !
6571: !  Form shift.
6572: !
6573:   x = h(en,en)
6574:   if ( l == en ) then
6575:     go to 270
6576:   end if
6577: 
6578:   y = h(na,na)
6579:   w = h(en,na) * h(na,en)
6580: 
6581:   if ( l == na ) then
6582:     go to 280
6583:   end if
6584: 
6585:   if ( itn == 0 ) then
6586:     ierr = en
6587:     return
6588:   end if
6589: !
6590: !  Form exceptional shift.
6591: !
6592:   if ( its == 10 .or. its == 20 ) then
6593: 
6594:     t = t + x
6595: 
6596:     do i = low, en
6597:       h(i,i) = h(i,i) - x
6598:     end do
6599: 
6600:     s = abs ( h(en,na) ) + abs ( h(na,enm2) )
6601:     x = 0.75D+00 * s
6602:     y = x
6603:     w = -0.4375D+00 * s * s
6604: 
6605:   end if
6606: 
6607:   its = its + 1
6608:   itn = itn - 1
6609: !
6610: !  Look for two consecutive small sub-diagonal elements.
6611: !
6612:   do mm = l, enm2
6613:      m = enm2 + l - mm
6614:      zz = h(m,m)
6615:      r = x - zz
6616:      s = y - zz
6617:      p = ( r * s - w ) / h(m+1,m) + h(m,m+1)
6618:      q = h(m+1,m+1) - zz - r - s
6619:      r = h(m+2,m+1)
6620:      s = abs ( p ) + abs ( q ) + abs ( r )
6621:      p = p / s
6622:      q = q / s
6623:      r = r / s
6624:      if ( m == l ) then
6625:        exit
6626:      end if
6627: 
6628:      tst1 = abs ( p ) * ( abs ( h(m-1,m-1) ) + abs ( zz ) + abs ( h(m+1,m+1) ) )
6629:      tst2 = tst1 + abs ( h(m,m-1) ) * ( abs ( q ) + abs ( r ) ) 
6630:      if ( tst2 == tst1 ) then
6631:        exit
6632:      end if
6633: 
6634:   end do
6635: 
6636:   do i = m+2, en
6637:     h(i,i-2) = 0.0D+00
6638:     if ( i /= m+2 ) then
6639:       h(i,i-3) = 0.0D+00
6640:     end if
6641:   end do
6642: !
6643: !  Double QR step involving rows L to EN and columns M to EN.
6644: !
6645:   do k = m, na
6646: 
6647:      notlas = k /= na
6648: 
6649:      if ( k /= m ) then
6650: 
6651:        p = h(k,k-1)
6652:        q = h(k+1,k-1)
6653:        r = 0.0D+00
6654:        if ( notlas ) then
6655:          r = h(k+2,k-1)
6656:        end if
6657: 
6658:        x = abs ( p ) + abs ( q ) + abs ( r )
6659:        if ( x == 0.0D+00 ) then
6660:          cycle
6661:        end if
6662: 
6663:        p = p / x
6664:        q = q / x
6665:        r = r / x
6666: 
6667:      end if
6668: 
6669:      s = sign ( sqrt ( p**2 + q**2 + r**2 ), p )
6670: 
6671:      if ( k /= m ) then
6672:        h(k,k-1) = - s * x
6673:      else if ( l /= m ) then
6674:        h(k,k-1) = -h(k,k-1)
6675:      end if
6676: 
6677:      p = p + s
6678:      x = p / s
6679:      y = q / s
6680:      zz = r / s
6681:      q = q / p
6682:      r = r / p
6683:      if ( notlas ) go to 225
6684: !
6685: !  Row modification.
6686: !
6687:      do j = k, n
6688:        p = h(k,j) + q * h(k+1,j)
6689:        h(k,j) = h(k,j) - p * x
6690:        h(k+1,j) = h(k+1,j) - p * y
6691:      end do
6692: 
6693:      j = min ( en, k+3 )
6694: !
6695: !  Column modification.
6696: !
6697:      do i = 1, j
6698:        p = x * h(i,k) + y * h(i,k+1)
6699:        h(i,k) = h(i,k) - p
6700:        h(i,k+1) = h(i,k+1) - p * q
6701:      end do
6702: !
6703: !  Accumulate transformations.
6704: !
6705:      do i = low, igh
6706:        p = x * z(i,k) + y * z(i,k+1)
6707:        z(i,k) = z(i,k) - p
6708:        z(i,k+1) = z(i,k+1) - p * q
6709:      end do
6710: 
6711:      go to 255
6712: 
6713: 225  continue
6714: !
6715: !  Row modification.
6716: !
6717:      do j = k, n
6718:        p = h(k,j) + q * h(k+1,j) + r * h(k+2,j)
6719:        h(k,j) = h(k,j) - p * x
6720:        h(k+1,j) = h(k+1,j) - p * y
6721:        h(k+2,j) = h(k+2,j) - p * zz
6722:      end do
6723: 
6724:      j = min ( en, k+3 )
6725: !
6726: !  Column modification.
6727: !
6728:      do i = 1, j
6729:        p = x * h(i,k) + y * h(i,k+1) + zz * h(i,k+2)
6730:        h(i,k) = h(i,k) - p
6731:        h(i,k+1) = h(i,k+1) - p * q
6732:        h(i,k+2) = h(i,k+2) - p * r
6733:      end do
6734: !
6735: !  Accumulate transformations.
6736: !
6737:      do i = low, igh
6738:         p = x * z(i,k) + y * z(i,k+1) + zz * z(i,k+2)
6739:         z(i,k) = z(i,k) - p
6740:         z(i,k+1) = z(i,k+1) - p * q
6741:         z(i,k+2) = z(i,k+2) - p * r
6742:      end do
6743: 
6744: 255 continue
6745: 
6746:   end do
6747: 
6748:   go to 70
6749: !
6750: !  One root found.
6751: !
6752: 270 continue
6753: 
6754:   h(en,en) = x + t
6755:   wr(en) = h(en,en)
6756:   wi(en) = 0.0D+00
6757:   en = na
6758:   go to 60
6759: !
6760: !  Two roots found.
6761: !
6762: 280 continue
6763: 
6764:   p = ( y - x ) / 2.0D+00
6765:   q = p * p + w
6766:   zz = sqrt ( abs ( q ) )
6767:   h(en,en) = x + t
6768:   x = h(en,en)
6769:   h(na,na) = y + t
6770: 
6771:   if ( q < 0.0D+00 ) go to 320
6772: !
6773: !  Real pair.
6774: !
6775:   zz = p + sign ( zz, p )
6776:   wr(na) = x + zz
6777:   wr(en) = wr(na)
6778: 
6779:   if ( zz /= 0.0D+00 ) then
6780:     wr(en) = x - w / zz
6781:   end if
6782: 
6783:   wi(na) = 0.0D+00
6784:   wi(en) = 0.0D+00
6785:   x = h(en,na)
6786:   s = abs ( x ) + abs ( zz )
6787:   p = x / s
6788:   q = zz / s
6789:   r = sqrt ( p**2 + q**2 )
6790:   p = p / r
6791:   q = q / r
6792: !
6793: !  Row modification.
6794: !
6795:   do j = na, n
6796:     zz = h(na,j)
6797:     h(na,j) = q * zz + p * h(en,j)
6798:     h(en,j) = q * h(en,j) - p * zz
6799:   end do
6800: !
6801: !  Column modification.
6802: !
6803:   do i = 1, en
6804:     zz = h(i,na)
6805:     h(i,na) = q * zz + p * h(i,en)
6806:     h(i,en) = q * h(i,en) - p * zz
6807:   end do
6808: !
6809: !  Accumulate transformations.
6810: !
6811:   do i = low, igh
6812:     zz = z(i,na)
6813:     z(i,na) = q * zz + p * z(i,en)
6814:     z(i,en) = q * z(i,en) - p * zz
6815:   end do
6816: 
6817:   go to 330
6818: !
6819: !  Complex pair
6820: !
6821: 320 continue
6822: 
6823:   wr(na) = x + p
6824:   wr(en) = x + p
6825:   wi(na) = zz
6826:   wi(en) = -zz
6827: 
6828: 330 continue
6829: 
6830:   en = enm2
6831:   go to 60
6832: !
6833: !  All roots found.  
6834: !  Backsubstitute to find vectors of upper triangular form.
6835: !
6836: 340 continue
6837: 
6838:   if ( norm == 0.0D+00 ) then
6839:     return
6840:   end if
6841: 
6842:   do nn = 1, n
6843: 
6844:      en = n + 1 - nn
6845:      p = wr(en)
6846:      q = wi(en)
6847:      na = en - 1
6848: 
6849:      if ( q < 0 ) then
6850:         go to 710
6851:      else if ( q == 0 ) then
6852:         go to 600
6853:      else
6854:         go to 800
6855:      end if
6856: 
6857: !
6858: !  Real vector
6859: !
6860: 600  continue
6861: 
6862:      m = en
6863:      h(en,en) = 1.0D+00
6864: 
6865:      if ( na == 0 ) go to 800
6866: 
6867:      do ii = 1, na
6868: 
6869:         i = en - ii
6870:         w = h(i,i) - p
6871:         r = dot_product ( h(i,m:en), h(m:en,en) )
6872: 
6873:         if ( wi(i) < 0.0D+00 ) then
6874:           zz = w
6875:           s = r
6876:           go to 700
6877:         end if
6878: 
6879:         m = i
6880:         if ( wi(i) /= 0.0D+00 ) go to 640
6881:         t = w
6882: 
6883:         if ( t == 0.0D+00 ) then
6884: 
6885:           tst1 = norm
6886:           t = tst1
6887: 
6888:           do
6889:             t = 0.01D+00 * t
6890:             tst2 = norm + t
6891:             if ( tst2 <= tst1 ) then
6892:               exit
6893:             end if
6894:           end do
6895: 
6896:         end if
6897: 
6898:         h(i,en) = -r / t
6899:         go to 680
6900: !
6901: !  Solve real equations.
6902: !
6903: 640     continue
6904: 
6905:         x = h(i,i+1)
6906:         y = h(i+1,i)
6907:         q = ( wr(i) - p ) * ( wr(i) - p) + wi(i) * wi(i)
6908:         t = ( x * s - zz * r ) / q
6909:         h(i,en) = t
6910: 
6911:         if ( abs ( x ) > abs ( zz ) ) then
6912:           h(i+1,en) = (-r - w * t) / x
6913:         else
6914:           h(i+1,en) = (-s - y * t) / zz
6915:         end if
6916: !
6917: !  Overflow control.
6918: !
6919: 680     continue
6920: 
6921:         t = abs ( h(i,en) )
6922: 
6923:         if ( t /= 0.0D+00 ) then
6924: 
6925:           tst1 = t
6926:           tst2 = tst1 + 1.0D+00 / tst1
6927: 
6928:           if ( tst2 <= tst1 ) then
6929:             h(i:en,en) = h(i:en,en) / t
6930:           end if
6931: 
6932:         end if
6933: 
6934: 700   continue
6935: 
6936:     end do
6937: !
6938: !  End real vector
6939: !
6940:      go to 800
6941: !
6942: !  Complex vector
6943: !
6944: 710  continue
6945: 
6946:      m = na
6947: !
6948: !  Last vector component chosen imaginary, so that the eigenvector 
6949: !  matrix is triangular.
6950: !
6951:      if ( abs ( h(en,na) ) > abs ( h(na,en) ) ) then
6952: 
6953:        h(na,na) = q / h(en,na)
6954:        h(na,en) = -(h(en,en) - p) / h(en,na)
6955: 
6956:      else
6957: 
6958:        call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( 0.0D+00, -h(na,en), h(na,na)-p, q, h(na,na), h(na,en) )
6959: 
6960:      end if
6961: 
6962:      h(en,na) = 0.0D+00
6963:      h(en,en) = 1.0D+00
6964:      enm2 = na - 1
6965: 
6966:      do ii = 1, enm2
6967: 
6968:         i = na - ii
6969:         w = h(i,i) - p
6970:         ra = dot_product ( h(i,m:en), h(m:en,na) )
6971:         sa = dot_product ( h(i,m:en), h(m:en,en) )
6972: 
6973:         if ( wi(i) < 0.0D+00 ) then
6974:           zz = w
6975:           r = ra
6976:           s = sa
6977:         end if
6978: 
6979:          m = i
6980: 
6981:         if ( wi(i) == 0.0D+00 ) then
6982:           call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( -ra, -sa, w, q, h(i,na), h(i,en) )
6983:           go to 790
6984:         end if
6985: !
6986: !  Solve complex equations.
6987: !
6988:         x = h(i,i+1)
6989:         y = h(i+1,i)
6990:         vr = ( wr(i) - p ) * ( wr(i) - p ) + wi(i) * wi(i) - q * q
6991:         vi = ( wr(i) - p ) * 2.0D+00 * q
6992: 
6993:         if ( vr == 0.0D+00 .and. vi == 0.0D+00 ) then
6994: 
6995:           tst1 = norm * ( abs ( w ) + abs ( q ) + abs ( x ) &
6996:             + abs ( y ) + abs ( zz ) )
6997:           vr = tst1
6998: 
6999:           do
7000:             vr = 0.01D+00 * vr
7001:             tst2 = tst1 + vr
7002:             if ( tst2 <= tst1 ) then
7003:               exit
7004:             end if
7005:           end do
7006: 
7007:         end if
7008: 
7009:         call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( x*r-zz*ra+q*sa, x*s-zz*sa-q*ra, vr, vi, h(i,na), h(i,en) )
7010: 
7011:         if ( abs ( x ) > abs ( zz ) + abs ( q ) ) then
7012:           h(i+1,na) = ( -ra - w * h(i,na) + q * h(i,en) ) / x
7013:           h(i+1,en) = ( -sa - w * h(i,en) - q * h(i,na) ) / x
7014:         else
7015:           call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( -r-y*h(i,na), -s-y*h(i,en), zz, q, h(i+1,na), h(i+1,en) )
7016:         end if
7017: !
7018: !  Overflow control.
7019: !
7020: 790     continue
7021: 
7022:         t = max ( abs ( h(i,na) ), abs ( h(i,en) ) )
7023: 
7024:         if ( t /= 0.0D+00 ) then
7025:           tst1 = t
7026:           tst2 = tst1 + 1.0D+00 / tst1
7027:           if ( tst2 <= tst1 ) then
7028:             h(i:en,na) = h(i:en,na) / t
7029:             h(i:en,en) = h(i:en,en) / t
7030:           end if
7031:         end if
7032: 
7033:       end do
7034: !
7035: !  End complex vector.
7036: !
7037: 800 continue
7038: 
7039:   end do
7040: !
7041: !  End back substitution.
7042: !
7043: !  Vectors of isolated roots.
7044: !
7045:   do i = 1, n
7046: 
7047:     if ( i < low .or. i > igh ) then
7048:       z(i,i:n) = h(i,i:n)
7049:     end if
7050: 
7051:   end do
7052: !
7053: !  Multiply by transformation matrix to give vectors of original full matrix.
7054: !
7055:   do jj = low, n
7056: 
7057:      j = n + low - jj
7058:      m = min ( j, igh )
7059: 
7060:      do i = low, igh
7061:        z(i,j) = dot_product ( z(i,low:m), h(low:m,j) )
7062:      end do
7063: 
7064:   end do
7065: 
7066:   return
7067: end
<p><a name=htrib3><H3>htrib3</H3></a></p> Click <a href="./callingtree/htrib3_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where htrib3 is used.
<hr>
7068: subroutine htrib3 ( n, a, tau, m, zr, zi )
7069: 
7070: !*****************************************************************************80
7071: !
7072: !! HTRIB3 determines eigenvectors by undoing the HTRID3 transformation.
7073: !
7074: !  Discussion:
7075: !
7076: !    This subroutine forms the eigenvectors of a complex hermitian
7077: !    matrix by back transforming those of the corresponding
7078: !    real symmetric tridiagonal matrix determined by HTRID3.
7079: !
7080: !  Licensing:
7081: !
7082: !    This code is distributed under the GNU LGPL license.
7083: !
7084: !  Modified:
7085: !
7086: !    18 October 2009
7087: !
7088: !  Author:
7089: !
7090: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
7091: !    Klema, Moler.
7092: !    FORTRAN90 version by John Burkardt.
7093: !
7094: !  Reference:
7095: !
7096: !    James Wilkinson, Christian Reinsch,
7097: !    Handbook for Automatic Computation,
7098: !    Volume II, Linear Algebra, Part 2,
7099: !    Springer, 1971,
7100: !    ISBN: 0387054146,
7101: !    LC: QA251.W67.
7102: !
7103: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
7104: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
7105: !    Matrix Eigensystem Routines, EISPACK Guide,
7106: !    Lecture Notes in Computer Science, Volume 6,
7107: !    Springer Verlag, 1976,
7108: !    ISBN13: 978-3540075462,
7109: !    LC: QA193.M37.
7110: !
7111: !  Parameters:
7112: !
7113: !    Input, integer ( kind = 4 ) N, is the order of the matrix.
7114: !
7115: !    Input, real ( kind = 8 ) A(N,N), contains information about the unitary 
7116: !    transformations used in the reduction by HTRID3.
7117: !
7118: !    Input, real ( kind = 8 ) TAU(2,N), contains further information about the 
7119: !    transformations.
7120: !
7121: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed.
7122: !
7123: !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, ZR contains the
7124: !    eigenvectors to be back transformed.  On output, ZR and ZI contain
7125: !    the real and imaginary parts of the transformed eigenvectors.
7126: !
7127:   implicit none
7128: 
7129:   integer ( kind = 4 ) m
7130:   integer ( kind = 4 ) n
7131: 
7132:   real    ( kind = 8 ) a(n,n)
7133:   real    ( kind = 8 ) h
7134:   integer ( kind = 4 ) i
7135:   integer ( kind = 4 ) j
7136:   integer ( kind = 4 ) k
7137:   integer ( kind = 4 ) l
7138:   real    ( kind = 8 ) s
7139:   real    ( kind = 8 ) si
7140:   real    ( kind = 8 ) tau(2,n)
7141:   real    ( kind = 8 ) zi(n,m)
7142:   real    ( kind = 8 ) zr(n,m)
7143: 
7144:   if ( m == 0 ) then
7145:     return
7146:   end if
7147: !
7148: !  Transform the eigenvectors of the real symmetric tridiagonal matrix 
7149: !  to those of the hermitian tridiagonal matrix.
7150: !
7151:   do k = 1, n
7152:     do j = 1, m
7153:       zi(k,j) = -zr(k,j) * tau(2,k)
7154:       zr(k,j) = zr(k,j) * tau(1,k)
7155:     end do
7156:   end do
7157: !
7158: !  Recover and apply the Householder matrices.
7159: !
7160:   do i = 2, n
7161: 
7162:     l = i - 1
7163:     h = a(i,i)
7164: 
7165:     if ( h /= 0.0D+00 ) then
7166: 
7167:       do j = 1, m
7168: 
7169:         s = 0.0D+00
7170:         si = 0.0D+00
7171: 
7172:         do k = 1, l
7173:           s = s + a(i,k) * zr(k,j) - a(k,i) * zi(k,j)
7174:           si = si + a(i,k) * zi(k,j) + a(k,i) * zr(k,j)
7175:         end do
7176: 
7177:         s = ( s / h ) / h
7178:         si = ( si / h ) / h
7179: 
7180:         zr(1:l,j) = zr(1:l,j) - s * a(i,1:l) - si * a(1:l,i)
7181:         zi(1:l,j) = zi(1:l,j) - si * a(i,1:l) + s * a(1:l,i)
7182: 
7183:       end do
7184: 
7185:     end if
7186: 
7187:   end do
7188: 
7189:   return
7190: end
<p><a name=htribk><H3>htribk</H3></a></p> Click <a href="./callingtree/htribk_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where htribk is used.
<hr>
7191: subroutine htribk ( n, ar, ai, tau, m, zr, zi )
7192: 
7193: !*****************************************************************************80
7194: !
7195: !! HTRIBK determines eigenvectors by undoing the HTRIDI transformation.
7196: !
7197: !  Discussion:
7198: !
7199: !    This subroutine forms the eigenvectors of a complex hermitian
7200: !    matrix by back transforming those of the corresponding
7201: !    real symmetric tridiagonal matrix determined by HTRIDI.
7202: !
7203: !  Licensing:
7204: !
7205: !    This code is distributed under the GNU LGPL license.
7206: !
7207: !  Modified:
7208: !
7209: !    18 October 2009
7210: !
7211: !  Author:
7212: !
7213: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
7214: !    Klema, Moler.
7215: !    FORTRAN90 version by John Burkardt.
7216: !
7217: !  Reference:
7218: !
7219: !    James Wilkinson, Christian Reinsch,
7220: !    Handbook for Automatic Computation,
7221: !    Volume II, Linear Algebra, Part 2,
7222: !    Springer, 1971,
7223: !    ISBN: 0387054146,
7224: !    LC: QA251.W67.
7225: !
7226: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
7227: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
7228: !    Matrix Eigensystem Routines, EISPACK Guide,
7229: !    Lecture Notes in Computer Science, Volume 6,
7230: !    Springer Verlag, 1976,
7231: !    ISBN13: 978-3540075462,
7232: !    LC: QA193.M37.
7233: !
7234: !  Parameters:
7235: !
7236: !    Input, integer ( kind = 4 ) N, the order of the matrix.
7237: !
7238: !    Input, real ( kind = 8 ) AR(N,N), AI(N,N), contain information about 
7239: !    the unitary transformations used in the reduction by HTRIDI in their
7240: !    full lower triangles, except for the diagonal of AR.
7241: !
7242: !    Input, real ( kind = 8 ) TAU(2,N), contains further information about the 
7243: !    transformations.
7244: !
7245: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed.
7246: !
7247: !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, ZR contains the
7248: !    eigenvectors to be back transformed.  On output, ZR and ZI contain
7249: !    the real and imaginary parts of the transformed eigenvectors.
7250: !
7251:   implicit none
7252: 
7253:   integer ( kind = 4 ) m
7254:   integer ( kind = 4 ) n
7255: 
7256:   real    ( kind = 8 ) ai(n,n)
7257:   real    ( kind = 8 ) ar(n,n)
7258:   real    ( kind = 8 ) h
7259:   integer ( kind = 4 ) i
7260:   integer ( kind = 4 ) j
7261:   integer ( kind = 4 ) k
7262:   integer ( kind = 4 ) l
7263:   real    ( kind = 8 ) s
7264:   real    ( kind = 8 ) si
7265:   real    ( kind = 8 ) tau(2,n)
7266:   real    ( kind = 8 ) zi(n,m)
7267:   real    ( kind = 8 ) zr(n,m)
7268: 
7269:   if ( m == 0 ) then
7270:     return
7271:   end if
7272: !
7273: !  Transform the eigenvectors of the real symmetric tridiagonal matrix to 
7274: !  those of the hermitian tridiagonal matrix.
7275: !
7276:   do k = 1, n
7277:     do j = 1, m
7278:       zi(k,j) = -zr(k,j) * tau(2,k)
7279:       zr(k,j) = zr(k,j) * tau(1,k)
7280:     end do
7281:   end do
7282: !
7283: !  Recover and apply the Householder matrices.
7284: !
7285:   do i = 2, n
7286: 
7287:     l = i - 1
7288:     h = ai(i,i)
7289: 
7290:     if ( h /= 0.0D+00 ) then
7291: 
7292:       do j = 1, m
7293: 
7294:         s = 0.0D+00
7295:         si = 0.0D+00
7296:         do k = 1, l
7297:           s = s + ar(i,k) * zr(k,j) - ai(i,k) * zi(k,j)
7298:           si = si + ar(i,k) * zi(k,j) + ai(i,k) * zr(k,j)
7299:         end do
7300: 
7301:         s = ( s / h ) / h
7302:         si = ( si / h ) / h
7303: 
7304:         zr(1:l,j) = zr(1:l,j) - s * ar(i,1:l) - si * ai(i,1:l)
7305:         zi(1:l,j) = zi(1:l,j) - si * ar(i,1:l) + s * ai(i,1:l)
7306: 
7307:       end do
7308: 
7309:     end if
7310: 
7311:   end do
7312: 
7313:   return
7314: end
<p><a name=htrid3><H3>htrid3</H3></a></p> Click <a href="./callingtree/htrid3_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where htrid3 is used.
<hr>
7315: subroutine htrid3 ( n, a, d, e, e2, tau )
7316: 
7317: !*****************************************************************************80
7318: !
7319: !! HTRID3 tridiagonalizes a complex hermitian packed matrix.
7320: !
7321: !  Discussion:
7322: !
7323: !    This subroutine reduces a complex hermitian matrix, stored as
7324: !    a single square array, to a real symmetric tridiagonal matrix
7325: !    using unitary similarity transformations.
7326: !
7327: !  Licensing:
7328: !
7329: !    This code is distributed under the GNU LGPL license.
7330: !
7331: !  Modified:
7332: !
7333: !    18 October 2009
7334: !
7335: !  Author:
7336: !
7337: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
7338: !    Klema, Moler.
7339: !    FORTRAN90 version by John Burkardt.
7340: !
7341: !  Reference:
7342: !
7343: !    James Wilkinson, Christian Reinsch,
7344: !    Handbook for Automatic Computation,
7345: !    Volume II, Linear Algebra, Part 2,
7346: !    Springer, 1971,
7347: !    ISBN: 0387054146,
7348: !    LC: QA251.W67.
7349: !
7350: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
7351: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
7352: !    Matrix Eigensystem Routines, EISPACK Guide,
7353: !    Lecture Notes in Computer Science, Volume 6,
7354: !    Springer Verlag, 1976,
7355: !    ISBN13: 978-3540075462,
7356: !    LC: QA193.M37.
7357: !
7358: !  Parameters:
7359: !
7360: !    Input, integer ( kind = 4 ) N, the order of the matrix.
7361: !
7362: !    Input/output, real ( kind = 8 ) A(N,N).  On input, the lower triangle of the complex 
7363: !    hermitian input matrix.  The real parts of the matrix elements are stored
7364: !    in the full lower triangle of A, and the imaginary parts are stored in 
7365: !    the transposed positions of the strict upper triangle of A.  No storage 
7366: !    is required for the zero imaginary parts of the diagonal elements.
7367: !    On output, A contains information about the unitary transformations
7368: !    used in the reduction.
7369: !
7370: !    Output, real ( kind = 8 ) D(N), the diagonal elements of the the tridiagonal matrix.
7371: !
7372: !    Output, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal
7373: !    matrix in E(2:N).  E(1) is set to zero.
7374: !
7375: !    Output, real ( kind = 8 ) E2(N), the squares of the corresponding elements of E.
7376: !    E2 may coincide with E if the squares are not needed.
7377: !
7378: !    Output, real ( kind = 8 ) TAU(2,N), contains further information about the 
7379: !    transformations.
7380: !
7381:   implicit none
7382: 
7383:   integer ( kind = 4 ) n
7384: 
7385:   real    ( kind = 8 ) a(n,n)
7386:   real    ( kind = 8 ) d(n)
7387:   real    ( kind = 8 ) e(n)
7388:   real    ( kind = 8 ) e2(n)
7389:   real    ( kind = 8 ) f
7390:   real    ( kind = 8 ) fi
7391:   real    ( kind = 8 ) g
7392:   real    ( kind = 8 ) gi
7393:   real    ( kind = 8 ) h
7394:   real    ( kind = 8 ) hh
7395:   integer ( kind = 4 ) i
7396:   integer ( kind = 4 ) ii
7397:   integer ( kind = 4 ) j
7398:   integer ( kind = 4 ) k
7399:   integer ( kind = 4 ) l
7400:   real    ( kind = 8 ) pythag
7401:   real    ( kind = 8 ) xscale
7402:   real    ( kind = 8 ) si
7403:   real    ( kind = 8 ) tau(2,n)
7404: 
7405:   tau(1,n) = 1.0D+00
7406:   tau(2,n) = 0.0D+00
7407: 
7408:   do ii = 1, n
7409: 
7410:     i = n + 1 - ii
7411:     l = i - 1
7412:     h = 0.0D+00
7413:     xscale = 0.0D+00
7414: 
7415:     if ( l < 1 ) then
7416:       e(i) = 0.0D+00
7417:       e2(i) = 0.0D+00
7418:       go to 290
7419:     end if
7420: !
7421: !  Scale row.
7422: !
7423:      do k = 1, l
7424:        xscale = xscale + abs ( a(i,k) ) + abs ( a(k,i) )
7425:      end do
7426: 
7427:      if ( xscale == 0.0D+00 ) then
7428:        tau(1,l) = 1.0D+00
7429:        tau(2,l) = 0.0D+00
7430:        e(i) = 0.0D+00
7431:        e2(i) = 0.0D+00
7432:        go to 290
7433:      end if
7434:    
7435:       do k = 1, l
7436:         a(i,k) = a(i,k) / xscale
7437:         a(k,i) = a(k,i) / xscale
7438:         h = h + a(i,k) * a(i,k) + a(k,i) * a(k,i)
7439:      end do
7440: 
7441:      e2(i) = xscale * xscale * h
7442:      g = sqrt ( h )
7443:      e(i) = xscale * g
7444:      f = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( a(i,l), a(l,i) )
7445: !
7446: !  Form next diagonal element of matrix T.
7447: !
7448:      if ( f /= 0.0D+00 ) then
7449: 
7450:        tau(1,l) = ( a(l,i) * tau(2,i) - a(i,l) * tau(1,i) ) / f
7451:        si = ( a(i,l) * tau(2,i) + a(l,i) * tau(1,i) ) / f
7452:        h = h + f * g
7453:        g = 1.0D+00 + g / f
7454:        a(i,l) = g * a(i,l)
7455:        a(l,i) = g * a(l,i)
7456: 
7457:        if ( l == 1 ) go to 270
7458: 
7459:      else
7460: 
7461:        tau(1,l) = -tau(1,i)
7462:        si = tau(2,i)
7463:        a(i,l) = g
7464: 
7465:      end if
7466: 
7467:      f = 0.0D+00
7468: 
7469:      do j = 1, l
7470: 
7471:         g = 0.0D+00
7472:         gi = 0.0D+00
7473: !
7474: !  Form element of A*U.
7475: !
7476:         do k = 1, j-1
7477:           g = g + a(j,k) * a(i,k) + a(k,j) * a(k,i)
7478:           gi = gi - a(j,k) * a(k,i) + a(k,j) * a(i,k)
7479:         end do
7480: 
7481:         g = g + a(j,j) * a(i,j)
7482:         gi = gi - a(j,j) * a(j,i)
7483: 
7484:         do k = j+1, l
7485:           g = g + a(k,j) * a(i,k) - a(j,k) * a(k,i)
7486:           gi = gi - a(k,j) * a(k,i) - a(j,k) * a(i,k)
7487:         end do
7488: !
7489: !  Form element of P.
7490: !
7491:         e(j) = g / h
7492:         tau(2,j) = gi / h
7493:         f = f + e(j) * a(i,j) - tau(2,j) * a(j,i)
7494: 
7495:      end do
7496: 
7497:      hh = f / ( h + h )
7498: !
7499: !  Form reduced A.
7500: !
7501:      do j = 1, l
7502: 
7503:         f = a(i,j)
7504:         g = e(j) - hh * f
7505:         e(j) = g
7506:         fi = -a(j,i)
7507:         gi = tau(2,j) - hh * fi
7508:         tau(2,j) = -gi
7509:         a(j,j) = a(j,j) - 2.0D+00 * ( f * g + fi * gi )
7510: 
7511:         do k = 1, j-1
7512:           a(j,k) = a(j,k) - f * e(k) - g * a(i,k) + fi * tau(2,k) + gi * a(k,i)
7513:           a(k,j) = a(k,j) - f * tau(2,k) - g * a(k,i) - fi * e(k) - gi * a(i,k)
7514:         end do
7515: 
7516:      end do
7517: 
7518: 270  continue
7519: 
7520:      a(i,1:l) = xscale * a(i,1:l)
7521:      a(1:l,i) = xscale * a(1:l,i)
7522:      tau(2,l) = -si
7523: 
7524: 290  continue
7525: 
7526:      d(i) = a(i,i)
7527:      a(i,i) = xscale * sqrt ( h )
7528: 
7529:   end do
7530: 
7531:   return
7532: end
<p><a name=htridi><H3>htridi</H3></a></p> Click <a href="./callingtree/htridi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where htridi is used.
<hr>
7533: subroutine htridi ( n, ar, ai, d, e, e2, tau )
7534: 
7535: !*****************************************************************************80
7536: !
7537: !! HTRIDI tridiagonalizes a complex hermitian matrix.
7538: !
7539: !  Discussion:
7540: !
7541: !    This subroutine reduces a complex hermitian matrix to a real symmetric 
7542: !    tridiagonal matrix using unitary similarity transformations.
7543: !
7544: !  Licensing:
7545: !
7546: !    This code is distributed under the GNU LGPL license.
7547: !
7548: !  Modified:
7549: !
7550: !    18 October 2009
7551: !
7552: !  Author:
7553: !
7554: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
7555: !    Klema, Moler.
7556: !    FORTRAN90 version by John Burkardt.
7557: !
7558: !  Reference:
7559: !
7560: !    James Wilkinson, Christian Reinsch,
7561: !    Handbook for Automatic Computation,
7562: !    Volume II, Linear Algebra, Part 2,
7563: !    Springer, 1971,
7564: !    ISBN: 0387054146,
7565: !    LC: QA251.W67.
7566: !
7567: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
7568: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
7569: !    Matrix Eigensystem Routines, EISPACK Guide,
7570: !    Lecture Notes in Computer Science, Volume 6,
7571: !    Springer Verlag, 1976,
7572: !    ISBN13: 978-3540075462,
7573: !    LC: QA193.M37.
7574: !
7575: !  Parameters:
7576: !
7577: !    Input, integer ( kind = 4 ) N, the order of the matrix.
7578: !
7579: !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real 
7580: !    and imaginary parts, respectively, of the complex hermitian input matrix.
7581: !    Only the lower triangle of the matrix need be supplied.
7582: !    On output, information about the unitary transformations used in the 
7583: !    reduction in their full lower triangles.  Their strict upper triangles 
7584: !    and the diagonal of AR are unaltered.
7585: !
7586: !    Output, real ( kind = 8 ) D(N), the diagonal elements of the the tridiagonal matrix.
7587: !
7588: !    Output, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal
7589: !    matrix in its last N-1 positions.  E(1) is set to zero.
7590: !
7591: !    Output, real ( kind = 8 ) E2(N), the squares of the corresponding elements of E.
7592: !    E2 may coincide with E if the squares are not needed.
7593: !
7594: !    Output, real ( kind = 8 ) TAU(2,N), contains further information about the 
7595: !    transformations.
7596: !
7597:   implicit none
7598: 
7599:   integer ( kind = 4 ) n
7600: 
7601:   real    ( kind = 8 ) ai(n,n)
7602:   real    ( kind = 8 ) ar(n,n)
7603:   real    ( kind = 8 ) d(n)
7604:   real    ( kind = 8 ) e(n)
7605:   real    ( kind = 8 ) e2(n)
7606:   real    ( kind = 8 ) f
7607:   real    ( kind = 8 ) fi
7608:   real    ( kind = 8 ) g
7609:   real    ( kind = 8 ) gi
7610:   real    ( kind = 8 ) h
7611:   real    ( kind = 8 ) hh
7612:   integer ( kind = 4 ) i
7613:   integer ( kind = 4 ) ii
7614:   integer ( kind = 4 ) j
7615:   integer ( kind = 4 ) k
7616:   integer ( kind = 4 ) l
7617:   real    ( kind = 8 ) pythag
7618:   real    ( kind = 8 ) xscale
7619:   real    ( kind = 8 ) si
7620:   real    ( kind = 8 ) tau(2,n)
7621: 
7622:   tau(1,n) = 1.0D+00
7623:   tau(2,n) = 0.0D+00
7624: 
7625:   do i = 1, n
7626:     d(i) = ar(i,i)
7627:   end do
7628: 
7629:   do ii = 1, n
7630: 
7631:     i = n + 1 - ii
7632:     l = i - 1
7633:     h = 0.0D+00
7634:     xscale = 0.0D+00
7635: 
7636:     if ( l < 1 ) then
7637:       e(i) = 0.0D+00
7638:       e2(i) = 0.0D+00
7639:       go to 290
7640:     end if
7641: !
7642: !  Scale row.
7643: !
7644:     do k = 1, l
7645:       xscale = xscale + abs ( ar(i,k) ) + abs ( ai(i,k) )
7646:     end do
7647: 
7648:     if ( xscale == 0.0D+00 ) then
7649:       tau(1,l) = 1.0D+00
7650:       tau(2,l) = 0.0D+00
7651:       e(i) = 0.0D+00
7652:       e2(i) = 0.0D+00
7653:       go to 290
7654:     end if
7655: 
7656:     ar(i,1:l) = ar(i,1:l) / xscale
7657:     ai(i,1:l) = ai(i,1:l) / xscale
7658: 
7659:     do k = 1, l
7660:       h = h + ar(i,k) * ar(i,k) + ai(i,k) * ai(i,k)
7661:     end do
7662: 
7663:     e2(i) = xscale * xscale * h
7664:     g = sqrt ( h )
7665:     e(i) = xscale * g
7666:     f = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( ar(i,l), ai(i,l) )
7667: !
7668: !  Form next diagonal element of matrix T.
7669: !
7670:     if ( f /= 0.0D+00 ) then
7671:       tau(1,l) = ( ai(i,l) * tau(2,i) - ar(i,l) * tau(1,i) ) / f
7672:       si = ( ar(i,l) * tau(2,i) + ai(i,l) * tau(1,i) ) / f
7673:       h = h + f * g
7674:       g = 1.0D+00 + g / f
7675:       ar(i,l) = g * ar(i,l)
7676:       ai(i,l) = g * ai(i,l)
7677:       if ( l == 1 ) go to 270
7678:     else
7679:       tau(1,l) = -tau(1,i)
7680:       si = tau(2,i)
7681:       ar(i,l) = g
7682:     end if
7683: 
7684:     f = 0.0D+00
7685: 
7686:     do j = 1, l
7687: 
7688:       g = 0.0D+00
7689:       gi = 0.0D+00
7690: !
7691: !  Form element of A*U.
7692: !
7693:       do k = 1, j
7694:         g = g + ar(j,k) * ar(i,k) + ai(j,k) * ai(i,k)
7695:         gi = gi - ar(j,k) * ai(i,k) + ai(j,k) * ar(i,k)
7696:       end do
7697: 
7698:       do k = j+1, l
7699:         g = g + ar(k,j) * ar(i,k) - ai(k,j) * ai(i,k)
7700:         gi = gi - ar(k,j) * ai(i,k) - ai(k,j) * ar(i,k)
7701:       end do
7702: !
7703: !  Form element of P.
7704: !
7705:       e(j) = g / h
7706:       tau(2,j) = gi / h
7707:       f = f + e(j) * ar(i,j) - tau(2,j) * ai(i,j)
7708: 
7709:     end do
7710: 
7711:     hh = f / ( h + h )
7712: !
7713: !  Form the reduced A.
7714: !
7715:     do j = 1, l
7716: 
7717:       f = ar(i,j)
7718:       g = e(j) - hh * f
7719:       e(j) = g
7720:       fi = - ai(i,j)
7721:       gi = tau(2,j) - hh * fi
7722:       tau(2,j) = -gi
7723: 
7724:       do k = 1, j
7725:         ar(j,k) = ar(j,k) - f * e(k) - g * ar(i,k) + fi * tau(2,k) &
7726:           + gi * ai(i,k)
7727:         ai(j,k) = ai(j,k) - f * tau(2,k) - g * ai(i,k) - fi * e(k) &
7728:           - gi * ar(i,k)
7729:       end do
7730: 
7731:     end do
7732: 
7733: 270 continue
7734: 
7735:     ar(i,1:l) = xscale * ar(i,1:l)
7736:     ai(i,1:l) = xscale * ai(i,1:l)
7737:     tau(2,l) = -si
7738: 
7739: 290 continue
7740: 
7741:     hh = d(i)
7742:     d(i) = ar(i,i)
7743:     ar(i,i) = hh
7744:     ai(i,i) = xscale * sqrt ( h )
7745:   
7746:   end do
7747: 
7748:   return
7749: end
<p><a name=imtql1><H3>imtql1</H3></a></p> Click <a href="./callingtree/imtql1_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where imtql1 is used.
<hr>
7750: subroutine imtql1 ( n, d, e, ierr )
7751: 
7752: !*****************************************************************************80
7753: !
7754: !! IMTQL1 computes all eigenvalues of a symmetric tridiagonal matrix.
7755: !
7756: !  Discussion:
7757: !
7758: !    This subroutine finds the eigenvalues of a symmetric
7759: !    tridiagonal matrix by the implicit QL method.
7760: !
7761: !  Licensing:
7762: !
7763: !    This code is distributed under the GNU LGPL license.
7764: !
7765: !  Modified:
7766: !
7767: !    18 October 2009
7768: !
7769: !  Author:
7770: !
7771: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
7772: !    Klema, Moler.
7773: !    FORTRAN90 version by John Burkardt.
7774: !
7775: !  Reference:
7776: !
7777: !    James Wilkinson, Christian Reinsch,
7778: !    Handbook for Automatic Computation,
7779: !    Volume II, Linear Algebra, Part 2,
7780: !    Springer, 1971,
7781: !    ISBN: 0387054146,
7782: !    LC: QA251.W67.
7783: !
7784: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
7785: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
7786: !    Matrix Eigensystem Routines, EISPACK Guide,
7787: !    Lecture Notes in Computer Science, Volume 6,
7788: !    Springer Verlag, 1976,
7789: !    ISBN13: 978-3540075462,
7790: !    LC: QA193.M37.
7791: !
7792: !  Parameters:
7793: !
7794: !    Input, integer ( kind = 4 ) N, the order of the matrix.
7795: !
7796: !    Input/output, real ( kind = 8 ) D(N).  On input, the diagonal elements of 
7797: !    the matrix.  On output, the eigenvalues in ascending order.  If an error 
7798: !    exit is made, the eigenvalues are correct and ordered for indices 
7799: !    1,2,...IERR-1, but may not be the smallest eigenvalues.
7800: !
7801: !    Input/output, real ( kind = 8 ) E(N).  On input, the subdiagonal elements 
7802: !    of the matrix in its last N-1 positions.  E(1) is arbitrary.  On output, 
7803: !    E has been overwritten.
7804: !
7805: !    Output, integer ( kind = 4 ) IERR, error flag.
7806: !    0, normal return,
7807: !    J, if the J-th eigenvalue has not been determined after 30 iterations.
7808: !
7809:   implicit none
7810: 
7811:   integer ( kind = 4 ) n
7812: 
7813:   real    ( kind = 8 ) b
7814:   real    ( kind = 8 ) c
7815:   real    ( kind = 8 ) d(n)
7816:   real    ( kind = 8 ) e(n)
7817:   real    ( kind = 8 ) f
7818:   real    ( kind = 8 ) g
7819:   integer ( kind = 4 ) i
7820:   integer ( kind = 4 ) ierr
7821:   integer ( kind = 4 ) ii
7822:   integer ( kind = 4 ) j
7823:   integer ( kind = 4 ) l
7824:   integer ( kind = 4 ) m
7825:   integer ( kind = 4 ) mml
7826:   real    ( kind = 8 ) p
7827:   real    ( kind = 8 ) pythag
7828:   real    ( kind = 8 ) r
7829:   real    ( kind = 8 ) s
7830:   real    ( kind = 8 ) tst1
7831:   real    ( kind = 8 ) tst2
7832: 
7833:   ierr = 0
7834: 
7835:   if ( n == 1 ) then
7836:     return
7837:   end if
7838: 
7839:   do i = 2, n
7840:     e(i-1) = e(i)
7841:   end do
7842:   e(n) = 0.0D+00
7843: 
7844:   do l = 1, n
7845: 
7846:     j = 0
7847: !
7848: !  Look for a small sub-diagonal element.
7849: !
7850: 105 continue
7851: 
7852:     do m = l, n
7853: 
7854:       if ( m == n ) then
7855:         exit
7856:       end if
7857: 
7858:       tst1 = abs ( d(m) ) + abs ( d(m+1) )
7859:       tst2 = tst1 + abs ( e(m) )
7860: 
7861:       if ( tst2 == tst1 ) then
7862:         exit
7863:       end if
7864: 
7865:     end do
7866: 
7867:     p = d(l)
7868: 
7869:     if ( m == l ) then
7870:       go to 215
7871:     end if
7872: 
7873:     if ( 30 <= j ) then
7874:       ierr = l
7875:       return
7876:     end if
7877: 
7878:     j = j + 1
7879: !
7880: !  Form shift.
7881: !
7882:     g = ( d(l+1) - p ) / ( 2.0D+00 * e(l) )
7883:     r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( g, 1.0D+00 )
7884:     g = d(m) - p + e(l) / ( g + sign ( r, g ) )
7885:     s = 1.0D+00
7886:     c = 1.0D+00
7887:     p = 0.0D+00
7888:     mml = m - l
7889: 
7890:     do ii = 1, mml
7891: 
7892:       i = m - ii
7893:       f = s * e(i)
7894:       b = c * e(i)
7895:       r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, g )
7896:       e(i+1) = r
7897: !
7898: !  Recover from underflow.
7899: !
7900:       if ( r == 0.0D+00 ) then
7901:         d(i+1) = d(i+1) - p
7902:         e(m) = 0.0D+00
7903:         go to 105
7904:       end if
7905: 
7906:       s = f / r
7907:       c = g / r
7908:       g = d(i+1) - p
7909:       r = ( d(i) - g ) * s + 2.0D+00 * c * b
7910:       p = s * r
7911:       d(i+1) = g + p
7912:       g = c * r - b
7913: 
7914:     end do
7915: 
7916:     d(l) = d(l) - p
7917:     e(l) = g
7918:     e(m) = 0.0D+00
7919:     go to 105
7920: !
7921: !  Order the eigenvalues.
7922: !
7923: 215 continue
7924: 
7925:     do ii = 2, l
7926:       i = l + 2 - ii
7927:       if ( d(i-1) <= p ) then
7928:         go to 270
7929:       end if
7930:       d(i) = d(i-1)
7931:     end do
7932: 
7933:     i = 1
7934: 
7935: 270 continue
7936: 
7937:     d(i) = p
7938: 
7939:   end do
7940: 
7941:   return
7942: end
<p><a name=imtql2><H3>imtql2</H3></a></p> Click <a href="./callingtree/imtql2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where imtql2 is used.
<hr>
7943: subroutine imtql2 ( n, d, e, z, ierr )
7944: 
7945: !*****************************************************************************80
7946: !
7947: !! IMTQL2 computes all eigenvalues/vectors of a symmetric tridiagonal matrix.
7948: !
7949: !  Discussion:
7950: !
7951: !    This subroutine finds the eigenvalues and eigenvectors
7952: !    of a symmetric tridiagonal matrix by the implicit QL method.
7953: !    The eigenvectors of a full symmetric matrix can also
7954: !    be found if TRED2 has been used to reduce this
7955: !    full matrix to tridiagonal form.
7956: !
7957: !  Licensing:
7958: !
7959: !    This code is distributed under the GNU LGPL license.
7960: !
7961: !  Modified:
7962: !
7963: !    18 October 2009
7964: !
7965: !  Author:
7966: !
7967: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
7968: !    Klema, Moler.
7969: !    FORTRAN90 version by John Burkardt.
7970: !
7971: !  Reference:
7972: !
7973: !    James Wilkinson, Christian Reinsch,
7974: !    Handbook for Automatic Computation,
7975: !    Volume II, Linear Algebra, Part 2,
7976: !    Springer, 1971,
7977: !    ISBN: 0387054146,
7978: !    LC: QA251.W67.
7979: !
7980: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
7981: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
7982: !    Matrix Eigensystem Routines, EISPACK Guide,
7983: !    Lecture Notes in Computer Science, Volume 6,
7984: !    Springer Verlag, 1976,
7985: !    ISBN13: 978-3540075462,
7986: !    LC: QA193.M37.
7987: !
7988: !  Parameters:
7989: !
7990: !    Input, integer ( kind = 4 ) N, the order of the matrix.
7991: !
7992: !    Input/output, real ( kind = 8 ) D(N).  On input, the diagonal elements of 
7993: !    the input matrix.  On output, the eigenvalues in ascending order.  If an
7994: !    error exit is made, the eigenvalues are correct but
7995: !    unordered for indices 1,2,...,IERR-1.
7996: !
7997: !    Input/output, real ( kind = 8 ) E(N).  On input, the subdiagonal elements 
7998: !    of the input matrix in E(2:N).  E(1) is arbitrary.  On output, E is
7999: !    overwritten.
8000: !
8001: !    Input/output, real ( kind = 8 ) Z(N,N).  On input, the transformation 
8002: !    matrix produced in the reduction by TRED2, if performed.  If the 
8003: !    eigenvectors of the tridiagonal matrix are desired, Z must contain the 
8004: !    identity matrix.  On output, Z contains orthonormal eigenvectors of the 
8005: !    symmetric tridiagonal (or full) matrix.  If an error exit is made, Z 
8006: !    contains the eigenvectors associated with the stored eigenvalues.
8007: !
8008: !    Output, integer ( kind = 4 ) IERR, error flag.
8009: !    0, for normal return,
8010: !    J, if the J-th eigenvalue has not been determined after 30 iterations.
8011: !
8012:   implicit none
8013: 
8014:   integer ( kind = 4 ) n
8015: 
8016:   real    ( kind = 8 ) b
8017:   real    ( kind = 8 ) c
8018:   real    ( kind = 8 ) d(n)
8019:   real    ( kind = 8 ) e(n)
8020:   real    ( kind = 8 ) f
8021:   real    ( kind = 8 ) g
8022:   integer ( kind = 4 ) i
8023:   integer ( kind = 4 ) ierr
8024:   integer ( kind = 4 ) ii
8025:   integer ( kind = 4 ) j
8026:   integer ( kind = 4 ) k
8027:   integer ( kind = 4 ) l
8028:   integer ( kind = 4 ) m
8029:   integer ( kind = 4 ) mml
8030:   real    ( kind = 8 ) p
8031:   real    ( kind = 8 ) pythag
8032:   real    ( kind = 8 ) r
8033:   real    ( kind = 8 ) s
8034:   real    ( kind = 8 ) t(n)
8035:   real    ( kind = 8 ) tst1
8036:   real    ( kind = 8 ) tst2
8037:   real    ( kind = 8 ) z(n,n)
8038: 
8039:   ierr = 0
8040: 
8041:   if ( n == 1 ) then
8042:     return
8043:   end if
8044: 
8045:   do i = 2, n
8046:     e(i-1) = e(i)
8047:   end do
8048:   e(n) = 0.0D+00
8049: 
8050:   do l = 1, n
8051: 
8052:     j = 0
8053: !
8054: !  Look for a small sub-diagonal element.
8055: !
8056: 105 continue
8057: 
8058:     do m = l, n
8059: 
8060:       if ( m == n ) then
8061:         exit
8062:       end if
8063: 
8064:       tst1 = abs ( d(m) ) + abs ( d(m+1) )
8065:       tst2 = tst1 + abs ( e(m) )
8066: 
8067:       if ( tst2 == tst1 ) then
8068:         exit
8069:       end if
8070: 
8071:     end do
8072: 
8073:     p = d(l)
8074: 
8075:     if ( m == l ) then
8076:       cycle
8077:     end if
8078: 
8079:     if ( 30 <= j ) then
8080:       ierr = l
8081:       return
8082:     end if
8083: 
8084:     j = j + 1
8085: !
8086: !  Form shift.
8087: !
8088:     g = ( d(l+1) - p ) / ( 2.0D+00 * e(l) )
8089:     r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( g, 1.0D+00 )
8090:     g = d(m) - p + e(l) / ( g + sign ( r, g ) )
8091:     s = 1.0D+00
8092:     c = 1.0D+00
8093:     p = 0.0D+00
8094:     mml = m - l
8095: 
8096:     do ii = 1, mml
8097: 
8098:       i = m - ii
8099:       f = s * e(i)
8100:       b = c * e(i)
8101:       r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, g )
8102:       e(i+1) = r
8103: !
8104: !  Recover from underflow.
8105: !
8106:       if ( r == 0.0D+00 ) then
8107:         d(i+1) = d(i+1) - p
8108:         e(m) = 0.0D+00
8109:         go to 105
8110:       end if
8111: 
8112:       s = f / r
8113:       c = g / r
8114:       g = d(i+1) - p
8115:       r = ( d(i) - g ) * s + 2.0D+00 * c * b
8116:       p = s * r
8117:       d(i+1) = g + p
8118:       g = c * r - b
8119: !
8120: !  Form vector.
8121: !
8122:       do k = 1, n
8123:         f = z(k,i+1)
8124:         z(k,i+1) = s * z(k,i) + c * f
8125:         z(k,i) = c * z(k,i) - s * f
8126:       end do
8127: 
8128:     end do
8129: 
8130:     d(l) = d(l) - p
8131:     e(l) = g
8132:     e(m) = 0.0D+00
8133:     go to 105
8134: 
8135:   end do
8136: !
8137: !  Order eigenvalues and eigenvectors.
8138: !
8139:   do ii = 2, n
8140: 
8141:     i = ii - 1
8142:     k = i
8143:     p = d(i)
8144: 
8145:     do j = ii, n
8146:       if ( d(j) < p ) then
8147:         k = j
8148:         p = d(j)
8149:       end if
8150:     end do
8151: 
8152:     if ( k /= i ) then
8153: 
8154:       d(k) = d(i)
8155:       d(i) = p
8156: 
8157:       t(1:n)   = z(1:n,i)
8158:       z(1:n,i) = z(1:n,k)
8159:       z(1:n,k) = t(1:n)
8160: 
8161:     end if
8162: 
8163:   end do
8164: 
8165:   return
8166: end
<p><a name=imtqlv><H3>imtqlv</H3></a></p> Click <a href="./callingtree/imtqlv_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where imtqlv is used.
<hr>
8167: subroutine imtqlv ( n, d, e, e2, w, ind, ierr )
8168: 
8169: !*****************************************************************************80
8170: !
8171: !! IMTQLV computes all eigenvalues of a real symmetric tridiagonal matrix.
8172: !
8173: !  Discussion:
8174: !
8175: !    This subroutine finds the eigenvalues of a symmetric tridiagonal
8176: !    matrix by the implicit QL method and associates with them
8177: !    their corresponding submatrix indices.
8178: !
8179: !  Licensing:
8180: !
8181: !    This code is distributed under the GNU LGPL license.
8182: !
8183: !  Modified:
8184: !
8185: !    18 October 2009
8186: !
8187: !  Author:
8188: !
8189: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
8190: !    Klema, Moler.
8191: !    FORTRAN90 version by John Burkardt.
8192: !
8193: !  Reference:
8194: !
8195: !    James Wilkinson, Christian Reinsch,
8196: !    Handbook for Automatic Computation,
8197: !    Volume II, Linear Algebra, Part 2,
8198: !    Springer, 1971,
8199: !    ISBN: 0387054146,
8200: !    LC: QA251.W67.
8201: !
8202: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
8203: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
8204: !    Matrix Eigensystem Routines, EISPACK Guide,
8205: !    Lecture Notes in Computer Science, Volume 6,
8206: !    Springer Verlag, 1976,
8207: !    ISBN13: 978-3540075462,
8208: !    LC: QA193.M37.
8209: !
8210: !  Parameters:
8211: !
8212: !    Input, integer ( kind = 4 ) N, the order of the matrix.
8213: !
8214: !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix.
8215: !
8216: !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the input matrix
8217: !    in E(2:N).  E(1) is arbitrary.
8218: !
8219: !    Input/output, real ( kind = 8 ) E2(N).  On input, the squares of the corresponding 
8220: !    elements of E.  E2(1) is arbitrary.  On output, elements of E2 
8221: !    corresponding to elements of E regarded as negligible have been 
8222: !    replaced by zero, causing the matrix to split into a direct sum of 
8223: !    submatrices.  E2(1) is also set to zero.
8224: !
8225: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.  If an
8226: !    error exit is made, the eigenvalues are correct and ordered for 
8227: !    indices 1,2,...IERR-1, but may not be the smallest eigenvalues.
8228: !
8229: !    Output, integer ( kind = 4 ) IND(N), the submatrix indices associated with the
8230: !    corresponding eigenvalues in W: 1 for eigenvalues belonging to the 
8231: !    first submatrix from the top, 2 for those belonging to the second 
8232: !    submatrix, and so on.
8233: !
8234: !    Output, integer ( kind = 4 ) IERR, error flag.
8235: !    0, for normal return,
8236: !    J, if the J-th eigenvalue has not been determined after 30 iterations.
8237: !
8238:   implicit none
8239: 
8240:   integer ( kind = 4 ) n
8241: 
8242:   real    ( kind = 8 ) b
8243:   real    ( kind = 8 ) c
8244:   real    ( kind = 8 ) d(n)
8245:   real    ( kind = 8 ) e(n)
8246:   real    ( kind = 8 ) e2(n)
8247:   real    ( kind = 8 ) f
8248:   real    ( kind = 8 ) g
8249:   integer ( kind = 4 ) i
8250:   integer ( kind = 4 ) ierr
8251:   integer ( kind = 4 ) ii
8252:   integer ( kind = 4 ) ind(n)
8253:   integer ( kind = 4 ) j
8254:   integer ( kind = 4 ) k
8255:   integer ( kind = 4 ) l
8256:   integer ( kind = 4 ) m
8257:   integer ( kind = 4 ) mml
8258:   real    ( kind = 8 ) p
8259:   real    ( kind = 8 ) pythag
8260:   real    ( kind = 8 ) r
8261:   real    ( kind = 8 ) rv1(n)
8262:   real    ( kind = 8 ) s
8263:   integer ( kind = 4 ) tag
8264:   real    ( kind = 8 ) tst1
8265:   real    ( kind = 8 ) tst2
8266:   real    ( kind = 8 ) w(n)
8267: 
8268:   ierr = 0
8269:   k = 0
8270:   tag = 0
8271:   w(1:n) = d(1:n)
8272:   e2(1) = 0.0D+00
8273:   rv1(1:n-1) = e(2:n)
8274:   rv1(n) = 0.0D+00
8275: 
8276:   do l = 1, n
8277: 
8278:     j = 0
8279: !
8280: !  Look for a small sub-diagonal element.
8281: !
8282: 105 continue
8283: 
8284:      do m = l, n
8285: 
8286:        if ( m == n ) then
8287:          exit
8288:        end if
8289: 
8290:        tst1 = abs ( w(m) ) + abs ( w(m+1) )
8291:        tst2 = tst1 + abs ( rv1(m) )
8292: 
8293:        if ( tst2 == tst1 ) then
8294:          exit
8295:        end if
8296: !
8297: !  Guard against underflowed element of E2.
8298: !
8299:        if ( e2(m+1) == 0.0D+00 ) go to 125
8300: 
8301:      end do
8302: 
8303:      if ( m <= k ) go to 130
8304: 
8305:      if ( m /= n ) e2(m+1) = 0.0D+00
8306: 
8307: 125  continue
8308: 
8309:      k = m
8310:      tag = tag + 1
8311: 
8312: 130  continue
8313: 
8314:      p = w(l)
8315: 
8316:      if ( m == l ) go to 215
8317: 
8318:      if ( j >= 30 ) then
8319:        ierr = l
8320:        return
8321:      end if
8322: 
8323:      j = j + 1
8324: !
8325: !  Form shift.
8326: !
8327:      g = ( w(l+1) - p ) / ( 2.0D+00 * rv1(l) )
8328:      r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( g, 1.0D+00 )
8329:      g = w(m) - p + rv1(l) / (g + sign ( r, g ) )
8330:      s = 1.0D+00
8331:      c = 1.0D+00
8332:      p = 0.0D+00
8333:      mml = m - l
8334: 
8335:      do ii = 1, mml
8336:        i = m - ii
8337:        f = s * rv1(i)
8338:        b = c * rv1(i)
8339:        r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, g )
8340:        rv1(i+1) = r
8341: 
8342:        if ( r == 0.0D+00 ) go to 210
8343: 
8344:        s = f / r
8345:        c = g / r
8346:        g = w(i+1) - p
8347:        r = ( w(i) - g ) * s + 2.0D+00 * c * b
8348:        p = s * r
8349:        w(i+1) = g + p
8350:        g = c * r - b
8351:      end do
8352: 
8353:      w(l) = w(l) - p
8354:      rv1(l) = g
8355:      rv1(m) = 0.0D+00
8356:      go to 105
8357: !
8358: !  Recover from underflow.
8359: !
8360: 210  continue
8361: 
8362:      w(i+1) = w(i+1) - p
8363:      rv1(m) = 0.0D+00
8364:      go to 105
8365: !
8366: !  Order the eigenvalues.
8367: !
8368: 215  continue
8369: 
8370:      do ii = 2, l
8371:         i = l + 2 - ii
8372:         if ( p >= w(i-1) ) go to 270
8373:         w(i) = w(i-1)
8374:         ind(i) = ind(i-1)
8375:      end do
8376: 
8377:      i = 1
8378: 
8379:   270   continue
8380: 
8381:      w(i) = p
8382:      ind(i) = tag
8383: 
8384:   end do
8385: 
8386:   return
8387: end
<p><a name=invit><H3>invit</H3></a></p> Click <a href="./callingtree/invit_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where invit is used.
<hr>
8388: subroutine invit ( n, a, wr, wi, select, mm, m, z, ierr )
8389: 
8390: !*****************************************************************************80
8391: !
8392: !! INVIT computes eigenvectors given eigenvalues, for a real upper Hessenberg matrix.
8393: !
8394: !  Discussion:
8395: !
8396: !    This subroutine finds those eigenvectors of a real upper Hessenberg 
8397: !    matrix corresponding to specified eigenvalues, using inverse iteration.
8398: !
8399: !  Licensing:
8400: !
8401: !    This code is distributed under the GNU LGPL license.
8402: !
8403: !  Modified:
8404: !
8405: !    18 October 2009
8406: !
8407: !  Author:
8408: !
8409: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
8410: !    Klema, Moler.
8411: !    FORTRAN90 version by John Burkardt.
8412: !
8413: !  Reference:
8414: !
8415: !    James Wilkinson, Christian Reinsch,
8416: !    Handbook for Automatic Computation,
8417: !    Volume II, Linear Algebra, Part 2,
8418: !    Springer, 1971,
8419: !    ISBN: 0387054146,
8420: !    LC: QA251.W67.
8421: !
8422: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
8423: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
8424: !    Matrix Eigensystem Routines, EISPACK Guide,
8425: !    Lecture Notes in Computer Science, Volume 6,
8426: !    Springer Verlag, 1976,
8427: !    ISBN13: 978-3540075462,
8428: !    LC: QA193.M37.
8429: !
8430: !  Parameters:
8431: !
8432: !    Input, integer ( kind = 4 ) N, the order of the matrix.
8433: !
8434: !    Input, real ( kind = 8 ) A(N,N), the Hessenberg matrix.
8435: !
8436: !    Input/output, real ( kind = 8 ) WR(N), WI(N).  On input, the real and imaginary 
8437: !    parts, respectively, of the eigenvalues of the matrix.  The eigenvalues 
8438: !    must be stored in a manner identical to that of subroutine HQR,
8439: !    which recognizes possible splitting of the matrix.  On output,
8440: !    WR may have been altered since close eigenvalues are perturbed
8441: !    slightly in searching for independent eigenvectors.
8442: !
8443: !    Input/output, logical SELECT(N).  On input, specifies the eigenvectors 
8444: !    to be found.  The eigenvector corresponding to the J-th eigenvalue is
8445: !    specified by setting SELECT(J) to TRUE.  On output, SELECT may have been 
8446: !    altered.  If the elements corresponding to a pair of conjugate complex 
8447: !    eigenvalues were each initially set to TRUE, the program resets the 
8448: !    second of the two elements to FALSE.
8449: !
8450: !    Input, integer ( kind = 4 ) MM, an upper bound for the number of columns required 
8451: !    to store the eigenvectors to be found.  Note that two columns are 
8452: !    required to store the eigenvector corresponding to a complex eigenvalue.
8453: !
8454: !    Input, integer ( kind = 4 ) M, the number of columns actually used to store
8455: !    the eigenvectors.
8456: !
8457: !    Output, real ( kind = 8 ) Z(N,MM), the real and imaginary parts of the eigenvectors.
8458: !    If the next selected eigenvalue is real, the next column
8459: !    of Z contains its eigenvector.  If the eigenvalue is complex, the next 
8460: !    two columns of Z contain the real and imaginary parts of its eigenvector.  
8461: !    The eigenvectors are normalized so that the component of largest 
8462: !    magnitude is 1.  Any vector which fails the acceptance test is set to zero.
8463: !
8464: !    Output, integer ( kind = 4 ) IERR, error flag.
8465: !    0, for normal return,
8466: !    -(2*N+1), if more than MM columns of Z are necessary to store the 
8467: !      eigenvectors corresponding to the specified eigenvalues.
8468: !    -K, if the iteration corresponding to the K-th value fails,
8469: !    -(N+K), if both error situations occur.
8470: !
8471:   implicit none
8472: 
8473:   integer ( kind = 4 ) n
8474: 
8475:   real    ( kind = 8 ) a(n,n)
8476:   real    ( kind = 8 ) eps3
8477:   real    ( kind = 8 ) growto
8478:   integer ( kind = 4 ) i
8479:   integer ( kind = 4 ) ierr
8480:   integer ( kind = 4 ) ii
8481:   real    ( kind = 8 ) ilambd
8482:   integer ( kind = 4 ) ip
8483:   integer ( kind = 4 ) its
8484:   integer ( kind = 4 ) j
8485:   integer ( kind = 4 ) k
8486:   integer ( kind = 4 ) km1
8487:   integer ( kind = 4 ) l
8488:   integer ( kind = 4 ) m
8489:   integer ( kind = 4 ) mm
8490:   integer ( kind = 4 ) mp
8491:   integer ( kind = 4 ) n1
8492:   real    ( kind = 8 ) norm
8493:   real    ( kind = 8 ) normv
8494:   integer ( kind = 4 ) ns
8495:   real    ( kind = 8 ) pythag
8496:   real    ( kind = 8 ) rlambd
8497:   real    ( kind = 8 ) rm1(n,n)
8498:   real    ( kind = 8 ) rv1(n)
8499:   real    ( kind = 8 ) rv2(n)
8500:   integer ( kind = 4 ) s
8501:   logical              select(n)
8502:   real    ( kind = 8 ) t
8503:   integer ( kind = 4 ) uk
8504:   real    ( kind = 8 ) ukroot
8505:   real    ( kind = 8 ) w
8506:   real    ( kind = 8 ) wi(n)
8507:   real    ( kind = 8 ) wr(n)
8508:   real    ( kind = 8 ) x
8509:   real    ( kind = 8 ) y
8510:   real    ( kind = 8 ) z(n,mm)
8511: 
8512:   ierr = 0
8513:   uk = 0
8514:   s = 1
8515: !
8516: !  The value of IP is:
8517: !
8518: !   0, real eigenvalue;
8519: !   1, first of conjugate complex pair;
8520: !  -1, second of conjugate complex pair.
8521: !
8522:   ip = 0
8523:   n1 = n - 1
8524: 
8525:   do k = 1, n
8526: 
8527:      if ( wi(k) /= 0.0D+00 .and. ip >= 0 ) then
8528:        ip = 1
8529:        if ( select(k) .and. select(k+1) ) select(k+1) = .false.
8530:      end if
8531: 
8532:      if ( .not. select(k) ) go to 960
8533: 
8534:      if ( wi(k) /= 0.0D+00 ) then
8535:        s = s + 1
8536:      end if
8537: 
8538:      if ( s > mm ) go to 1000
8539: 
8540:      if ( uk >= k ) go to 200
8541: !
8542: !  Check for possible splitting.
8543: !
8544:      do uk = k, n
8545:        if ( uk == n ) then
8546:          exit
8547:        end if
8548:        if ( a(uk+1,uk) == 0.0D+00 ) then
8549:          exit
8550:        end if
8551:      end do
8552: !
8553: !  Compute infinity norm of leading UK by UK (Hessenberg) matrix.
8554: !
8555:      norm = 0.0D+00
8556:      mp = 1
8557: 
8558:      do i = 1, uk
8559: 
8560:        x = sum ( abs ( a(i,mp:uk) ) )
8561:        norm = max ( norm, x )
8562:        mp = i
8563: 
8564:      end do
8565: !
8566: !  EPS3 replaces zero pivot in decomposition and close roots are modified 
8567: !  by EPS3.
8568: !
8569:      if ( norm == 0.0D+00 ) then
8570:        norm = 1.0D+00
8571:      end if
8572: 
8573:      eps3 = abs ( norm ) * epsilon ( eps3 )
8574: !
8575: !  GROWTO is the criterion for the growth.
8576: !
8577:      ukroot = uk
8578:      ukroot = sqrt ( ukroot )
8579:      growto = 0.1D+00 / ukroot
8580: 
8581: 200  continue
8582: 
8583:      rlambd = wr(k)
8584:      ilambd = wi(k)
8585:      if ( k == 1 ) go to 280
8586:      km1 = k - 1
8587:      go to 240
8588: !
8589: !  Perturb eigenvalue if it is close to any previous eigenvalue.
8590: !
8591: 220 continue
8592: 
8593:      rlambd = rlambd + eps3
8594: 
8595: 240  continue
8596: 
8597:      do ii = 1, km1
8598:        i = k - ii
8599:        if ( select(i) .and. abs ( wr(i) - rlambd ) < eps3 .and. &
8600:           abs ( wi(i) - ilambd ) < eps3 ) then
8601:         go to 220
8602:        end if
8603:      end do
8604: 
8605:      wr(k) = rlambd
8606: !
8607: !  Perturb conjugate eigenvalue to match.
8608: !
8609:      wr(k+ip) = rlambd
8610: !
8611: !  Form upper Hessenberg A - rlambd*I (transposed) and initial real vector.
8612: !
8613: 280  continue
8614: 
8615:      mp = 1
8616: 
8617:      do i = 1, uk
8618: 
8619:         rm1(mp:uk,i) = a(i,mp:uk)
8620: 
8621:         rm1(i,i) = rm1(i,i) - rlambd
8622:         mp = i
8623:         rv1(i) = eps3
8624: 
8625:      end do
8626: 
8627:      its = 0
8628: 
8629:      if ( ilambd /= 0.0D+00 ) go to 520
8630: !
8631: !  Real eigenvalue.
8632: !
8633: !  Triangular decomposition with interchanges, replacing zero pivots by eps3.
8634: !
8635:      do i = 2, uk
8636: 
8637:         mp = i - 1
8638: 
8639:         if ( abs ( rm1(mp,i) ) > abs ( rm1(mp,mp) ) ) then
8640: 
8641:           do j = mp, uk
8642:             call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( rm1(j,i), rm1(j,mp) )
8643:           end do
8644: 
8645:         end if
8646: 
8647:         if ( rm1(mp,mp) == 0.0D+00 ) then
8648:           rm1(mp,mp) = eps3
8649:         end if
8650: 
8651:         x = rm1(mp,i) / rm1(mp,mp)
8652: 
8653:         if ( x /= 0.0D+00 ) then
8654:           rm1(i:uk,i) = rm1(i:uk,i) - x * rm1(i:uk,mp)
8655:         end if
8656: 
8657:       end do
8658: 
8659:       if ( rm1(uk,uk) == 0.0D+00 ) then
8660:         rm1(uk,uk) = eps3
8661:       end if
8662: !
8663: !  Back substitution for real vector.
8664: !
8665: 440   continue
8666: 
8667:       do ii = 1, uk
8668: 
8669:         i = uk + 1 - ii
8670:         y = rv1(i)
8671: 
8672:         do j = i+1, uk
8673:           y = y - rm1(j,i) * rv1(j)
8674:         end do
8675: 
8676:         rv1(i) = y / rm1(i,i)
8677: 
8678:      end do
8679: 
8680:      go to 740
8681: !
8682: !  Complex eigenvalue.
8683: !
8684: !  Triangular decomposition with interchanges,
8685: !  replacing zero pivots by EPS3.  
8686: !  Store imaginary parts in upper triangle starting at (1,3)
8687: !
8688: 520  continue
8689: 
8690:      ns = n - s
8691:      z(1,s-1) = -ilambd
8692:      z(1,s) = 0.0D+00
8693: 
8694:      if ( n /= 2 ) then
8695:        rm1(1,3) = -ilambd
8696:        z(1,s-1) = 0.0D+00
8697:        rm1(1,4:n) = 0.0D+00
8698:      end if
8699: 
8700:      do i = 2, uk
8701: 
8702:         mp = i - 1
8703:         w = rm1(mp,i)
8704: 
8705:         if ( i < n ) then
8706:           t = rm1(mp,i+1)
8707:         else if ( i == n ) then
8708:           t = z(mp,s-1)
8709:         end if
8710: 
8711:         x = rm1(mp,mp) * rm1(mp,mp) + t * t
8712: 
8713:         if ( w * w <= x ) go to 580
8714: 
8715:         x = rm1(mp,mp) / w
8716:         y = t / w
8717:         rm1(mp,mp) = w
8718: 
8719:         if ( i < n ) then
8720:           rm1(mp,i+1) = 0.0D+00
8721:         else if ( i == n ) then
8722:           z(mp,s-1) = 0.0D+00
8723:         end if
8724: 
8725:         do j = i, uk
8726: 
8727:           w = rm1(j,i)
8728:           rm1(j,i) = rm1(j,mp) - x * w
8729:           rm1(j,mp) = w
8730: 
8731:           if ( j >= n1 ) then
8732:             l = j - ns
8733:             z(i,l) = z(mp,l) - y * w
8734:             z(mp,l) = 0.0D+00
8735:           else
8736:             rm1(i,j+2) = rm1(mp,j+2) - y * w
8737:             rm1(mp,j+2) = 0.0D+00
8738:           end if
8739: 
8740:         end do
8741: 
8742:         rm1(i,i) = rm1(i,i) - y * ilambd
8743: 
8744:         if ( i >= n1 ) then
8745:           l = i - ns
8746:           z(mp,l) = -ilambd
8747:           z(i,l) = z(i,l) + x * ilambd
8748:         else
8749:           rm1(mp,i+2) = -ilambd
8750:           rm1(i,i+2) = rm1(i,i+2) + x * ilambd
8751:         end if
8752: 
8753:         go to 640
8754: 
8755: 580     continue
8756: 
8757:         if ( x == 0.0D+00 ) then
8758:           rm1(mp,mp) = eps3
8759:           if ( i < n ) then
8760:             rm1(mp,i+1) = 0.0D+00
8761:           else if ( i == n ) then
8762:             z(mp,s-1) = 0.0D+00
8763:           end if
8764:           t = 0.0D+00
8765:           x = eps3**2
8766:         end if
8767: 
8768:         w = w / x
8769:         x = rm1(mp,mp) * w
8770:         y = -t * w
8771: 
8772:         do j = i, uk
8773:           if ( j >= n1 ) then
8774:             l = j - ns
8775:             t = z(mp,l)
8776:             z(i,l) = -x * t - y * rm1(j,mp)
8777:           else
8778:             t = rm1(mp,j+2)
8779:             rm1(i,j+2) = -x * t - y * rm1(j,mp)
8780:           end if
8781:           rm1(j,i) = rm1(j,i) - x * rm1(j,mp) + y * t
8782:         end do
8783: 
8784:         if ( i >= n1 ) then
8785:           l = i - ns
8786:           z(i,l) = z(i,l) - ilambd
8787:         else
8788:           rm1(i,i+2) = rm1(i,i+2) - ilambd
8789:         end if
8790: 
8791: 640    continue
8792: 
8793:      end do
8794: 
8795:      if ( uk >= n1 ) then
8796:        l = uk - ns
8797:        t = z(uk,l)
8798:      else
8799:        t = rm1(uk,uk+2)
8800:      end if
8801: 
8802:      if ( rm1(uk,uk) == 0.0D+00 .and. t == 0.0D+00 ) then
8803:        rm1(uk,uk) = eps3
8804:      end if
8805: !
8806: !  Back substitution for complex vector.
8807: !
8808: 660  continue
8809: 
8810:      do ii = 1, uk
8811: 
8812:         i = uk + 1 - ii
8813:         x = rv1(i)
8814:         y = 0.0D+00
8815: 
8816:         do j = i+1, uk
8817: 
8818:           if ( j >= n1 ) then
8819:             t = z(i,j-ns)
8820:           else
8821:             t = rm1(i,j+2)
8822:           end if
8823: 
8824:           x = x - rm1(j,i) * rv1(j) + t * rv2(j)
8825:           y = y - rm1(j,i) * rv2(j) - t * rv1(j)
8826: 
8827:         end do
8828: 
8829:         if ( i >= n1 ) then
8830:           t = z(i,i-ns)
8831:         else
8832:           t = rm1(i,i+2)
8833:         end if
8834: 
8835:        call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( x, y, rm1(i,i), t, rv1(i), rv2(i) )
8836: 
8837:      end do
8838: !
8839: !  Acceptance test for real or complex eigenvector and normalization.
8840: !
8841: 740  continue
8842: 
8843:      its = its + 1
8844:      norm = 0.0D+00
8845:      normv = 0.0D+00
8846: 
8847:      do i = 1, uk
8848:        if ( ilambd == 0.0D+00 ) then
8849:          x = abs ( rv1(i) )
8850:        else
8851:          x = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( rv1(i), rv2(i) )
8852:        end if
8853:        if ( normv < x )  then
8854:          normv = x
8855:          j = i
8856:        end if
8857:        norm = norm + x
8858:      end do
8859: 
8860:      if ( norm < growto ) go to 840
8861: !
8862: !  Accept vector.
8863: !
8864:      x = rv1(j)
8865:      if ( ilambd == 0.0D+00 ) then
8866:        x = 1.0D+00 / x
8867:      else
8868:        y = rv2(j)
8869:      end if
8870: 
8871:      do i = 1, uk
8872:        if ( ilambd == 0.0D+00 ) then
8873:          z(i,s) = rv1(i) * x
8874:        else
8875:          call <a href="./eispack.f90.html#cdiv" TARGET=CENT_PANEL>cdiv</a> ( rv1(i), rv2(i), x, y, z(i,s-1), z(i,s) )
8876:        end if
8877:      end do
8878: 
8879:      if ( uk == n ) go to 940
8880:      j = uk + 1
8881:      go to 900
8882: !
8883: !  Choose a new starting vector.
8884: !
8885: 840  continue
8886: 
8887:      if ( its >= uk ) go to 880
8888: 
8889:      x = ukroot
8890:      y = eps3 / ( x + 1.0D+00 )
8891: 
8892:      rv1(1) = eps3
8893:      rv1(2:uk) = y
8894:      
8895:      j = uk - its + 1
8896:      rv1(j) = rv1(j) - eps3 * x
8897:      if ( ilambd == 0.0D+00 ) go to 440
8898:      go to 660
8899: !
8900: !  Set error: unaccepted eigenvector.
8901: !
8902: 880  continue
8903: 
8904:      j = 1
8905:      ierr = -k
8906: !
8907: !  Set remaining vector components to zero.
8908: !
8909: 900  continue
8910: 
8911:      do i = j, n
8912:        z(i,s) = 0.0D+00
8913:        if ( ilambd /= 0.0D+00 ) z(i,s-1) = 0.0D+00
8914:      end do
8915: 
8916: 940  continue
8917: 
8918:      s = s + 1
8919: 
8920: 960  continue
8921: 
8922:      if ( ip == (-1) ) then
8923:        ip = 0
8924:      end if
8925: 
8926:      if ( ip == 1 ) then
8927:        ip = -1
8928:      end if
8929: 
8930:   end do
8931: 
8932:   go to 1001
8933: !
8934: !  Set error: underestimate of eigenvector space required.
8935: !
8936: 1000 continue
8937: 
8938:   if ( ierr /= 0 ) then
8939:     ierr = ierr - n
8940:   end if
8941: 
8942:   if ( ierr == 0 ) then
8943:     ierr = -(2 * n + 1)
8944:   end if
8945: 
8946: 1001 continue
8947: 
8948:   m = s - 1 - abs ( ip )
8949: 
8950:   return
8951: end
<p><a name=minfit><H3>minfit</H3></a></p> Click <a href="./callingtree/minfit_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where minfit is used.
<hr>
8952: subroutine minfit ( nm, m, n, a, w, ip, b, ierr )
8953: 
8954: !*****************************************************************************80
8955: !
8956: !! MINFIT solves the least squares problem, for a real overdetermined linear system.
8957: !
8958: !  Discussion:
8959: !
8960: !    This subroutine is part of an algorithm for solving general linear
8961: !    systems of the form A*X=B.  
8962: !
8963: !    It determines the singular value decomposition 
8964: !      A = U * S * V' 
8965: !    of a real M by N rectangular matrix, forming U' * B 
8966: !    rather than U.  Householder bidiagonalization and a variant of the 
8967: !    QR algorithm are used.
8968: !
8969: !  Licensing:
8970: !
8971: !    This code is distributed under the GNU LGPL license.
8972: !
8973: !  Modified:
8974: !
8975: !    18 October 2009
8976: !
8977: !  Author:
8978: !
8979: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
8980: !    Klema, Moler.
8981: !    FORTRAN90 version by John Burkardt.
8982: !
8983: !  Reference:
8984: !
8985: !    James Wilkinson, Christian Reinsch,
8986: !    Handbook for Automatic Computation,
8987: !    Volume II, Linear Algebra, Part 2,
8988: !    Springer, 1971,
8989: !    ISBN: 0387054146,
8990: !    LC: QA251.W67.
8991: !
8992: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
8993: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
8994: !    Matrix Eigensystem Routines, EISPACK Guide,
8995: !    Lecture Notes in Computer Science, Volume 6,
8996: !    Springer Verlag, 1976,
8997: !    ISBN13: 978-3540075462,
8998: !    LC: QA193.M37.
8999: !
9000: !  Parameters:
9001: !
9002: !    Input, integer ( kind = 4 ) NM, the leading dimension of the two-dimensional arrays.
9003: !    NM must be at least as large as the maximum of M and N.
9004: !
9005: !    Input, integer ( kind = 4 ) M, the number of rows of A and B.
9006: !
9007: !    Input, integer ( kind = 4 ) N, the number of columns of A, and the order of V.
9008: !
9009: !    Input/output, real ( kind = 8 ) A(NM,N). On input, the rectangular coefficient matrix.
9010: !    On output, A has been overwritten by the orthogonal matrix V of the
9011: !    decomposition in its first N rows and columns.  If an error exit is made, 
9012: !    the columns of V corresponding to indices of correct singular values 
9013: !    should be correct.
9014: !
9015: !    Output, real ( kind = 8 ) W(N), the singular values of A.  These are the diagonal 
9016: !    elements of S.  They are unordered.  If an error exit is made, the 
9017: !    singular values should be correct for indices IERR+1, IERR+2,...,N.
9018: !
9019: !    Input, integer ( kind = 4 ) IP, is the number of columns of B.  IP can be zero.
9020: !
9021: !    Input/output, real ( kind = 8 ) B(NM,IP).  On input, the constant column matrix,
9022: !    On output, B has been overwritten by U'*B.  If an error exit is made,
9023: !    the rows of U'*B corresponding to indices of correct singular values 
9024: !    should be correct.
9025: !
9026: !    Output, integer ( kind = 4 ) IERR, error flag.
9027: !    0, for normal return,
9028: !    K, if the K-th singular value has not been determined after 30 iterations.
9029: !
9030:   implicit none
9031: 
9032:   integer ( kind = 4 ) ip
9033:   integer ( kind = 4 ) n
9034:   integer ( kind = 4 ) nm
9035: 
9036:   real    ( kind = 8 ) a(nm,n)
9037:   real    ( kind = 8 ) b(nm,ip)
9038:   real    ( kind = 8 ) c
9039:   real    ( kind = 8 ) f
9040:   real    ( kind = 8 ) g
9041:   real    ( kind = 8 ) h
9042:   integer ( kind = 4 ) i
9043:   integer ( kind = 4 ) i1
9044:   integer ( kind = 4 ) ierr
9045:   integer ( kind = 4 ) ii
9046:   integer ( kind = 4 ) its
9047:   integer ( kind = 4 ) j
9048:   integer ( kind = 4 ) k
9049:   integer ( kind = 4 ) k1
9050:   integer ( kind = 4 ) kk
9051:   integer ( kind = 4 ) l
9052:   integer ( kind = 4 ) l1
9053:   integer ( kind = 4 ) ll
9054:   integer ( kind = 4 ) m
9055:   integer ( kind = 4 ) m1
9056:   real    ( kind = 8 ) pythag
9057:   real    ( kind = 8 ) rv1(n)
9058:   real    ( kind = 8 ) s
9059:   real    ( kind = 8 ) xscale
9060:   real    ( kind = 8 ) tst1
9061:   real    ( kind = 8 ) tst2
9062:   real    ( kind = 8 ) w(n)
9063:   real    ( kind = 8 ) x
9064:   real    ( kind = 8 ) y
9065:   real    ( kind = 8 ) z
9066: 
9067:   ierr = 0
9068: !
9069: !  Householder reduction to bidiagonal form.
9070: !
9071:   g = 0.0D+00
9072:   xscale = 0.0D+00
9073:   x = 0.0D+00
9074: 
9075:   do i = 1, n
9076: 
9077:     l = i + 1
9078:     rv1(i) = xscale * g
9079:     g = 0.0D+00
9080:     s = 0.0D+00
9081:     xscale = 0.0D+00
9082: 
9083:     if ( i <= m ) then
9084: 
9085:       xscale = sum ( abs ( a(i:m,i) ) )
9086: 
9087:       if ( xscale /= 0.0D+00 ) then
9088: 
9089:         a(i:m,i) = a(i:m,i) / xscale
9090: 
9091:         s = s + sum ( a(i:m,i)**2 )
9092: 
9093:         f = a(i,i)
9094:         g = - sign ( sqrt ( s ), f )
9095:         h = f * g - s
9096:         a(i,i) = f - g
9097: 
9098:         do j = l, n
9099: 
9100:           s = dot_product ( a(i:m,i), a(i:m,j) )
9101: 
9102:           f = s / h
9103:           a(i:m,j) = a(i:m,j) + f * a(i:m,i)
9104: 
9105:         end do
9106: 
9107:         do j = 1, ip
9108: 
9109:           s = dot_product ( a(i:m,i), b(i:m,j) )
9110: 
9111:           b(i:m,j) = b(i:m,j) + s * a(i:m,i) / h
9112: 
9113:         end do
9114: 
9115:         a(i:m,i) = xscale * a(i:m,i)
9116: 
9117:       end if
9118: 
9119:     end if
9120: 
9121:     w(i) = xscale * g
9122:     g = 0.0D+00
9123:     s = 0.0D+00
9124:     xscale = 0.0D+00
9125: 
9126:     if ( i <= m .and. i /= n ) then
9127: 
9128:       do k = l, n
9129:         xscale = xscale + abs ( a(i,k) )
9130:       end do
9131: 
9132:       if ( xscale /= 0.0D+00 ) then
9133: 
9134:         a(i,l:n) = a(i,l:n) / xscale
9135: 
9136:         s = s + sum ( a(i,l:n)**2 )
9137: 
9138:         f = a(i,l)
9139:         g = - sign ( sqrt ( s ), f )
9140:         h = f * g - s
9141:         a(i,l) = f - g
9142:         rv1(l:n) = a(i,l:n) / h
9143: 
9144:         do j = l, m
9145: 
9146:           s = dot_product ( a(j,l:n), a(i,l:n) )
9147: 
9148:           a(j,l:n) = a(j,l:n) + s * rv1(l:n)
9149: 
9150:         end do
9151: 
9152:         a(i,l:n) = xscale * a(i,l:n)
9153: 
9154:       end if
9155: 
9156:     end if
9157: 
9158:     x = max ( x, abs ( w(i) ) + abs ( rv1(i) ) )
9159: 
9160:   end do
9161: !
9162: !  Accumulation of right-hand transformations.
9163: !
9164:   do ii = 1, n
9165: 
9166:     i = n + 1 - ii
9167: 
9168:     if ( i /= n ) then
9169: 
9170:       if ( g /= 0.0D+00 ) then
9171: 
9172:         a(l:n,i) = ( a(i,l:n) / a(i,l) ) / g
9173: 
9174:         do j = l, n
9175: 
9176:           s = dot_product ( a(i,l:n), a(l:n,j) )
9177: 
9178:           a(l:n,j) = a(l:n,j) + s * a(l:n,i)
9179: 
9180:         end do
9181: 
9182:       end if
9183: 
9184:       a(i,l:n) = 0.0D+00
9185:       a(l:n,i) = 0.0D+00
9186: 
9187:     end if
9188: 
9189:     a(i,i) = 1.0D+00
9190:     g = rv1(i)
9191:     l = i
9192: 
9193:   end do
9194: 
9195:   if ( m < n .and. ip /= 0 ) then
9196:     m1 = m + 1
9197:     b(m+1:n,1:ip) = 0.0D+00
9198:   end if
9199: !
9200: !  Diagonalization of the bidiagonal form.
9201: !
9202:   tst1 = x
9203: 
9204:   do kk = 1, n
9205: 
9206:     k1 = n - kk
9207:     k = k1 + 1
9208:     its = 0
9209: !
9210: !  Test for splitting.
9211: !
9212: 520 continue
9213: 
9214:     do ll = 1, k
9215: 
9216:       l1 = k - ll
9217:       l = l1 + 1
9218:       tst2 = tst1 + abs ( rv1(l) )
9219: 
9220:       if ( tst2 == tst1 ) then
9221:         go to 565
9222:       end if
9223: 
9224:       tst2 = tst1 + abs ( w(k-ll) )
9225: 
9226:       if ( tst2 == tst1 ) then
9227:         exit
9228:       end if
9229: 
9230:     end do
9231: !
9232: !  Cancellation of RV1(l) if l greater than 1.
9233: !
9234:     c = 0.0D+00
9235:     s = 1.0D+00
9236: 
9237:     do i = l, k
9238: 
9239:       f = s * rv1(i)
9240:       rv1(i) = c * rv1(i)
9241:       tst2 = tst1 + abs ( f)
9242: 
9243:       if ( tst2 == tst1 ) then
9244:         exit
9245:       end if
9246: 
9247:       g = w(i)
9248:       h = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, g )
9249:       w(i) = h
9250:       c = g / h
9251:       s = -f / h
9252: 
9253:       do j = 1, ip
9254:         y = b(l1,j)
9255:         z = b(i,j)
9256:         b(l1,j) = y * c + z * s
9257:         b(i,j) = -y * s + z * c
9258:       end do
9259: 
9260:     end do
9261: !
9262: !  Test for convergence.
9263: !
9264: 565 continue
9265: 
9266:     z = w(k)
9267: 
9268:     if ( l == k ) go to 650
9269: !
9270: !  Shift from bottom 2 by 2 minor.
9271: !
9272:      if ( its >= 30 ) then
9273:        ierr = k
9274:        return
9275:      end if
9276: 
9277:      its = its + 1
9278:      x = w(l)
9279:      y = w(k1)
9280:      g = rv1(k1)
9281:      h = rv1(k)
9282:      f = 0.5D+00 * ( ( ( g + z ) / h ) * ( ( g - z ) / y ) + y / h - h / y )
9283:      g = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, 1.0D+00 )
9284:      f = x - ( z / x ) * z + ( h / x ) * ( y / ( f + sign ( g, f ) ) - h )
9285: !
9286: !  Next QR transformation.
9287: !
9288:      c = 1.0D+00
9289:      s = 1.0D+00
9290: 
9291:      do i1 = l, k1
9292: 
9293:         i = i1 + 1
9294:         g = rv1(i)
9295:         y = w(i)
9296:         h = s * g
9297:         g = c * g
9298:         z = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, h )
9299:         rv1(i1) = z
9300:         c = f / z
9301:         s = h / z
9302:         f = x * c + g * s
9303:         g = -x * s + g * c
9304:         h = y * s
9305:         y = y * c
9306: 
9307:         do j = 1, n
9308:           x = a(j,i1)
9309:           z = a(j,i)
9310:           a(j,i1) = x * c + z * s
9311:           a(j,i) = -x * s + z * c
9312:         end do
9313: 
9314:         z = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, h )
9315:         w(i1) = z
9316: 
9317:         if ( z /= 0.0D+00 ) then
9318:           c = f / z
9319:           s = h / z
9320:         end if
9321: 
9322:         f = c * g + s * y
9323:         x = -s * g + c * y
9324: 
9325:         do j = 1, ip
9326:           y = b(i1,j)
9327:           z = b(i,j)
9328:           b(i1,j) = y * c + z * s
9329:           b(i,j) = -y * s + z * c
9330:         end do
9331: 
9332:      end do
9333: 
9334:      rv1(l) = 0.0D+00
9335:      rv1(k) = f
9336:      w(k) = x
9337:      go to 520
9338: !
9339: !  Convergence.
9340: !
9341: 650 continue
9342: 
9343:     if ( z < 0.0D+00 ) then
9344:       w(k) = - z
9345:       a(1:n,k) = - a(1:n,k)
9346:     end if
9347: 
9348:   end do
9349: 
9350:   return
9351: end
<p><a name=ortbak><H3>ortbak</H3></a></p> Click <a href="./callingtree/ortbak_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ortbak is used.
<hr>
9352: subroutine ortbak ( n, low, igh, a, ort, m, z )
9353: 
9354: !*****************************************************************************80
9355: !
9356: !! ORTBAK determines eigenvectors by undoing the ORTHES transformation.
9357: !
9358: !  Discussion:
9359: !
9360: !    This subroutine forms the eigenvectors of a real general
9361: !    matrix by back transforming those of the corresponding
9362: !    upper Hessenberg matrix determined by ORTHES.
9363: !
9364: !  Licensing:
9365: !
9366: !    This code is distributed under the GNU LGPL license.
9367: !
9368: !  Modified:
9369: !
9370: !    18 October 2009
9371: !
9372: !  Author:
9373: !
9374: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
9375: !    Klema, Moler.
9376: !    FORTRAN90 version by John Burkardt.
9377: !
9378: !  Reference:
9379: !
9380: !    James Wilkinson, Christian Reinsch,
9381: !    Handbook for Automatic Computation,
9382: !    Volume II, Linear Algebra, Part 2,
9383: !    Springer, 1971,
9384: !    ISBN: 0387054146,
9385: !    LC: QA251.W67.
9386: !
9387: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
9388: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
9389: !    Matrix Eigensystem Routines, EISPACK Guide,
9390: !    Lecture Notes in Computer Science, Volume 6,
9391: !    Springer Verlag, 1976,
9392: !    ISBN13: 978-3540075462,
9393: !    LC: QA193.M37.
9394: !
9395: !  Parameters:
9396: !
9397: !    Input, integer ( kind = 4 ) N, the order of the matrix.
9398: !
9399: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine BALANC.  
9400: !    If BALANC has not been used, set LOW = 1 and IGH equal to the order of 
9401: !    the matrix.
9402: !
9403: !    Input, real ( kind = 8 ) A(N,IGH), contains information about the orthogonal 
9404: !    transformations used in the reduction by ORTHES in its strict 
9405: !    lower triangle.
9406: !
9407: !    Input/output, real ( kind = 8 ) ORT(IGH), contains further information about the 
9408: !    transformations used in the reduction by ORTHES.  On output, ORT
9409: !    has been altered.
9410: !
9411: !    Input, integer ( kind = 4 ) M, the number of columns of Z to be back transformed.
9412: !
9413: !    Input/output, real ( kind = 8 ) Z(N,N).  On input, the real and imaginary parts of 
9414: !    the eigenvectors to be back transformed in the first M columns.  On
9415: !    output, the real and imaginary parts of the transformed eigenvectors.
9416: !
9417:   implicit none
9418: 
9419:   integer ( kind = 4 ) igh
9420:   integer ( kind = 4 ) m
9421:   integer ( kind = 4 ) n
9422: 
9423:   real    ( kind = 8 ) a(n,igh)
9424:   real    ( kind = 8 ) g
9425:   integer ( kind = 4 ) i
9426:   integer ( kind = 4 ) j
9427:   integer ( kind = 4 ) low
9428:   integer ( kind = 4 ) mp
9429:   real    ( kind = 8 ) ort(igh)
9430:   real    ( kind = 8 ) z(n,m)
9431: 
9432:   if ( m == 0 ) then
9433:     return
9434:   end if
9435: 
9436:   do mp = igh - 1, low + 1, -1
9437: 
9438:     if ( a(mp,mp-1) /= 0.0D+00 ) then
9439: 
9440:       ort(mp+1:igh) = a(mp+1:igh,mp-1)
9441: 
9442:       do j = 1, m
9443: 
9444:         g = dot_product ( ort(mp:igh), z(mp:igh,j) )
9445: 
9446:         g = ( g / ort(mp) ) / a(mp,mp-1)
9447: 
9448:         do i = mp, igh
9449:           z(i,j) = z(i,j) + g * ort(i)
9450:         end do
9451: 
9452:       end do
9453: 
9454:     end if
9455: 
9456:   end do
9457: 
9458:   return
9459: end
<p><a name=orthes><H3>orthes</H3></a></p> Click <a href="./callingtree/orthes_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where orthes is used.
<hr>
9460: subroutine orthes ( n, low, igh, a, ort )
9461: 
9462: !*****************************************************************************80
9463: !
9464: !! ORTHES transforms a real general matrix to upper Hessenberg form.
9465: !
9466: !  Discussion:
9467: !
9468: !    Given a real general matrix, this subroutine reduces a submatrix 
9469: !    situated in rows and columns LOW through IGH to upper Hessenberg form by
9470: !    orthogonal similarity transformations.
9471: !
9472: !  Modified:
9473: !
9474: !    04 February 2003
9475: !
9476: !  Reference:
9477: !
9478: !    James Wilkinson, Christian Reinsch,
9479: !    Handbook for Automatic Computation,
9480: !    Volume II, Linear Algebra, Part 2,
9481: !    Springer, 1971,
9482: !    ISBN: 0387054146,
9483: !    LC: QA251.W67.
9484: !
9485: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
9486: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
9487: !    Matrix Eigensystem Routines, EISPACK Guide,
9488: !    Lecture Notes in Computer Science, Volume 6,
9489: !    Springer Verlag, 1976,
9490: !    ISBN13: 978-3540075462,
9491: !    LC: QA193.M37.
9492: !
9493: !  Parameters:
9494: !
9495: !    Input, integer ( kind = 4 ) N, the order of the matrix.
9496: !
9497: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine BALANC.  
9498: !    If BALANC has not been used, set LOW = 1 and IGH = N.
9499: !
9500: !    Input/output, real ( kind = 8 ) A(N,N).  On input, the matrix.  On output,
9501: !    the Hessenberg matrix.  Information about the orthogonal transformations 
9502: !    used in the reduction is stored in the remaining triangle under the
9503: !    Hessenberg matrix.
9504: !
9505: !    Output, real ( kind = 8 ) ORT(IGH), contains further information about the 
9506: !    transformations.
9507: !
9508:   implicit none
9509: 
9510:   integer ( kind = 4 ) igh
9511:   integer ( kind = 4 ) n
9512: 
9513:   real    ( kind = 8 ) a(n,n)
9514:   real    ( kind = 8 ) f
9515:   real    ( kind = 8 ) g
9516:   real    ( kind = 8 ) h
9517:   integer ( kind = 4 ) i
9518:   integer ( kind = 4 ) ii
9519:   integer ( kind = 4 ) j
9520:   integer ( kind = 4 ) jj
9521:   integer ( kind = 4 ) la
9522:   integer ( kind = 4 ) low
9523:   integer ( kind = 4 ) m
9524:   integer ( kind = 4 ) mp
9525:   real    ( kind = 8 ) ort(igh)
9526:   real    ( kind = 8 ) xscale
9527: 
9528:   la = igh - 1
9529: 
9530:   do m = low + 1, la
9531: 
9532:      h = 0.0D+00
9533:      ort(m) = 0.0D+00
9534:      xscale = 0.0D+00
9535: !
9536: !  Scale the column.
9537: !
9538:      do i = m, igh
9539:        xscale = xscale + abs ( a(i,m-1) )
9540:      end do
9541: 
9542:      if ( xscale /= 0.0D+00 ) then
9543: 
9544:      mp = m + igh
9545: 
9546:      do ii = m, igh
9547:        i = mp - ii
9548:        ort(i) = a(i,m-1) / xscale
9549:        h = h + ort(i) * ort(i)
9550:      end do
9551: 
9552:      g = - sign ( sqrt ( h ), ort(m) )
9553:      h = h - ort(m) * g
9554:      ort(m) = ort(m) - g
9555: !
9556: !  Form (I-(U*Ut)/h) * A.
9557: !
9558:      do j = m, n
9559: 
9560:         f = 0.0D+00
9561: 
9562:         do ii = m, igh
9563:           i = mp - ii
9564:           f = f + ort(i) * a(i,j)
9565:         end do
9566: 
9567:         f = f / h
9568: 
9569:         do i = m, igh
9570:           a(i,j) = a(i,j) - f * ort(i)
9571:         end do
9572: 
9573:      end do
9574: !
9575: !  Form (I-(u*ut)/h) * A * (I-(u*ut)/h).
9576: !
9577:      do i = 1, igh
9578: 
9579:         f = 0.0D+00
9580:         do jj = m, igh
9581:           j = mp - jj
9582:           f = f + ort(j) * a(i,j)
9583:         end do
9584: 
9585:         a(i,m:igh) = a(i,m:igh) - f * ort(m:igh) / h
9586: 
9587:      end do
9588: 
9589:      ort(m) = xscale * ort(m)
9590:      a(m,m-1) = xscale * g
9591: 
9592:     end if
9593: 
9594:   end do
9595: 
9596:   return
9597: end
<p><a name=ortran><H3>ortran</H3></a></p> Click <a href="./callingtree/ortran_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ortran is used.
<hr>
9598: subroutine ortran ( n, low, igh, a, ort, z )
9599: 
9600: !*****************************************************************************80
9601: !
9602: !! ORTRAN accumulates similarity transformations generated by ORTHES.
9603: !
9604: !  Discussion:
9605: !
9606: !    This subroutine accumulates the orthogonal similarity
9607: !    transformations used in the reduction of a real general
9608: !    matrix to upper Hessenberg form by ORTHES.
9609: !
9610: !  Licensing:
9611: !
9612: !    This code is distributed under the GNU LGPL license.
9613: !
9614: !  Modified:
9615: !
9616: !    18 October 2009
9617: !
9618: !  Author:
9619: !
9620: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
9621: !    Klema, Moler.
9622: !    FORTRAN90 version by John Burkardt.
9623: !
9624: !  Reference:
9625: !
9626: !    James Wilkinson, Christian Reinsch,
9627: !    Handbook for Automatic Computation,
9628: !    Volume II, Linear Algebra, Part 2,
9629: !    Springer, 1971,
9630: !    ISBN: 0387054146,
9631: !    LC: QA251.W67.
9632: !
9633: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
9634: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
9635: !    Matrix Eigensystem Routines, EISPACK Guide,
9636: !    Lecture Notes in Computer Science, Volume 6,
9637: !    Springer Verlag, 1976,
9638: !    ISBN13: 978-3540075462,
9639: !    LC: QA193.M37.
9640: !
9641: !  Parameters:
9642: !
9643: !    Input, integer ( kind = 4 ) N, the order of the matrix.
9644: !
9645: !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing 
9646: !    routine BALANC.  If BALANC has not been used, set LOW = 1, IGH = N.
9647: !
9648: !    Input, real ( kind = 8 ) A(N,IGH), contains information about the orthogonal 
9649: !    transformations used in the reduction by ORTHES in its strict lower 
9650: !    triangle.
9651: !
9652: !    Input/output, real ( kind = 8 ) ORT(IGH), contains further information about the 
9653: !    transformations used in the reduction by ORTHES.  On output, ORT
9654: !    has been further altered.
9655: !
9656: !    Output, real ( kind = 8 ) Z(N,N), contains the transformation matrix produced in the
9657: !    reduction by ORTHES.
9658: !
9659:   implicit none
9660: 
9661:   integer ( kind = 4 ) igh
9662:   integer ( kind = 4 ) n
9663: 
9664:   real    ( kind = 8 ) a(n,igh)
9665:   real    ( kind = 8 ) g
9666:   integer ( kind = 4 ) i
9667:   integer ( kind = 4 ) j
9668:   integer ( kind = 4 ) kl
9669:   integer ( kind = 4 ) low
9670:   integer ( kind = 4 ) mm
9671:   integer ( kind = 4 ) mp
9672:   real    ( kind = 8 ) ort(igh)
9673:   real    ( kind = 8 ) z(n,n)
9674: !
9675: !  Initialize Z to the identity matrix.
9676: !
9677:   z(1:n,1:n) = 0.0D+00
9678: 
9679:   do i = 1, n
9680:     z(i,i) = 1.0D+00
9681:   end do
9682: 
9683:   kl = igh - low - 1
9684: 
9685:   if ( kl < 1 ) then
9686:     return
9687:   end if
9688: 
9689:   do mm = 1, kl
9690: 
9691:     mp = igh - mm
9692: 
9693:     if ( a(mp,mp-1) /= 0.0D+00 ) then
9694: 
9695:       ort(mp+1:igh) = a(mp+1:igh,mp-1)
9696: 
9697:       do j = mp, igh
9698: 
9699:         g = dot_product ( ort(mp:igh), z(mp:igh,j) )
9700: 
9701:         g = ( g / ort(mp) ) / a(mp,mp-1)
9702: 
9703:         z(mp:igh,j) = z(mp:igh,j) + g * ort(mp:igh)
9704: 
9705:       end do
9706: 
9707:     end if
9708: 
9709:   end do
9710: 
9711:   return
9712: end
<p><a name=pythag><H3>pythag</H3></a></p> Click <a href="./callingtree/pythag_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where pythag is used.
<hr>
9713: function pythag ( a, b )
9714: 
9715: !*****************************************************************************80
9716: !
9717: !! PYTHAG computes SQRT ( A * A + B * B ) carefully.
9718: !
9719: !  Discussion:
9720: !
9721: !    The formula
9722: !
9723: !      PYTHAG = sqrt ( A * A + B * B )
9724: !
9725: !    is reasonably accurate, but can fail if, for example, A**2 is larger 
9726: !    than the machine overflow.  The formula can lose most of its accuracy 
9727: !    if the sum of the squares is very large or very small.
9728: !
9729: !  Licensing:
9730: !
9731: !    This code is distributed under the GNU LGPL license.
9732: !
9733: !  Modified:
9734: !
9735: !    18 October 2009
9736: !
9737: !  Author:
9738: !
9739: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
9740: !    Klema, Moler.
9741: !    FORTRAN90 version by John Burkardt.
9742: !
9743: !  Reference:
9744: !
9745: !    James Wilkinson, Christian Reinsch,
9746: !    Handbook for Automatic Computation,
9747: !    Volume II, Linear Algebra, Part 2,
9748: !    Springer, 1971,
9749: !    ISBN: 0387054146,
9750: !    LC: QA251.W67.
9751: !
9752: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
9753: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
9754: !    Matrix Eigensystem Routines, EISPACK Guide,
9755: !    Lecture Notes in Computer Science, Volume 6,
9756: !    Springer Verlag, 1976,
9757: !    ISBN13: 978-3540075462,
9758: !    LC: QA193.M37.
9759: !
9760: !  Modified:
9761: !
9762: !    04 February 2003
9763: !
9764: !  Parameters:
9765: !
9766: !    Input, real ( kind = 8 ) A, B, the two legs of a right triangle.
9767: !
9768: !    Output, real ( kind = 8 ) PYTHAG, the length of the hypotenuse.
9769: !
9770:   implicit none
9771: 
9772:   real    ( kind = 8 ) a
9773:   real    ( kind = 8 ) b
9774:   real    ( kind = 8 ) p
9775:   real    ( kind = 8 ) pythag
9776:   real    ( kind = 8 ) r
9777:   real    ( kind = 8 ) s
9778:   real    ( kind = 8 ) t
9779:   real    ( kind = 8 ) u
9780: 
9781:   p = max ( abs ( a ), abs ( b ) )
9782: 
9783:   if ( p /= 0.0D+00 ) then
9784: 
9785:     r = ( min ( abs ( a ), abs ( b ) ) / p )**2
9786: 
9787:     do
9788: 
9789:       t = 4.0D+00 + r
9790: 
9791:       if ( t == 4.0D+00 ) then
9792:         exit
9793:       end if
9794: 
9795:       s = r / t
9796:       u = 1.0D+00 + 2.0D+00 * s
9797:       p = u * p
9798:       r = ( s / u )**2 * r
9799: 
9800:     end do
9801: 
9802:   end if
9803: 
9804:   <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> = p
9805: 
9806:   return
9807: end
<p><a name=qzhes><H3>qzhes</H3></a></p> Click <a href="./callingtree/qzhes_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where qzhes is used.
<hr>
9808: subroutine qzhes ( n, a, b, matz, z )
9809: 
9810: !*****************************************************************************80
9811: !
9812: !! QZHES carries out transformations for a generalized eigenvalue problem.
9813: !
9814: !  Discussion:
9815: !
9816: !    This subroutine is the first step of the QZ algorithm
9817: !    for solving generalized matrix eigenvalue problems.
9818: !
9819: !    This subroutine accepts a pair of real general matrices and
9820: !    reduces one of them to upper Hessenberg form and the other
9821: !    to upper triangular form using orthogonal transformations.
9822: !    it is usually followed by QZIT, QZVAL and, possibly, QZVEC.
9823: !
9824: !  Licensing:
9825: !
9826: !    This code is distributed under the GNU LGPL license.
9827: !
9828: !  Modified:
9829: !
9830: !    18 October 2009
9831: !
9832: !  Author:
9833: !
9834: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
9835: !    Klema, Moler.
9836: !    FORTRAN90 version by John Burkardt.
9837: !
9838: !  Reference:
9839: !
9840: !    James Wilkinson, Christian Reinsch,
9841: !    Handbook for Automatic Computation,
9842: !    Volume II, Linear Algebra, Part 2,
9843: !    Springer, 1971,
9844: !    ISBN: 0387054146,
9845: !    LC: QA251.W67.
9846: !
9847: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
9848: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
9849: !    Matrix Eigensystem Routines, EISPACK Guide,
9850: !    Lecture Notes in Computer Science, Volume 6,
9851: !    Springer Verlag, 1976,
9852: !    ISBN13: 978-3540075462,
9853: !    LC: QA193.M37.
9854: !
9855: !  Parameters:
9856: !
9857: !    Input, integer ( kind = 4 ) N, the order of the matrices.
9858: !
9859: !    Input/output, real ( kind = 8 ) A(N,N).  On input, the first real general matrix.
9860: !    On output, A has been reduced to upper Hessenberg form.  The elements
9861: !    below the first subdiagonal have been set to zero.
9862: !
9863: !    Input/output, real ( kind = 8 ) B(N,N).  On input, a real general matrix.
9864: !    On output, B has been reduced to upper triangular form.  The elements
9865: !    below the main diagonal have been set to zero.
9866: !
9867: !    Input, logical MATZ, should be TRUE if the right hand transformations
9868: !    are to be accumulated for later use in computing eigenvectors.
9869: !
9870: !    Output, real ( kind = 8 ) Z(N,N), contains the product of the right hand 
9871: !    transformations if MATZ is TRUE.
9872: !
9873:   implicit none
9874: 
9875:   integer ( kind = 4 ) n
9876: 
9877:   real    ( kind = 8 ) a(n,n)
9878:   real    ( kind = 8 ) b(n,n)
9879:   integer ( kind = 4 ) i
9880:   integer ( kind = 4 ) j
9881:   integer ( kind = 4 ) k
9882:   integer ( kind = 4 ) l
9883:   integer ( kind = 4 ) l1
9884:   integer ( kind = 4 ) lb
9885:   logical              matz
9886:   integer ( kind = 4 ) nk1
9887:   integer ( kind = 4 ) nm1
9888:   real    ( kind = 8 ) r
9889:   real    ( kind = 8 ) rho
9890:   real    ( kind = 8 ) s
9891:   real    ( kind = 8 ) t
9892:   real    ( kind = 8 ) u1
9893:   real    ( kind = 8 ) u2
9894:   real    ( kind = 8 ) v1
9895:   real    ( kind = 8 ) v2
9896:   real    ( kind = 8 ) z(n,n)
9897: !
9898: !  Set Z to the identity matrix.
9899: !
9900:   if ( matz ) then
9901: 
9902:     z(1:n,1:n) = 0.0D+00
9903: 
9904:     do i = 1, n
9905:       z(i,i) = 1.0D+00
9906:     end do
9907: 
9908:   end if
9909: !
9910: !  Reduce B to upper triangular form.
9911: !
9912:   if ( n <= 1 ) then
9913:     return
9914:   end if
9915: 
9916:   nm1 = n - 1
9917: 
9918:   do l = 1, n-1
9919: 
9920:     l1 = l + 1
9921: 
9922:     s = sum ( abs ( b(l+1:n,l) ) )
9923: 
9924:     if ( s /= 0.0D+00 ) then
9925: 
9926:       s = s + abs ( b(l,l) )
9927:       b(l:n,l) = b(l:n,l) / s
9928: 
9929:       r = sqrt ( sum ( b(l:n,l)**2 ) )
9930:       r = sign ( r, b(l,l) )
9931:       b(l,l) = b(l,l) + r
9932:       rho = r * b(l,l)
9933: 
9934:       do j = l+1, n
9935: 
9936:         t = dot_product ( b(l:n,l), b(l:n,j) )
9937: 
9938:         b(l:n,j) = b(l:n,j) - t * b(l:n,l) / rho
9939: 
9940:       end do
9941: 
9942:       do j = 1, n
9943: 
9944:         t = dot_product ( b(l:n,l), a(l:n,j) )
9945: 
9946:         a(l:n,j) = a(l:n,j) - t * b(l:n,l) / rho
9947: 
9948:       end do
9949: 
9950:       b(l,l) = - s * r
9951:       b(l+1:n,l) = 0.0D+00
9952: 
9953:     end if
9954: 
9955:   end do
9956: !
9957: !  Reduce A to upper Hessenberg form, while keeping B triangular.
9958: !
9959:   if ( n == 2 ) then
9960:     return
9961:   end if
9962: 
9963:   do k = 1, n-2
9964: 
9965:      nk1 = nm1 - k
9966: 
9967:      do lb = 1, nk1
9968: 
9969:         l = n - lb
9970:         l1 = l + 1
9971: !
9972: !  Zero A(l+1,k).
9973: !
9974:         s = abs ( a(l,k) ) + abs ( a(l1,k) )
9975: 
9976:         if ( s /= 0.0D+00 ) then
9977: 
9978:         u1 = a(l,k) / s
9979:         u2 = a(l1,k) / s
9980:         r = sign ( sqrt ( u1**2 + u2**2 ), u1 )
9981:         v1 =  -(u1 + r) / r
9982:         v2 = -u2 / r
9983:         u2 = v2 / v1
9984: 
9985:         do j = k, n
9986:           t = a(l,j) + u2 * a(l1,j)
9987:           a(l,j) = a(l,j) + t * v1
9988:           a(l1,j) = a(l1,j) + t * v2
9989:         end do
9990: 
9991:         a(l1,k) = 0.0D+00
9992: 
9993:         do j = l, n
9994:           t = b(l,j) + u2 * b(l1,j)
9995:           b(l,j) = b(l,j) + t * v1
9996:           b(l1,j) = b(l1,j) + t * v2
9997:         end do
9998: !
9999: !  Zero B(l+1,l).
10000: !
10001:         s = abs ( b(l1,l1) ) + abs ( b(l1,l) )
10002: 
10003:         if ( s /= 0.0 ) then
10004: 
10005:         u1 = b(l1,l1) / s
10006:         u2 = b(l1,l) / s
10007:         r = sign ( sqrt ( u1**2 + u2**2 ), u1 )
10008:         v1 =  -( u1 + r ) / r
10009:         v2 = -u2 / r
10010:         u2 = v2 / v1
10011: 
10012:         do i = 1, l1
10013:           t = b(i,l1) + u2 * b(i,l)
10014:           b(i,l1) = b(i,l1) + t * v1
10015:           b(i,l) = b(i,l) + t * v2
10016:         end do
10017: 
10018:         b(l1,l) = 0.0D+00
10019: 
10020:         do i = 1, n
10021:           t = a(i,l1) + u2 * a(i,l)
10022:           a(i,l1) = a(i,l1) + t * v1
10023:           a(i,l) = a(i,l) + t * v2
10024:         end do
10025: 
10026:         if ( matz ) then
10027: 
10028:           do i = 1, n
10029:             t = z(i,l1) + u2 * z(i,l)
10030:             z(i,l1) = z(i,l1) + t * v1
10031:             z(i,l) = z(i,l) + t * v2
10032:           end do
10033: 
10034:         end if
10035: 
10036:         end if
10037: 
10038:       end if
10039: 
10040:     end do
10041: 
10042:   end do
10043: 
10044:   return
10045: end
<p><a name=qzit><H3>qzit</H3></a></p> Click <a href="./callingtree/qzit_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where qzit is used.
<hr>
10046: subroutine qzit ( n, a, b, eps1, matz, z, ierr )
10047: 
10048: !*****************************************************************************80
10049: !
10050: !! QZIT carries out iterations to solve a generalized eigenvalue problem.
10051: !
10052: !  Discussion:
10053: !
10054: !    This subroutine is the second step of the QZ algorithm
10055: !    for solving generalized matrix eigenvalue problems.
10056: !
10057: !    This subroutine accepts a pair of real matrices, one of them
10058: !    in upper Hessenberg form and the other in upper triangular form.
10059: !    It reduces the Hessenberg matrix to quasi-triangular form using
10060: !    orthogonal transformations while maintaining the triangular form
10061: !    of the other matrix.  It is usually preceded by QZHES and
10062: !    followed by QZVAL and, possibly, QZVEC.
10063: !
10064: !  Licensing:
10065: !
10066: !    This code is distributed under the GNU LGPL license.
10067: !
10068: !  Modified:
10069: !
10070: !    18 October 2009
10071: !
10072: !  Author:
10073: !
10074: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
10075: !    Klema, Moler.
10076: !    FORTRAN90 version by John Burkardt.
10077: !
10078: !  Reference:
10079: !
10080: !    James Wilkinson, Christian Reinsch,
10081: !    Handbook for Automatic Computation,
10082: !    Volume II, Linear Algebra, Part 2,
10083: !    Springer, 1971,
10084: !    ISBN: 0387054146,
10085: !    LC: QA251.W67.
10086: !
10087: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
10088: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
10089: !    Matrix Eigensystem Routines, EISPACK Guide,
10090: !    Lecture Notes in Computer Science, Volume 6,
10091: !    Springer Verlag, 1976,
10092: !    ISBN13: 978-3540075462,
10093: !    LC: QA193.M37.
10094: !
10095: !  Parameters:
10096: !
10097: !    Input, integer ( kind = 4 ) N, the order of the matrices.
10098: !
10099: !    Input/output, real ( kind = 8 ) A(N,N).  On input, a real upper Hessenberg matrix.
10100: !    On output, A has been reduced to quasi-triangular form.  The elements
10101: !    below the first subdiagonal are still zero and no two consecutive 
10102: !    subdiagonal elements are nonzero.
10103: !
10104: !    Input/output, real ( kind = 8 ) B(N,N).  On input, a real upper triangular matrix.
10105: !    On output, B is still in upper triangular form, although its elements
10106: !    have been altered.  The location B(N,1) is used to store EPS1 times 
10107: !    the norm of B for later use by QZVAL and QZVEC.
10108: !
10109: !    Input, real ( kind = 8 ) EPS1, a tolerance used to determine negligible elements.
10110: !    EPS1 = 0.0D+00 (or negative) may be input, in which case an element 
10111: !    will be neglected only if it is less than roundoff error times the 
10112: !    norm of its matrix.  If the input EPS1 is positive, then an element 
10113: !    will be considered negligible if it is less than EPS1 times the norm 
10114: !    of its matrix.  A positive value of EPS1 may result in faster execution,
10115: !    but less accurate results.
10116: !
10117: !    Input, logical MATZ, should be TRUE if the right hand transformations
10118: !    are to be accumulated for later use in computing eigenvectors.
10119: !
10120: !    Input/output, real ( kind = 8 ) Z(N,N).  If MATZ is FALSE, Z is not referenced.
10121: !    Otherwise, on input, the transformation matrix produced in the reduction 
10122: !    by QZHES, if performed, or else the identity matrix.  On output, Z 
10123: !    contains the product of the right hand transformations for both steps.
10124: !
10125: !    Output, integer ( kind = 4 ) IERR, error flag.
10126: !    0, for normal return,
10127: !    J, if the limit of 30*N iterations is exhausted while the J-th 
10128: !      eigenvalue is being sought.
10129: !
10130:   implicit none
10131: 
10132:   integer ( kind = 4 ) n
10133: 
10134:   real    ( kind = 8 ) a(n,n)
10135:   real    ( kind = 8 ) a1
10136:   real    ( kind = 8 ) a11
10137:   real    ( kind = 8 ) a12
10138:   real    ( kind = 8 ) a2
10139:   real    ( kind = 8 ) a21
10140:   real    ( kind = 8 ) a22
10141:   real    ( kind = 8 ) a3
10142:   real    ( kind = 8 ) a33
10143:   real    ( kind = 8 ) a34
10144:   real    ( kind = 8 ) a43
10145:   real    ( kind = 8 ) a44
10146:   real    ( kind = 8 ) ani
10147:   real    ( kind = 8 ) anorm
10148:   real    ( kind = 8 ) b(n,n)
10149:   real    ( kind = 8 ) b11
10150:   real    ( kind = 8 ) b12
10151:   real    ( kind = 8 ) b22
10152:   real    ( kind = 8 ) b33
10153:   real    ( kind = 8 ) b34
10154:   real    ( kind = 8 ) b44
10155:   real    ( kind = 8 ) bni
10156:   real    ( kind = 8 ) bnorm
10157:   integer ( kind = 4 ) en
10158:   integer ( kind = 4 ) enm2
10159:   integer ( kind = 4 ) enorn
10160:   real    ( kind = 8 ) ep
10161:   real    ( kind = 8 ) eps1
10162:   real    ( kind = 8 ) epsa
10163:   real    ( kind = 8 ) epsb
10164:   integer ( kind = 4 ) i
10165:   integer ( kind = 4 ) ierr
10166:   integer ( kind = 4 ) ish
10167:   integer ( kind = 4 ) itn
10168:   integer ( kind = 4 ) its
10169:   integer ( kind = 4 ) j
10170:   integer ( kind = 4 ) k
10171:   integer ( kind = 4 ) k1
10172:   integer ( kind = 4 ) k2
10173:   integer ( kind = 4 ) km1
10174:   integer ( kind = 4 ) l
10175:   integer ( kind = 4 ) l1
10176:   integer ( kind = 4 ) ld
10177:   integer ( kind = 4 ) ll
10178:   integer ( kind = 4 ) lm1
10179:   integer ( kind = 4 ) lor1
10180:   logical              matz
10181:   integer ( kind = 4 ) na
10182:   logical              notlas
10183:   real    ( kind = 8 ) r
10184:   real    ( kind = 8 ) s
10185:   real    ( kind = 8 ) sh
10186:   real    ( kind = 8 ) t
10187:   real    ( kind = 8 ) u1
10188:   real    ( kind = 8 ) u2
10189:   real    ( kind = 8 ) u3
10190:   real    ( kind = 8 ) v1
10191:   real    ( kind = 8 ) v2
10192:   real    ( kind = 8 ) v3
10193:   real    ( kind = 8 ) z(n,n)
10194: 
10195:   ierr = 0
10196: !
10197: !  Compute EPSA and EPSB.
10198: !
10199:   anorm = 0.0D+00
10200:   bnorm = 0.0D+00
10201: 
10202:   do i = 1, n
10203: 
10204:     if ( i == 1 ) then
10205:       ani = 0.0D+00
10206:     else
10207:       ani = abs ( a(i,i-1) )
10208:     end if
10209: 
10210:     bni = 0.0D+00
10211: 
10212:     do j = i, n
10213:       ani = ani + abs ( a(i,j) )
10214:       bni = bni + abs ( b(i,j) )
10215:     end do
10216: 
10217:     anorm = max ( anorm, ani )
10218:     bnorm = max ( bnorm, bni )
10219: 
10220:   end do
10221: 
10222:   if ( anorm == 0.0D+00 ) then
10223:     anorm = 1.0D+00
10224:   end if
10225: 
10226:   if ( bnorm == 0.0D+00 ) then
10227:     bnorm = 1.0D+00
10228:   end if
10229: 
10230:   ep = eps1
10231: 
10232:   if ( ep > 0.0D+00 ) then
10233:     go to 50
10234:   end if
10235: !
10236: !  Use roundoff level if EPS1 is 0.
10237: !
10238:   ep = epsilon ( ep )
10239: 
10240: 50 continue
10241: 
10242:   epsa = ep * anorm
10243:   epsb = ep * bnorm
10244: !
10245: !  Reduce A to quasi-triangular form, while keeping B triangular.
10246: !
10247:   lor1 = 1
10248:   enorn = n
10249:   en = n
10250:   itn = 30 * n
10251: !
10252: !  Begin QZ step.
10253: !
10254: 60 continue
10255: 
10256:   if ( en <= 2 ) then
10257:     go to 1001
10258:   end if
10259: 
10260:   if (.not. matz) enorn = en
10261:   its = 0
10262:   na = en - 1
10263:   enm2 = na - 1
10264: 
10265: 70 continue
10266: 
10267:   ish = 2
10268: !
10269: !  Check for convergence or reducibility.
10270: !
10271:   do ll = 1, en
10272:     lm1 = en - ll
10273:     l = lm1 + 1
10274:     if ( l == 1 ) go to 95
10275:     if ( abs ( a(l,lm1) ) <= epsa ) then
10276:       exit
10277:     end if
10278:   end do
10279: 
10280: 90 continue
10281: 
10282:   a(l,lm1) = 0.0D+00
10283:   if ( l < na ) go to 95
10284: !
10285: !  1-by-1 or 2-by-2 block isolated.
10286: !
10287:   en = lm1
10288:   go to 60
10289: !
10290: !  Check for small top of B.
10291: !
10292: 95 continue
10293: 
10294:   ld = l
10295: 
10296: 100 continue
10297: 
10298:   l1 = l + 1
10299:   b11 = b(l,l)
10300: 
10301:   if ( abs ( b11 ) > epsb ) go to 120
10302: 
10303:   b(l,l) = 0.0D+00
10304:   s = abs ( a(l,l) ) + abs ( a(l1,l) )
10305:   u1 = a(l,l) / s
10306:   u2 = a(l1,l) / s
10307:   r = sign ( sqrt ( u1**2 + u2**2 ), u1 )
10308:   v1 = - ( u1 + r ) / r
10309:   v2 = -u2 / r
10310:   u2 = v2 / v1
10311: 
10312:   do j = l, enorn
10313:     t = a(l,j) + u2 * a(l1,j)
10314:     a(l,j) = a(l,j) + t * v1
10315:     a(l1,j) = a(l1,j) + t * v2
10316:     t = b(l,j) + u2 * b(l1,j)
10317:     b(l,j) = b(l,j) + t * v1
10318:     b(l1,j) = b(l1,j) + t * v2
10319:   end do
10320: 
10321:   if ( l /= 1 ) then
10322:     a(l,lm1) = -a(l,lm1)
10323:   end if
10324:   lm1 = l
10325:   l = l1
10326:   go to 90
10327: 
10328: 120 continue
10329: 
10330:   a11 = a(l,l) / b11
10331:   a21 = a(l1,l) / b11
10332:   if ( ish == 1 ) go to 140
10333: !
10334: !  Iteration strategy.
10335: !
10336:   if ( itn == 0 ) go to 1000
10337:   if ( its == 10 ) go to 155
10338: !
10339: !  Determine type of shift.
10340: !
10341:   b22 = b(l1,l1)
10342:   if ( abs ( b22 ) < epsb ) b22 = epsb
10343:   b33 = b(na,na)
10344:   if ( abs ( b33 ) < epsb ) b33 = epsb
10345:   b44 = b(en,en)
10346:   if ( abs ( b44 ) < epsb ) b44 = epsb
10347:   a33 = a(na,na) / b33
10348:   a34 = a(na,en) / b44
10349:   a43 = a(en,na) / b33
10350:   a44 = a(en,en) / b44
10351:   b34 = b(na,en) / b44
10352:   t = 0.5D+00 * (a43 * b34 - a33 - a44)
10353:   r = t * t + a34 * a43 - a33 * a44
10354: 
10355:   if ( r < 0.0D+00 ) go to 150
10356: !
10357: !  Determine single shift zeroth column of A.
10358: !
10359:   ish = 1
10360:   r = sqrt ( r )
10361:   sh = -t + r
10362:   s = -t - r
10363:   if ( abs ( s - a44 ) < abs ( sh - a44 ) ) sh = s
10364: !
10365: !  Look for two consecutive small sub-diagonal elements of A.
10366: ! 
10367:   do ll = ld, enm2
10368:     l = enm2 + ld - ll
10369:     if ( l == ld ) then
10370:       exit
10371:     end if
10372:     lm1 = l - 1
10373:     l1 = l + 1
10374:     t = a(l,l)
10375:     if ( abs ( b(l,l) ) > epsb ) t = t - sh * b(l,l)
10376:     if ( abs ( a(l,lm1) ) <= abs ( t / a(l1,l) ) * epsa ) go to 100
10377:   end do
10378: 
10379: 140 continue
10380: 
10381:   a1 = a11 - sh
10382:   a2 = a21
10383: 
10384:   if ( l /= ld ) then
10385:     a(l,lm1) = -a(l,lm1)
10386:   end if
10387: 
10388:   go to 160
10389: !
10390: !  Determine double shift zeroth column of A.
10391: !
10392: 150 continue
10393: 
10394:   a12 = a(l,l1) / b22
10395:   a22 = a(l1,l1) / b22
10396:   b12 = b(l,l1) / b22
10397:   a1 = ( ( a33 - a11 ) * ( a44 - a11 ) - a34 * a43 + a43 * b34 * a11 ) &
10398:     / a21 + a12 - a11 * b12
10399:   a2 = (a22 - a11) - a21 * b12 - (a33 - a11) - (a44 - a11) + a43 * b34
10400:   a3 = a(l1+1,l1) / b22
10401:   go to 160
10402: !
10403: !  Ad hoc shift.
10404: !
10405: 155 continue
10406: 
10407:   a1 = 0.0D+00
10408:   a2 = 1.0D+00
10409:   a3 = 1.1605D+00
10410: 
10411:   160 continue
10412:   its = its + 1
10413:   itn = itn - 1
10414:   if ( .not. matz ) lor1 = ld
10415: !
10416: !  Main loop.
10417: !
10418:   do k = l, na
10419: 
10420:      notlas = k /= na .and. ish == 2
10421:      k1 = k + 1
10422:      k2 = k + 2
10423:      km1 = max ( k-1, l )
10424:      ll = min ( en, k1+ish )
10425: 
10426:      if ( notlas ) go to 190
10427: !
10428: !  Zero A(k+1,k-1).
10429: !
10430:      if ( k /= l ) then
10431:        a1 = a(k,km1)
10432:        a2 = a(k1,km1)
10433:      end if
10434: 
10435:      s = abs ( a1 ) + abs ( a2 )
10436: 
10437:      if ( s == 0.0D+00 ) go to 70
10438: 
10439:      u1 = a1 / s
10440:      u2 = a2 / s
10441:      r = sign ( sqrt ( u1**2 + u1**2 ), u1 )
10442:      v1 = -( u1 + r ) / r
10443:      v2 = -u2 / r
10444:      u2 = v2 / v1
10445: 
10446:      do j = km1, enorn
10447:        t = a(k,j) + u2 * a(k1,j)
10448:        a(k,j) = a(k,j) + t * v1
10449:        a(k1,j) = a(k1,j) + t * v2
10450:        t = b(k,j) + u2 * b(k1,j)
10451:        b(k,j) = b(k,j) + t * v1
10452:        b(k1,j) = b(k1,j) + t * v2
10453:      end do
10454: 
10455:      if ( k /= l ) then
10456:        a(k1,km1) = 0.0D+00
10457:      end if
10458: 
10459:      go to 240
10460: !
10461: !  Zero A(k+1,k-1) and A(k+2,k-1).
10462: !
10463: 190  continue
10464: 
10465:      if ( k /= l ) then
10466:        a1 = a(k,km1)
10467:        a2 = a(k1,km1)
10468:        a3 = a(k2,km1)
10469:      end if
10470: 
10471:      s = abs ( a1 ) + abs ( a2 ) + abs ( a3 )
10472: 
10473:      if ( s == 0.0D+00 ) go to 260
10474: 
10475:      u1 = a1 / s
10476:      u2 = a2 / s
10477:      u3 = a3 / s
10478:      r = sign ( sqrt ( u1**2 + u2**2 + u3**2 ), u1 )
10479:      v1 = -(u1 + r) / r
10480:      v2 = -u2 / r
10481:      v3 = -u3 / r
10482:      u2 = v2 / v1
10483:      u3 = v3 / v1
10484: 
10485:      do j = km1, enorn
10486:        t = a(k,j) + u2 * a(k1,j) + u3 * a(k2,j)
10487:        a(k,j) = a(k,j) + t * v1
10488:        a(k1,j) = a(k1,j) + t * v2
10489:        a(k2,j) = a(k2,j) + t * v3
10490:        t = b(k,j) + u2 * b(k1,j) + u3 * b(k2,j)
10491:        b(k,j) = b(k,j) + t * v1
10492:        b(k1,j) = b(k1,j) + t * v2
10493:        b(k2,j) = b(k2,j) + t * v3
10494:      end do
10495: 
10496:      if ( k /= l ) then
10497:        a(k1,km1) = 0.0D+00
10498:        a(k2,km1) = 0.0D+00
10499:      end if
10500: !
10501: !  Zero B(k+2,k+1) and B(k+2,k).
10502: !
10503:      s = abs ( b(k2,k2) ) + abs ( b(k2,k1) ) + abs ( b(k2,k) )
10504:      if ( s == 0.0D+00 ) go to 240
10505:      u1 = b(k2,k2) / s
10506:      u2 = b(k2,k1) / s
10507:      u3 = b(k2,k) / s
10508:      r = sign ( sqrt ( u1**2 + u2**2 + u3**2 ), u1 )
10509:      v1 = -(u1 + r) / r
10510:      v2 = -u2 / r
10511:      v3 = -u3 / r
10512:      u2 = v2 / v1
10513:      u3 = v3 / v1
10514: 
10515:      do i = lor1, ll
10516:        t = a(i,k2) + u2 * a(i,k1) + u3 * a(i,k)
10517:        a(i,k2) = a(i,k2) + t * v1
10518:        a(i,k1) = a(i,k1) + t * v2
10519:        a(i,k) = a(i,k) + t * v3
10520:        t = b(i,k2) + u2 * b(i,k1) + u3 * b(i,k)
10521:        b(i,k2) = b(i,k2) + t * v1
10522:        b(i,k1) = b(i,k1) + t * v2
10523:        b(i,k) = b(i,k) + t * v3
10524:      end do
10525: 
10526:      b(k2,k) = 0.0D+00
10527:      b(k2,k1) = 0.0D+00
10528: 
10529:      if ( matz ) then
10530: 
10531:        do i = 1, n
10532:          t = z(i,k2) + u2 * z(i,k1) + u3 * z(i,k)
10533:          z(i,k2) = z(i,k2) + t * v1
10534:          z(i,k1) = z(i,k1) + t * v2
10535:          z(i,k) = z(i,k) + t * v3
10536:        end do
10537: 
10538:      end if
10539: !
10540: !  Zero B(k+1,k).
10541: !
10542: 240  continue
10543: 
10544:      s = abs ( b(k1,k1) ) + abs ( b(k1,k) )
10545: 
10546:      if ( s /= 0.0D+00 ) then
10547: 
10548:      u1 = b(k1,k1) / s
10549:      u2 = b(k1,k) / s
10550:      r = sign ( sqrt ( u1**2 + u2**2 ), u1 )
10551:      v1 = -( u1 + r ) / r
10552:      v2 = -u2 / r
10553:      u2 = v2 / v1
10554: 
10555:      do i = lor1, ll
10556:        t = a(i,k1) + u2 * a(i,k)
10557:        a(i,k1) = a(i,k1) + t * v1
10558:        a(i,k) = a(i,k) + t * v2
10559:        t = b(i,k1) + u2 * b(i,k)
10560:        b(i,k1) = b(i,k1) + t * v1
10561:        b(i,k) = b(i,k) + t * v2
10562:      end do
10563: 
10564:      b(k1,k) = 0.0D+00
10565: 
10566:      if ( matz ) then
10567: 
10568:        do i = 1, n
10569:          t = z(i,k1) + u2 * z(i,k)
10570:          z(i,k1) = z(i,k1) + t * v1
10571:          z(i,k) = z(i,k) + t * v2
10572:        end do
10573: 
10574:      end if
10575: 
10576:    end if
10577: 
10578: 260  continue
10579: 
10580:   end do
10581: 
10582:   go to 70
10583: !
10584: !  Set error: not all eigenvalues have converged after 30*N iterations.
10585: !
10586: 1000 continue
10587: 
10588:   ierr = en
10589: !
10590: !  Save EPSB for use by QZVAL and QZVEC.
10591: !
10592:  1001 continue
10593: 
10594:   if ( n > 1 ) then
10595:     b(n,1) = epsb
10596:   end if
10597: 
10598:   return
10599: end
<p><a name=qzval><H3>qzval</H3></a></p> Click <a href="./callingtree/qzval_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where qzval is used.
<hr>
10600: subroutine qzval ( n, a, b, alfr, alfi, beta, matz, z )
10601: 
10602: !*****************************************************************************80
10603: !
10604: !! QZVAL computes eigenvalues for a generalized eigenvalue problem.
10605: !
10606: !  Discussion:
10607: !
10608: !    This subroutine is the third step of the QZ algorithm
10609: !    for solving generalized matrix eigenvalue problems.
10610: !
10611: !    This subroutine accepts a pair of real matrices, one of them
10612: !    in quasi-triangular form and the other in upper triangular form.
10613: !    It reduces the quasi-triangular matrix further, so that any
10614: !    remaining 2-by-2 blocks correspond to pairs of complex
10615: !    eigenvalues, and returns quantities whose ratios give the
10616: !    generalized eigenvalues.  It is usually preceded by QZHES
10617: !    and QZIT and may be followed by QZVEC.
10618: !
10619: !  Licensing:
10620: !
10621: !    This code is distributed under the GNU LGPL license.
10622: !
10623: !  Modified:
10624: !
10625: !    18 October 2009
10626: !
10627: !  Author:
10628: !
10629: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
10630: !    Klema, Moler.
10631: !    FORTRAN90 version by John Burkardt.
10632: !
10633: !  Reference:
10634: !
10635: !    James Wilkinson, Christian Reinsch,
10636: !    Handbook for Automatic Computation,
10637: !    Volume II, Linear Algebra, Part 2,
10638: !    Springer, 1971,
10639: !    ISBN: 0387054146,
10640: !    LC: QA251.W67.
10641: !
10642: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
10643: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
10644: !    Matrix Eigensystem Routines, EISPACK Guide,
10645: !    Lecture Notes in Computer Science, Volume 6,
10646: !    Springer Verlag, 1976,
10647: !    ISBN13: 978-3540075462,
10648: !    LC: QA193.M37.
10649: !
10650: !  Parameters:
10651: !
10652: !    Input, integer ( kind = 4 ) N, the order of the matrices.
10653: !
10654: !    Input/output, real ( kind = 8 ) A(N,N).  On input, a real upper quasi-triangular 
10655: !    matrix.  On output, A has been reduced further to a quasi-triangular 
10656: !    matrix in which all nonzero subdiagonal elements correspond to
10657: !    pairs of complex eigenvalues.
10658: !
10659: !    Input/output, real ( kind = 8 ) B(N,N).  On input, a real upper triangular matrix.  
10660: !    In addition, location B(n,1) contains the tolerance quantity EPSB
10661: !    computed and saved in QZIT.  On output, B is still in upper triangular 
10662: !    form, although its elements have been altered.  B(N,1) is unaltered.
10663: !
10664: !    Output, real ( kind = 8 ) ALFR(N), ALFI(N), the real and imaginary parts of the
10665: !    diagonal elements of the triangular matrix that would be obtained 
10666: !    if A were reduced completely to triangular form by unitary 
10667: !    transformations.  Non-zero values of ALFI occur in pairs, the first 
10668: !    member positive and the second negative.
10669: !
10670: !    Output, real ( kind = 8 ) BETA(N), the diagonal elements of the corresponding B,
10671: !    normalized to be real and non-negative.  The generalized eigenvalues 
10672: !    are then the ratios (ALFR + I * ALFI) / BETA.
10673: !
10674: !    Input, logical MATZ, should be TRUE if the right hand transformations
10675: !    are to be accumulated for later use in computing eigenvectors, and 
10676: !    to FALSE otherwise.
10677: !
10678: !    Input/output, real ( kind = 8 ) Z(N,N), is only used if MATZ is TRUE.
10679: !    On input, the transformation matrix produced in the reductions by QZHES
10680: !    and QZIT, if performed, or else the identity matrix.  On output, 
10681: !    the product of the right hand transformations for all three steps.
10682: !
10683:   implicit none
10684: 
10685:   integer ( kind = 4 ) n
10686: 
10687:   real    ( kind = 8 ) a(n,n)
10688:   real    ( kind = 8 ) a1
10689:   real    ( kind = 8 ) a11
10690:   real    ( kind = 8 ) a11i
10691:   real    ( kind = 8 ) a11r
10692:   real    ( kind = 8 ) a12
10693:   real    ( kind = 8 ) a12i
10694:   real    ( kind = 8 ) a12r
10695:   real    ( kind = 8 ) a1i
10696:   real    ( kind = 8 ) a2
10697:   real    ( kind = 8 ) a21
10698:   real    ( kind = 8 ) a22
10699:   real    ( kind = 8 ) a22i
10700:   real    ( kind = 8 ) a22r
10701:   real    ( kind = 8 ) a2i
10702:   real    ( kind = 8 ) an
10703:   real    ( kind = 8 ) alfi(n)
10704:   real    ( kind = 8 ) alfr(n)
10705:   real    ( kind = 8 ) b(n,n)
10706:   real    ( kind = 8 ) b11
10707:   real    ( kind = 8 ) b12
10708:   real    ( kind = 8 ) b22
10709:   real    ( kind = 8 ) beta(n)
10710:   real    ( kind = 8 ) bn
10711:   real    ( kind = 8 ) c
10712:   real    ( kind = 8 ) cq
10713:   real    ( kind = 8 ) cz
10714:   real    ( kind = 8 ) d
10715:   real    ( kind = 8 ) di
10716:   real    ( kind = 8 ) dr
10717:   real    ( kind = 8 ) e
10718:   real    ( kind = 8 ) ei
10719:   integer ( kind = 4 ) en
10720:   real    ( kind = 8 ) epsb
10721:   integer ( kind = 4 ) i
10722:   integer ( kind = 4 ) isw
10723:   integer ( kind = 4 ) j
10724:   logical              matz
10725:   integer ( kind = 4 ) na
10726:   integer ( kind = 4 ) nn
10727:   real    ( kind = 8 ) r
10728:   real    ( kind = 8 ) s
10729:   real    ( kind = 8 ) sqi
10730:   real    ( kind = 8 ) sqr
10731:   real    ( kind = 8 ) ssi
10732:   real    ( kind = 8 ) ssr
10733:   real    ( kind = 8 ) szi
10734:   real    ( kind = 8 ) szr
10735:   real    ( kind = 8 ) t
10736:   real    ( kind = 8 ) ti
10737:   real    ( kind = 8 ) tr
10738:   real    ( kind = 8 ) u1
10739:   real    ( kind = 8 ) u2
10740:   real    ( kind = 8 ) v1
10741:   real    ( kind = 8 ) v2
10742:   real    ( kind = 8 ) z(n,n)
10743: 
10744:   epsb = b(n,1)
10745:   isw = 1
10746: !
10747: !  Find eigenvalues of quasi-triangular matrices.
10748: !
10749:   do nn = 1, n
10750: 
10751:      en = n + 1 - nn
10752:      na = en - 1
10753: 
10754:      if ( isw == 2 ) go to 505
10755: 
10756:      if ( en == 1 ) go to 410
10757: 
10758:      if ( a(en,na) /= 0.0D+00 ) go to 420
10759: !
10760: !  1-by-1 block, one real root.
10761: !
10762: 410  continue
10763: 
10764:      alfr(en) = a(en,en)
10765:      if ( b(en,en) < 0.0D+00 ) alfr(en) = -alfr(en)
10766:      beta(en) = abs ( b(en,en) )
10767:      alfi(en) = 0.0D+00
10768:      go to 510
10769: !
10770: !  2-by-2 block.
10771: !
10772: 420  continue
10773: 
10774:      if ( abs ( b(na,na) ) <= epsb ) then
10775:        a1 = a(na,na)
10776:        a2 = a(en,na)
10777:        go to 460
10778:      end if
10779: 
10780:      if ( abs ( b(en,en) ) <= epsb ) then
10781:        a1 = a(en,en)
10782:        a2 = a(en,na)
10783:        bn = 0.0D+00
10784:        go to 435
10785:      end if
10786: 
10787:      an = abs ( a(na,na) ) + abs ( a(na,en) ) + abs ( a(en,na) ) &
10788:        + abs ( a(en,en) )
10789:      bn = abs ( b(na,na) ) + abs ( b(na,en) ) + abs ( b(en,en) )
10790:      a11 = a(na,na) / an
10791:      a12 = a(na,en) / an
10792:      a21 = a(en,na) / an
10793:      a22 = a(en,en) / an
10794:      b11 = b(na,na) / bn
10795:      b12 = b(na,en) / bn
10796:      b22 = b(en,en) / bn
10797:      e = a11 / b11
10798:      ei = a22 / b22
10799:      s = a21 / ( b11 * b22 )
10800:      t = ( a22 - e * b22 ) / b22
10801: 
10802:      if ( abs ( e ) > abs ( ei ) ) then
10803:        e = ei
10804:        t = ( a11 - e * b11 ) / b11
10805:      end if
10806: 
10807:      c = 0.5D+00 * ( t - s * b12 )
10808:      d = c**2 + s * ( a12 - e * b12 )
10809: 
10810:      if ( d < 0.0D+00 ) then
10811:        go to 480
10812:      end if
10813: !
10814: !  Two real roots.
10815: !  Zero both A(EN,NA) and B(EN,NA).
10816: !
10817:      e = e + ( c + sign ( sqrt ( d ), c ) )
10818:      a11 = a11 - e * b11
10819:      a12 = a12 - e * b12
10820:      a22 = a22 - e * b22
10821: 
10822:      if ( abs ( a11 ) + abs ( a12 ) >= abs ( a21 ) + abs ( a22 ) ) then
10823:        a1 = a12
10824:        a2 = a11
10825:      else
10826:        a1 = a22
10827:        a2 = a21
10828:      end if
10829: !
10830: !  Choose and apply real Z.
10831: !
10832: 435  continue
10833: 
10834:      s = abs ( a1 ) + abs ( a2 )
10835:      u1 = a1 / s
10836:      u2 = a2 / s
10837:      r = sign ( sqrt ( u1**2 + u2**2 ), u1 )
10838:      v1 = - ( u1 + r ) / r
10839:      v2 = - u2 / r
10840:      u2 = v2 / v1
10841: 
10842:      do i = 1, en
10843:        t = a(i,en) + u2 * a(i,na)
10844:        a(i,en) = a(i,en) + t * v1
10845:        a(i,na) = a(i,na) + t * v2
10846:        t = b(i,en) + u2 * b(i,na)
10847:        b(i,en) = b(i,en) + t * v1
10848:        b(i,na) = b(i,na) + t * v2
10849:      end do
10850: 
10851:      if ( matz ) then
10852: 
10853:        do i = 1, n
10854:          t = z(i,en) + u2 * z(i,na)
10855:          z(i,en) = z(i,en) + t * v1
10856:          z(i,na) = z(i,na) + t * v2
10857:        end do
10858: 
10859:      end if
10860: 
10861:      if ( bn == 0.0D+00 ) go to 475
10862: 
10863:      if ( an >= abs ( e ) * bn ) then
10864:        a1 = b(na,na)
10865:        a2 = b(en,na)
10866:      else
10867:        a1 = a(na,na)
10868:        a2 = a(en,na)
10869:      end if
10870: !
10871: !  Choose and apply real Q.
10872: !
10873: 460  continue
10874: 
10875:      s = abs ( a1 ) + abs ( a2 )
10876:      if ( s == 0.0D+00 ) go to 475
10877:      u1 = a1 / s
10878:      u2 = a2 / s
10879:      r = sign ( sqrt ( u1**2 + u2**2 ), u1 )
10880:      v1 = -(u1 + r) / r
10881:      v2 = -u2 / r
10882:      u2 = v2 / v1
10883: 
10884:      do j = na, n
10885:        t = a(na,j) + u2 * a(en,j)
10886:        a(na,j) = a(na,j) + t * v1
10887:        a(en,j) = a(en,j) + t * v2
10888:        t = b(na,j) + u2 * b(en,j)
10889:        b(na,j) = b(na,j) + t * v1
10890:        b(en,j) = b(en,j) + t * v2
10891:      end do
10892: 
10893: 475  continue
10894: 
10895:      a(en,na) = 0.0D+00
10896:      b(en,na) = 0.0D+00
10897:      alfr(na) = a(na,na)
10898:      alfr(en) = a(en,en)
10899:      if ( b(na,na) < 0.0D+00 ) alfr(na) = -alfr(na)
10900:      if ( b(en,en) < 0.0D+00 ) alfr(en) = -alfr(en)
10901:      beta(na) = abs ( b(na,na) )
10902:      beta(en) = abs ( b(en,en) )
10903:      alfi(en) = 0.0D+00
10904:      alfi(na) = 0.0D+00
10905:      go to 505
10906: !
10907: !  Two complex roots.
10908: !
10909: 480  continue
10910: 
10911:      e = e + c
10912:      ei = sqrt ( -d )
10913:      a11r = a11 - e * b11
10914:      a11i = ei * b11
10915:      a12r = a12 - e * b12
10916:      a12i = ei * b12
10917:      a22r = a22 - e * b22
10918:      a22i = ei * b22
10919: 
10920:      if ( abs ( a11r ) + abs ( a11i ) + abs ( a12r ) + abs ( a12i ) >= &
10921:             abs ( a21 ) + abs ( a22r ) + abs ( a22i ) ) then
10922:        a1 = a12r
10923:        a1i = a12i
10924:        a2 = -a11r
10925:        a2i = -a11i
10926:      else
10927:        a1 = a22r
10928:        a1i = a22i
10929:        a2 = -a21
10930:        a2i = 0.0D+00
10931:      end if
10932: !
10933: !  Choose complex Z.
10934: !
10935:      cz = sqrt ( a1**2 + a1i**2 )
10936: 
10937:      if ( cz /= 0.0D+00 ) then
10938:        szr = ( a1 * a2 + a1i * a2i) / cz
10939:        szi = ( a1 * a2i - a1i * a2) / cz
10940:        r = sqrt ( cz**2 + szr**2 + szi**2 )
10941:        cz = cz / r
10942:        szr = szr / r
10943:        szi = szi / r
10944:      else
10945:        szr = 1.0D+00
10946:        szi = 0.0D+00
10947:      end if
10948: 
10949:      if ( an >= ( abs ( e ) + ei ) * bn ) then
10950:        a1 = cz * b11 + szr * b12
10951:        a1i = szi * b12
10952:        a2 = szr * b22
10953:        a2i = szi * b22
10954:      else
10955:        a1 = cz * a11 + szr * a12
10956:        a1i = szi * a12
10957:        a2 = cz * a21 + szr * a22
10958:        a2i = szi * a22
10959:      end if
10960: !
10961: !  Choose complex Q.
10962: !
10963:      cq = sqrt ( a1**2 + a1i**2 )
10964: 
10965:      if ( cq /= 0.0D+00 ) then
10966:        sqr = ( a1 * a2 + a1i * a2i ) / cq
10967:        sqi = ( a1 * a2i - a1i * a2 ) / cq
10968:        r = sqrt ( cq**2 + sqr**2 + sqi**2 )
10969:        cq = cq / r
10970:        sqr = sqr / r
10971:        sqi = sqi / r
10972:      else
10973:        sqr = 1.0D+00
10974:        sqi = 0.0D+00
10975:      end if
10976: !
10977: !  Compute diagonal elements that would result if transformations were applied.
10978: !
10979:      ssr = sqr * szr + sqi * szi
10980:      ssi = sqr * szi - sqi * szr
10981:      i = 1
10982:      tr = cq * cz * a11 + cq * szr * a12 + sqr * cz * a21 + ssr * a22
10983:      ti = cq * szi * a12 - sqi * cz * a21 + ssi * a22
10984:      dr = cq * cz * b11 + cq * szr * b12 + ssr * b22
10985:      di = cq * szi * b12 + ssi * b22
10986:      go to 503
10987: 
10988: 502  continue
10989: 
10990:      i = 2
10991:      tr = ssr * a11 - sqr * cz * a12 - cq * szr * a21 + cq * cz * a22
10992:      ti = -ssi * a11 - sqi * cz * a12 + cq * szi * a21
10993:      dr = ssr * b11 - sqr * cz * b12 + cq * cz * b22
10994:      di = -ssi * b11 - sqi * cz * b12
10995: 
10996: 503  continue
10997: 
10998:      t = ti * dr - tr * di
10999: 
11000:      if ( t < 0.0D+00 ) then
11001:        j = en
11002:      else
11003:        j = na
11004:      end if
11005: 
11006:      r = sqrt ( dr**2 + di**2 )
11007:      beta(j) = bn * r
11008:      alfr(j) = an * (tr * dr + ti * di) / r
11009:      alfi(j) = an * t / r
11010: 
11011:      if ( i == 1 ) go to 502
11012: 
11013: 505  continue
11014: 
11015:      isw = 3 - isw
11016: 
11017: 510  continue
11018: 
11019:   end do
11020: 
11021:   b(n,1) = epsb
11022: 
11023:   return
11024: end
<p><a name=qzvec><H3>qzvec</H3></a></p> Click <a href="./callingtree/qzvec_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where qzvec is used.
<hr>
11025: subroutine qzvec ( n, a, b, alfr, alfi, beta, z )
11026: 
11027: !*****************************************************************************80
11028: !
11029: !! QZVEC computes eigenvectors for a generalized eigenvalue problem.
11030: !
11031: !  Discussion:
11032: !
11033: !    This subroutine is the optional fourth step of the QZ algorithm
11034: !    for solving generalized matrix eigenvalue problems.
11035: !
11036: !    This subroutine accepts a pair of real matrices, one of them in
11037: !    quasi-triangular form (in which each 2-by-2 block corresponds to
11038: !    a pair of complex eigenvalues) and the other in upper triangular
11039: !    form.  It computes the eigenvectors of the triangular problem and
11040: !    transforms the results back to the original coordinate system.
11041: !    it is usually preceded by QZHES, QZIT, and QZVAL.
11042: !
11043: !  Licensing:
11044: !
11045: !    This code is distributed under the GNU LGPL license.
11046: !
11047: !  Modified:
11048: !
11049: !    18 October 2009
11050: !
11051: !  Author:
11052: !
11053: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
11054: !    Klema, Moler.
11055: !    FORTRAN90 version by John Burkardt.
11056: !
11057: !  Reference:
11058: !
11059: !    James Wilkinson, Christian Reinsch,
11060: !    Handbook for Automatic Computation,
11061: !    Volume II, Linear Algebra, Part 2,
11062: !    Springer, 1971,
11063: !    ISBN: 0387054146,
11064: !    LC: QA251.W67.
11065: !
11066: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
11067: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
11068: !    Matrix Eigensystem Routines, EISPACK Guide,
11069: !    Lecture Notes in Computer Science, Volume 6,
11070: !    Springer Verlag, 1976,
11071: !    ISBN13: 978-3540075462,
11072: !    LC: QA193.M37.
11073: !
11074: !  Parameters:
11075: !
11076: !    Input, integer ( kind = 4 ) N, the order of the matrices.
11077: !
11078: !    Input, real ( kind = 8 ) A(N,N), contains a real upper quasi-triangular matrix.
11079: !    Its subdiagonal elements provide information about the storage of 
11080: !    the complex eigenvectors.
11081: !
11082: !    Input/output, real ( kind = 8 ) B(N,N).  On input, a real upper triangular matrix.  
11083: !    In addition, location B(N,1) contains the tolerance quantity EPSB
11084: !    computed and saved in QZIT.  On output, B has been destroyed.
11085: !
11086: !    Input, real ( kind = 8 ) ALFR(N), ALFI(N), BETA(N), vectors whose ratios 
11087: !      ( ALFR + I * ALFI ) / BETA 
11088: !    are the generalized eigenvalues.  They are usually obtained from QZVAL.
11089: !
11090: !    Input/output, real ( kind = 8 ) Z(N,N).  On input, the transformation matrix produced 
11091: !    in the reductions by QZHES, QZIT, and QZVAL, if performed.  If the 
11092: !    eigenvectors of the triangular problem are desired, Z must contain the 
11093: !    identity matrix.  On output, Z contains the real and imaginary parts of 
11094: !    the eigenvectors:
11095: !    If ALFI(I) == 0.0, the I-th eigenvalue is real and the I-th column of Z 
11096: !    contains its eigenvector.
11097: !    If ALFI(I) > 0.0, the eigenvalue is the first of a complex pair and the
11098: !    I-th and (I+1)-th columns of Z contain its eigenvector.
11099: !    If ALFI(I) < 0.0, the eigenvalue is the second of a complex pair and the 
11100: !    (I-1)-th and I-th columns of Z contain the conjugate of its eigenvector.
11101: !    Each eigenvector is normalized so that the modulus of its largest 
11102: !    component is 1.0D+00 .
11103: !
11104:   implicit none
11105: 
11106:   integer ( kind = 4 ) n
11107: 
11108:   real    ( kind = 8 ) a(n,n)
11109:   real    ( kind = 8 ) alfi(n)
11110:   real    ( kind = 8 ) alfm
11111:   real    ( kind = 8 ) alfr(n)
11112:   real    ( kind = 8 ) almi
11113:   real    ( kind = 8 ) almr
11114:   real    ( kind = 8 ) b(n,n)
11115:   real    ( kind = 8 ) beta(n)
11116:   real    ( kind = 8 ) betm
11117:   real    ( kind = 8 ) d
11118:   real    ( kind = 8 ) di
11119:   real    ( kind = 8 ) dr
11120:   integer ( kind = 4 ) en
11121:   integer ( kind = 4 ) enm2
11122:   real    ( kind = 8 ) epsb
11123:   integer ( kind = 4 ) i
11124:   integer ( kind = 4 ) ii
11125:   integer ( kind = 4 ) isw
11126:   integer ( kind = 4 ) j
11127:   integer ( kind = 4 ) jj
11128:   integer ( kind = 4 ) k
11129:   integer ( kind = 4 ) m
11130:   integer ( kind = 4 ) na
11131:   integer ( kind = 4 ) nn
11132:   real    ( kind = 8 ) q
11133:   real    ( kind = 8 ) r
11134:   real    ( kind = 8 ) ra
11135:   real    ( kind = 8 ) rr
11136:   real    ( kind = 8 ) s
11137:   real    ( kind = 8 ) sa
11138:   real    ( kind = 8 ) t
11139:   real    ( kind = 8 ) t1
11140:   real    ( kind = 8 ) t2
11141:   real    ( kind = 8 ) ti
11142:   real    ( kind = 8 ) tr
11143:   real    ( kind = 8 ) w
11144:   real    ( kind = 8 ) w1
11145:   real    ( kind = 8 ) x
11146:   real    ( kind = 8 ) x1
11147:   real    ( kind = 8 ) y
11148:   real    ( kind = 8 ) z(n,n)
11149:   real    ( kind = 8 ) z1
11150:   real    ( kind = 8 ) zz
11151: 
11152:   epsb = b(n,1)
11153:   isw = 1
11154: 
11155:   do nn = 1, n
11156: 
11157:      en = n + 1 - nn
11158:      na = en - 1
11159: 
11160:      if ( isw == 2 ) go to 795
11161: 
11162:      if ( alfi(en) /= 0.0D+00 ) go to 710
11163: !
11164: !  Real vector.
11165: !
11166:      m = en
11167:      b(en,en) = 1.0D+00
11168: 
11169:      if ( na == 0 ) go to 800
11170: 
11171:      alfm = alfr(m)
11172:      betm = beta(m)
11173: 
11174:      do ii = 1, na
11175: 
11176:         i = en - ii
11177:         w = betm * a(i,i) - alfm * b(i,i)
11178:         r = 0.0D+00
11179: 
11180:         do j = m, en
11181:           r = r + ( betm * a(i,j) - alfm * b(i,j) ) * b(j,en)
11182:         end do
11183: 
11184:         if ( i == 1 .or. isw == 2 ) go to 630
11185: 
11186:         if ( betm * a(i,i-1) == 0.0D+00 ) go to 630
11187: 
11188:         zz = w
11189:         s = r
11190:         go to 690
11191: 
11192: 630     continue
11193: 
11194:         m = i
11195: 
11196:         if ( isw == 2 ) go to 640
11197: !
11198: !  Real 1-by-1 block.
11199: !
11200:         t = w
11201:         if ( w == 0.0D+00 ) t = epsb
11202:         b(i,en) = - r / t
11203:         go to 700
11204: !
11205: !  Real 2-by-2 block.
11206: !
11207: 640     continue
11208: 
11209:         x = betm * a(i,i+1) - alfm * b(i,i+1)
11210:         y = betm * a(i+1,i)
11211:         q = w * zz - x * y
11212:         t = ( x * s - zz * r ) / q
11213:         b(i,en) = t
11214: 
11215:         if ( abs ( x ) <= abs ( zz ) ) go to 650
11216: 
11217:         b(i+1,en) = (-r - w * t) / x
11218: 
11219:         go to 690
11220: 
11221: 650     continue
11222: 
11223:         b(i+1,en) = (-s - y * t) / zz
11224: 
11225: 690     continue
11226: 
11227:         isw = 3 - isw
11228: 
11229: 700     continue
11230: 
11231:      end do
11232: !
11233: !  End real vector.
11234: !
11235:      go to 800
11236: !
11237: !  Complex vector.
11238: !
11239: 710  continue
11240: 
11241:      m = na
11242:      almr = alfr(m)
11243:      almi = alfi(m)
11244:      betm = beta(m)
11245: !
11246: !  Last vector component chosen imaginary so eigenvector matrix is triangular.
11247: !
11248:      y = betm * a(en,na)
11249:      b(na,na) = -almi * b(en,en) / y
11250:      b(na,en) = ( almr * b(en,en) - betm * a(en,en) ) / y
11251:      b(en,na) = 0.0D+00
11252:      b(en,en) = 1.0D+00
11253:      enm2 = na - 1
11254: 
11255:      do ii = 1, enm2
11256: 
11257:         i = na - ii
11258:         w = betm * a(i,i) - almr * b(i,i)
11259:         w1 = -almi * b(i,i)
11260:         ra = 0.0D+00
11261:         sa = 0.0D+00
11262: 
11263:         do j = m, en
11264:           x = betm * a(i,j) - almr * b(i,j)
11265:           x1 = -almi * b(i,j)
11266:           ra = ra + x * b(j,na) - x1 * b(j,en)
11267:           sa = sa + x * b(j,en) + x1 * b(j,na)
11268:         end do
11269: 
11270:         if ( i == 1 .or. isw == 2 ) go to 770
11271:         if ( betm * a(i,i-1) == 0.0D+00 ) go to 770
11272: 
11273:         zz = w
11274:         z1 = w1
11275:         r = ra
11276:         s = sa
11277:         isw = 2
11278:         go to 790
11279: 770     continue
11280: 
11281:         m = i
11282:         if ( isw == 2 ) go to 780
11283: !
11284: !  Complex 1-by-1 block.
11285: !
11286:         tr = -ra
11287:         ti = -sa
11288: 
11289: 773     continue
11290: 
11291:         dr = w
11292:         di = w1
11293: !
11294: !  Complex divide (t1,t2) = (tr,ti) / (dr,di),
11295: !
11296: 775     continue
11297: 
11298:         if ( abs ( di ) > abs ( dr ) ) go to 777
11299:         rr = di / dr
11300:         d = dr + di * rr
11301:         t1 = (tr + ti * rr) / d
11302:         t2 = (ti - tr * rr) / d
11303:         go to ( 787, 782 ), isw
11304: 
11305: 777     continue
11306: 
11307:         rr = dr / di
11308:         d = dr * rr + di
11309:         t1 = ( tr * rr + ti ) / d
11310:         t2 = ( ti * rr - tr ) / d
11311:         go to ( 787, 782 ), isw
11312: !
11313: !  Complex 2-by-2 block.
11314: !
11315: 780     continue
11316: 
11317:         x = betm * a(i,i+1) - almr * b(i,i+1)
11318:         x1 = -almi * b(i,i+1)
11319:         y = betm * a(i+1,i)
11320:         tr = y * ra - w * r + w1 * s
11321:         ti = y * sa - w * s - w1 * r
11322:         dr = w * zz - w1 * z1 - x * y
11323:         di = w * z1 + w1 * zz - x1 * y
11324:         if ( dr == 0.0D+00 .and. di == 0.0D+00 ) dr = epsb
11325:         go to 775
11326: 
11327: 782     continue
11328: 
11329:         b(i+1,na) = t1
11330:         b(i+1,en) = t2
11331:         isw = 1
11332:         if ( abs ( y ) > abs ( w ) + abs ( w1 ) ) go to 785
11333:         tr = -ra - x * b(i+1,na) + x1 * b(i+1,en)
11334:         ti = -sa - x * b(i+1,en) - x1 * b(i+1,na)
11335:         go to 773
11336: 
11337: 785     continue
11338: 
11339:         t1 = (-r - zz * b(i+1,na) + z1 * b(i+1,en) ) / y
11340:         t2 = (-s - zz * b(i+1,en) - z1 * b(i+1,na) ) / y
11341: 
11342: 787     continue
11343: 
11344:         b(i,na) = t1
11345:         b(i,en) = t2
11346: 
11347: 790     continue
11348: 
11349:      end do
11350: !
11351: !  End complex vector.
11352: !
11353: 795   continue
11354: 
11355:       isw = 3 - isw
11356: 
11357: 800   continue
11358: 
11359:   end do
11360: !
11361: !  End back substitution.
11362: !  Transform to original coordinate system.
11363: !
11364:   do jj = 1, n
11365: 
11366:      j = n + 1 - jj
11367: 
11368:      do i = 1, n
11369: 
11370:         zz = 0.0D+00
11371: 
11372:         do k = 1, j
11373:           zz = zz + z(i,k) * b(k,j)
11374:         end do
11375: 
11376:         z(i,j) = zz
11377: 
11378:       end do
11379: 
11380:   end do
11381: !
11382: !  Normalize so that modulus of largest component of each vector is 1.
11383: !  (ISW is 1 initially from before).
11384: !
11385:   do j = 1, n
11386: 
11387:      d = 0.0D+00
11388:      if ( isw == 2 ) go to 920
11389:      if ( alfi(j) /= 0.0D+00 ) go to 945
11390: 
11391:      do i = 1, n
11392:        d = max ( d, abs ( z(i,j) ) )
11393:      end do
11394: 
11395:      z(1:n,j) = z(1:n,j) / d
11396: 
11397:      go to 950
11398: 
11399: 920  continue
11400: 
11401:      do i = 1, n
11402:        r = abs ( z(i,j-1) ) + abs ( z(i,j) )
11403:        if ( r /= 0.0D+00 ) then
11404:          r = r * sqrt ( ( z(i,j-1) / r )**2 + ( z(i,j) / r )**2 )
11405:        end if
11406:        if ( r > d ) d = r
11407:      end do
11408: 
11409:      z(1:n,j-1) = z(1:n,j-1) / d
11410:      z(1:n,j) = z(1:n,j) / d
11411: 
11412: 945  continue
11413: 
11414:      isw = 3 - isw
11415: 
11416: 950  continue
11417: 
11418:   end do
11419: 
11420:   return
11421: end
<p><a name=r8_swap><H3>r8_swap</H3></a></p> Click <a href="./callingtree/r8_swap_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where r8_swap is used.
<hr>
11422: subroutine r8_swap ( x, y )
11423: 
11424: !*****************************************************************************80
11425: !
11426: !! R8_SWAP swaps two R8's.
11427: !
11428: !  Licensing:
11429: !
11430: !    This code is distributed under the GNU LGPL license.
11431: !
11432: !  Modified:
11433: !
11434: !    22 December 2000
11435: !
11436: !  Author:
11437: !
11438: !    John Burkardt
11439: !
11440: !  Parameters:
11441: !
11442: !    Input/output, real ( kind = 8 ) X, Y.  On output, the values of X and
11443: !    Y have been interchanged.
11444: !
11445:   implicit none
11446: 
11447:   real    ( kind = 8 ) x
11448:   real    ( kind = 8 ) y
11449:   real    ( kind = 8 ) z
11450: 
11451:   z = x
11452:   x = y
11453:   y = z
11454: 
11455:   return
11456: end
<p><a name=r8mat_print><H3>r8mat_print</H3></a></p> Click <a href="./callingtree/r8mat_print_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where r8mat_print is used.
<hr>
11457: subroutine r8mat_print ( m, n, a, title )
11458: 
11459: !*****************************************************************************80
11460: !
11461: !! R8MAT_PRINT prints an R8MAT.
11462: !
11463: !  Discussion:
11464: !
11465: !    An R8MAT is an array of R8 values.
11466: !
11467: !  Licensing:
11468: !
11469: !    This code is distributed under the GNU LGPL license.
11470: !
11471: !  Modified:
11472: !
11473: !    12 September 2004
11474: !
11475: !  Author:
11476: !
11477: !    John Burkardt
11478: !
11479: !  Parameters:
11480: !
11481: !    Input, integer ( kind = 4 ) M, the number of rows in A.
11482: !
11483: !    Input, integer ( kind = 4 ) N, the number of columns in A.
11484: !
11485: !    Input, real ( kind = 8 ) A(M,N), the matrix.
11486: !
11487: !    Input, character ( len = * ) TITLE, a title.
11488: !
11489:   implicit none
11490: 
11491:   integer   ( kind = 4 ) m
11492:   integer   ( kind = 4 ) n
11493: 
11494:   real      ( kind = 8 ) a(m,n)
11495:   character ( len = * )  title
11496: 
11497:   call <a href="./eispack.f90.html#r8mat_print_some" TARGET=CENT_PANEL>r8mat_print_some</a> ( m, n, a, 1, 1, m, n, title )
11498: 
11499:   return
11500: end
<p><a name=r8mat_print_some><H3>r8mat_print_some</H3></a></p> Click <a href="./callingtree/r8mat_print_some_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where r8mat_print_some is used.
<hr>
11501: subroutine r8mat_print_some ( m, n, a, ilo, jlo, ihi, jhi, title )
11502: 
11503: !*****************************************************************************80
11504: !
11505: !! R8MAT_PRINT_SOME prints some of an R8MAT.
11506: !
11507: !  Discussion:
11508: !
11509: !    An R8MAT is an array of R8 values.
11510: !
11511: !  Licensing:
11512: !
11513: !    This code is distributed under the GNU LGPL license.
11514: !
11515: !  Modified:
11516: !
11517: !    26 March 2005
11518: !
11519: !  Author:
11520: !
11521: !    John Burkardt
11522: !
11523: !  Parameters:
11524: !
11525: !    Input, integer ( kind = 4 ) M, N, the number of rows and columns.
11526: !
11527: !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed.
11528: !
11529: !    Input, integer ( kind = 4 ) ILO, JLO, the first row and column to print.
11530: !
11531: !    Input, integer ( kind = 4 ) IHI, JHI, the last row and column to print.
11532: !
11533: !    Input, character ( len = * ) TITLE, a title.
11534: !
11535:   implicit none
11536: 
11537:   integer   ( kind = 4 ), parameter :: incx = 5
11538:   integer   ( kind = 4 ) m
11539:   integer   ( kind = 4 ) n
11540: 
11541:   real      ( kind = 8 ) a(m,n)
11542:   character ( len = 14 ) ctemp(incx)
11543:   integer   ( kind = 4 ) i
11544:   integer   ( kind = 4 ) i2hi
11545:   integer   ( kind = 4 ) i2lo
11546:   integer   ( kind = 4 ) ihi
11547:   integer   ( kind = 4 ) ilo
11548:   integer   ( kind = 4 ) inc
11549:   integer   ( kind = 4 ) j
11550:   integer   ( kind = 4 ) j2
11551:   integer   ( kind = 4 ) j2hi
11552:   integer   ( kind = 4 ) j2lo
11553:   integer   ( kind = 4 ) jhi
11554:   integer   ( kind = 4 ) jlo
11555:   character ( len = * )  title
11556: 
11557:   write ( *, '(a)' ) ' '
11558:   write ( *, '(a)' ) trim ( title )
11559: 
11560:   do j2lo = max ( jlo, 1 ), min ( jhi, n ), incx
11561: 
11562:     j2hi = j2lo + incx - 1
11563:     j2hi = min ( j2hi, n )
11564:     j2hi = min ( j2hi, jhi )
11565: 
11566:     inc = j2hi + 1 - j2lo
11567: 
11568:     write ( *, '(a)' ) ' '
11569: 
11570:     do j = j2lo, j2hi
11571:       j2 = j + 1 - j2lo
11572:       write ( ctemp(j2), '(i8,6x)' ) j
11573:     end do
11574: 
11575:     write ( *, '(''  Col   '',5a14)' ) ctemp(1:inc)
11576:     write ( *, '(a)' ) '  Row'
11577:     write ( *, '(a)' ) ' '
11578: 
11579:     i2lo = max ( ilo, 1 )
11580:     i2hi = min ( ihi, m )
11581: 
11582:     do i = i2lo, i2hi
11583: 
11584:       do j2 = 1, inc
11585: 
11586:         j = j2lo - 1 + j2
11587: 
11588:         if ( a(i,j) == real ( int ( a(i,j) ), kind = 8 ) ) then
11589:           write ( ctemp(j2), '(f8.0,6x)' ) a(i,j)
11590:         else
11591:           write ( ctemp(j2), '(g14.6)' ) a(i,j)
11592:         end if
11593: 
11594:       end do
11595: 
11596:       write ( *, '(i5,1x,5a14)' ) i, ( ctemp(j), j = 1, inc )
11597: 
11598:     end do
11599: 
11600:   end do
11601: 
11602:   return
11603: end
<p><a name=r8vec_print><H3>r8vec_print</H3></a></p> Click <a href="./callingtree/r8vec_print_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where r8vec_print is used.
<hr>
11604: subroutine r8vec_print ( n, a, title )
11605: 
11606: !*****************************************************************************80
11607: !
11608: !! R8VEC_PRINT prints an R8VEC.
11609: !
11610: !  Discussion:
11611: !
11612: !    An R8VEC is a vector of R8 values.
11613: !
11614: !  Modified:
11615: !
11616: !    22 August 2000
11617: !
11618: !  Author:
11619: !
11620: !    John Burkardt
11621: !
11622: !  Parameters:
11623: !
11624: !    Input, integer ( kind = 4 ) N, the number of components of the vector.
11625: !
11626: !    Input, real ( kind = 8 ) A(N), the vector to be printed.
11627: !
11628: !    Input, character ( len = * ) TITLE, a title.
11629: !
11630:   implicit none
11631: 
11632:   integer   ( kind = 4 ) n
11633: 
11634:   real      ( kind = 8 ) a(n)
11635:   integer   ( kind = 4 ) i
11636:   character ( len = * ) title
11637: 
11638:   write ( *, '(a)' ) ' '
11639:   write ( *, '(a)' ) trim ( title )
11640:   write ( *, '(a)' ) ' '
11641:   do i = 1, n
11642:     write ( *, '(2x,i8,2x,g16.8)' ) i, a(i)
11643:   end do
11644: 
11645:   return
11646: end
<p><a name=r8vec2_print><H3>r8vec2_print</H3></a></p> Click <a href="./callingtree/r8vec2_print_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where r8vec2_print is used.
<hr>
11647: subroutine r8vec2_print ( n, a1, a2, title )
11648: 
11649: !*****************************************************************************80
11650: !
11651: !! R8VEC2_PRINT prints an R8VEC2.
11652: !
11653: !  Discussion:
11654: !
11655: !    An R8VEC2 is a dataset consisting of N pairs of R8's, stored
11656: !    as two separate vectors A1 and A2.
11657: !
11658: !  Modified:
11659: !
11660: !    13 December 2004
11661: !
11662: !  Author:
11663: !
11664: !    John Burkardt
11665: !
11666: !  Parameters:
11667: !
11668: !    Input, integer ( kind = 4 ) N, the number of components of the vector.
11669: !
11670: !    Input, real ( kind = 8 ) A1(N), A2(N), the vectors to be printed.
11671: !
11672: !    Input, character ( len = * ) TITLE, a title.
11673: !
11674:   implicit none
11675: 
11676:   integer   ( kind = 4 ) n
11677: 
11678:   real      ( kind = 8 ) a1(n)
11679:   real      ( kind = 8 ) a2(n)
11680:   integer   ( kind = 4 ) i
11681:   character ( len = * )  title
11682: 
11683:   write ( *, '(a)' ) ' '
11684:   write ( *, '(a)' ) trim ( title )
11685:   write ( *, '(a)' ) ' '
11686: 
11687:   if ( all ( a1(1:n) == aint ( a1(1:n) ) ) .and. &
11688:        all ( a2(1:n) == aint ( a2(1:n) ) ) ) then
11689:     do i = 1, n
11690:       write ( *, '(i8,2i8)' ) i, int ( a1(i) ), int ( a2(i) )
11691:     end do
11692:   else if ( all ( abs ( a1(1:n) ) < 1000000.0D+00 ) .and. &
11693:             all ( abs ( a2(1:n) ) < 1000000.0D+00 ) ) then
11694:     do i = 1, n
11695:       write ( *, '(i8,2f14.6)' ) i, a1(i), a2(i)
11696:     end do
11697:   else
11698:     do i = 1, n
11699:       write ( *, '(i8,2g14.6)' ) i, a1(i), a2(i)
11700:     end do
11701:   end if
11702: 
11703:   return
11704: end
<p><a name=ratqr><H3>ratqr</H3></a></p> Click <a href="./callingtree/ratqr_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where ratqr is used.
<hr>
11705: subroutine ratqr ( n, eps1, d, e, e2, m, w, ind, bd, type, idef, ierr )
11706: 
11707: !*****************************************************************************80
11708: !
11709: !! RATQR computes selected eigenvalues of a real symmetric tridiagonal matrix.
11710: !
11711: !  Discussion:
11712: !
11713: !    This subroutine finds the algebraically smallest or largest
11714: !    eigenvalues of a symmetric tridiagonal matrix by the
11715: !    rational QR method with Newton corrections.
11716: !
11717: !  Licensing:
11718: !
11719: !    This code is distributed under the GNU LGPL license.
11720: !
11721: !  Modified:
11722: !
11723: !    18 October 2009
11724: !
11725: !  Author:
11726: !
11727: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
11728: !    Klema, Moler.
11729: !    FORTRAN90 version by John Burkardt.
11730: !
11731: !  Reference:
11732: !
11733: !    James Wilkinson, Christian Reinsch,
11734: !    Handbook for Automatic Computation,
11735: !    Volume II, Linear Algebra, Part 2,
11736: !    Springer, 1971,
11737: !    ISBN: 0387054146,
11738: !    LC: QA251.W67.
11739: !
11740: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
11741: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
11742: !    Matrix Eigensystem Routines, EISPACK Guide,
11743: !    Lecture Notes in Computer Science, Volume 6,
11744: !    Springer Verlag, 1976,
11745: !    ISBN13: 978-3540075462,
11746: !    LC: QA193.M37.
11747: !
11748: !  Parameters:
11749: !
11750: !    Input, integer ( kind = 4 ) N, the order of the matrix.
11751: !
11752: !    Input/output, real ( kind = 8 ) EPS1.  On input, a theoretical absolute 
11753: !    error tolerance for the computed eigenvalues.  If the input EPS1 is 
11754: !    non-positive, or indeed smaller than its default value, it is reset at 
11755: !    each iteration to the respective default value, namely, the product of 
11756: !    the relative machine precision and the magnitude of the current eigenvalue 
11757: !    iterate.  The theoretical absolute error in the K-th eigenvalue is usually 
11758: !    not greater than K times EPS1.  On output, EPS1 is unaltered unless it has 
11759: !    been reset to its (last) default value.
11760: !
11761: !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix.
11762: !
11763: !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the input matrix
11764: !    in E(2:N).  E(1) is arbitrary.
11765: !
11766: !    Input/output, real ( kind = 8 ) E2(N).  On input, E2(2:N-1) contains the 
11767: !    squares of the corresponding elements of E, and E2(1) is arbitrary.  On 
11768: !    output, elements of E2 corresponding to elements of E regarded as 
11769: !    negligible have been replaced by zero, causing the matrix to split into 
11770: !    a direct sum of submatrices.  E2(1) is set to 0.0D+00 if the smallest 
11771: !    eigenvalues have been found, and to 2.0D+00 if the largest eigenvalues 
11772: !    have been found.  E2 is otherwise unaltered (unless overwritten by BD).
11773: !
11774: !    Input, integer ( kind = 4 ) M, the number of eigenvalues to be found.
11775: !
11776: !    Output, real ( kind = 8 ) W(M), the M algebraically smallest eigenvalues in
11777: !    ascending order, or the M largest eigenvalues in descending order.  
11778: !    If an error exit is made because of an incorrect specification of IDEF, 
11779: !    no eigenvalues are found.  If the Newton iterates for a particular
11780: !    eigenvalue are not monotone, the best estimate obtained is returned 
11781: !    and IERR is set.  W may coincide with D.
11782: !
11783: !    Outpt, integer IND(N), contains in its first M positions the submatrix 
11784: !    indices associated with the corresponding eigenvalues in W:
11785: !    1 for eigenvalues belonging to the first submatrix from the top, 2 for 
11786: !    those belonging to the second submatrix, and so on.
11787: !
11788: !    Output, real ( kind = 8 ) BD(N), contains refined bounds for the 
11789: !    theoretical errors of the corresponding eigenvalues in W.  These bounds 
11790: !    are usually within the tolerance specified by EPS1.  BD may coincide 
11791: !    with E2.
11792: !
11793: !    Input, integer ( kind = 4 ) IDEF, should be set to 1 if the input matrix 
11794: !    is known to be positive definite, to -1 if the input matrix is known to 
11795: !    be negative  definite, and to 0 otherwise.
11796: !
11797: !    Input, logical TYPE, should be set to TRUE if the smallest eigenvalues
11798: !    are to be found, and to FALSE if the largest eigenvalues are to be found.
11799: !
11800: !    Output, integer ( kind = 4 ) IERR, error flag.
11801: !    0, for normal return,
11802: !    6*N+1, if IDEF is set to 1 and TYPE to .true. when the matrix is not 
11803: !      positive definite, or if IDEF is set to -1 and TYPE to .false.
11804: !      when the matrix is not negative definite,
11805: !    5*N+K, if successive iterates to the K-th eigenvalue are not monotone 
11806: !      increasing, where K refers to the last such occurrence.
11807: !
11808:   implicit none
11809: 
11810:   integer ( kind = 4 ) n
11811: 
11812:   real    ( kind = 8 ) bd(n)
11813:   real    ( kind = 8 ) d(n)
11814:   real    ( kind = 8 ) delta
11815:   real    ( kind = 8 ) e(n)
11816:   real    ( kind = 8 ) e2(n)
11817:   real    ( kind = 8 ) ep
11818:   real    ( kind = 8 ) eps1
11819:   real    ( kind = 8 ) err
11820:   real    ( kind = 8 ) f
11821:   integer ( kind = 4 ) i
11822:   integer ( kind = 4 ) idef
11823:   integer ( kind = 4 ) ierr
11824:   integer ( kind = 4 ) ii
11825:   integer ( kind = 4 ) ind(n)
11826:   integer ( kind = 4 ) j
11827:   integer ( kind = 4 ) jdef
11828:   integer ( kind = 4 ) jj
11829:   integer ( kind = 4 ) k
11830:   integer ( kind = 4 ) m
11831:   real    ( kind = 8 ) p
11832:   real    ( kind = 8 ) q
11833:   real    ( kind = 8 ) qp
11834:   real    ( kind = 8 ) r
11835:   real    ( kind = 8 ) s
11836:   real    ( kind = 8 ) tot
11837:   logical              type
11838:   real    ( kind = 8 ) w(n)
11839: 
11840:   ierr = 0
11841:   jdef = idef
11842:   w(1:n) = d(1:n)
11843: 
11844:   if ( .not. type ) then
11845:     j = 1
11846:     go to 400
11847:   end if
11848: 
11849: 40 continue
11850: 
11851:   err = 0.0D+00
11852:   s = 0.0D+00
11853: !
11854: !  Look for small sub-diagonal entries and define initial shift 
11855: !  from lower Gerschgorin bound.
11856: !
11857: !  Copy E2 array into BD.
11858: !
11859:   tot = w(1)
11860:   q = 0.0D+00
11861:   j = 0
11862: 
11863:   do i = 1, n
11864: 
11865:      p = q
11866: 
11867:      if ( i == 1 ) go to 60
11868: 
11869:      if ( p > ( abs ( d(i) ) + abs (  d(i-1) ) ) * epsilon ( p ) ) then
11870:        go to 80
11871:      end if
11872: 
11873: 60   continue
11874: 
11875:      e2(i) = 0.0D+00
11876: 
11877: 80   continue
11878: 
11879:      bd(i) = e2(i)
11880: !
11881: !  Count also if element of E2 has underflowed.
11882: !
11883:      if ( e2(i) == 0.0D+00 ) j = j + 1
11884:      ind(i) = j
11885:      q = 0.0D+00
11886:      if ( i /= n ) q = abs ( e(i+1) )
11887:      tot = min ( w(i)-p-q, tot )
11888: 
11889:   end do
11890: 
11891:   if ( jdef == 1 .and. tot < 0.0D+00 ) then
11892:     go to 140
11893:   end if
11894: 
11895:   w(1:n) = w(1:n) - tot
11896: 
11897:   go to 160
11898: 
11899: 140 continue
11900: 
11901:   tot = 0.0D+00
11902: 
11903: 160 continue
11904: 
11905:   do k = 1, m
11906: !
11907: !  Next QR transformation.
11908: !
11909: 180  continue
11910: 
11911:      tot = tot + s
11912:      delta = w(n) - s
11913:      i = n
11914:      f = abs ( tot ) * epsilon ( f )
11915:      if ( eps1 < f ) eps1 = f
11916:      if ( delta > eps1 ) go to 190
11917:      if ( delta < (-eps1) ) go to 1000
11918:      go to 300
11919: !
11920: !  Replace small sub-diagonal squares by zero to reduce the incidence of 
11921: !  underflows.
11922: !
11923: 190  continue
11924: 
11925:      do j = k+1, n
11926:        if ( bd(j) <= ( abs (  w(j) + w(j-1) ) * epsilon ( bd(j) ) ) ** 2 ) then
11927:          bd(j) = 0.0D+00
11928:        end if
11929:      end do
11930: 
11931:      f = bd(n) / delta
11932:      qp = delta + f
11933:      p = 1.0D+00
11934: 
11935:      do ii = 1, n-k
11936: 
11937:        i = n - ii
11938:        q = w(i) - s - f
11939:        r = q / qp
11940:        p = p * r + 1.0D+00
11941:        ep = f * r
11942:        w(i+1) = qp + ep
11943:        delta = q - ep
11944: 
11945:        if ( delta > eps1 ) go to 220
11946:        if ( delta < (-eps1) ) go to 1000
11947:        go to 300
11948: 
11949: 220    continue
11950: 
11951:        f = bd(i) / q
11952:        qp = delta + f
11953:        bd(i+1) = qp * ep
11954: 
11955:      end do
11956: 
11957:      w(k) = qp
11958:      s = qp / p
11959: 
11960:      if ( tot + s > tot ) go to 180
11961: !
11962: !  Set error: irregular end of iteration.
11963: !  Deflate minimum diagonal element.
11964: !
11965:      ierr = 5 * n + k
11966:      s = 0.0D+00
11967:      delta = qp
11968: 
11969:      do j = k, n
11970:        if ( w(j) <= delta ) then
11971:          i = j
11972:          delta = w(j)
11973:        end if
11974:      end do
11975: !
11976: !  Convergence.
11977: !
11978: 300  continue
11979: 
11980:      if ( i < n ) bd(i+1) = bd(i) * f / qp
11981:      ii = ind(i)
11982: 
11983:      do jj = 1, i-k
11984:        j = i - jj
11985:        w(j+1) = w(j) - s
11986:        bd(j+1) = bd(j)
11987:        ind(j+1) = ind(j)
11988:      end do
11989: 
11990:      w(k) = tot
11991:      err = err + abs ( delta)
11992:      bd(k) = err
11993:      ind(k) = ii
11994: 
11995:   end do
11996: 
11997:   if ( type ) then
11998:     return
11999:   end if
12000: 
12001:   f = bd(1)
12002:   e2(1) = 2.0D+00
12003:   bd(1) = f
12004:   j = 2
12005: !
12006: !  Negate elements of W for largest values.
12007: !
12008: 400 continue
12009: 
12010:   w(1:n) = - w(1:n)
12011:   jdef = -jdef
12012: 
12013:   if ( j == 1 ) then
12014:     go to 40
12015:   end if
12016: 
12017:   return
12018: !
12019: !  Set error: IDEF specified incorrectly.
12020: !
12021:  1000 continue
12022: 
12023:   ierr = 6 * n + 1
12024:   return
12025: end
<p><a name=rebak><H3>rebak</H3></a></p> Click <a href="./callingtree/rebak_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rebak is used.
<hr>
12026: subroutine rebak ( n, b, dl, m, z )
12027: 
12028: !*****************************************************************************80
12029: !
12030: !! REBAK determines eigenvectors by undoing the REDUC transformation.
12031: !
12032: !  Discussion:
12033: !
12034: !    This subroutine forms the eigenvectors of a generalized
12035: !    symmetric eigensystem by back transforming those of the
12036: !    derived symmetric matrix determined by REDUC.
12037: !
12038: !  Licensing:
12039: !
12040: !    This code is distributed under the GNU LGPL license.
12041: !
12042: !  Modified:
12043: !
12044: !    18 October 2009
12045: !
12046: !  Author:
12047: !
12048: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12049: !    Klema, Moler.
12050: !    FORTRAN90 version by John Burkardt.
12051: !
12052: !  Reference:
12053: !
12054: !    James Wilkinson, Christian Reinsch,
12055: !    Handbook for Automatic Computation,
12056: !    Volume II, Linear Algebra, Part 2,
12057: !    Springer, 1971,
12058: !    ISBN: 0387054146,
12059: !    LC: QA251.W67.
12060: !
12061: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12062: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12063: !    Matrix Eigensystem Routines, EISPACK Guide,
12064: !    Lecture Notes in Computer Science, Volume 6,
12065: !    Springer Verlag, 1976,
12066: !    ISBN13: 978-3540075462,
12067: !    LC: QA193.M37.
12068: !
12069: !  Parameters:
12070: !
12071: !    Input, integer ( kind = 4 ) N, the order of the matrix.
12072: !
12073: !    Input, real ( kind = 8 ) B(N,N), contains information about the similarity 
12074: !    transformation (Cholesky decomposition) used in the reduction by REDUC
12075: !    in its strict lower triangle.
12076: !
12077: !    Input, real ( kind = 8 ) DL(N), further information about the transformation.
12078: !
12079: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed.
12080: !
12081: !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the eigenvectors to be back
12082: !    transformed in its first M columns.  On output, the transformed 
12083: !    eigenvectors.
12084: !
12085:   implicit none
12086: 
12087:   integer ( kind = 4 ) m
12088:   integer ( kind = 4 ) n
12089: 
12090:   real    ( kind = 8 ) b(n,n)
12091:   real    ( kind = 8 ) dl(n)
12092:   integer ( kind = 4 ) i
12093:   integer ( kind = 4 ) j
12094:   real    ( kind = 8 ) z(n,m)
12095: 
12096:   do j = 1, m
12097:     do i = n, 1, -1
12098:       z(i,j) = ( z(i,j) - dot_product ( b(i+1:n,i), z(i+1:n,j) ) ) / dl(i)
12099:     end do
12100:   end do
12101: 
12102:   return
12103: end
<p><a name=rebakb><H3>rebakb</H3></a></p> Click <a href="./callingtree/rebakb_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rebakb is used.
<hr>
12104: subroutine rebakb ( n, b, dl, m, z )
12105: 
12106: !*****************************************************************************80
12107: !
12108: !! REBAKB determines eigenvectors by undoing the REDUC2 transformation.
12109: !
12110: !  Discussion:
12111: !
12112: !    This subroutine forms the eigenvectors of a generalized
12113: !    symmetric eigensystem by back transforming those of the
12114: !    derived symmetric matrix determined by REDUC2.
12115: !
12116: !  Licensing:
12117: !
12118: !    This code is distributed under the GNU LGPL license.
12119: !
12120: !  Modified:
12121: !
12122: !    18 October 2009
12123: !
12124: !  Author:
12125: !
12126: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12127: !    Klema, Moler.
12128: !    FORTRAN90 version by John Burkardt.
12129: !
12130: !  Reference:
12131: !
12132: !    James Wilkinson, Christian Reinsch,
12133: !    Handbook for Automatic Computation,
12134: !    Volume II, Linear Algebra, Part 2,
12135: !    Springer, 1971,
12136: !    ISBN: 0387054146,
12137: !    LC: QA251.W67.
12138: !
12139: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12140: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12141: !    Matrix Eigensystem Routines, EISPACK Guide,
12142: !    Lecture Notes in Computer Science, Volume 6,
12143: !    Springer Verlag, 1976,
12144: !    ISBN13: 978-3540075462,
12145: !    LC: QA193.M37.
12146: !
12147: !  Parameters:
12148: !
12149: !    Input, integer ( kind = 4 ) N, the order of the matrix.
12150: !
12151: !    Input, real ( kind = 8 ) B(N,N), contains information about the similarity 
12152: !    transformation (Cholesky decomposition) used in the reduction by REDUC2
12153: !    in its strict lower triangle.
12154: !
12155: !    Input, real ( kind = 8 ) DL(N), further information about the transformation.
12156: !
12157: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed.
12158: !
12159: !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the eigenvectors to be back
12160: !    transformed in its first M columns.  On output, the transformed 
12161: !    eigenvectors.
12162: !
12163:   implicit none
12164: 
12165:   integer ( kind = 4 ) m
12166:   integer ( kind = 4 ) n
12167: 
12168:   real    ( kind = 8 ) b(n,n)
12169:   real    ( kind = 8 ) dl(n)
12170:   integer ( kind = 4 ) i
12171:   integer ( kind = 4 ) j
12172:   real    ( kind = 8 ) z(n,m)
12173: 
12174:   do j = 1, m
12175: 
12176:     do i = n, 1, -1
12177: 
12178:       z(i,j) = dl(i) * z(i,j) + dot_product ( b(i,1:i-1), z(1:i-1,j) )
12179: 
12180:     end do
12181: 
12182:   end do
12183: 
12184:   return
12185: end
<p><a name=reduc><H3>reduc</H3></a></p> Click <a href="./callingtree/reduc_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where reduc is used.
<hr>
12186: subroutine reduc ( n, a, b, dl, ierr )
12187: 
12188: !*****************************************************************************80
12189: !
12190: !! REDUC reduces the eigenvalue problem A*x=lambda*B*x to A*x=lambda*x.
12191: !
12192: !  Discussion:
12193: !
12194: !    This subroutine reduces the generalized symmetric eigenproblem
12195: !    ax=(lambda)bx, where B is positive definite, to the standard
12196: !    symmetric eigenproblem using the Cholesky factorization of B.
12197: !
12198: !  Licensing:
12199: !
12200: !    This code is distributed under the GNU LGPL license.
12201: !
12202: !  Modified:
12203: !
12204: !    18 October 2009
12205: !
12206: !  Author:
12207: !
12208: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12209: !    Klema, Moler.
12210: !    FORTRAN90 version by John Burkardt.
12211: !
12212: !  Reference:
12213: !
12214: !    James Wilkinson, Christian Reinsch,
12215: !    Handbook for Automatic Computation,
12216: !    Volume II, Linear Algebra, Part 2,
12217: !    Springer, 1971,
12218: !    ISBN: 0387054146,
12219: !    LC: QA251.W67.
12220: !
12221: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12222: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12223: !    Matrix Eigensystem Routines, EISPACK Guide,
12224: !    Lecture Notes in Computer Science, Volume 6,
12225: !    Springer Verlag, 1976,
12226: !    ISBN13: 978-3540075462,
12227: !    LC: QA193.M37.
12228: !
12229: !  Parameters:
12230: !
12231: !    Input, integer ( kind = 4 ) N, the order of the matrices A and B.  If the Cholesky
12232: !    factor L of B is already available, N should be prefixed with a minus sign.
12233: !
12234: !    Input/output, real ( kind = 8 ) A(N,N).  On input, A contains a real symmetric matrix.
12235: !    Only the full upper triangle of the matrix need be supplied.
12236: !    On output, A contains in its full lower triangle the full lower triangle
12237: !    of the symmetric matrix derived from the reduction to the
12238: !    standard form.  The strict upper triangle of a is unaltered.
12239: !
12240: !    Input/output, real ( kind = 8 ) B(N,N).  On input, the real symmetric input matrix.  
12241: !    Only the full upper triangle of the matrix need be supplied.  If
12242: !    N is negative, the strict lower triangle of B contains, instead, the 
12243: !    strict lower triangle of its Cholesky factor L.  In any case, on output,
12244: !    B contains in its strict lower triangle the strict lower triangle of 
12245: !    its Cholesky factor L.  The full upper triangle of B is unaltered.
12246: !
12247: !    Input/output, real ( kind = 8 ) DL(N).  If N is negative, then the DL contains
12248: !    the diagonal elements of L on input.  In any case, DL will contain
12249: !    the diagonal elements of L on output,
12250: !
12251: !    Output, integer ( kind = 4 ) IERR, error flag.
12252: !    0, for normal return,
12253: !    7*N+1, if B is not positive definite.
12254: !
12255:   implicit none
12256: 
12257:   integer ( kind = 4 ) n
12258: 
12259:   real    ( kind = 8 ) a(n,n)
12260:   real    ( kind = 8 ) b(n,n)
12261:   real    ( kind = 8 ) dl(n)
12262:   integer ( kind = 4 ) i
12263:   integer ( kind = 4 ) ierr
12264:   integer ( kind = 4 ) j
12265:   integer ( kind = 4 ) k
12266:   integer ( kind = 4 ) nn
12267:   real    ( kind = 8 ) x
12268:   real    ( kind = 8 ) y
12269: 
12270:   ierr = 0
12271:   nn = abs ( n )
12272: !
12273: !  Form L in the arrays B and DL.
12274: !
12275:   do i = 1, n
12276: 
12277:      do j = i, n
12278: 
12279:         x = b(i,j)
12280: 
12281:         do k = 1, i - 1
12282:           x = x - b(i,k) * b(j,k)
12283:         end do
12284: 
12285:         if ( j == i ) then
12286: 
12287:           if ( x <= 0.0D+00 ) then
12288:             write ( *, '(a)' ) ' '
12289:             write ( *, '(a)' ) 'REDUC - Fatal error!'
12290:             write ( *, '(a)' ) '  The matrix is not positive definite.'
12291:             ierr = 7 * n + 1
12292:             return
12293:           end if
12294: 
12295:           y = sqrt ( x )
12296:           dl(i) = y
12297:         else
12298:           b(j,i) = x / y
12299:         end if
12300: 
12301:     end do
12302: 
12303:   end do
12304: !
12305: !  Form the transpose of the upper triangle of INV(L)*A
12306: !  in the lower triangle of the array A.
12307: !
12308:   do i = 1, nn
12309: 
12310:      y = dl(i)
12311: 
12312:      do j = i, nn
12313: 
12314:         x = a(i,j)
12315: 
12316:         do k = 1, i - 1
12317:           x = x - b(i,k) * a(j,k)
12318:         end do
12319: 
12320:         a(j,i) = x / y
12321: 
12322:       end do
12323: 
12324:   end do
12325: !
12326: !  Pre-multiply by INV(L) and overwrite.
12327: !
12328:   do j = 1, nn
12329: 
12330:      do i = j, nn
12331: 
12332:         x = a(i,j)
12333: 
12334:         do k = j, i-1
12335:           x = x - a(k,j) * b(i,k)
12336:         end do
12337: 
12338:         do k = 1, j-1
12339:           x = x - a(j,k) * b(i,k)
12340:         end do
12341: 
12342:         a(i,j) = x / dl(i)
12343: 
12344:     end do
12345: 
12346:   end do
12347: 
12348:   return
12349: end
<p><a name=reduc2><H3>reduc2</H3></a></p> Click <a href="./callingtree/reduc2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where reduc2 is used.
<hr>
12350: subroutine reduc2 ( n, a, b, dl, ierr )
12351: 
12352: !*****************************************************************************80
12353: !
12354: !! REDUC2 reduces the eigenvalue problem A*B*x=lamdba*x to A*x=lambda*x.
12355: !
12356: !  Discussion:
12357: !
12358: !    This subroutine reduces the generalized symmetric eigenproblems
12359: !    abx=(lambda)x or bay=(lambda)y, where B is positive definite,
12360: !    to the standard symmetric eigenproblem using the Cholesky
12361: !    factorization of B.
12362: !
12363: !  Licensing:
12364: !
12365: !    This code is distributed under the GNU LGPL license.
12366: !
12367: !  Modified:
12368: !
12369: !    18 October 2009
12370: !
12371: !  Author:
12372: !
12373: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12374: !    Klema, Moler.
12375: !    FORTRAN90 version by John Burkardt.
12376: !
12377: !  Reference:
12378: !
12379: !    James Wilkinson, Christian Reinsch,
12380: !    Handbook for Automatic Computation,
12381: !    Volume II, Linear Algebra, Part 2,
12382: !    Springer, 1971,
12383: !    ISBN: 0387054146,
12384: !    LC: QA251.W67.
12385: !
12386: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12387: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12388: !    Matrix Eigensystem Routines, EISPACK Guide,
12389: !    Lecture Notes in Computer Science, Volume 6,
12390: !    Springer Verlag, 1976,
12391: !    ISBN13: 978-3540075462,
12392: !    LC: QA193.M37.
12393: !
12394: !  Parameters:
12395: !
12396: !    Input, integer ( kind = 4 ) N, the order of the matrices A and B.  If the Cholesky
12397: !    factor L of B is already available, N should be prefixed with a minus sign.
12398: !
12399: !    Input/output, real ( kind = 8 ) A(N,N).  On input, A contains a real symmetric matrix.
12400: !    Only the full upper triangle of the matrix need be supplied.
12401: !    On output, A contains in its full lower triangle the full lower triangle
12402: !    of the symmetric matrix derived from the reduction to the
12403: !    standard form.  The strict upper triangle of a is unaltered.
12404: !
12405: !    Input/output, real ( kind = 8 ) B(N,N).  On input, the real symmetric input matrix.  
12406: !    Only the full upper triangle of the matrix need be supplied.  If
12407: !    N is negative, the strict lower triangle of B contains, instead, the 
12408: !    strict lower triangle of its Cholesky factor L.  In any case, on output,
12409: !    B contains in its strict lower triangle the strict lower triangle of 
12410: !    its Cholesky factor L.  The full upper triangle of B is unaltered.
12411: !
12412: !    Input/output, real ( kind = 8 ) DL(N).  If N is negative, then the DL contains
12413: !    the diagonal elements of L on input.  In any case, DL will contain
12414: !    the diagonal elements of L on output,
12415: !
12416: !    Output, integer ( kind = 4 ) IERR, error flag.
12417: !    0, for normal return,
12418: !    7*N+1, if B is not positive definite.
12419: !
12420:   implicit none
12421: 
12422:   integer ( kind = 4 ) n
12423: 
12424:   real    ( kind = 8 ) a(n,n)
12425:   real    ( kind = 8 ) b(n,n)
12426:   real    ( kind = 8 ) dl(n)
12427:   integer ( kind = 4 ) i
12428:   integer ( kind = 4 ) ierr
12429:   integer ( kind = 4 ) j
12430:   integer ( kind = 4 ) k
12431:   integer ( kind = 4 ) nn
12432:   real    ( kind = 8 ) x
12433:   real    ( kind = 8 ) y
12434: 
12435:   ierr = 0
12436:   nn = abs ( n )
12437: !
12438: !  Form L in the arrays B and DL.
12439: !
12440:   do i = 1, n
12441: 
12442:      do j = i, n
12443: 
12444:         x = b(i,j)
12445: 
12446:         do k = 1, i - 1
12447:           x = x - b(i,k) * b(j,k)
12448:         end do
12449: 
12450:         if ( j == i ) then
12451: 
12452:           if ( x <= 0.0D+00 ) then
12453:             write ( *, '(a)' ) ' '
12454:             write ( *, '(a)' ) 'REDUC2 - Fatal error!'
12455:             write ( *, '(a)' ) '  The matrix is not positive definite.'
12456:             ierr = 7 * n + 1
12457:             return
12458:           end if
12459: 
12460:           y = sqrt ( x )
12461:           dl(i) = y
12462: 
12463:         else
12464: 
12465:           b(j,i) = x / y
12466: 
12467:         end if
12468: 
12469:     end do
12470: 
12471:   end do
12472: !
12473: !  Form the lower triangle of A*L in the lower triangle of A.
12474: !
12475:   do i = 1, nn
12476: 
12477:      do j = 1, i
12478: 
12479:         x = a(j,i) * dl(j)
12480: 
12481:         do k = j+1, i
12482:           x = x + a(k,i) * b(k,j)
12483:         end do
12484: 
12485:         do k = i+1, nn
12486:           x = x + a(i,k) * b(k,j)
12487:         end do
12488: 
12489:         a(i,j) = x
12490: 
12491:      end do
12492: 
12493:   end do
12494: !
12495: !  Pre-multiply by L' and overwrite.
12496: !
12497:   do i = 1, nn
12498: 
12499:     y = dl(i)
12500: 
12501:     do j = 1, i
12502: 
12503:       x = y * a(i,j)
12504: 
12505:       do k = i+1, nn
12506:         x = x + a(k,j) * b(k,i)
12507:       end do
12508: 
12509:       a(i,j) = x
12510: 
12511:     end do
12512: 
12513:   end do
12514: 
12515:   return
12516: end
<p><a name=rg><H3>rg</H3></a></p> Click <a href="./callingtree/rg_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rg is used.
<hr>
12517: subroutine rg ( n, a, wr, wi, matz, z, ierr )
12518: 
12519: !*****************************************************************************80
12520: !
12521: !! RG computes eigenvalues and eigenvectors of a real general matrix.
12522: !
12523: !  Discussion:
12524: !
12525: !    This subroutine calls the recommended sequence of
12526: !    subroutines from the eigensystem subroutine package (eispack)
12527: !    to find the eigenvalues and eigenvectors (if desired)
12528: !    of a real general matrix.
12529: !
12530: !  Licensing:
12531: !
12532: !    This code is distributed under the GNU LGPL license.
12533: !
12534: !  Modified:
12535: !
12536: !    18 October 2009
12537: !
12538: !  Author:
12539: !
12540: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12541: !    Klema, Moler.
12542: !    FORTRAN90 version by John Burkardt.
12543: !
12544: !  Reference:
12545: !
12546: !    James Wilkinson, Christian Reinsch,
12547: !    Handbook for Automatic Computation,
12548: !    Volume II, Linear Algebra, Part 2,
12549: !    Springer, 1971,
12550: !    ISBN: 0387054146,
12551: !    LC: QA251.W67.
12552: !
12553: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12554: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12555: !    Matrix Eigensystem Routines, EISPACK Guide,
12556: !    Lecture Notes in Computer Science, Volume 6,
12557: !    Springer Verlag, 1976,
12558: !    ISBN13: 978-3540075462,
12559: !    LC: QA193.M37.
12560: !
12561: !  Parameters:
12562: !
12563: !    Input, integer ( kind = 4 ) N, the order of the matrix.
12564: !
12565: !    Input/output, real ( kind = 8 ) A(N,N), the real general matrix.  On output,
12566: !    A has been overwritten.
12567: !
12568: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and
12569: !    nonzero if both eigenvalues and eigenvectors are desired.
12570: !
12571: !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts, respectively, 
12572: !    of the eigenvalues.  Complex conjugate pairs of eigenvalues appear 
12573: !    consecutively with the eigenvalue having the positive imaginary part first.
12574: !
12575: !    Output, real ( kind = 8 ) Z(N,N), contains the real and imaginary parts of the 
12576: !    eigenvectors if MATZ is not zero.  If the J-th eigenvalue is real, the
12577: !    J-th column of Z contains its eigenvector.  If the J-th eigenvalue is 
12578: !    complex with positive imaginary part, the J-th and (J+1)-th columns of 
12579: !    Z contain the real and imaginary parts of its eigenvector.  The 
12580: !    conjugate of this vector is the eigenvector for the conjugate eigenvalue.
12581: !
12582: !    Output, integer ( kind = 4 ) IERR, an error completion code described in the 
12583: !    documentation for HQR and HQR2.  The normal completion code is zero.
12584: !
12585:   implicit none
12586: 
12587:   integer ( kind = 4 ) n
12588: 
12589:   real    ( kind = 8 ) a(n,n)
12590:   real    ( kind = 8 ) fv1(n)
12591:   integer ( kind = 4 ) ierr
12592:   integer ( kind = 4 ) is1
12593:   integer ( kind = 4 ) is2
12594:   integer ( kind = 4 ) iv1(n)
12595:   integer ( kind = 4 ) matz
12596:   real    ( kind = 8 ) wi(n)
12597:   real    ( kind = 8 ) wr(n)
12598:   real    ( kind = 8 ) z(n,n)
12599: 
12600:   call <a href="./eispack.f90.html#balanc" TARGET=CENT_PANEL>balanc</a> ( n, a, is1, is2, fv1 )
12601: 
12602:   call <a href="./eispack.f90.html#elmhes" TARGET=CENT_PANEL>elmhes</a> ( n, is1, is2, a, iv1 )
12603: 
12604:   if ( matz == 0 ) then
12605: 
12606:     call <a href="./eispack.f90.html#hqr" TARGET=CENT_PANEL>hqr</a> ( n, is1, is2, a, wr, wi, ierr )
12607: 
12608:     if ( ierr /= 0 ) then
12609:       return
12610:     end if
12611: 
12612:   else
12613: 
12614:     call <a href="./eispack.f90.html#eltran" TARGET=CENT_PANEL>eltran</a> ( n, is1, is2, a, iv1, z )
12615: 
12616:     call <a href="./eispack.f90.html#hqr2" TARGET=CENT_PANEL>hqr2</a> ( n, is1, is2, a, wr, wi, z, ierr )
12617: 
12618:     if ( ierr /= 0 ) then
12619:       return
12620:     end if
12621: 
12622:     call <a href="./eispack.f90.html#balbak" TARGET=CENT_PANEL>balbak</a> ( n, is1, is2, fv1, n, z )
12623: 
12624:   end if
12625: 
12626:   return
12627: end
<p><a name=rgg><H3>rgg</H3></a></p> Click <a href="./callingtree/rgg_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rgg is used.
<hr>
12628: subroutine rgg ( n, a, b, alfr, alfi, beta, matz, z, ierr )
12629: 
12630: !*****************************************************************************80
12631: !
12632: !! RGG computes eigenvalues/vectors for the generalized problem A*x = lambda*B*x.
12633: !
12634: !  Discussion:
12635: !
12636: !    This subroutine calls the recommended sequence of
12637: !    subroutines from the eigensystem subroutine package (eispack)
12638: !    to find the eigenvalues and eigenvectors (if desired)
12639: !    for the real general generalized eigenproblem  
12640: !
12641: !      A * x = lambda * B * x.
12642: !
12643: !  Licensing:
12644: !
12645: !    This code is distributed under the GNU LGPL license.
12646: !
12647: !  Modified:
12648: !
12649: !    18 October 2009
12650: !
12651: !  Author:
12652: !
12653: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12654: !    Klema, Moler.
12655: !    FORTRAN90 version by John Burkardt.
12656: !
12657: !  Reference:
12658: !
12659: !    James Wilkinson, Christian Reinsch,
12660: !    Handbook for Automatic Computation,
12661: !    Volume II, Linear Algebra, Part 2,
12662: !    Springer, 1971,
12663: !    ISBN: 0387054146,
12664: !    LC: QA251.W67.
12665: !
12666: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12667: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12668: !    Matrix Eigensystem Routines, EISPACK Guide,
12669: !    Lecture Notes in Computer Science, Volume 6,
12670: !    Springer Verlag, 1976,
12671: !    ISBN13: 978-3540075462,
12672: !    LC: QA193.M37.
12673: !
12674: !  Parameters:
12675: !
12676: !    Input, integer ( kind = 4 ) N, the order of the matrices A and B.
12677: !
12678: !    Input/output, real ( kind = 8 ) A(N,N), B(N,N), the two real general matrices.
12679: !    On output, A and B have been overwritten.
12680: !
12681: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and
12682: !    nonzero if both eigenvalues and eigenvectors are desired.
12683: !
12684: !    Output, real ( kind = 8 ) ALFR(N), ALFI(N), the real and imaginary parts,
12685: !    respectively, of the numerators of the eigenvalues.
12686: !
12687: !    Output, real ( kind = 8 ) BETA(N), the denominators of the eigenvalues,
12688: !    which are thus given by the ratios (ALFR + I * ALFI ) / BETA.
12689: !    Complex conjugate pairs of eigenvalues appear consecutively
12690: !    with the eigenvalue having the positive imaginary part first.
12691: !
12692: !    Output, real ( kind = 8 ) Z(N,N), contains the real and imaginary parts of the 
12693: !    eigenvectors if MATZ is not zero.  If the J-th eigenvalue is real, the
12694: !    J-th column of Z contains its eigenvector.  If the J-th eigenvalue is 
12695: !    complex with positive imaginary part, the J-th and (J+1)-th columns of 
12696: !    Z contain the real and imaginary parts of its eigenvector.  The 
12697: !    conjugate of this vector is the eigenvector for the conjugate eigenvalue.
12698: !
12699: !    Output, integer ( kind = 4 ) IERR, is set equal to an error completion code 
12700: !    described in the documentation for QZIT.  The normal completion 
12701: !    code is zero.
12702: !
12703:   implicit none
12704: 
12705:   integer ( kind = 4 ) n
12706: 
12707:   real    ( kind = 8 ) a(n,n)
12708:   real    ( kind = 8 ) alfi(n)
12709:   real    ( kind = 8 ) alfr(n)
12710:   real    ( kind = 8 ) b(n,n)
12711:   real    ( kind = 8 ) beta(n)
12712:   real    ( kind = 8 ) eps1
12713:   integer ( kind = 4 ) ierr
12714:   integer ( kind = 4 ) matz
12715:   logical              tf
12716:   real    ( kind = 8 ) z(n,n)
12717: 
12718:   eps1 = 0.0D+00
12719: 
12720:   if ( matz == 0 ) then
12721:     tf = .false.
12722:   else
12723:     tf = .true.
12724:   end if
12725: 
12726:   call <a href="./eispack.f90.html#qzhes" TARGET=CENT_PANEL>qzhes</a> ( n, a, b, tf, z )
12727: 
12728:   call <a href="./eispack.f90.html#qzit" TARGET=CENT_PANEL>qzit</a> ( n, a, b, eps1, tf, z, ierr )
12729: 
12730:   if ( ierr /= 0 ) then
12731:     return
12732:   end if
12733: 
12734:   call <a href="./eispack.f90.html#qzval" TARGET=CENT_PANEL>qzval</a> ( n, a, b, alfr, alfi, beta, tf, z )
12735: 
12736:   if ( matz /= 0 ) then
12737:     call <a href="./eispack.f90.html#qzvec" TARGET=CENT_PANEL>qzvec</a> ( n, a, b, alfr, alfi, beta, z )
12738:   end if
12739: 
12740:   return
12741: end
<p><a name=rs><H3>rs</H3></a></p> Click <a href="./callingtree/rs_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rs is used.
<hr>
12742: subroutine rs ( n, a, w, matz, z, ierr )
12743: 
12744: !*****************************************************************************80
12745: !
12746: !! RS computes eigenvalues and eigenvectors of real symmetric matrix.
12747: !
12748: !  Discussion:
12749: !
12750: !    This subroutine calls the recommended sequence of
12751: !    subroutines from the eigensystem subroutine package (eispack)
12752: !    to find the eigenvalues and eigenvectors (if desired)
12753: !    of a real symmetric matrix.
12754: !
12755: !  Licensing:
12756: !
12757: !    This code is distributed under the GNU LGPL license.
12758: !
12759: !  Modified:
12760: !
12761: !    18 October 2009
12762: !
12763: !  Author:
12764: !
12765: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12766: !    Klema, Moler.
12767: !    FORTRAN90 version by John Burkardt.
12768: !
12769: !  Reference:
12770: !
12771: !    James Wilkinson, Christian Reinsch,
12772: !    Handbook for Automatic Computation,
12773: !    Volume II, Linear Algebra, Part 2,
12774: !    Springer, 1971,
12775: !    ISBN: 0387054146,
12776: !    LC: QA251.W67.
12777: !
12778: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12779: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12780: !    Matrix Eigensystem Routines, EISPACK Guide,
12781: !    Lecture Notes in Computer Science, Volume 6,
12782: !    Springer Verlag, 1976,
12783: !    ISBN13: 978-3540075462,
12784: !    LC: QA193.M37.
12785: !
12786: !  Parameters:
12787: !
12788: !    Input, integer ( kind = 4 ) N, the order of the matrix.
12789: !
12790: !    Input, real ( kind = 8 ) A(N,N), the real symmetric matrix.
12791: !
12792: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and
12793: !    nonzero if both eigenvalues and eigenvectors are desired.
12794: !
12795: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
12796: !
12797: !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero.
12798: !
12799: !    Output, integer ( kind = 4 ) IERR, is set equal to an error
12800: !    completion code described in the documentation for TQLRAT and TQL2.  
12801: !    The normal completion code is zero.
12802: !
12803:   implicit none
12804: 
12805:   integer ( kind = 4 ) n
12806: 
12807:   real    ( kind = 8 ) a(n,n)
12808:   real    ( kind = 8 ) fv1(n)
12809:   real    ( kind = 8 ) fv2(n)
12810:   integer ( kind = 4 ) ierr
12811:   integer ( kind = 4 ) matz
12812:   real    ( kind = 8 ) w(n)
12813:   real    ( kind = 8 ) z(n,n)
12814: 
12815:   if ( matz == 0 ) then
12816: 
12817:     call <a href="./eispack.f90.html#tred1" TARGET=CENT_PANEL>tred1</a> ( n, a, w, fv1, fv2 )
12818: 
12819:     call <a href="./eispack.f90.html#tqlrat" TARGET=CENT_PANEL>tqlrat</a> ( n, w, fv2, ierr )
12820: 
12821:   else
12822: 
12823:     call <a href="./eispack.f90.html#tred2" TARGET=CENT_PANEL>tred2</a> ( n, a, w, fv1, z )
12824: 
12825:     call <a href="./eispack.f90.html#tql2" TARGET=CENT_PANEL>tql2</a> ( n, w, fv1, z, ierr )
12826: 
12827:   end if
12828: 
12829:   return
12830: end
<p><a name=rsb><H3>rsb</H3></a></p> Click <a href="./callingtree/rsb_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rsb is used.
<hr>
12831: subroutine rsb ( n, mb, a, w, matz, z, ierr )
12832: 
12833: !*****************************************************************************80
12834: !
12835: !! RSB computes eigenvalues and eigenvectors of a real symmetric band matrix.
12836: !
12837: !  Discussion:
12838: !
12839: !    This subroutine calls the recommended sequence of
12840: !    subroutines from the eigensystem subroutine package (eispack)
12841: !    to find the eigenvalues and eigenvectors (if desired)
12842: !    of a real symmetric band matrix.
12843: !
12844: !  Licensing:
12845: !
12846: !    This code is distributed under the GNU LGPL license.
12847: !
12848: !  Modified:
12849: !
12850: !    18 October 2009
12851: !
12852: !  Author:
12853: !
12854: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12855: !    Klema, Moler.
12856: !    FORTRAN90 version by John Burkardt.
12857: !
12858: !  Reference:
12859: !
12860: !    James Wilkinson, Christian Reinsch,
12861: !    Handbook for Automatic Computation,
12862: !    Volume II, Linear Algebra, Part 2,
12863: !    Springer, 1971,
12864: !    ISBN: 0387054146,
12865: !    LC: QA251.W67.
12866: !
12867: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12868: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12869: !    Matrix Eigensystem Routines, EISPACK Guide,
12870: !    Lecture Notes in Computer Science, Volume 6,
12871: !    Springer Verlag, 1976,
12872: !    ISBN13: 978-3540075462,
12873: !    LC: QA193.M37.
12874: !
12875: !  Parameters:
12876: !
12877: !    Input, integer ( kind = 4 ) N, the order of the matrix.
12878: !
12879: !    Input, integer ( kind = 4 ) MB, the half band width of the matrix, defined as the
12880: !    number of adjacent diagonals, including the principal diagonal, required
12881: !    to specify the non-zero portion of the lower triangle of the matrix.
12882: !
12883: !    Input, real ( kind = 8 ) A(N,MB), contains the lower triangle of the real symmetric
12884: !    band matrix.  Its lowest subdiagonal is stored in the last N+1-MB 
12885: !    positions of the first column, its next subdiagonal in the last 
12886: !    N+2-MB positions of the second column, further subdiagonals similarly, 
12887: !    and finally its principal diagonal in the N positions of the last 
12888: !    column.  Contents of storages not part of the matrix are arbitrary.
12889: !
12890: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and
12891: !    nonzero if both eigenvalues and eigenvectors are desired.
12892: !
12893: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
12894: !
12895: !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero.
12896: !
12897: !    Output, integer ( kind = 4 ) IERR, is set to an error
12898: !    completion code described in the documentation for TQLRAT and TQL2.  
12899: !    The normal completion code is zero.
12900: !
12901:   implicit none
12902: 
12903:   integer ( kind = 4 ) mb
12904:   integer ( kind = 4 ) n
12905: 
12906:   real    ( kind = 8 ) a(n,mb)
12907:   real    ( kind = 8 ) fv1(n)
12908:   real    ( kind = 8 ) fv2(n)
12909:   integer ( kind = 4 ) ierr
12910:   integer ( kind = 4 ) matz
12911:   logical              tf
12912:   real    ( kind = 8 ) w(n)
12913:   real    ( kind = 8 ) z(n,n)
12914: 
12915:   if ( mb <= 0 ) then
12916:     ierr = 12 * n
12917:     return
12918:   end if
12919: 
12920:   if ( n < mb ) then
12921:     ierr = 12 * n
12922:     return
12923:   end if
12924: 
12925:   if ( matz == 0 ) then
12926:  
12927:     tf = .false.
12928: 
12929:     call <a href="./eispack.f90.html#bandr" TARGET=CENT_PANEL>bandr</a> ( n, mb, a, w, fv1, fv2, tf, z )
12930: 
12931:     call <a href="./eispack.f90.html#tqlrat" TARGET=CENT_PANEL>tqlrat</a> ( n, w, fv2, ierr )
12932: 
12933:   else
12934: 
12935:     tf = .true.
12936: 
12937:     call <a href="./eispack.f90.html#bandr" TARGET=CENT_PANEL>bandr</a> ( n, mb, a, w, fv1, fv1, tf, z )
12938: 
12939:     call <a href="./eispack.f90.html#tql2" TARGET=CENT_PANEL>tql2</a> ( n, w, fv1, z, ierr )
12940: 
12941:   end if
12942: 
12943:   return
12944: end
<p><a name=rsg><H3>rsg</H3></a></p> Click <a href="./callingtree/rsg_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rsg is used.
<hr>
12945: subroutine rsg ( n, a, b, w, matz, z, ierr )
12946: 
12947: !*****************************************************************************80
12948: !
12949: !! RSG computes eigenvalues/vectors, A*x=lambda*B*x, A symmetric, B pos-def.
12950: !
12951: !  Discussion:
12952: !
12953: !    This subroutine calls the recommended sequence of
12954: !    subroutines from the eigensystem subroutine package (eispack)
12955: !    to find the eigenvalues and eigenvectors (if desired)
12956: !    for the real symmetric generalized eigenproblem  ax = (lambda)bx.
12957: !
12958: !  Licensing:
12959: !
12960: !    This code is distributed under the GNU LGPL license.
12961: !
12962: !  Modified:
12963: !
12964: !    18 October 2009
12965: !
12966: !  Author:
12967: !
12968: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
12969: !    Klema, Moler.
12970: !    FORTRAN90 version by John Burkardt.
12971: !
12972: !  Reference:
12973: !
12974: !    James Wilkinson, Christian Reinsch,
12975: !    Handbook for Automatic Computation,
12976: !    Volume II, Linear Algebra, Part 2,
12977: !    Springer, 1971,
12978: !    ISBN: 0387054146,
12979: !    LC: QA251.W67.
12980: !
12981: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
12982: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
12983: !    Matrix Eigensystem Routines, EISPACK Guide,
12984: !    Lecture Notes in Computer Science, Volume 6,
12985: !    Springer Verlag, 1976,
12986: !    ISBN13: 978-3540075462,
12987: !    LC: QA193.M37.
12988: !
12989: !  Modified:
12990: !
12991: !    04 February 2003
12992: !
12993: !  Parameters:
12994: !
12995: !    Input, integer ( kind = 4 ) N, the order of the matrices A and B.
12996: !
12997: !    Input, real ( kind = 8 ) A(N,N), contains a real symmetric matrix.
12998: !
12999: !    Input, real ( kind = 8 ) B(N,N), contains a positive definite real symmetric matrix.
13000: !
13001: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and
13002: !    nonzero if both eigenvalues and eigenvectors are desired.
13003: !
13004: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
13005: !
13006: !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero.
13007: !
13008: !    Output, integer ( kind = 4 ) IERR, is set to an error
13009: !    completion code described in the documentation for TQLRAT and TQL2.  
13010: !    The normal completion code is zero.
13011: !
13012:   implicit none
13013: 
13014:   integer ( kind = 4 ) n
13015: 
13016:   real    ( kind = 8 ) a(n,n)
13017:   real    ( kind = 8 ) b(n,n)
13018:   real    ( kind = 8 ) fv1(n)
13019:   real    ( kind = 8 ) fv2(n)
13020:   integer ( kind = 4 ) ierr
13021:   integer ( kind = 4 ) matz
13022:   real    ( kind = 8 ) w(n)
13023:   real    ( kind = 8 ) z(n,n)
13024: 
13025:   call <a href="./eispack.f90.html#reduc" TARGET=CENT_PANEL>reduc</a> ( n, a, b, fv2, ierr )
13026: 
13027:   if ( ierr /= 0 ) then
13028:     write ( *, '(a)' ) ' '
13029:     write ( *, '(a)' ) 'RSG - Fatal error!'
13030:     write ( *, '(a)' ) '  Error return from REDUC.'
13031:     return
13032:   end if
13033: 
13034:   if ( matz == 0 ) then
13035: 
13036:     call <a href="./eispack.f90.html#tred1" TARGET=CENT_PANEL>tred1</a> ( n, a, w, fv1, fv2 )
13037: 
13038:     call <a href="./eispack.f90.html#tqlrat" TARGET=CENT_PANEL>tqlrat</a> ( n, w, fv2, ierr )
13039: 
13040:     if ( ierr /= 0 ) then
13041:       write ( *, '(a)' ) ' '
13042:       write ( *, '(a)' ) 'RSG - Warning!'
13043:       write ( *, '(a)' ) '  Error return from TQLRAT!'
13044:       return
13045:     end if
13046: 
13047:   else
13048: 
13049:     call <a href="./eispack.f90.html#tred2" TARGET=CENT_PANEL>tred2</a> ( n, a, w, fv1, z )
13050: 
13051:     call <a href="./eispack.f90.html#tql2" TARGET=CENT_PANEL>tql2</a> ( n, w, fv1, z, ierr )
13052: 
13053:     if ( ierr /= 0 ) then
13054:       write ( *, '(a)' ) ' '
13055:       write ( *, '(a)' ) 'RSG - Fatal error!'
13056:       write ( *, '(a)' ) '  Error return from TQL2!'
13057:       return
13058:     end if
13059: 
13060:     call <a href="./eispack.f90.html#rebak" TARGET=CENT_PANEL>rebak</a> ( n, b, fv2, n, z )
13061: 
13062:   end if
13063: 
13064:   return
13065: end
<p><a name=rsgab><H3>rsgab</H3></a></p> Click <a href="./callingtree/rsgab_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rsgab is used.
<hr>
13066: subroutine rsgab ( n, a, b, w, matz, z, ierr )
13067: 
13068: !*****************************************************************************80
13069: !
13070: !! RSGAB computes eigenvalues/vectors, A*B*x=lambda*x, A symmetric, B pos-def.
13071: !
13072: !  Discussion:
13073: !
13074: !    This subroutine calls the recommended sequence of
13075: !    subroutines from the eigensystem subroutine package (eispack)
13076: !    to find the eigenvalues and eigenvectors (if desired)
13077: !    for the real symmetric generalized eigenproblem  abx = (lambda)x.
13078: !
13079: !  Licensing:
13080: !
13081: !    This code is distributed under the GNU LGPL license.
13082: !
13083: !  Modified:
13084: !
13085: !    18 October 2009
13086: !
13087: !  Author:
13088: !
13089: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
13090: !    Klema, Moler.
13091: !    FORTRAN90 version by John Burkardt.
13092: !
13093: !  Reference:
13094: !
13095: !    James Wilkinson, Christian Reinsch,
13096: !    Handbook for Automatic Computation,
13097: !    Volume II, Linear Algebra, Part 2,
13098: !    Springer, 1971,
13099: !    ISBN: 0387054146,
13100: !    LC: QA251.W67.
13101: !
13102: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
13103: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
13104: !    Matrix Eigensystem Routines, EISPACK Guide,
13105: !    Lecture Notes in Computer Science, Volume 6,
13106: !    Springer Verlag, 1976,
13107: !    ISBN13: 978-3540075462,
13108: !    LC: QA193.M37.
13109: !
13110: !  Parameters:
13111: !
13112: !    Input, integer ( kind = 4 ) N, the order of the matrices A and B.
13113: !
13114: !    Input, real ( kind = 8 ) A(N,N), contains a real symmetric matrix.
13115: !
13116: !    Input, real ( kind = 8 ) B(N,N), contains a positive definite real symmetric matrix.
13117: !
13118: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and
13119: !    nonzero if both eigenvalues and eigenvectors are desired.
13120: !
13121: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
13122: !
13123: !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero.
13124: !
13125: !    Output, integer ( kind = 4 ) IERR, is set to an error
13126: !    completion code described in the documentation for TQLRAT and TQL2.  
13127: !    The normal completion code is zero.
13128: !
13129:   implicit none
13130: 
13131:   integer ( kind = 4 ) n
13132: 
13133:   real    ( kind = 8 ) a(n,n)
13134:   real    ( kind = 8 ) b(n,n)
13135:   real    ( kind = 8 ) fv1(n)
13136:   real    ( kind = 8 ) fv2(n)
13137:   integer ( kind = 4 ) ierr
13138:   integer ( kind = 4 ) matz
13139:   real    ( kind = 8 ) w(n)
13140:   real    ( kind = 8 ) z(n,n)
13141: 
13142:   call <a href="./eispack.f90.html#reduc2" TARGET=CENT_PANEL>reduc2</a> ( n, a, b, fv2, ierr )
13143: 
13144:   if ( ierr /= 0 ) then
13145:     return
13146:   end if
13147: 
13148:   if ( matz == 0 ) then
13149: 
13150:     call <a href="./eispack.f90.html#tred1" TARGET=CENT_PANEL>tred1</a> ( n, a, w, fv1, fv2 )
13151: 
13152:     call <a href="./eispack.f90.html#tqlrat" TARGET=CENT_PANEL>tqlrat</a> ( n, w, fv2, ierr )
13153: 
13154:   else
13155: 
13156:     call <a href="./eispack.f90.html#tred2" TARGET=CENT_PANEL>tred2</a> ( n, a, w, fv1, z )
13157: 
13158:     call <a href="./eispack.f90.html#tql2" TARGET=CENT_PANEL>tql2</a> ( n, w, fv1, z, ierr )
13159: 
13160:     if ( ierr /= 0 ) then
13161:       return
13162:     end if
13163: 
13164:     call <a href="./eispack.f90.html#rebak" TARGET=CENT_PANEL>rebak</a> ( n, b, fv2, n, z )
13165: 
13166:   end if
13167: 
13168:   return
13169: end
<p><a name=rsgba><H3>rsgba</H3></a></p> Click <a href="./callingtree/rsgba_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rsgba is used.
<hr>
13170: subroutine rsgba ( n, a, b, w, matz, z, ierr )
13171: 
13172: !*****************************************************************************80
13173: !
13174: !! RSGBA computes eigenvalues/vectors, B*A*x=lambda*x, A symmetric, B pos-def.
13175: !
13176: !  Discussion:
13177: !
13178: !    This subroutine calls the recommended sequence of
13179: !    subroutines from the eigensystem subroutine package (eispack)
13180: !    to find the eigenvalues and eigenvectors (if desired)
13181: !    for the real symmetric generalized eigenproblem:
13182: ! 
13183: !      B * A * x = lambda * x
13184: !
13185: !  Licensing:
13186: !
13187: !    This code is distributed under the GNU LGPL license.
13188: !
13189: !  Modified:
13190: !
13191: !    18 October 2009
13192: !
13193: !  Author:
13194: !
13195: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
13196: !    Klema, Moler.
13197: !    FORTRAN90 version by John Burkardt.
13198: !
13199: !  Reference:
13200: !
13201: !    James Wilkinson, Christian Reinsch,
13202: !    Handbook for Automatic Computation,
13203: !    Volume II, Linear Algebra, Part 2,
13204: !    Springer, 1971,
13205: !    ISBN: 0387054146,
13206: !    LC: QA251.W67.
13207: !
13208: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
13209: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
13210: !    Matrix Eigensystem Routines, EISPACK Guide,
13211: !    Lecture Notes in Computer Science, Volume 6,
13212: !    Springer Verlag, 1976,
13213: !    ISBN13: 978-3540075462,
13214: !    LC: QA193.M37.
13215: !
13216: !  Parameters:
13217: !
13218: !    Input, integer ( kind = 4 ) N, the order of the matrices A and B.
13219: !
13220: !    Input, real ( kind = 8 ) A(N,N), a real symmetric matrix.
13221: !
13222: !    Input, real ( kind = 8 ) B(N,N), a positive definite symmetric matrix.
13223: !
13224: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and
13225: !    nonzero if both eigenvalues and eigenvectors are desired.
13226: !
13227: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
13228: !
13229: !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero.
13230: !
13231: !    Output, integer ( kind = 4 ) IERR, is set to an error
13232: !    completion code described in the documentation for TQLRAT and TQL2.  
13233: !    The normal completion code is zero.
13234: !
13235:   implicit none
13236: 
13237:   integer ( kind = 4 ) n
13238: 
13239:   real    ( kind = 8 ) a(n,n)
13240:   real    ( kind = 8 ) b(n,n)
13241:   real    ( kind = 8 ) fv1(n)
13242:   real    ( kind = 8 ) fv2(n)
13243:   integer ( kind = 4 ) ierr
13244:   integer ( kind = 4 ) matz
13245:   real    ( kind = 8 ) w(n)
13246:   real    ( kind = 8 ) z(n,n)
13247: 
13248:   call <a href="./eispack.f90.html#reduc2" TARGET=CENT_PANEL>reduc2</a> ( n, a, b, fv2, ierr )
13249: 
13250:   if ( ierr /= 0 ) then
13251:     return
13252:   end if
13253: 
13254:   if ( matz == 0 ) then
13255: 
13256:     call <a href="./eispack.f90.html#tred1" TARGET=CENT_PANEL>tred1</a> ( n, a, w, fv1, fv2 )
13257: 
13258:     call <a href="./eispack.f90.html#tqlrat" TARGET=CENT_PANEL>tqlrat</a> ( n, w, fv2, ierr )
13259: 
13260:   else
13261: 
13262:     call <a href="./eispack.f90.html#tred2" TARGET=CENT_PANEL>tred2</a> ( n, a, w, fv1, z )
13263: 
13264:     call <a href="./eispack.f90.html#tql2" TARGET=CENT_PANEL>tql2</a> ( n, w, fv1, z, ierr )
13265: 
13266:     if ( ierr /= 0 ) then
13267:       return
13268:     end if
13269: 
13270:     call <a href="./eispack.f90.html#rebakb" TARGET=CENT_PANEL>rebakb</a> ( n, b, fv2, n, z )
13271: 
13272:   end if
13273: 
13274:   return
13275: end
<p><a name=rsm><H3>rsm</H3></a></p> Click <a href="./callingtree/rsm_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rsm is used.
<hr>
13276: subroutine rsm ( n, a, w, m, z, ierr )
13277: 
13278: !*****************************************************************************80
13279: !
13280: !! RSM computes eigenvalues, some eigenvectors, real symmetric matrix.
13281: !
13282: !  Discussion:
13283: !
13284: !    This subroutine calls the recommended sequence of
13285: !    subroutines from the eigensystem subroutine package (eispack)
13286: !    to find all of the eigenvalues and some of the eigenvectors
13287: !    of a real symmetric matrix.
13288: !
13289: !  Licensing:
13290: !
13291: !    This code is distributed under the GNU LGPL license.
13292: !
13293: !  Modified:
13294: !
13295: !    18 October 2009
13296: !
13297: !  Author:
13298: !
13299: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
13300: !    Klema, Moler.
13301: !    FORTRAN90 version by John Burkardt.
13302: !
13303: !  Reference:
13304: !
13305: !    James Wilkinson, Christian Reinsch,
13306: !    Handbook for Automatic Computation,
13307: !    Volume II, Linear Algebra, Part 2,
13308: !    Springer, 1971,
13309: !    ISBN: 0387054146,
13310: !    LC: QA251.W67.
13311: !
13312: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
13313: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
13314: !    Matrix Eigensystem Routines, EISPACK Guide,
13315: !    Lecture Notes in Computer Science, Volume 6,
13316: !    Springer Verlag, 1976,
13317: !    ISBN13: 978-3540075462,
13318: !    LC: QA193.M37.
13319: !
13320: !  Parameters:
13321: !
13322: !    Input, integer ( kind = 4 ) N, the order of the matrix.
13323: !
13324: !    Input, real ( kind = 8 ) A(N,N), the symmetric matrix.
13325: !
13326: !    Input, integer ( kind = 4 ) M, specifies the number of eigenvectors to compute.
13327: !
13328: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
13329: !
13330: !    Output, real ( kind = 8 ) Z(N,M), contains the orthonormal eigenvectors associated
13331: !    with the first M eigenvalues.
13332: !
13333: !    Output, integer ( kind = 4 ) IERR, is set to an error
13334: !    completion code described in the documentation for TQLRAT, IMTQLV and
13335: !    TINVIT.  The normal completion code is zero.
13336: !
13337:   implicit none
13338: 
13339:   integer ( kind = 4 ) m
13340:   integer ( kind = 4 ) n
13341: 
13342:   real    ( kind = 8 ) a(n,n)
13343:   real    ( kind = 8 ) fwork1(n)
13344:   real    ( kind = 8 ) fwork2(n)
13345:   real    ( kind = 8 ) fwork3(n)
13346:   integer ( kind = 4 ) ierr
13347:   integer ( kind = 4 ) iwork(n)
13348:   integer ( kind = 4 ) k1
13349:   integer ( kind = 4 ) k2
13350:   integer ( kind = 4 ) k3
13351:   integer ( kind = 4 ) k4
13352:   real    ( kind = 8 ) w(n)
13353:   real    ( kind = 8 ) z(n,m)
13354: 
13355:   k1 = 1
13356:   k2 = k1 + n
13357:   k3 = k2 + n
13358:   k4 = k3 + n
13359: 
13360:   if ( m <= 0 ) then
13361: 
13362:     call <a href="./eispack.f90.html#tred1" TARGET=CENT_PANEL>tred1</a> ( n, a, w, fwork1, fwork2 )
13363: 
13364:     call <a href="./eispack.f90.html#tqlrat" TARGET=CENT_PANEL>tqlrat</a> ( n, w, fwork2, ierr )
13365: 
13366:   else
13367: 
13368:     call <a href="./eispack.f90.html#tred1" TARGET=CENT_PANEL>tred1</a> ( n, a, fwork1, fwork2, fwork3 )
13369: 
13370:     call <a href="./eispack.f90.html#imtqlv" TARGET=CENT_PANEL>imtqlv</a> ( n, fwork1, fwork2, fwork3, w, iwork, ierr )
13371: 
13372:     call <a href="./eispack.f90.html#tinvit" TARGET=CENT_PANEL>tinvit</a> ( n, fwork1, fwork2, fwork3, m, w, iwork, z, ierr )
13373: 
13374:     call <a href="./eispack.f90.html#trbak1" TARGET=CENT_PANEL>trbak1</a> ( n, a, fwork2, m, z )
13375: 
13376:   end if
13377: 
13378:   return
13379: end
<p><a name=rsp><H3>rsp</H3></a></p> Click <a href="./callingtree/rsp_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rsp is used.
<hr>
13380: subroutine rsp ( n, nv, a, w, matz, z, ierr )
13381: 
13382: !*****************************************************************************80
13383: !
13384: !! RSP computes eigenvalues and eigenvectors of real symmetric packed matrix.
13385: !
13386: !  Discussion:
13387: !
13388: !    This subroutine calls the recommended sequence of
13389: !    subroutines from the eigensystem subroutine package (eispack)
13390: !    to find the eigenvalues and eigenvectors (if desired)
13391: !    of a real symmetric packed matrix.
13392: !
13393: !  Licensing:
13394: !
13395: !    This code is distributed under the GNU LGPL license.
13396: !
13397: !  Modified:
13398: !
13399: !    18 October 2009
13400: !
13401: !  Author:
13402: !
13403: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
13404: !    Klema, Moler.
13405: !    FORTRAN90 version by John Burkardt.
13406: !
13407: !  Reference:
13408: !
13409: !    James Wilkinson, Christian Reinsch,
13410: !    Handbook for Automatic Computation,
13411: !    Volume II, Linear Algebra, Part 2,
13412: !    Springer, 1971,
13413: !    ISBN: 0387054146,
13414: !    LC: QA251.W67.
13415: !
13416: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
13417: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
13418: !    Matrix Eigensystem Routines, EISPACK Guide,
13419: !    Lecture Notes in Computer Science, Volume 6,
13420: !    Springer Verlag, 1976,
13421: !    ISBN13: 978-3540075462,
13422: !    LC: QA193.M37.
13423: !
13424: !  Parameters:
13425: !
13426: !    Input, integer ( kind = 4 ) N, the order of the matrix.
13427: !
13428: !    Input, integer ( kind = 4 ) NV, the dimension of the array A, which 
13429: !    must be at least (N*(N+1))/2.
13430: !
13431: !    Input, real ( kind = 8 ) A(NV), contains the lower triangle of the real symmetric
13432: !    packed matrix stored row-wise.
13433: !
13434: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and
13435: !    nonzero if both eigenvalues and eigenvectors are desired.
13436: !
13437: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
13438: !
13439: !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero.
13440: !
13441: !    Output, integer ( kind = 4 ) IERR, is set to an error
13442: !    completion code described in the documentation for TQLRAT and TQL2.  
13443: !    The normal completion code is zero.
13444: !
13445:   implicit none
13446: 
13447:   integer ( kind = 4 ) n
13448:   integer ( kind = 4 ) nv
13449: 
13450:   real    ( kind = 8 ) a(nv)
13451:   real    ( kind = 8 ) fv1(n)
13452:   real    ( kind = 8 ) fv2(n)
13453:   integer ( kind = 4 ) i
13454:   integer ( kind = 4 ) ierr
13455:   integer ( kind = 4 ) matz
13456:   real    ( kind = 8 ) w(n)
13457:   real    ( kind = 8 ) z(n,n)
13458: 
13459:   if ( ( n * ( n + 1 ) ) / 2 > nv ) then
13460:     ierr = 20 * n
13461:     return
13462:   end if
13463: 
13464:   call <a href="./eispack.f90.html#tred3" TARGET=CENT_PANEL>tred3</a> ( n, nv, a, w, fv1, fv2 )
13465: 
13466:   if ( matz == 0 ) then
13467: 
13468:     call <a href="./eispack.f90.html#tqlrat" TARGET=CENT_PANEL>tqlrat</a> ( n, w, fv2, ierr )
13469: 
13470:     if ( ierr /= 0 ) then
13471:       write ( *, '(a)' ) ' '
13472:       write ( *, '(a)' ) 'RSP - Fatal error!'
13473:       write ( *, '(a)' ) '  Error return from TQLRAT.'
13474:       return
13475:     end if
13476: 
13477:   else
13478: 
13479:     z(1:n,1:n) = 0.0D+00
13480: 
13481:     do i = 1, n
13482:       z(i,i) = 1.0D+00
13483:     end do
13484: 
13485:     call <a href="./eispack.f90.html#tql2" TARGET=CENT_PANEL>tql2</a> ( n, w, fv1, z, ierr )
13486: 
13487:     if ( ierr /= 0 ) then
13488:       write ( *, '(a)' ) ' '
13489:       write ( *, '(a)' ) 'RSP - Fatal error!'
13490:       write ( *, '(a)' ) '  Error return from TQL2.'
13491:       return
13492:     end if
13493: 
13494:     call <a href="./eispack.f90.html#trbak3" TARGET=CENT_PANEL>trbak3</a> ( n, nv, a, n, z )
13495: 
13496:   end if
13497: 
13498:   return
13499: end
<p><a name=rspp><H3>rspp</H3></a></p> Click <a href="./callingtree/rspp_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rspp is used.
<hr>
13500: subroutine rspp ( n, nv, a, w, matz, z, ierr, m, type )
13501: 
13502: !*****************************************************************************80
13503: !
13504: !! RSPP computes some eigenvalues/vectors, real symmetric packed matrix.
13505: !
13506: !  Discussion:
13507: !
13508: !    This routine calls the appropriate routines for the following problem:
13509: !
13510: !    Given a symmetric matrix A, which is stored in a packed mode, find
13511: !    the M smallest or largest eigenvalues, and corresponding eigenvectors.
13512: !
13513: !    The routine RSP returns all eigenvalues and eigenvectors.
13514: !
13515: !  Licensing:
13516: !
13517: !    This code is distributed under the GNU LGPL license.
13518: !
13519: !  Modified:
13520: !
13521: !    18 October 2009
13522: !
13523: !  Author:
13524: !
13525: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
13526: !    Klema, Moler.
13527: !    FORTRAN90 version by John Burkardt.
13528: !
13529: !  Reference:
13530: !
13531: !    James Wilkinson, Christian Reinsch,
13532: !    Handbook for Automatic Computation,
13533: !    Volume II, Linear Algebra, Part 2,
13534: !    Springer, 1971,
13535: !    ISBN: 0387054146,
13536: !    LC: QA251.W67.
13537: !
13538: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
13539: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
13540: !    Matrix Eigensystem Routines, EISPACK Guide,
13541: !    Lecture Notes in Computer Science, Volume 6,
13542: !    Springer Verlag, 1976,
13543: !    ISBN13: 978-3540075462,
13544: !    LC: QA193.M37.
13545: !
13546: !  Parameters:
13547: !
13548: !    Input, integer ( kind = 4 ) N, the order of A, the number of rows and 
13549: !    columns in the original matrix.
13550: !
13551: !    Input, integer ( kind = 4 ) NV, is the of the array A as specified in the 
13552: !    calling program.  NV must not be less than N*(N+1)/2.
13553: !
13554: !    Input, real ( kind = 8 ) A((N*(N+1))/2), on input the lower triangle of the
13555: !    real symmetric matrix, stored row-wise in the vector,
13556: !    in the order A(1,1), / A(2,1), A(2,2), / A(3,1), A(3,2), A(3,3)/
13557: !    and so on.
13558: !
13559: !    Output, real ( kind = 8 ) W(M), the eigenvalues requested.
13560: !
13561: !    Input, integer ( kind = 4 ) MATZ, is set to 0 if only eigenvalues are 
13562: !    desired.  Otherwise it is set to any non-zero integer for both eigenvalues 
13563: !    and eigenvectors.
13564: !
13565: !    Output, real ( kind = 8 ) Z(N,M), the eigenvectors.
13566: !
13567: !    Output, integer ( kind = 4 ) IERR, error flag from RATQR.  IERR=0 on 
13568: !    normal return.  IERR nonzero, in this case, means that the algorithm broke
13569: !    down while computing an eigenvalue.
13570: !
13571: !    Input, integer ( kind = 4 ) M, the number of eigenvalues to be found.
13572: !
13573: !    Input, logical TYPE, set to .true. if the smallest eigenvalues
13574: !    are to be found, or .false. if the largest ones are sought.
13575: !
13576:   implicit none
13577: 
13578:   integer ( kind = 4 ) m
13579:   integer ( kind = 4 ) n
13580:   integer ( kind = 4 ) nv
13581: 
13582:   real    ( kind = 8 ) a(nv)
13583:   real    ( kind = 8 ) bd(n)
13584:   real    ( kind = 8 ) eps1
13585:   integer ( kind = 4 ) idef
13586:   integer ( kind = 4 ) ierr
13587:   integer ( kind = 4 ) iwork(n)
13588:   integer ( kind = 4 ) matz
13589:   logical              type
13590:   real    ( kind = 8 ) w(m)
13591:   real    ( kind = 8 ) work1(n)
13592:   real    ( kind = 8 ) work2(n)
13593:   real    ( kind = 8 ) work3(n)
13594:   real    ( kind = 8 ) z(n,m)
13595: !
13596: !  IDEF =
13597: !    -1 if the matrix is known to be negative definite, 
13598: !    +1 if the matrix is known to be positive definite, or
13599: !    0 otherwise.
13600: !
13601:   idef = 0
13602: !
13603: !  Reduce to symmetric tridiagonal form.
13604: !
13605:   call <a href="./eispack.f90.html#tred3" TARGET=CENT_PANEL>tred3</a> ( n, nv, a, work1, work2, work3 )
13606: !
13607: !  Find the eigenvalues.
13608: !
13609:   eps1 = 0.0D+00
13610: 
13611:   call <a href="./eispack.f90.html#ratqr" TARGET=CENT_PANEL>ratqr</a> ( n, eps1, work1, work2, work3, m, w, iwork, &
13612:     bd, type, idef, ierr )
13613: 
13614:   if ( ierr /= 0 ) then
13615:     write ( *, '(a)' ) ' '
13616:     write ( *, '(a)' ) 'RSPP - Fatal error!'
13617:     write ( *, '(a)' ) '  Error return from RATQR.'
13618:     return
13619:   end if
13620: !
13621: !  Find eigenvectors for the first M eigenvalues.
13622: !
13623:   if ( matz /= 0 ) then
13624: 
13625:     call <a href="./eispack.f90.html#tinvit" TARGET=CENT_PANEL>tinvit</a> ( n, work1, work2, work3, m, w, iwork, z, ierr )
13626: 
13627:     if ( ierr /= 0 ) then
13628:       write ( *, '(a)' ) ' '
13629:       write ( *, '(a)' ) 'RSPP - Fatal error!'
13630:       write ( *, '(a)' ) '  Error return from TINVIT.'
13631:       return
13632:     end if
13633: !
13634: !  Reverse the transformation.
13635: !
13636:     call <a href="./eispack.f90.html#trbak3" TARGET=CENT_PANEL>trbak3</a> ( n, nv, a, m, z )
13637: 
13638:   end if
13639: 
13640:   return
13641: end
<p><a name=rst><H3>rst</H3></a></p> Click <a href="./callingtree/rst_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rst is used.
<hr>
13642: subroutine rst ( n, w, e, matz, z, ierr )
13643: 
13644: !*****************************************************************************80
13645: !
13646: !! RST computes eigenvalues/vectors, real symmetric tridiagonal matrix.
13647: !
13648: !  Discussion:
13649: !
13650: !    This subroutine calls the recommended sequence of subroutines 
13651: !    to find the eigenvalues and eigenvectors (if desired)
13652: !    of a real symmetric tridiagonal matrix.
13653: !
13654: !  Licensing:
13655: !
13656: !    This code is distributed under the GNU LGPL license.
13657: !
13658: !  Modified:
13659: !
13660: !    18 October 2009
13661: !
13662: !  Author:
13663: !
13664: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
13665: !    Klema, Moler.
13666: !    FORTRAN90 version by John Burkardt.
13667: !
13668: !  Reference:
13669: !
13670: !    James Wilkinson, Christian Reinsch,
13671: !    Handbook for Automatic Computation,
13672: !    Volume II, Linear Algebra, Part 2,
13673: !    Springer, 1971,
13674: !    ISBN: 0387054146,
13675: !    LC: QA251.W67.
13676: !
13677: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
13678: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
13679: !    Matrix Eigensystem Routines, EISPACK Guide,
13680: !    Lecture Notes in Computer Science, Volume 6,
13681: !    Springer Verlag, 1976,
13682: !    ISBN13: 978-3540075462,
13683: !    LC: QA193.M37.
13684: !
13685: !  Parameters:
13686: !
13687: !    Input, integer ( kind = 4 ) N, the order of the matrix.
13688: !
13689: !    Input/output, real ( kind = 8 ) W(N).  On input, the diagonal elements 
13690: !    of the real symmetric tridiagonal matrix.  On output, the eigenvalues in 
13691: !    ascending order.
13692: !
13693: !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the matrix in
13694: !    E(2:N).  E(1) is arbitrary.
13695: !
13696: !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, 
13697: !    and nonzero if both eigenvalues and eigenvectors are desired.
13698: !
13699: !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ 
13700: !    is nonzero.
13701: !
13702: !    Output, integer ( kind = 4 ) IERR, is set to an error
13703: !    completion code described in the documentation for IMTQL1 and IMTQL2.  
13704: !    The normal completion code is zero.
13705: !
13706:   implicit none
13707: 
13708:   integer ( kind = 4 ) n
13709: 
13710:   real    ( kind = 8 ) e(n)
13711:   integer ( kind = 4 ) i
13712:   integer ( kind = 4 ) ierr
13713:   integer ( kind = 4 ) matz
13714:   real    ( kind = 8 ) w(n)
13715:   real    ( kind = 8 ) z(n,n)
13716: 
13717:   if ( matz == 0 ) then
13718: 
13719:     call <a href="./eispack.f90.html#imtql1" TARGET=CENT_PANEL>imtql1</a> ( n, w, e, ierr )
13720: 
13721:     if ( ierr /= 0 ) then
13722:       write ( *, '(a)' ) ' '
13723:       write ( *, '(a)' ) 'RST - Fatal error!'
13724:       write ( *, '(a)' ) '  Error return from IMTQL1.'
13725:       return
13726:     end if
13727: 
13728:   else
13729: 
13730:     z(1:n,1:n) = 0.0D+00
13731: 
13732:     do i = 1, n
13733:       z(i,i) = 1.0D+00
13734:     end do
13735: 
13736:     call <a href="./eispack.f90.html#imtql2" TARGET=CENT_PANEL>imtql2</a> ( n, w, e, z, ierr )
13737: 
13738:     if ( ierr /= 0 ) then
13739:       write ( *, '(a)' ) ' '
13740:       write ( *, '(a)' ) 'RST - Fatal error!'
13741:       write ( *, '(a)' ) '  Error return from IMTQL2.'
13742:       return
13743:     end if
13744: 
13745:   end if
13746: 
13747:   return
13748: end
<p><a name=rt><H3>rt</H3></a></p> Click <a href="./callingtree/rt_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where rt is used.
<hr>
13749: subroutine rt ( n, a, w, matz, z, ierr )
13750: 
13751: !*****************************************************************************80
13752: !
13753: !! RT computes eigenvalues/vectors, real sign-symmetric tridiagonal matrix.
13754: !
13755: !  Discussion:
13756: !
13757: !    This subroutine calls the recommended sequence of subroutines 
13758: !    to find the eigenvalues and eigenvectors (if desired)
13759: !    of a special real tridiagonal matrix.
13760: !
13761: !  Licensing:
13762: !
13763: !    This code is distributed under the GNU LGPL license.
13764: !
13765: !  Modified:
13766: !
13767: !    18 October 2009
13768: !
13769: !  Author:
13770: !
13771: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
13772: !    Klema, Moler.
13773: !    FORTRAN90 version by John Burkardt.
13774: !
13775: !  Reference:
13776: !
13777: !    James Wilkinson, Christian Reinsch,
13778: !    Handbook for Automatic Computation,
13779: !    Volume II, Linear Algebra, Part 2,
13780: !    Springer, 1971,
13781: !    ISBN: 0387054146,
13782: !    LC: QA251.W67.
13783: !
13784: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
13785: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
13786: !    Matrix Eigensystem Routines, EISPACK Guide,
13787: !    Lecture Notes in Computer Science, Volume 6,
13788: !    Springer Verlag, 1976,
13789: !    ISBN13: 978-3540075462,
13790: !    LC: QA193.M37.
13791: !
13792: !  Parameters:
13793: !
13794: !    Input, integer ( kind = 4 ) N, the order of the matrix.
13795: !
13796: !    Input, real ( kind = 8 ) A(N,N), contains the special real tridiagonal 
13797: !    matrix in its first three columns.  The subdiagonal elements are stored
13798: !    in the last N-1 positions of the first column, the diagonal elements 
13799: !    in the second column, and the superdiagonal elements in the first N-1 
13800: !    positions of the third column.  Elements A(1,1) and A(N,3) are arbitrary.
13801: !
13802: !    Input, integer ( kind = 4 ) MATZ, is 0 if only eigenvalues are desired, 
13803: !    and nonzero if both eigenvalues and eigenvectors are desired.
13804: !
13805: !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.
13806: !
13807: !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ 
13808: !    is nonzero.
13809: !
13810: !    Output, integer ( kind = 4 ) IERR, is set to an error
13811: !    completion code described in the documentation for IMTQL1 and IMTQL2.  
13812: !    The normal completion code is zero.
13813: !
13814:   implicit none
13815: 
13816:   integer ( kind = 4 ) n
13817: 
13818:   real    ( kind = 8 ) fv1(n)
13819:   integer ( kind = 4 ) ierr
13820:   integer ( kind = 4 ) matz
13821:   real    ( kind = 8 ) a(n,3)
13822:   real    ( kind = 8 ) w(n)
13823:   real    ( kind = 8 ) z(n,n)
13824: 
13825:   if ( matz == 0 ) then
13826: 
13827:     call <a href="./eispack.f90.html#figi" TARGET=CENT_PANEL>figi</a> ( n, a, w, fv1, fv1, ierr )
13828: 
13829:     if ( ierr /= 0 ) then
13830:       write ( *, '(a)' ) ' '
13831:       write ( *, '(a)' ) 'RT - Fatal error!'
13832:       write ( *, '(a)' ) '  Error return from FIGI.'
13833:       return
13834:     end if
13835: 
13836:     call <a href="./eispack.f90.html#imtql1" TARGET=CENT_PANEL>imtql1</a> ( n, w, fv1, ierr )
13837: 
13838:     if ( ierr /= 0 ) then
13839:       write ( *, '(a)' ) ' '
13840:       write ( *, '(a)' ) 'RT - Fatal error!'
13841:       write ( *, '(a)' ) '  Error return from IMTQL1.'
13842:       return
13843:     end if
13844: 
13845:   else
13846: 
13847:     call <a href="./eispack.f90.html#figi2" TARGET=CENT_PANEL>figi2</a> ( n, a, w, fv1, z, ierr )
13848: 
13849:     if ( ierr /= 0 ) then
13850:       write ( *, '(a)' ) ' '
13851:       write ( *, '(a)' ) 'RT - Fatal error!'
13852:       write ( *, '(a)' ) '  Error return from FIGI2.'
13853:       return
13854:     end if
13855: 
13856:     call <a href="./eispack.f90.html#imtql2" TARGET=CENT_PANEL>imtql2</a> ( n, w, fv1, z, ierr )
13857: 
13858:     if ( ierr /= 0 ) then
13859:       write ( *, '(a)' ) ' '
13860:       write ( *, '(a)' ) 'RT - Fatal error!'
13861:       write ( *, '(a)' ) '  Error return from IMTQL2.'
13862:       return
13863:     end if
13864: 
13865:   end if
13866: 
13867:   return
13868: end
<p><a name=svd><H3>svd</H3></a></p> Click <a href="./callingtree/svd_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where svd is used.
<hr>
13869: subroutine svd ( m, n, a, w, matu, u, matv, v, ierr )
13870: 
13871: !*****************************************************************************80
13872: !
13873: !! SVD computes the singular value decomposition for a real matrix.
13874: !
13875: !  Discussion:
13876: !
13877: !    This subroutine determines the singular value decomposition
13878: !
13879: !      A = U * S * V' 
13880: !
13881: !    of a real M by N rectangular matrix.  Householder bidiagonalization 
13882: !    and a variant of the QR algorithm are used.
13883: !
13884: !  Licensing:
13885: !
13886: !    This code is distributed under the GNU LGPL license.
13887: !
13888: !  Modified:
13889: !
13890: !    18 October 2009
13891: !
13892: !  Author:
13893: !
13894: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
13895: !    Klema, Moler.
13896: !    FORTRAN90 version by John Burkardt.
13897: !
13898: !  Reference:
13899: !
13900: !    Golub and Reinsch,
13901: !    Numerische Mathematik,
13902: !    Volume 14, 1970, pages 403-420.
13903: !
13904: !    James Wilkinson, Christian Reinsch,
13905: !    Handbook for Automatic Computation,
13906: !    Volume II, Linear Algebra, Part 2,
13907: !    Springer, 1971,
13908: !    ISBN: 0387054146,
13909: !    LC: QA251.W67.
13910: !
13911: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
13912: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
13913: !    Matrix Eigensystem Routines, EISPACK Guide,
13914: !    Lecture Notes in Computer Science, Volume 6,
13915: !    Springer Verlag, 1976,
13916: !    ISBN13: 978-3540075462,
13917: !    LC: QA193.M37.
13918: !
13919: !  Parameters:
13920: !
13921: !    Input, integer ( kind = 4 ) M, the number of rows of A and U.
13922: !
13923: !    Input, integer ( kind = 4 ) N, the number of columns of A and U, and 
13924: !    the order of V.
13925: !
13926: !    Input, real ( kind = 8 ) A(M,N), the M by N matrix to be decomposed.
13927: !
13928: !    Output, real ( kind = 8 ) W(N), the singular values of A.  These are the
13929: !    diagonal elements of S.  They are unordered.  If an error exit is 
13930: !    made, the singular values should be correct for indices 
13931: !    IERR+1, IERR+2,..., N.
13932: !
13933: !    Input, logical MATU, should be set to TRUE if the U matrix in the
13934: !    decomposition is desired, and to FALSE otherwise.
13935: !
13936: !    Output, real ( kind = 8 ) U(M,N), contains the matrix U, with orthogonal 
13937: !    columns, of the decomposition, if MATU has been set to TRUE.  Otherwise
13938: !    U is used as a temporary array.  U may coincide with A.
13939: !    If an error exit is made, the columns of U corresponding
13940: !    to indices of correct singular values should be correct.
13941: !
13942: !    Input, logical MATV, should be set to TRUE if the V matrix in the
13943: !    decomposition is desired, and to FALSE otherwise.
13944: !
13945: !    Output, real ( kind = 8 ) V(N,N), the orthogonal matrix V of the decomposition if
13946: !    MATV has been set to TRUE.  Otherwise V is not referenced.
13947: !    V may also coincide with A if U is not needed.  If an error
13948: !    exit is made, the columns of V corresponding to indices of
13949: !    correct singular values should be correct.
13950: !
13951: !    Output, integer ( kind = 4 ) IERR, error flag.
13952: !    0, for normal return,
13953: !    K, if the K-th singular value has not been determined after 30 iterations.
13954: !
13955:   implicit none
13956: 
13957:   integer ( kind = 4 ) m
13958:   integer ( kind = 4 ) n
13959: 
13960:   real    ( kind = 8 ) a(m,n)
13961:   real    ( kind = 8 ) c
13962:   real    ( kind = 8 ) f
13963:   real    ( kind = 8 ) g
13964:   real    ( kind = 8 ) h
13965:   integer ( kind = 4 ) i
13966:   integer ( kind = 4 ) ierr
13967:   integer ( kind = 4 ) its
13968:   integer ( kind = 4 ) i1
13969:   integer ( kind = 4 ) j
13970:   integer ( kind = 4 ) k
13971:   integer ( kind = 4 ) kk
13972:   integer ( kind = 4 ) k1
13973:   integer ( kind = 4 ) l
13974:   integer ( kind = 4 ) ll
13975:   integer ( kind = 4 ) l1
13976:   logical              matu
13977:   logical              matv
13978:   integer ( kind = 4 ) mn
13979:   real    ( kind = 8 ) pythag
13980:   real    ( kind = 8 ) rv1(n)
13981:   real    ( kind = 8 ) s
13982:   real    ( kind = 8 ) xscale
13983:   real    ( kind = 8 ) tst1
13984:   real    ( kind = 8 ) tst2
13985:   real    ( kind = 8 ) u(m,n)
13986:   real    ( kind = 8 ) v(n,n)
13987:   real    ( kind = 8 ) w(n)
13988:   real    ( kind = 8 ) x
13989:   real    ( kind = 8 ) y
13990:   real    ( kind = 8 ) z
13991: 
13992:   ierr = 0
13993:   u(1:m,1:n) = a(1:m,1:n)
13994: !
13995: !  Householder reduction to bidiagonal form.
13996: !
13997:   g = 0.0D+00
13998:   xscale = 0.0D+00
13999:   x = 0.0D+00
14000: 
14001:   do i = 1, n
14002: 
14003:     l = i + 1
14004:     rv1(i) = xscale * g
14005:     g = 0.0D+00
14006:     s = 0.0D+00
14007:     xscale = 0.0D+00
14008: 
14009:     if ( i <= m ) then
14010: 
14011:       xscale = sum ( abs ( u(i:m,i) ) )
14012: 
14013:       if ( xscale /= 0.0D+00 ) then
14014: 
14015:         u(i:m,i) = u(i:m,i) / xscale
14016: 
14017:         s = sum ( u(i:m,i)**2 )
14018: 
14019:         f = u(i,i)
14020:         g = - sign ( sqrt ( s ), f )
14021:         h = f * g - s
14022:         u(i,i) = f - g
14023: 
14024:         if ( i /= n ) then
14025: 
14026:           do j = l, n
14027:             s = dot_product ( u(i:m,i), u(i:m,j) )
14028:             u(i:m,j) = u(i:m,j) + s * u(i:m,i) / h
14029:           end do
14030: 
14031:         end if
14032: 
14033:         u(i:m,i) = xscale * u(i:m,i)
14034: 
14035:       end if
14036: 
14037:     end if
14038: 
14039:     w(i) = xscale * g
14040:     g = 0.0D+00
14041:     s = 0.0D+00
14042:     xscale = 0.0D+00
14043: 
14044:     if ( i <= m .and. i /= n ) then
14045: 
14046:       xscale = sum ( abs ( u(i,l:n) ) )
14047: 
14048:       if ( xscale /= 0.0D+00 ) then
14049: 
14050:         u(i,l:n) = u(i,l:n) / xscale
14051:         s = sum ( u(i,l:n)**2 )
14052:         f = u(i,l)
14053:         g = - sign ( sqrt ( s ), f )
14054:         h = f * g - s
14055:         u(i,l) = f - g
14056:         rv1(l:n) = u(i,l:n) / h
14057: 
14058:         if ( i /= m ) then
14059: 
14060:           do j = l, m
14061: 
14062:             s = dot_product ( u(j,l:n), u(i,l:n) )
14063: 
14064:             u(j,l:n) = u(j,l:n) + s * rv1(l:n)
14065: 
14066:           end do
14067: 
14068:         end if
14069: 
14070:         u(i,l:n) = xscale * u(i,l:n)
14071: 
14072:       end if
14073: 
14074:     end if
14075: 
14076:     x = max ( x, abs ( w(i) ) + abs ( rv1(i) ) )
14077: 
14078:   end do
14079: !
14080: !  Accumulation of right-hand transformations.
14081: !
14082:   if ( matv ) then
14083: 
14084:     do i = n, 1, -1
14085: 
14086:       if ( i /= n ) then
14087: 
14088:          if ( g /= 0.0D+00 ) then
14089: 
14090:           v(l:n,i) = ( u(i,l:n) / u(i,l) ) / g
14091: 
14092:           do j = l, n
14093: 
14094:             s = dot_product ( u(i,l:n), v(l:n,j) )
14095: 
14096:             v(l:n,j) = v(l:n,j) + s * v(l:n,i)
14097: 
14098:           end do
14099: 
14100:         end if
14101: 
14102:         v(i,l:n) = 0.0D+00
14103:         v(l:n,i) = 0.0D+00
14104: 
14105:       end if
14106: 
14107:       v(i,i) = 1.0D+00
14108:       g = rv1(i)
14109:       l = i
14110: 
14111:     end do
14112: 
14113:   end if
14114: !
14115: !  Accumulation of left-hand transformations.
14116: !
14117:   if ( matu ) then
14118: 
14119:     mn = min ( m, n )
14120: 
14121:     do i = min ( m, n ), 1, -1
14122: 
14123:       l = i + 1
14124:       g = w(i)
14125: 
14126:       if ( i /= n ) then
14127:         u(i,l:n) = 0.0D+00
14128:       end if
14129: 
14130:       if ( g /= 0.0D+00 ) then
14131: 
14132:         if ( i /= mn ) then
14133: 
14134:           do j = l, n
14135:             s = dot_product ( u(l:m,i), u(l:m,j) )
14136:             f = ( s / u(i,i) ) / g
14137:             u(i:m,j) = u(i:m,j) + f * u(i:m,i)
14138:           end do
14139: 
14140:         end if
14141: 
14142:         u(i:m,i) = u(i:m,i) / g
14143: 
14144:       else
14145: 
14146:         u(i:m,i) = 0.0D+00
14147: 
14148:       end if
14149: 
14150:       u(i,i) = u(i,i) + 1.0D+00
14151: 
14152:     end do
14153: 
14154:   end if
14155: !
14156: !  Diagonalization of the bidiagonal form.
14157: !
14158:   tst1 = x
14159: 
14160:   do kk = 1, n
14161: 
14162:      k1 = n - kk
14163:      k = k1 + 1
14164:      its = 0
14165: !
14166: !  Test for splitting.
14167: !
14168: 520  continue
14169: 
14170:      do ll = 1, k
14171: 
14172:        l1 = k - ll
14173:        l = l1 + 1
14174:        tst2 = tst1 + abs ( rv1(l) )
14175: 
14176:        if ( tst2 == tst1 ) then
14177:          go to 565
14178:        end if
14179: 
14180:        tst2 = tst1 + abs ( w(l1) )
14181: 
14182:        if ( tst2 == tst1 ) then
14183:          exit
14184:        end if
14185: 
14186:      end do
14187: !
14188: !  Cancellation of rv1(l) if L greater than 1.
14189: !
14190:      c = 0.0D+00
14191:      s = 1.0D+00
14192: 
14193:      do i = l, k
14194: 
14195:        f = s * rv1(i)
14196:        rv1(i) = c * rv1(i)
14197:        tst2 = tst1 + abs ( f )
14198: 
14199:        if ( tst2 == tst1 ) then
14200:          go to 565
14201:        end if
14202: 
14203:        g = w(i)
14204:        h = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, g )
14205:        w(i) = h
14206:        c = g / h
14207:        s = -f / h
14208: 
14209:        if ( matu ) then
14210: 
14211:          do j = 1, m
14212:            y = u(j,l1)
14213:            z = u(j,i)
14214:            u(j,l1) = y * c + z * s
14215:            u(j,i) = -y * s + z * c
14216:          end do
14217: 
14218:        end if
14219: 
14220:     end do
14221: !
14222: !  Test for convergence.
14223: !
14224: 565 continue
14225:  
14226:     z = w(k)
14227: 
14228:     if ( l == k ) go to 650
14229: !
14230: !  Shift from bottom 2 by 2 minor.
14231: !
14232:     if ( its >= 30 ) then
14233:       ierr = k
14234:       return
14235:     end if
14236: 
14237:     its = its + 1
14238:     x = w(l)
14239:     y = w(k1)
14240:     g = rv1(k1)
14241:     h = rv1(k)
14242:     f = 0.5D+00 * ( ( ( g + z ) / h ) * ( ( g - z ) / y ) + y / h - h / y )
14243:     g = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, 1.0D+00 )
14244:     f = x - ( z / x ) * z + ( h / x ) * ( y / ( f + sign ( g, f ) ) - h)
14245: !
14246: !  Next QR transformation.
14247: !
14248:     c = 1.0D+00
14249:     s = 1.0D+00
14250: 
14251:     do i1 = l, k1
14252: 
14253:       i = i1 + 1
14254:       g = rv1(i)
14255:       y = w(i)
14256:       h = s * g
14257:       g = c * g
14258:       z = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, h )
14259:       rv1(i1) = z
14260:       c = f / z
14261:       s = h / z
14262:       f = x * c + g * s
14263:       g = -x * s + g * c
14264:       h = y * s
14265:       y = y * c
14266: 
14267:       if ( matv ) then
14268: 
14269:         do j = 1, n
14270:           x = v(j,i1)
14271:           z = v(j,i)
14272:           v(j,i1) = x * c + z * s
14273:           v(j,i) = -x * s + z * c
14274:         end do
14275: 
14276:       end if
14277: 
14278:       z = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( f, h )
14279:       w(i1) = z
14280: !
14281: !  Rotation can be arbitrary if Z is zero.
14282: !
14283:       if ( z /= 0.0D+00 ) then
14284:         c = f / z
14285:         s = h / z
14286:       end if
14287: 
14288:       f = c * g + s * y
14289:       x = -s * g + c * y
14290: 
14291:       if ( matu ) then
14292: 
14293:         do j = 1, m
14294:           y = u(j,i1)
14295:           z = u(j,i)
14296:           u(j,i1) = y * c + z * s
14297:           u(j,i) = -y * s + z * c
14298:         end do
14299: 
14300:       end if
14301: 
14302:     end do
14303: 
14304:     rv1(l) = 0.0D+00
14305:     rv1(k) = f
14306:     w(k) = x
14307:     go to 520
14308: !
14309: !  Convergence.
14310: !
14311: 650 continue
14312: 
14313:     if ( z <= 0.0D+00 ) then
14314: 
14315:       w(k) = - z
14316: 
14317:       if ( matv ) then
14318:         v(1:n,k) = - v(1:n,k)
14319:       end if
14320: 
14321:     end if
14322: 
14323:   end do
14324: 
14325:   return
14326: end
<p><a name=timestamp><H3>timestamp</H3></a></p> Click <a href="./callingtree/timestamp_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where timestamp is used.
<hr>
14327: subroutine timestamp ( )
14328: 
14329: !*****************************************************************************80
14330: !
14331: !! TIMESTAMP prints the current YMDHMS date as a time stamp.
14332: !
14333: !  Example:
14334: !
14335: !    May 31 2001   9:45:54.872 AM
14336: !
14337: !  Licensing:
14338: !
14339: !    This code is distributed under the GNU LGPL license.
14340: !
14341: !  Modified:
14342: !
14343: !    04 February 2003
14344: !
14345: !  Author:
14346: !
14347: !    John Burkardt
14348: !
14349: !  Parameters:
14350: !
14351: !    None
14352: !
14353:   implicit none
14354: 
14355:   character ( len = 8 )  ampm
14356:   integer   ( kind = 4 ) d
14357:   character ( len = 8 )  date
14358:   integer   ( kind = 4 ) h
14359:   integer   ( kind = 4 ) m
14360:   integer   ( kind = 4 ) mm
14361:   character ( len = 9 ), parameter, dimension(12) :: month = (/ &
14362:     'January  ', 'February ', 'March    ', 'April    ', &
14363:     'May      ', 'June     ', 'July     ', 'August   ', &
14364:     'September', 'October  ', 'November ', 'December ' /)
14365:   integer   ( kind = 4 ) n
14366:   integer   ( kind = 4 ) s
14367:   character ( len = 10 ) time
14368:   integer   ( kind = 4 ) values(8)
14369:   integer   ( kind = 4 ) y
14370:   character ( len = 5 )  zone
14371: 
14372:   call <a href="#" TARGET=CENT_PANEL>date_and_time</a> ( date, time, zone, values )
14373: 
14374:   y = values(1)
14375:   m = values(2)
14376:   d = values(3)
14377:   h = values(5)
14378:   n = values(6)
14379:   s = values(7)
14380:   mm = values(8)
14381: 
14382:   if ( h < 12 ) then
14383:     ampm = 'AM'
14384:   else if ( h == 12 ) then
14385:     if ( n == 0 .and. s == 0 ) then
14386:       ampm = 'Noon'
14387:     else
14388:       ampm = 'PM'
14389:     end if
14390:   else
14391:     h = h - 12
14392:     if ( h < 12 ) then
14393:       ampm = 'PM'
14394:     else if ( h == 12 ) then
14395:       if ( n == 0 .and. s == 0 ) then
14396:         ampm = 'Midnight'
14397:       else
14398:         ampm = 'AM'
14399:       end if
14400:     end if
14401:   end if
14402: 
14403:   write ( *, '(a,1x,i2,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) &
14404:     trim ( month(m) ), d, y, h, ':', n, ':', s, '.', mm, trim ( ampm )
14405: 
14406:   return
14407: end
<p><a name=tinvit><H3>tinvit</H3></a></p> Click <a href="./callingtree/tinvit_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tinvit is used.
<hr>
14408: subroutine tinvit ( n, d, e, e2, m, w, ind, z, ierr )
14409: 
14410: !*****************************************************************************80
14411: !
14412: !! TINVIT computes eigenvectors from eigenvalues, real tridiagonal symmetric.
14413: !
14414: !  Discussion:
14415: !
14416: !    This subroutine finds those eigenvectors of a tridiagonal
14417: !    symmetric matrix corresponding to specified eigenvalues,
14418: !    using inverse iteration.
14419: !
14420: !  Licensing:
14421: !
14422: !    This code is distributed under the GNU LGPL license.
14423: !
14424: !  Modified:
14425: !
14426: !    18 October 2009
14427: !
14428: !  Author:
14429: !
14430: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
14431: !    Klema, Moler.
14432: !    FORTRAN90 version by John Burkardt.
14433: !
14434: !  Reference:
14435: !
14436: !    James Wilkinson, Christian Reinsch,
14437: !    Handbook for Automatic Computation,
14438: !    Volume II, Linear Algebra, Part 2,
14439: !    Springer, 1971,
14440: !    ISBN: 0387054146,
14441: !    LC: QA251.W67.
14442: !    B Smith, J Boyle, J Dongarra, B Garbow, Y Ikebe, V Klema, C Moler,
14443: !    Matrix Eigensystem Routines, EISPACK Guide,
14444: !    Lecture Notes in Computer Science, Volume 6,
14445: !    Springer Verlag, 1976.
14446: !
14447: !  Parameters:
14448: !
14449: !    Input, integer ( kind = 4 ) N, the order of the matrix.
14450: !
14451: !    Input, real ( kind = 8 ) D(N), the diagonal elements of the matrix.
14452: !
14453: !    Input, real ( kind = 8 ) E(N), contains the subdiagonal elements of the input matrix
14454: !    in E(2:N).  E(1) is arbitrary.
14455: !
14456: !    Input, real ( kind = 8 ) E2(N), contains the squares of the corresponding elements 
14457: !    of E, with zeros corresponding to negligible elements of E.
14458: !    E(I) is considered negligible if it is not larger than the product of 
14459: !    the relative machine precision and the sum of the magnitudes of D(I) 
14460: !    and D(I-1).  E2(1) must contain 0.0D+00 if the eigenvalues are in 
14461: !    ascending order, or 2.0D+00 if the eigenvalues are in descending order.  
14462: !    If BISECT, TRIDIB, or IMTQLV has been used to find the eigenvalues,
14463: !    their output E2 array is exactly what is expected here.
14464: !
14465: !    Input, integer ( kind = 4 ) M, the number of specified eigenvalues.
14466: !
14467: !    Input, real ( kind = 8 ) W(M), the eigenvalues.
14468: !
14469: !    Input, integer ( kind = 4 ) IND(M), the submatrix indices associated with the 
14470: !    corresponding eigenvalues in W: 1 for eigenvalues belonging to the 
14471: !    first submatrix from the top, 2 for those belonging to the second 
14472: !    submatrix, and so on.
14473: !
14474: !    Output, real ( kind = 8 ) Z(N,M), the associated set of orthonormal eigenvectors.
14475: !    Any vector which fails to converge is set to zero.
14476: !
14477: !    Output, integer ( kind = 4 ) IERR, error flag.
14478: !    0, for normal return,
14479: !    -R, if the eigenvector corresponding to the R-th eigenvalue fails to 
14480: !      converge in 5 iterations.
14481: !
14482:   implicit none
14483: 
14484:   integer ( kind = 4 ) m
14485:   integer ( kind = 4 ) n
14486: 
14487:   real    ( kind = 8 ) d(n)
14488:   real    ( kind = 8 ) e(n)
14489:   real    ( kind = 8 ) e2(n)
14490:   real    ( kind = 8 ) eps2
14491:   real    ( kind = 8 ) eps3
14492:   real    ( kind = 8 ) eps4
14493:   integer ( kind = 4 ) group
14494:   integer ( kind = 4 ) i
14495:   integer ( kind = 4 ) ierr
14496:   integer ( kind = 4 ) ii
14497:   integer ( kind = 4 ) ind(m)
14498:   integer ( kind = 4 ) ip
14499:   integer ( kind = 4 ) its
14500:   integer ( kind = 4 ) j
14501:   integer ( kind = 4 ) jj
14502:   real    ( kind = 8 ) norm
14503:   real    ( kind = 8 ) order
14504:   integer ( kind = 4 ) p
14505:   real    ( kind = 8 ) pythag
14506:   integer ( kind = 4 ) q
14507:   integer ( kind = 4 ) r
14508:   real    ( kind = 8 ) rv1(n)
14509:   real    ( kind = 8 ) rv2(n)
14510:   real    ( kind = 8 ) rv3(n)
14511:   real    ( kind = 8 ) rv4(n)
14512:   real    ( kind = 8 ) rv6(n)
14513:   integer ( kind = 4 ) s
14514:   integer ( kind = 4 ) tag
14515:   real    ( kind = 8 ) u
14516:   real    ( kind = 8 ) uk
14517:   real    ( kind = 8 ) v
14518:   real    ( kind = 8 ) w(m)
14519:   real    ( kind = 8 ) x0
14520:   real    ( kind = 8 ) x1
14521:   real    ( kind = 8 ) xu
14522:   real    ( kind = 8 ) z(n,m)
14523: 
14524:   ierr = 0
14525: 
14526:   if ( m == 0 ) then
14527:     return
14528:   end if
14529: 
14530:   u = 0.0D+00
14531:   x0 = 0.0D+00
14532: 
14533:   tag = 0
14534:   order = 1.0D+00 - e2(1)
14535:   q = 0
14536: !
14537: !  Establish and process next submatrix.
14538: !
14539: 100 continue
14540: 
14541:   p = q + 1
14542: 
14543:   do q = p, n
14544:     if ( q == n ) then
14545:       exit
14546:     end if
14547:     if ( e2(q+1) == 0.0D+00 ) then
14548:       exit
14549:     end if
14550:   end do
14551: !
14552: !  Find vectors by inverse iteration.
14553: !
14554:   tag = tag + 1
14555:   s = 0
14556: 
14557:   do r = 1, m
14558: 
14559:      if ( ind(r) /= tag ) go to 920
14560: 
14561:      its = 1
14562:      x1 = w(r)
14563: 
14564:      if ( s /= 0 ) go to 510
14565: !
14566: !  Check for isolated root.
14567: !
14568:      xu = 1.0D+00
14569: 
14570:      if ( p == q ) then
14571:        rv6(p) = 1.0D+00
14572:        go to 870
14573:      end if
14574: 
14575:      norm = abs ( d(p) )
14576:      ip = p + 1
14577: 
14578:      do i = p+1, q
14579:        norm = max ( norm, abs ( d(i) ) + abs ( e(i) ) )
14580:      end do
14581: !
14582: !  EPS2 is the criterion for grouping,
14583: !  EPS3 replaces zero pivots and equal roots are modified by EPS3,
14584: !  EPS4 is taken very small to avoid overflow.
14585: !
14586:      eps2 = 0.001D+00 * norm
14587:      eps3 = abs ( norm ) * epsilon ( eps3 )
14588:      uk = q - p + 1
14589:      eps4 = uk * eps3
14590:      uk = eps4 / sqrt ( uk )
14591:      s = p
14592: 
14593: 505 continue
14594: 
14595:      group = 0
14596:      go to 520
14597: !
14598: !  Look for close or coincident roots.
14599: !
14600: 510  continue
14601: 
14602:      if ( abs ( x1 - x0 ) >= eps2 ) go to 505
14603: 
14604:      group = group + 1
14605: 
14606:      if ( order * (x1 - x0) <= 0.0D+00 ) then
14607:        x1 = x0 + order * eps3
14608:      end if
14609: !
14610: !  Elimination with interchanges and initialization of vector.
14611: !
14612: 520  continue
14613: 
14614:      v = 0.0D+00
14615: 
14616:      do i = p, q
14617: 
14618:         rv6(i) = uk
14619: 
14620:         if ( i == p ) go to 560
14621: 
14622:         if ( abs ( e(i) ) < abs ( u ) ) go to 540
14623: 
14624:         xu = u / e(i)
14625:         rv4(i) = xu
14626:         rv1(i-1) = e(i)
14627:         rv2(i-1) = d(i) - x1
14628:         rv3(i-1) = 0.0D+00
14629:         if ( i /= q ) rv3(i-1) = e(i+1)
14630:         u = v - xu * rv2(i-1)
14631:         v = - xu * rv3(i-1)
14632:         go to 580
14633: 
14634: 540     continue
14635: 
14636:         xu = e(i) / u
14637:         rv4(i) = xu
14638:         rv1(i-1) = u
14639:         rv2(i-1) = v
14640:         rv3(i-1) = 0.0D+00
14641: 
14642: 560     continue
14643: 
14644:         u = d(i) - x1 - xu * v
14645:         if ( i /= q ) v = e(i+1)
14646: 
14647: 580     continue
14648: 
14649:      end do
14650: 
14651:      if ( u == 0.0D+00 ) then
14652:        u = eps3
14653:      end if
14654: 
14655:      rv1(q) = u
14656:      rv2(q) = 0.0D+00
14657:      rv3(q) = 0.0D+00
14658: !
14659: !  Back substitution.
14660: !
14661: 600   continue
14662: 
14663:   do ii = p, q
14664:     i = p + q - ii
14665:     rv6(i) = ( rv6(i) - u * rv2(i) - v * rv3(i) ) / rv1(i)
14666:     v = u
14667:     u = rv6(i)
14668:   end do
14669: !
14670: !  Orthogonalize with respect to previous members of group.
14671: !
14672:      j = r
14673: 
14674:      do jj = 1, group
14675: 
14676:        do
14677: 
14678:          j = j - 1
14679: 
14680:          if ( ind(j) == tag ) then
14681:            exit
14682:          end if
14683: 
14684:        end do
14685: 
14686:        xu = dot_product ( rv6(p:q), z(p:q,j) )
14687: 
14688:        rv6(p:q) = rv6(p:q) - xu * z(p:q,j)
14689: 
14690:      end do
14691: 
14692:      norm = sum ( abs ( rv6(p:q) ) )
14693: 
14694:      if ( norm >= 1.0D+00 ) go to 840
14695: !
14696: !  Forward substitution.
14697: !
14698:      if ( its == 5 ) go to 830
14699: 
14700:      if ( norm == 0.0D+00 ) then
14701:        rv6(s) = eps4
14702:        s = s + 1
14703:        if ( s > q ) s = p
14704:        go to 780
14705:      end if
14706: 
14707:      xu = eps4 / norm
14708:      rv6(p:q) = rv6(p:q) * xu
14709: !
14710: !  Elimination operations on next vector iterate.
14711: !
14712: 780  continue
14713: !
14714: !  If RV1(I-1) == E(I), a row interchange was performed earlier in the
14715: !  triangularization process.
14716: !
14717:      do i = ip, q
14718: 
14719:        u = rv6(i)
14720: 
14721:        if ( rv1(i-1) == e(i) ) then
14722:          u = rv6(i-1)
14723:          rv6(i-1) = rv6(i)
14724:        end if
14725: 
14726:        rv6(i) = u - rv4(i) * rv6(i-1)
14727: 
14728:      end do
14729: 
14730:      its = its + 1
14731:      go to 600
14732: !
14733: !  Set error: non-converged eigenvector.
14734: !
14735: 830  continue
14736: 
14737:      ierr = -r
14738:      xu = 0.0D+00
14739:      go to 870
14740: !
14741: !  Normalize so that sum of squares is 1 and expand to full order.
14742: !
14743: 840  continue
14744: 
14745:      u = 0.0D+00
14746:      do i = p, q
14747:        u = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( u, rv6(i) )
14748:      end do
14749: 
14750:      xu = 1.0D+00 / u
14751: 
14752: 870  continue
14753: 
14754:      z(1:n,r) = 0.0D+00
14755:      z(p:q,r) = rv6(p:q) * xu
14756: 
14757:      x0 = x1
14758: 
14759: 920  continue
14760: 
14761:   end do
14762: 
14763:   if ( q < n ) go to 100
14764: 
14765:   return
14766: end
<p><a name=tql1><H3>tql1</H3></a></p> Click <a href="./callingtree/tql1_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tql1 is used.
<hr>
14767: subroutine tql1 ( n, d, e, ierr )
14768: 
14769: !*****************************************************************************80
14770: !
14771: !! TQL1 computes all eigenvalues of a real symmetric tridiagonal matrix.
14772: !
14773: !  Discussion:
14774: !
14775: !    This subroutine finds the eigenvalues of a symmetric tridiagonal 
14776: !    matrix by the QL method.
14777: !
14778: !  Licensing:
14779: !
14780: !    This code is distributed under the GNU LGPL license.
14781: !
14782: !  Modified:
14783: !
14784: !    18 October 2009
14785: !
14786: !  Author:
14787: !
14788: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
14789: !    Klema, Moler.
14790: !    FORTRAN90 version by John Burkardt.
14791: !
14792: !  References:
14793: !
14794: !    Bowdler, Martin, Reinsch, Wilkinson,
14795: !    Numerische Mathematik,
14796: !    Volume 11, 1968, pages 293-306.
14797: !
14798: !    James Wilkinson, Christian Reinsch,
14799: !    Handbook for Automatic Computation,
14800: !    Volume II, Linear Algebra, Part 2,
14801: !    Springer, 1971,
14802: !    ISBN: 0387054146,
14803: !    LC: QA251.W67.
14804: !
14805: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
14806: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
14807: !    Matrix Eigensystem Routines, EISPACK Guide,
14808: !    Lecture Notes in Computer Science, Volume 6,
14809: !    Springer Verlag, 1976,
14810: !    ISBN13: 978-3540075462,
14811: !    LC: QA193.M37.
14812: !
14813: !  Parameters:
14814: !
14815: !    Input, integer ( kind = 4 ) N, is the order of the matrix.
14816: !
14817: !    Input/output, real ( kind = 8 ) D(N).
14818: !    On input, the diagonal elements of the matrix.
14819: !    On output, the eigenvalues in ascending order.
14820: !    If an error exit is made, the eigenvalues are correct and
14821: !    ordered for indices 1, 2,... IERR-1, but may not be
14822: !    the smallest eigenvalues.
14823: !
14824: !    Input/output, real ( kind = 8 ) E(N).  On input, E(2:N) contains the subdiagonal 
14825: !    elements of the input matrix, and E(1) is arbitrary.
14826: !    On output, E has been destroyed.
14827: !
14828: !    Output, integer ( kind = 4 ) IERR, error flag.
14829: !    0, normal return,
14830: !    J, if the J-th eigenvalue has not been determined after 
14831: !    30 iterations.
14832: !
14833:   implicit none
14834: 
14835:   integer ( kind = 4 ) n
14836: 
14837:   real    ( kind = 8 ) c
14838:   real    ( kind = 8 ) c2
14839:   real    ( kind = 8 ) c3
14840:   real    ( kind = 8 ) d(n)
14841:   real    ( kind = 8 ) dl1
14842:   real    ( kind = 8 ) e(n)
14843:   real    ( kind = 8 ) el1
14844:   real    ( kind = 8 ) f
14845:   real    ( kind = 8 ) g
14846:   real    ( kind = 8 ) h
14847:   integer ( kind = 4 ) i
14848:   integer ( kind = 4 ) ierr
14849:   integer ( kind = 4 ) ii
14850:   integer ( kind = 4 ) j
14851:   integer ( kind = 4 ) l
14852:   integer ( kind = 4 ) l1
14853:   integer ( kind = 4 ) l2
14854:   integer ( kind = 4 ) m
14855:   integer ( kind = 4 ) mml
14856:   real    ( kind = 8 ) p
14857:   real    ( kind = 8 ) pythag
14858:   real    ( kind = 8 ) r
14859:   real    ( kind = 8 ) s
14860:   real    ( kind = 8 ) s2
14861:   real    ( kind = 8 ) tst1
14862:   real    ( kind = 8 ) tst2
14863: 
14864:   ierr = 0
14865:   if ( n == 1 ) then
14866:     return
14867:   end if
14868: 
14869:   do i = 2, n
14870:     e(i-1) = e(i)
14871:   end do
14872: 
14873:   f = 0.0D+00
14874:   tst1 = 0.0D+00
14875:   e(n) = 0.0D+00
14876: 
14877:   do l = 1, n
14878: 
14879:     j = 0
14880:     h = abs ( d(l) ) + abs ( e(l) )
14881:     tst1 = max ( tst1, h )
14882: !
14883: !  Look for a small sub-diagonal element.
14884: !
14885:     do m = l, n
14886: 
14887:       tst2 = tst1 + abs ( e(m) )
14888: 
14889:       if ( tst2 == tst1 ) then
14890:         exit
14891:       end if
14892: 
14893:     end do
14894: 
14895:     if ( m == l ) go to 210
14896: 
14897: 130 continue
14898: 
14899:     if ( j >= 30 ) then
14900:       ierr = l
14901:       return
14902:     end if
14903: 
14904:     j = j + 1
14905: !
14906: !  Form the shift.
14907: !
14908:     l1 = l + 1
14909:     l2 = l1 + 1
14910:     g = d(l)
14911:     p = ( d(l1) - g ) / ( 2.0D+00 * e(l) )
14912:     r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( p, 1.0D+00 )
14913:     d(l) = e(l) / ( p + sign ( r, p ) )
14914:     d(l1) = e(l) * ( p + sign ( r, p ) )
14915:     dl1 = d(l1)
14916:     h = g - d(l)
14917: 
14918:     d(l2:n) = d(l2:n) - h
14919: 
14920:     f = f + h
14921: !
14922: !  QL transformation.
14923: !
14924:     p = d(m)
14925:     c = 1.0D+00
14926:     c2 = c
14927:     el1 = e(l1)
14928:     s = 0.0D+00
14929:     mml = m - l
14930: 
14931:     do ii = 1, mml
14932:       c3 = c2
14933:       c2 = c
14934:       s2 = s
14935:       i = m - ii
14936:       g = c * e(i)
14937:       h = c * p
14938:       r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( p, e(i) )
14939:       e(i+1) = s * r
14940:       s = e(i) / r
14941:       c = p / r
14942:       p = c * d(i) - s * g
14943:       d(i+1) = h + s * ( c * g + s * d(i) )
14944:     end do
14945: 
14946:     p = - s * s2 * c3 * el1 * e(l) / dl1
14947:     e(l) = s * p
14948:     d(l) = c * p
14949:     tst2 = tst1 + abs ( e(l) )
14950:     if ( tst2 > tst1 ) go to 130
14951: 
14952: 210 continue
14953: 
14954:     p = d(l) + f
14955: !
14956: !  Order the eigenvalues.
14957: !
14958:     do ii = 2, l
14959:       i = l + 2 - ii
14960:       if ( p >= d(i-1) ) then
14961:         go to 270
14962:       end if
14963:       d(i) = d(i-1)
14964:     end do
14965: 
14966:     i = 1
14967: 
14968: 270 continue
14969: 
14970:     d(i) = p
14971: 
14972:   end do
14973: 
14974:   return
14975: end
<p><a name=tql2><H3>tql2</H3></a></p> Click <a href="./callingtree/tql2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tql2 is used.
<hr>
14976: subroutine tql2 ( n, d, e, z, ierr )
14977: 
14978: !*****************************************************************************80
14979: !
14980: !! TQL2 computes all eigenvalues/vectors, real symmetric tridiagonal matrix.
14981: !
14982: !  Discussion:
14983: !
14984: !    This subroutine finds the eigenvalues and eigenvectors of a symmetric 
14985: !    tridiagonal matrix by the QL method.  The eigenvectors of a full 
14986: !    symmetric matrix can also be found if TRED2 has been used to reduce this
14987: !    full matrix to tridiagonal form.
14988: !
14989: !  Licensing:
14990: !
14991: !    This code is distributed under the GNU LGPL license.
14992: !
14993: !  Modified:
14994: !
14995: !    18 October 2009
14996: !
14997: !  Author:
14998: !
14999: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
15000: !    Klema, Moler.
15001: !    FORTRAN90 version by John Burkardt.
15002: !
15003: !  Reference:
15004: !
15005: !    Bowdler, Martin, Reinsch, Wilkinson,
15006: !    TQL2,
15007: !    Numerische Mathematik,
15008: !    Volume 11, pages 293-306, 1968.
15009: !
15010: !    James Wilkinson, Christian Reinsch,
15011: !    Handbook for Automatic Computation,
15012: !    Volume II, Linear Algebra, Part 2,
15013: !    Springer, 1971,
15014: !    ISBN: 0387054146,
15015: !    LC: QA251.W67.
15016: !
15017: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
15018: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
15019: !    Matrix Eigensystem Routines, EISPACK Guide,
15020: !    Lecture Notes in Computer Science, Volume 6,
15021: !    Springer Verlag, 1976,
15022: !    ISBN13: 978-3540075462,
15023: !    LC: QA193.M37.
15024: !
15025: !  Parameters:
15026: !
15027: !    Input, integer ( kind = 4 ) N, the order of the matrix.
15028: !
15029: !    Input/output, real ( kind = 8 ) D(N).  On input, the diagonal elements of the matrix.
15030: !    On output, the eigenvalues in ascending order.  If an error exit is 
15031: !    made, the eigenvalues are correct but unordered for indices 1,2,...,IERR-1.
15032: !
15033: !    Input/output, real ( kind = 8 ) E(N).  On input, E(2:N) contains the subdiagonal 
15034: !    elements of the input matrix, and E(1) is arbitrary.
15035: !    On output, E has been destroyed.
15036: !
15037: !    Input, real ( kind = 8 ) Z(N,N).  On input, the transformation matrix produced in 
15038: !    the reduction by TRED2, if performed.  If the eigenvectors of the 
15039: !    tridiagonal matrix are desired, Z must contain the identity matrix.
15040: !    On output, Z contains the orthonormal eigenvectors of the symmetric
15041: !    tridiagonal (or full) matrix.  If an error exit is made, Z contains 
15042: !    the eigenvectors associated with the stored eigenvalues.
15043: !
15044: !    Output, integer ( kind = 4 ) IERR, error flag.
15045: !    0, normal return,
15046: !    J, if the J-th eigenvalue has not been determined after 
15047: !    30 iterations.
15048: !
15049:   implicit none
15050: 
15051:   integer ( kind = 4 ) n
15052: 
15053:   real    ( kind = 8 ) c
15054:   real    ( kind = 8 ) c2
15055:   real    ( kind = 8 ) c3
15056:   real    ( kind = 8 ) d(n)
15057:   real    ( kind = 8 ) dl1
15058:   real    ( kind = 8 ) e(n)
15059:   real    ( kind = 8 ) el1
15060:   real    ( kind = 8 ) f
15061:   real    ( kind = 8 ) g
15062:   real    ( kind = 8 ) h
15063:   integer ( kind = 4 ) i
15064:   integer ( kind = 4 ) ierr
15065:   integer ( kind = 4 ) ii
15066:   integer ( kind = 4 ) j
15067:   integer ( kind = 4 ) k
15068:   integer ( kind = 4 ) l
15069:   integer ( kind = 4 ) l1
15070:   integer ( kind = 4 ) l2
15071:   integer ( kind = 4 ) m
15072:   integer ( kind = 4 ) mml
15073:   real    ( kind = 8 ) p
15074:   real    ( kind = 8 ) pythag
15075:   real    ( kind = 8 ) r
15076:   real    ( kind = 8 ) s
15077:   real    ( kind = 8 ) s2
15078:   real    ( kind = 8 ) tst1
15079:   real    ( kind = 8 ) tst2
15080:   real    ( kind = 8 ) z(n,n)
15081: !
15082:   ierr = 0
15083: 
15084:   if ( n == 1 ) then
15085:     return
15086:   end if
15087: 
15088:   do i = 2, n
15089:     e(i-1) = e(i)
15090:   end do
15091: 
15092:   f = 0.0D+00
15093:   tst1 = 0.0D+00
15094:   e(n) = 0.0D+00
15095: 
15096:   do l = 1, n
15097: 
15098:      j = 0
15099:      h = abs ( d(l) ) + abs ( e(l) )
15100:      tst1 = max ( tst1, h )
15101: !
15102: !  Look for a small sub-diagonal element.
15103: !
15104:      do m = l, n
15105:        tst2 = tst1 + abs ( e(m) )
15106:        if ( tst2 == tst1 ) then
15107:          exit
15108:        end if
15109:      end do
15110: 
15111:      if ( m == l ) go to 220
15112: 
15113:  130 continue
15114: 
15115:      if ( j >= 30 ) then
15116:        ierr = l
15117:        return
15118:      end if
15119: 
15120:      j = j + 1
15121: !
15122: !  Form shift.
15123: !
15124:      l1 = l + 1
15125:      l2 = l1 + 1
15126:      g = d(l)
15127:      p = ( d(l1) - g ) / ( 2.0D+00 * e(l) )
15128:      r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( p, 1.0D+00 )
15129:      d(l) = e(l) / ( p + sign ( r, p ) )
15130:      d(l1) = e(l) * ( p + sign ( r, p ) )
15131:      dl1 = d(l1)
15132:      h = g - d(l)
15133:      d(l2:n) = d(l2:n) - h
15134:      f = f + h
15135: !
15136: !  QL transformation.
15137: !
15138:      p = d(m)
15139:      c = 1.0D+00
15140:      c2 = c
15141:      el1 = e(l1)
15142:      s = 0.0D+00
15143:      mml = m - l
15144: 
15145:      do ii = 1, mml
15146: 
15147:         c3 = c2
15148:         c2 = c
15149:         s2 = s
15150:         i = m - ii
15151:         g = c * e(i)
15152:         h = c * p
15153:         r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( p, e(i) )
15154:         e(i+1) = s * r
15155:         s = e(i) / r
15156:         c = p / r
15157:         p = c * d(i) - s * g
15158:         d(i+1) = h + s * ( c * g + s * d(i) )
15159: !
15160: !  Form vector.
15161: !
15162:         do k = 1, n
15163:           h = z(k,i+1)
15164:           z(k,i+1) = s * z(k,i) + c * h
15165:           z(k,i) = c * z(k,i) - s * h
15166:         end do
15167: 
15168:      end do
15169: 
15170:      p = - s * s2 * c3 * el1 * e(l) / dl1
15171:      e(l) = s * p
15172:      d(l) = c * p
15173:      tst2 = tst1 + abs ( e(l) )
15174: 
15175:      if ( tst2 > tst1 ) then 
15176:        go to 130
15177:      end if
15178: 
15179: 220  continue
15180: 
15181:      d(l) = d(l) + f
15182: 
15183:   end do
15184: !
15185: !  Order eigenvalues and eigenvectors.
15186: !
15187:   do ii = 2, n
15188: 
15189:     i = ii - 1
15190:     k = i
15191:     p = d(i)
15192: 
15193:     do j = ii, n
15194: 
15195:       if ( d(j) < p ) then
15196:         k = j
15197:         p = d(j)
15198:       end if
15199: 
15200:     end do
15201: 
15202:     if ( k /= i ) then
15203: 
15204:       d(k) = d(i)
15205:       d(i) = p
15206: 
15207:       do j = 1, n
15208:         call <a href="./eispack.f90.html#r8_swap" TARGET=CENT_PANEL>r8_swap</a> ( z(j,i), z(j,k) )
15209:       end do
15210: 
15211:     end if
15212: 
15213:   end do
15214: 
15215:   return
15216: end
<p><a name=tqlrat><H3>tqlrat</H3></a></p> Click <a href="./callingtree/tqlrat_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tqlrat is used.
<hr>
15217: subroutine tqlrat ( n, d, e2, ierr )
15218: 
15219: !*****************************************************************************80
15220: !
15221: !! TQLRAT computes all eigenvalues of a real symmetric tridiagonal matrix.
15222: !
15223: !  Discussion:
15224: !
15225: !    This subroutine finds the eigenvalues of a symmetric
15226: !    tridiagonal matrix by the rational QL method.
15227: !
15228: !  Licensing:
15229: !
15230: !    This code is distributed under the GNU LGPL license.
15231: !
15232: !  Modified:
15233: !
15234: !    18 October 2009
15235: !
15236: !  Author:
15237: !
15238: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
15239: !    Klema, Moler.
15240: !    FORTRAN90 version by John Burkardt.
15241: !
15242: !  Reference:
15243: !
15244: !    C Reinsch,
15245: !    Algorithm 464, TQLRAT,
15246: !    Communications of the ACM,
15247: !    Volume 16, page 689, 1973.
15248: !
15249: !    James Wilkinson, Christian Reinsch,
15250: !    Handbook for Automatic Computation,
15251: !    Volume II, Linear Algebra, Part 2,
15252: !    Springer, 1971,
15253: !    ISBN: 0387054146,
15254: !    LC: QA251.W67.
15255: !
15256: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
15257: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
15258: !    Matrix Eigensystem Routines, EISPACK Guide,
15259: !    Lecture Notes in Computer Science, Volume 6,
15260: !    Springer Verlag, 1976,
15261: !    ISBN13: 978-3540075462,
15262: !    LC: QA193.M37.
15263: !
15264: !  Parameters:
15265: !
15266: !    Input, integer ( kind = 4 ) N, the order of the matrix.
15267: !
15268: !    Input/output, real ( kind = 8 ) D(N).  On input, D contains the diagonal elements
15269: !    of the matrix.  On output, D contains the eigenvalues in ascending
15270: !    order.  If an error exit was made, then the eigenvalues are correct
15271: !    in positions 1 through IERR-1, but may not be the smallest eigenvalues.
15272: !
15273: !    Input/output, real ( kind = 8 ) E2(N), contains in positions 2 through N the
15274: !    squares of the subdiagonal elements of the matrix.  E2(1) is
15275: !    arbitrary.  On output, E2 has been overwritten by workspace
15276: !    information.
15277: !
15278: !    Output, integer ( kind = 4 ) IERR, error flag.
15279: !    0, for no error,
15280: !    J, if the J-th eigenvalue could not be determined after 30 iterations.
15281: !
15282:   implicit none
15283: 
15284:   integer ( kind = 4 ) n
15285: 
15286:   real    ( kind = 8 ) b
15287:   real    ( kind = 8 ) c
15288:   real    ( kind = 8 ) d(n)
15289:   real    ( kind = 8 ) e2(n)
15290:   real    ( kind = 8 ) f
15291:   real    ( kind = 8 ) g
15292:   real    ( kind = 8 ) h
15293:   integer ( kind = 4 ) i
15294:   integer ( kind = 4 ) ierr
15295:   integer ( kind = 4 ) ii
15296:   integer ( kind = 4 ) j
15297:   integer ( kind = 4 ) l
15298:   integer ( kind = 4 ) l1
15299:   integer ( kind = 4 ) m
15300:   integer ( kind = 4 ) mml
15301:   real    ( kind = 8 ) p
15302:   real    ( kind = 8 ) pythag
15303:   real    ( kind = 8 ) r
15304:   real    ( kind = 8 ) s
15305:   real    ( kind = 8 ) t
15306: 
15307:   ierr = 0
15308: 
15309:   if ( n == 1 ) then
15310:     return
15311:   end if
15312: 
15313:   do i = 2, n
15314:     e2(i-1) = e2(i)
15315:   end do
15316: 
15317:   f = 0.0D+00
15318:   t = 0.0D+00
15319:   e2(n) = 0.0D+00
15320: 
15321:   do l = 1, n
15322: 
15323:      j = 0
15324:      h = abs ( d(l) ) + sqrt ( e2(l) )
15325: 
15326:      if ( t <= h ) then
15327: 
15328:        t = h
15329:        b = abs ( t ) * epsilon ( b )
15330:        c = b * b
15331: 
15332:      end if
15333: !
15334: !  Look for small squared sub-diagonal element.
15335: !
15336:      do m = l, n
15337:        if ( e2(m) <= c ) then
15338:          exit
15339:        end if
15340:      end do
15341: 
15342:      if ( m == l ) go to 210
15343: 
15344: 130  continue
15345: 
15346:      if ( j >= 30 ) then
15347:        ierr = l
15348:        return
15349:      end if
15350: 
15351:      j = j + 1
15352: !
15353: !  Form shift.
15354: !
15355:      l1 = l + 1
15356:      s = sqrt ( e2(l) )
15357:      g = d(l)
15358:      p = ( d(l1) - g ) / ( 2.0D+00 * s )
15359:      r = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( p, 1.0D+00 )
15360:      d(l) = s / ( p + sign ( r, p ) )
15361:      h = g - d(l)
15362:      d(l1:n) = d(l1:n) - h
15363:      f = f + h
15364: !
15365: !  Rational QL transformation.
15366: !
15367:      g = d(m)
15368:      if ( g == 0.0D+00 ) g = b
15369:      h = g
15370:      s = 0.0D+00
15371:      mml = m - l
15372: 
15373:      do ii = 1, mml
15374:        i = m - ii
15375:        p = g * h
15376:        r = p + e2(i)
15377:        e2(i+1) = s * r
15378:        s = e2(i) / r
15379:        d(i+1) = h + s * ( h + d(i) )
15380:        g = d(i) - e2(i) / g
15381:        if ( g == 0.0D+00 ) g = b
15382:        h = g * p / r
15383:      end do
15384: 
15385:      e2(l) = s * g
15386:      d(l) = h
15387: !
15388: !  Guard against underflow in convergence test.
15389: !
15390:      if ( h == 0.0D+00 ) go to 210
15391:      if ( abs ( e2(l) ) <= abs ( c / h ) ) go to 210
15392:      e2(l) = h * e2(l)
15393:      if ( e2(l) /= 0.0D+00 ) go to 130
15394: 
15395: 210  continue
15396: 
15397:      p = d(l) + f
15398: !
15399: !  Order the eigenvalues.
15400: !
15401:      do ii = 2, l
15402:        i = l + 2 - ii
15403:        if ( p >= d(i-1) ) go to 270
15404:        d(i) = d(i-1)
15405:      end do
15406: 
15407:      i = 1
15408: 
15409: 270  continue
15410: 
15411:      d(i) = p
15412: 
15413:   end do
15414: 
15415:   return
15416: end
<p><a name=trbak1><H3>trbak1</H3></a></p> Click <a href="./callingtree/trbak1_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where trbak1 is used.
<hr>
15417: subroutine trbak1 ( n, a, e, m, z ) 
15418: 
15419: !*****************************************************************************80
15420: !
15421: !! TRBAK1 determines eigenvectors by undoing the TRED1 transformation.
15422: !
15423: !  Discussion:
15424: !
15425: !    This subroutine forms the eigenvectors of a real symmetric
15426: !    matrix by back transforming those of the corresponding
15427: !    symmetric tridiagonal matrix determined by TRED1.
15428: !
15429: !  Licensing:
15430: !
15431: !    This code is distributed under the GNU LGPL license.
15432: !
15433: !  Modified:
15434: !
15435: !    18 October 2009
15436: !
15437: !  Author:
15438: !
15439: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
15440: !    Klema, Moler.
15441: !    FORTRAN90 version by John Burkardt.
15442: !
15443: !  Reference:
15444: !
15445: !    James Wilkinson, Christian Reinsch,
15446: !    Handbook for Automatic Computation,
15447: !    Volume II, Linear Algebra, Part 2,
15448: !    Springer, 1971,
15449: !    ISBN: 0387054146,
15450: !    LC: QA251.W67.
15451: !
15452: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
15453: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
15454: !    Matrix Eigensystem Routines, EISPACK Guide,
15455: !    Lecture Notes in Computer Science, Volume 6,
15456: !    Springer Verlag, 1976,
15457: !    ISBN13: 978-3540075462,
15458: !    LC: QA193.M37.
15459: !  Parameters:
15460: !
15461: !    Input, integer ( kind = 4 ) N, the order of the matrix.
15462: !
15463: !    Input, real ( kind = 8 ) A(N,N), contains information about the orthogonal 
15464: !    transformations used in the reduction by TRED1 in its strict lower
15465: !    triangle.
15466: !
15467: !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal
15468: !    matrix in E(2:N).  E(1) is arbitrary.
15469: !
15470: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed.
15471: !
15472: !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the eigenvectors to be back 
15473: !    transformed.  On output, the transformed eigenvectors.
15474: !
15475:   implicit none
15476: 
15477:   integer ( kind = 4 ) m
15478:   integer ( kind = 4 ) n
15479: 
15480:   real    ( kind = 8 ) a(n,n)
15481:   real    ( kind = 8 ) e(n)
15482:   integer ( kind = 4 ) i
15483:   integer ( kind = 4 ) j
15484:   integer ( kind = 4 ) l
15485:   real    ( kind = 8 ) s
15486:   real    ( kind = 8 ) z(n,m)
15487: 
15488:   if ( m <= 0 ) then
15489:     return
15490:   end if
15491: 
15492:   if ( n <= 1 ) then
15493:     return
15494:   end if
15495: 
15496:   do i = 2, n
15497: 
15498:     l = i - 1
15499: 
15500:     if ( e(i) /= 0.0D+00 ) then
15501: 
15502:       do j = 1, m
15503: 
15504:         s = dot_product ( a(i,1:l), z(1:l,j) )
15505: 
15506:         s = ( s / a(i,l) ) / e(i)
15507: 
15508:         z(1:l,j) = z(1:l,j) + s * a(i,1:l)
15509: 
15510:       end do
15511: 
15512:     end if
15513: 
15514:   end do
15515: 
15516:   continue
15517: 
15518:   return
15519: end
<p><a name=trbak3><H3>trbak3</H3></a></p> Click <a href="./callingtree/trbak3_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where trbak3 is used.
<hr>
15520: subroutine trbak3 ( n, nv, a, m, z )
15521: 
15522: !*****************************************************************************80
15523: !
15524: !! TRBAK3 determines eigenvectors by undoing the TRED3 transformation.
15525: !
15526: !  Discussion:
15527: !
15528: !    This subroutine forms the eigenvectors of a real symmetric
15529: !    matrix by back transforming those of the corresponding
15530: !    symmetric tridiagonal matrix determined by TRED3.
15531: !
15532: !  Licensing:
15533: !
15534: !    This code is distributed under the GNU LGPL license.
15535: !
15536: !  Modified:
15537: !
15538: !    18 October 2009
15539: !
15540: !  Author:
15541: !
15542: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
15543: !    Klema, Moler.
15544: !    FORTRAN90 version by John Burkardt.
15545: !
15546: !  Reference:
15547: !
15548: !    James Wilkinson, Christian Reinsch,
15549: !    Handbook for Automatic Computation,
15550: !    Volume II, Linear Algebra, Part 2,
15551: !    Springer, 1971,
15552: !    ISBN: 0387054146,
15553: !    LC: QA251.W67.
15554: !
15555: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
15556: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
15557: !    Matrix Eigensystem Routines, EISPACK Guide,
15558: !    Lecture Notes in Computer Science, Volume 6,
15559: !    Springer Verlag, 1976,
15560: !    ISBN13: 978-3540075462,
15561: !    LC: QA193.M37.
15562: !
15563: !  Parameters:
15564: !
15565: !    Input, integer ( kind = 4 ) N, the order of the matrix.
15566: !
15567: !    Input, integer ( kind = 4 ) NV, the dimension of the array paramater A,
15568: !    which must be at least N*(N+1)/2.
15569: !
15570: !    Input, real ( kind = 8 ) A(NV), information about the orthogonal transformations
15571: !    used in the reduction by TRED3.
15572: !
15573: !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed.
15574: !
15575: !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the eigenvectors to be back 
15576: !    transformed.  On output, the transformed eigenvectors.
15577: !
15578:   implicit none
15579: 
15580:   integer ( kind = 4 ) m
15581:   integer ( kind = 4 ) nv
15582: 
15583:   real    ( kind = 8 ) a(nv)
15584:   real    ( kind = 8 ) h
15585:   integer ( kind = 4 ) i
15586:   integer ( kind = 4 ) ik
15587:   integer ( kind = 4 ) iz
15588:   integer ( kind = 4 ) j
15589:   integer ( kind = 4 ) k
15590:   integer ( kind = 4 ) l
15591:   integer ( kind = 4 ) n
15592:   real    ( kind = 8 ) s
15593:   real    ( kind = 8 ) z(n,m)
15594: 
15595:   if ( m == 0 ) then
15596:     return
15597:   end if
15598: 
15599:   do i = 2, n
15600: 
15601:     l = i - 1
15602:     iz = ( i * l ) / 2
15603:     ik = iz + i
15604:     h = a(ik)
15605: 
15606:     if ( h /= 0.0D+00 ) then
15607: 
15608:       do j = 1, m
15609: 
15610:         s = 0.0D+00
15611:         ik = iz
15612: 
15613:         do k = 1, l
15614:           ik = ik + 1
15615:           s = s + a(ik) * z(k,j)
15616:         end do
15617: 
15618:         s = ( s / h ) / h
15619:         ik = iz
15620: 
15621:         do k = 1, l
15622:           ik = ik + 1
15623:           z(k,j) = z(k,j) - s * a(ik)
15624:         end do
15625: 
15626:       end do
15627: 
15628:     end if
15629: 
15630:   end do
15631: 
15632:   return
15633: end
<p><a name=tred1><H3>tred1</H3></a></p> Click <a href="./callingtree/tred1_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tred1 is used.
<hr>
15634: subroutine tred1 ( n, a, d, e, e2 )
15635: 
15636: !*****************************************************************************80
15637: !
15638: !! TRED1 transforms a real symmetric matrix to symmetric tridiagonal form.
15639: !
15640: !  Discussion:
15641: !
15642: !    The routine reduces a real symmetric matrix to a symmetric 
15643: !    tridiagonal matrix using orthogonal similarity transformations.
15644: !
15645: !  Licensing:
15646: !
15647: !    This code is distributed under the GNU LGPL license.
15648: !
15649: !  Modified:
15650: !
15651: !    18 October 2009
15652: !
15653: !  Author:
15654: !
15655: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
15656: !    Klema, Moler.
15657: !    FORTRAN90 version by John Burkardt.
15658: !
15659: !  Reference:
15660: !
15661: !    Martin, Reinsch, Wilkinson,
15662: !    TRED1,
15663: !    Numerische Mathematik,
15664: !    Volume 11, pages 181-195, 1968.
15665: !
15666: !    James Wilkinson, Christian Reinsch,
15667: !    Handbook for Automatic Computation,
15668: !    Volume II, Linear Algebra, Part 2,
15669: !    Springer, 1971,
15670: !    ISBN: 0387054146,
15671: !    LC: QA251.W67.
15672: !
15673: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
15674: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
15675: !    Matrix Eigensystem Routines, EISPACK Guide,
15676: !    Lecture Notes in Computer Science, Volume 6,
15677: !    Springer Verlag, 1976,
15678: !    ISBN13: 978-3540075462,
15679: !    LC: QA193.M37.
15680: !
15681: !  Parameters:
15682: !
15683: !    Input, integer ( kind = 4 ) N, the order of the matrix A.
15684: !
15685: !    Input/output, real ( kind = 8 ) A(N,N), on input, contains the real symmetric matrix.  
15686: !    Only the lower triangle of the matrix need be supplied.
15687: !    On output, A contains information about the orthogonal transformations 
15688: !    used in the reduction in its strict lower triangle.  
15689: !    The full upper triangle of A is unaltered.
15690: !
15691: !    Output, real ( kind = 8 ) D(N), contains the diagonal elements of the tridiagonal 
15692: !    matrix.
15693: !
15694: !    Output, real ( kind = 8 ) E(N), contains the subdiagonal elements of the tridiagonal
15695: !    matrix in its last n-1 positions.  e(1) is set to zero.
15696: !
15697: !    Output, real ( kind = 8 ) E2(N), contains the squares of the corresponding 
15698: !    elements of E.  E2 may coincide with E if the squares are not needed.
15699: !
15700:   implicit none
15701: 
15702:   integer ( kind = 4 ) n
15703: 
15704:   real    ( kind = 8 ) a(n,n)
15705:   real    ( kind = 8 ) d(n)
15706:   real    ( kind = 8 ) e(n)
15707:   real    ( kind = 8 ) e2(n)
15708:   real    ( kind = 8 ) f
15709:   real    ( kind = 8 ) g
15710:   real    ( kind = 8 ) h
15711:   integer ( kind = 4 ) i
15712:   integer ( kind = 4 ) ii
15713:   integer ( kind = 4 ) j
15714:   integer ( kind = 4 ) k
15715:   integer ( kind = 4 ) l
15716:   real    ( kind = 8 ) xscale
15717: 
15718:   d(1:n) = a(n,1:n)
15719: 
15720:   do i = 1, n
15721:     a(n,i) = a(i,i)
15722:   end do
15723: 
15724:   do ii = 1, n
15725: 
15726:     i = n + 1 - ii
15727:     l = i - 1
15728:     h = 0.0D+00
15729: !
15730: !  Scale row.
15731: !
15732:     xscale = sum ( abs ( d(1:l) ) )
15733: 
15734:     if ( xscale == 0.0D+00 ) then
15735: 
15736:       do j = 1, l
15737:         d(j) = a(l,j)
15738:         a(l,j) = a(i,j)
15739:         a(i,j) = 0.0D+00
15740:       end do
15741: 
15742:       e(i) = 0.0D+00
15743:       e2(i) = 0.0D+00
15744: 
15745:       cycle
15746: 
15747:     end if
15748: 
15749:     d(1:l) = d(1:l) / xscale
15750: 
15751:     do k = 1, l
15752:       h = h + d(k)**2
15753:     end do
15754: 
15755:     e2(i) = h * xscale**2
15756:     f = d(l)
15757:     g = - sign ( sqrt ( h ), f )
15758:     e(i) = xscale * g
15759:     h = h - f * g
15760:     d(l) = f - g
15761: 
15762:     if ( l >= 1 ) then
15763: !
15764: !  Form A * U.
15765: !
15766:       e(1:l) = 0.0D+00
15767: 
15768:       do j = 1, l
15769: 
15770:         f = d(j)
15771:         g = e(j) + a(j,j) * f
15772: 
15773:         do k = j+1, l
15774:           g = g + a(k,j) * d(k)
15775:           e(k) = e(k) + a(k,j) * f
15776:         end do
15777: 
15778:         e(j) = g
15779: 
15780:       end do
15781: !
15782: !  Form P.
15783: !
15784:       f = 0.0D+00
15785: 
15786:       do j = 1, l
15787:         e(j) = e(j) / h
15788:         f = f + e(j) * d(j)
15789:       end do
15790: 
15791:       h = f / ( h + h )
15792: !
15793: !  Form Q.
15794: !
15795:       e(1:l) = e(1:l) - h * d(1:l)
15796: !
15797: !  Form reduced A.
15798: !
15799:       do j = 1, l
15800: 
15801:         f = d(j)
15802:         g = e(j)
15803: 
15804:         a(j:l,j) = a(j:l,j) - f * e(j:l) - g * d(j:l)
15805: 
15806:       end do
15807: 
15808:     end if
15809: 
15810:     do j = 1, l
15811:       f = d(j)
15812:       d(j) = a(l,j)
15813:       a(l,j) = a(i,j)
15814:       a(i,j) = f * xscale
15815:     end do
15816: 
15817: 
15818:   end do
15819: 
15820:   return
15821: end
<p><a name=tred2><H3>tred2</H3></a></p> Click <a href="./callingtree/tred2_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tred2 is used.
<hr>
15822: subroutine tred2 ( n, a, d, e, z )
15823: 
15824: !*****************************************************************************80
15825: !
15826: !! TRED2 transforms a real symmetric matrix to symmetric tridiagonal form.
15827: !
15828: !  Discussion:
15829: !
15830: !    This subroutine reduces a real symmetric matrix to a
15831: !    symmetric tridiagonal matrix using and accumulating
15832: !    orthogonal similarity transformations.
15833: !
15834: !    A and Z may coincide, in which case a single storage area is used
15835: !    for the input of A and the output of Z.
15836: !
15837: !  Licensing:
15838: !
15839: !    This code is distributed under the GNU LGPL license.
15840: !
15841: !  Modified:
15842: !
15843: !    18 October 2009
15844: !
15845: !  Author:
15846: !
15847: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
15848: !    Klema, Moler.
15849: !    FORTRAN90 version by John Burkardt.
15850: !
15851: !  Reference:
15852: !
15853: !    Martin, Reinsch, Wilkinson,
15854: !    TRED2,
15855: !    Numerische Mathematik, 
15856: !    Volume 11, pages 181-195, 1968.
15857: !
15858: !    James Wilkinson, Christian Reinsch,
15859: !    Handbook for Automatic Computation,
15860: !    Volume II, Linear Algebra, Part 2,
15861: !    Springer, 1971,
15862: !    ISBN: 0387054146,
15863: !    LC: QA251.W67.
15864: !
15865: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
15866: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
15867: !    Matrix Eigensystem Routines, EISPACK Guide,
15868: !    Lecture Notes in Computer Science, Volume 6,
15869: !    Springer Verlag, 1976,
15870: !    ISBN13: 978-3540075462,
15871: !    LC: QA193.M37.
15872: !
15873: !  Parameters:
15874: !
15875: !    Input, integer ( kind = 4 ) N, the order of the matrix.
15876: !
15877: !    Input, real ( kind = 8 ) A(N,N), the real symmetric input matrix.  Only the
15878: !    lower triangle of the matrix need be supplied.
15879: !
15880: !    Output, real ( kind = 8 ) D(N), the diagonal elements of the tridiagonal matrix.
15881: !
15882: !    Output, real ( kind = 8 ) E(N), contains the subdiagonal elements of the tridiagonal
15883: !    matrix in E(2:N).  E(1) is set to zero.
15884: !
15885: !    Output, real ( kind = 8 ) Z(N,N), the orthogonal transformation matrix produced 
15886: !    in the reduction.
15887: !
15888:   implicit none
15889: 
15890:   integer ( kind = 4 ) n
15891: 
15892:   real    ( kind = 8 ) a(n,n)
15893:   real    ( kind = 8 ) d(n)
15894:   real    ( kind = 8 ) e(n)
15895:   real    ( kind = 8 ) f
15896:   real    ( kind = 8 ) g
15897:   real    ( kind = 8 ) h
15898:   real    ( kind = 8 ) hh
15899:   integer ( kind = 4 ) i
15900:   integer ( kind = 4 ) ii
15901:   integer ( kind = 4 ) j
15902:   integer ( kind = 4 ) k
15903:   integer ( kind = 4 ) l
15904:   real    ( kind = 8 ) xscale
15905:   real    ( kind = 8 ) z(n,n)
15906: 
15907:   do i = 1, n
15908:     z(i:n,i) = a(i:n,i)
15909:   end do
15910: 
15911:   d(1:n) = a(n,1:n)
15912: 
15913:   do ii = 2, n
15914: 
15915:     i = n + 2 - ii
15916:     l = i - 1
15917:     h = 0.0D+00
15918:     xscale = 0.0D+00
15919: !
15920: !  Scale row.
15921: !
15922:     do k = 1, l
15923:       xscale = xscale + abs ( d(k) )
15924:     end do
15925: 
15926:     if ( xscale == 0.0D+00 ) then
15927: 
15928:       e(i) = d(l)
15929: 
15930:       do j = 1, l
15931:         d(j) = z(l,j)
15932:         z(i,j) = 0.0D+00
15933:         z(j,i) = 0.0D+00
15934:       end do
15935: 
15936:       go to 290
15937: 
15938:     end if
15939: 
15940:     d(1:l) = d(1:l) / xscale
15941: 
15942:     h = h + dot_product ( d(1:l), d(1:l) )
15943: 
15944:     f = d(l)
15945:     g = - sign ( sqrt ( h ), f )
15946:     e(i) = xscale * g
15947:     h = h - f * g
15948:     d(l) = f - g
15949: !
15950: !  Form A*U.
15951: !
15952:     e(1:l) = 0.0D+00
15953: 
15954:     do j = 1, l
15955: 
15956:       f = d(j)
15957:       z(j,i) = f
15958:       g = e(j) + z(j,j) * f
15959: 
15960:       do k = j+1, l
15961:         g = g + z(k,j) * d(k)
15962:         e(k) = e(k) + z(k,j) * f
15963:       end do
15964: 
15965:       e(j) = g
15966: 
15967:     end do
15968: !
15969: !  Form P.
15970: !
15971:     e(1:l) = e(1:l) / h
15972: 
15973:     f = dot_product ( e(1:l), d(1:l) )
15974: 
15975:     hh = 0.5D+00 * f / h
15976: !
15977: !  Form Q.
15978: !
15979:     e(1:l) = e(1:l) - hh * d(1:l)
15980: !
15981: !  Form reduced A.
15982: !
15983:     do j = 1, l
15984: 
15985:       f = d(j)
15986:       g = e(j)
15987: 
15988:       z(j:l,j) = z(j:l,j) - f * e(j:l) - g * d(j:l)
15989: 
15990:       d(j) = z(l,j)
15991:       z(i,j) = 0.0D+00
15992: 
15993:     end do
15994: 
15995: 290 continue
15996: 
15997:     d(i) = h
15998: 
15999: 
16000:   end do
16001: !
16002: !  Accumulation of transformation matrices.
16003: !
16004:   do i = 2, n
16005: 
16006:     l = i - 1
16007:     z(n,l) = z(l,l)
16008:     z(l,l) = 1.0D+00
16009:     h = d(i)
16010:     if ( h /= 0.0D+00 ) then
16011: 
16012:       d(1:l) = z(1:l,i) / h
16013: 
16014:       do j = 1, l
16015: 
16016:         g = dot_product ( z(1:l,i), z(1:l,j) )
16017: 
16018:         do k = 1, l
16019:           z(k,j) = z(k,j) - g * d(k)
16020:         end do
16021: 
16022:       end do
16023: 
16024:     end if
16025: 
16026:     z(1:l,i) = 0.0D+00
16027: 
16028:   end do
16029: 
16030:   d(1:n) = z(n,1:n)
16031: 
16032:   z(n,1:n-1) = 0.0D+00
16033:   z(n,n) = 1.0D+00
16034: 
16035:   e(1) = 0.0D+00
16036: 
16037:   return
16038: end
<p><a name=tred3><H3>tred3</H3></a></p> Click <a href="./callingtree/tred3_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tred3 is used.
<hr>
16039: subroutine tred3 ( n, nv, a, d, e, e2 )
16040: 
16041: !*****************************************************************************80
16042: !
16043: !! TRED3 transforms a real symmetric packed matrix to symmetric tridiagonal form.
16044: !
16045: !  Discussion:
16046: !
16047: !    This subroutine reduces a real symmetric matrix, stored as
16048: !    a one-dimensional array, to a symmetric tridiagonal matrix
16049: !    using orthogonal similarity transformations.
16050: !
16051: !  Licensing:
16052: !
16053: !    This code is distributed under the GNU LGPL license.
16054: !
16055: !  Modified:
16056: !
16057: !    18 October 2009
16058: !
16059: !  Author:
16060: !
16061: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
16062: !    Klema, Moler.
16063: !    FORTRAN90 version by John Burkardt.
16064: !
16065: !  Reference:
16066: !
16067: !    Martin, Reinsch, Wilkinson,
16068: !    TRED3,
16069: !    Numerische Mathematik,
16070: !    Volume 11, pages 181-195, 1968.
16071: !
16072: !    James Wilkinson, Christian Reinsch,
16073: !    Handbook for Automatic Computation,
16074: !    Volume II, Linear Algebra, Part 2,
16075: !    Springer, 1971,
16076: !    ISBN: 0387054146,
16077: !    LC: QA251.W67.
16078: !
16079: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
16080: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
16081: !    Matrix Eigensystem Routines, EISPACK Guide,
16082: !    Lecture Notes in Computer Science, Volume 6,
16083: !    Springer Verlag, 1976,
16084: !    ISBN13: 978-3540075462,
16085: !    LC: QA193.M37.
16086: !
16087: !  Parameters:
16088: !
16089: !    Input, integer ( kind = 4 ) N, the order of the matrix.
16090: !
16091: !    Input, integer ( kind = 4 ) NV, the dimension of A, which must be at least
16092: !    (N*(N+1))/2.
16093: !
16094: !    Input/output, real ( kind = 8 ) A(NV).  On input, the lower triangle of the real 
16095: !    symmetric matrix, stored row-wise.  On output, information about the 
16096: !    orthogonal transformations used in the reduction.
16097: !
16098: !    Output, real ( kind = 8 ) D(N), the diagonal elements of the tridiagonal matrix.
16099: !
16100: !    Output, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal
16101: !    matrix in E(2:N).  E(1) is set to zero.
16102: !
16103: !    Output, real ( kind = 8 ) E2(N),  the squares of the corresponding elements of E.
16104: !    E2 may coincide with E if the squares are not needed.
16105: !
16106:   implicit none
16107: 
16108:   integer ( kind = 4 ) n
16109:   integer ( kind = 4 ) nv
16110: 
16111:   real    ( kind = 8 ) a(nv)
16112:   real    ( kind = 8 ) d(n)
16113:   real    ( kind = 8 ) e(n)
16114:   real    ( kind = 8 ) e2(n)
16115:   real    ( kind = 8 ) f
16116:   real    ( kind = 8 ) g
16117:   real    ( kind = 8 ) h
16118:   real    ( kind = 8 ) hh
16119:   integer ( kind = 4 ) i
16120:   integer ( kind = 4 ) ii
16121:   integer ( kind = 4 ) iz
16122:   integer ( kind = 4 ) j
16123:   integer ( kind = 4 ) jk
16124:   integer ( kind = 4 ) k
16125:   integer ( kind = 4 ) l
16126:   real    ( kind = 8 ) xscale
16127: 
16128:   do ii = 1, n
16129: 
16130:      i = n + 1 - ii
16131:      l = i - 1
16132:      iz = ( i * l ) / 2
16133:      h = 0.0D+00
16134:      xscale = 0.0D+00
16135: !
16136: !  Scale row.
16137: !
16138:      do k = 1, l
16139:        iz = iz + 1
16140:        d(k) = a(iz)
16141:        xscale = xscale + abs ( d(k) )
16142:      end do
16143: 
16144:      if ( xscale == 0.0D+00 ) then
16145:        e(i) = 0.0D+00
16146:        e2(i) = 0.0D+00
16147:        go to 290
16148:      end if
16149: 
16150:      do k = 1, l
16151:        d(k) = d(k) / xscale
16152:        h = h + d(k)**2
16153:      end do
16154: 
16155:      e2(i) = xscale * xscale * h
16156:      f = d(l)
16157:      g = - sign ( sqrt ( h ), f )
16158:      e(i) = xscale * g
16159:      h = h - f * g
16160:      d(l) = f - g
16161:      a(iz) = xscale * d(l)
16162: 
16163:      if ( l == 1 ) go to 290
16164: 
16165:      jk = 1
16166: 
16167:      do j = 1, l
16168: 
16169:         f = d(j)
16170:         g = 0.0D+00
16171: 
16172:         do k = 1, j-1
16173:           g = g + a(jk) * d(k)
16174:           e(k) = e(k) + a(jk) * f
16175:           jk = jk + 1
16176:         end do
16177: 
16178:         e(j) = g + a(jk) * f
16179:         jk = jk + 1
16180: 
16181:      end do
16182: !
16183: !  Form P.
16184: !
16185:      e(1:l) = e(1:l) / h
16186:      f = dot_product ( e(1:l), d(1:l) )
16187:      hh = f / ( h + h )
16188: !
16189: !  Form Q.
16190: !
16191:      e(1:l) = e(1:l) - hh * d(1:l)
16192:      jk = 1
16193: !
16194: !  Form reduced A.
16195: !
16196:      do j = 1, l
16197:        f = d(j)
16198:        g = e(j)
16199:        do k = 1, j
16200:          a(jk) = a(jk) - f * e(k) - g * d(k)
16201:          jk = jk + 1
16202:        end do
16203:      end do
16204: 
16205: 290  continue
16206: 
16207:      d(i) = a(iz+1)
16208:      a(iz+1) = xscale * sqrt ( h )
16209: 
16210:   end do
16211: 
16212:   return
16213: end
<p><a name=tridib><H3>tridib</H3></a></p> Click <a href="./callingtree/tridib_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tridib is used.
<hr>
16214: subroutine tridib ( n, eps1, d, e, e2, lb, ub, m11, m, w, ind, ierr )
16215: 
16216: !*****************************************************************************80
16217: !
16218: !! TRIDIB computes some eigenvalues of a real symmetric tridiagonal matrix.
16219: !
16220: !  Discussion:
16221: !
16222: !    This subroutine finds those eigenvalues of a tridiagonal
16223: !    symmetric matrix between specified boundary indices,
16224: !    using bisection.
16225: !
16226: !  Licensing:
16227: !
16228: !    This code is distributed under the GNU LGPL license.
16229: !
16230: !  Modified:
16231: !
16232: !    18 October 2009
16233: !
16234: !  Author:
16235: !
16236: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
16237: !    Klema, Moler.
16238: !    FORTRAN90 version by John Burkardt.
16239: !
16240: !  Reference:
16241: !
16242: !    James Wilkinson, Christian Reinsch,
16243: !    Handbook for Automatic Computation,
16244: !    Volume II, Linear Algebra, Part 2,
16245: !    Springer, 1971,
16246: !    ISBN: 0387054146,
16247: !    LC: QA251.W67.
16248: !
16249: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
16250: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
16251: !    Matrix Eigensystem Routines, EISPACK Guide,
16252: !    Lecture Notes in Computer Science, Volume 6,
16253: !    Springer Verlag, 1976,
16254: !    ISBN13: 978-3540075462,
16255: !    LC: QA193.M37.
16256: !
16257: !  Parameters:
16258: !
16259: !    Input, integer ( kind = 4 ) N, the order of the matrix.
16260: !
16261: !    Input/output, real ( kind = 8 ) EPS1.  On input, an absolute error tolerance for 
16262: !    the computed eigenvalues.  It should be chosen commensurate with
16263: !    relative perturbations in the matrix elements of the order of the 
16264: !    relative machine precision.  If the input EPS1 is non-positive, it 
16265: !    is reset for each submatrix to a default value, namely, minus the
16266: !    product of the relative machine precision and the 1-norm of the submatrix.
16267: !
16268: !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix.
16269: !
16270: !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the input matrix
16271: !    in E(2:N).  E(1) is arbitrary.
16272: !
16273: !    Input/output, real ( kind = 8 ) E2(N).  On input, the squares of the corresponding 
16274: !    elements of E.  E2(1) is arbitrary.  On output, elements of E2 
16275: !    corresponding to elements of E regarded as negligible, have been 
16276: !    replaced by zero, causing the matrix to split into a direct sum of 
16277: !    submatrices.  E2(1) is also set to zero.
16278: !
16279: !    Input, integer ( kind = 4 ) M11, the lower boundary index for the desired eigenvalues.
16280: !
16281: !    Input, integer ( kind = 4 ) M, the number of eigenvalues desired.  The upper
16282: !    boundary index M22 is then obtained as M22 = M11 + M - 1.
16283: !
16284: !    Output, real ( kind = 8 ) LB, UB, define an interval containing exactly the desired
16285: !    eigenvalues.
16286: !
16287: !    Output, real ( kind = 8 ) W(M), the eigenvalues between indices M11 and M22 
16288: !    in ascending order.
16289: !
16290: !    Output, integer ( kind = 4 ) IND(M), the submatrix indices associated with the 
16291: !    corresponding eigenvalues in W: 1 for eigenvalues belonging to the 
16292: !    first submatrix from the top, 2 for those belonging to the second 
16293: !    submatrix, and so on.
16294: !
16295: !    Output, integer ( kind = 4 ) IERR, error flag.
16296: !    0, for normal return,
16297: !    3*N+1, if multiple eigenvalues at index M11 make unique selection 
16298: !      impossible,
16299: !    3*N+2, if multiple eigenvalues at index M22 make unique selection
16300: !      impossible.
16301: !
16302:   implicit none
16303: 
16304:   integer ( kind = 4 ) m
16305:   integer ( kind = 4 ) n
16306: 
16307:   real    ( kind = 8 ) d(n)
16308:   real    ( kind = 8 ) e(n)
16309:   real    ( kind = 8 ) e2(n)
16310:   real    ( kind = 8 ) eps1
16311:   integer ( kind = 4 ) i
16312:   integer ( kind = 4 ) ierr
16313:   integer ( kind = 4 ) ii
16314:   integer ( kind = 4 ) ind(m)
16315:   integer ( kind = 4 ) isturm
16316:   integer ( kind = 4 ) j
16317:   integer ( kind = 4 ) k
16318:   integer ( kind = 4 ) l
16319:   real    ( kind = 8 ) lb
16320:   integer ( kind = 4 ) m1
16321:   integer ( kind = 4 ) m11
16322:   integer ( kind = 4 ) m2
16323:   integer ( kind = 4 ) m22
16324:   integer ( kind = 4 ) p
16325:   integer ( kind = 4 ) q
16326:   integer ( kind = 4 ) r
16327:   real    ( kind = 8 ) rv4(n)
16328:   real    ( kind = 8 ) rv5(n)
16329:   integer ( kind = 4 ) s
16330:   real    ( kind = 8 ) t1
16331:   real    ( kind = 8 ) t2
16332:   integer ( kind = 4 ) tag
16333:   real    ( kind = 8 ) tst1
16334:   real    ( kind = 8 ) tst2
16335:   real    ( kind = 8 ) u
16336:   real    ( kind = 8 ) ub
16337:   real    ( kind = 8 ) v
16338:   real    ( kind = 8 ) w(m)
16339:   real    ( kind = 8 ) x0
16340:   real    ( kind = 8 ) x1
16341:   real    ( kind = 8 ) xu
16342: 
16343:   ierr = 0
16344:   tag = 0
16345:   xu = d(1)
16346:   x0 = d(1)
16347:   s = 0
16348:   u = 0.0D+00
16349: !
16350: !  Look for small sub-diagonal entries and determine an
16351: !  interval containing all the eigenvalues.
16352: !
16353:   do i = 1, n
16354: 
16355:      x1 = u
16356: 
16357:      if ( i == n ) then
16358:        u = 0.0D+00
16359:      else
16360:        u = abs ( e(i+1) )
16361:      end if
16362: 
16363:      xu = min ( xu, d(i)-(x1+u) )
16364:      x0 = max ( x0, d(i)+(x1+u) )
16365: 
16366:      if ( i >= 1 ) then
16367:        tst1 = abs ( d(i) ) + abs ( d(i-1) )
16368:        tst2 = tst1 + abs ( e(i) )
16369:        if ( tst2 <= tst1 ) then
16370:          e2(i) = 0.0D+00
16371:        end if
16372:      else
16373:        e2(i) = 0.0D+00
16374:      end if
16375: 
16376:   end do
16377: 
16378:   x1 = n
16379:   x1 = x1 * max ( abs ( xu ), abs ( x0 ) ) * epsilon ( x1 )
16380:   xu = xu - x1
16381:   t1 = xu
16382:   x0 = x0 + x1
16383:   t2 = x0
16384: !
16385: !  Determine an interval containing exactly the desired eigenvalues.
16386: !
16387:   p = 1
16388:   q = n
16389:   m1 = m11 - 1
16390:   if ( m1 == 0 ) go to 75
16391:   isturm = 1
16392: 
16393: 50 continue
16394: 
16395:   v = x1
16396:   x1 = xu + (x0 - xu) * 0.5D+00
16397:   if ( x1 == v ) go to 980
16398:   go to 320
16399: 
16400: 60 continue
16401: 
16402:   if ( s - m1 < 0 ) then
16403:     go to 65
16404:   else if ( s - m1 == 0 ) then
16405:     go to 73
16406:   else
16407:     go to 70
16408:   end if
16409: 
16410: 65 continue
16411: 
16412:   xu = x1
16413:   go to 50
16414: 
16415: 70 continue
16416: 
16417:   x0 = x1
16418:   go to 50
16419: 
16420: 73 continue
16421: 
16422:   xu = x1
16423:   t1 = x1
16424: 
16425: 75 continue
16426: 
16427:   m22 = m1 + m
16428:   if ( m22 == n ) go to 90
16429:   x0 = t2
16430:   isturm = 2
16431:   go to 50
16432: 
16433: 80 continue
16434: 
16435:   if ( s - m22 < 0 ) then
16436:     go to 65
16437:   else if ( s - m22 == 0 ) then
16438:     go to 85
16439:   else
16440:     go to 70
16441:   end if
16442: 
16443: 85 continue
16444: 
16445:    t2 = x1
16446: 
16447: 90 continue
16448: 
16449:   q = 0
16450:   r = 0
16451: !
16452: !  Establish and process next submatrix, refining interval by the 
16453: !  Gerschgorin bounds.
16454: !
16455: 100 continue
16456: 
16457:   if ( r == m ) then
16458:     go to 1001
16459:   end if
16460: 
16461:   tag = tag + 1
16462:   p = q + 1
16463:   xu = d(p)
16464:   x0 = d(p)
16465:   u = 0.0D+00
16466: 
16467:   do q = p, n
16468: 
16469:     x1 = u
16470:     u = 0.0D+00
16471:     v = 0.0D+00
16472: 
16473:     if ( q < n ) then
16474:       u = abs ( e(q+1) )
16475:       v = e2(q+1)
16476:     end if
16477: 
16478:     xu = min ( d(q)-(x1+u), xu )
16479:     x0 = max ( d(q)+(x1+u), x0 )
16480: 
16481:     if ( v == 0.0D+00 ) then
16482:       exit
16483:     end if
16484: 
16485:   end do
16486: 
16487:   x1 = max ( abs ( xu ), abs ( x0 ) ) * epsilon ( x1 )
16488:   if ( eps1 <= 0.0D+00 ) eps1 = -x1
16489:   if ( p /= q ) go to 180
16490: !
16491: !  Check for isolated root within interval.
16492: !
16493:   if ( t1 > d(p) .or. d(p) >= t2 ) go to 940
16494:   m1 = p
16495:   m2 = p
16496:   rv5(p) = d(p)
16497:   go to 900
16498: 
16499: 180 continue
16500: 
16501:   x1 = x1 * (q - p + 1)
16502:   lb = max ( t1, xu-x1 )
16503:   ub = min ( t2, x0+x1 )
16504:   x1 = lb
16505:   isturm = 3
16506:   go to 320
16507: 
16508: 200 continue
16509: 
16510:   m1 = s + 1
16511:   x1 = ub
16512:   isturm = 4
16513:   go to 320
16514: 
16515: 220 continue
16516: 
16517:   m2 = s
16518:   if ( m1 > m2 ) go to 940
16519: !
16520: !  Find roots by bisection.
16521: !
16522:   x0 = ub
16523:   isturm = 5
16524: 
16525:   rv5(m1:m2) = ub
16526:   rv4(m1:m2) = lb
16527: !
16528: !  Loop for the K-th eigenvalue.
16529: !
16530:   k = m2
16531: 
16532: 250 continue
16533: 
16534:   xu = lb
16535: 
16536:   do ii = m1, k
16537: 
16538:     i = m1 + k - ii
16539:     if ( xu < rv4(i) ) then
16540:       xu = rv4(i)
16541:       exit
16542:     end if
16543: 
16544:   end do
16545: 
16546:   if ( x0 > rv5(k) ) x0 = rv5(k)
16547: !
16548: !  Next bisection step.
16549: !
16550: 300  continue
16551: 
16552:      x1 = ( xu + x0 ) * 0.5D+00
16553:      if ( ( x0 - xu ) <= abs ( eps1) ) go to 420
16554:      tst1 = 2.0D+00 * ( abs ( xu ) + abs ( x0 ) )
16555:      tst2 = tst1 + (x0 - xu)
16556:      if ( tst2 == tst1 ) go to 420
16557: !
16558: !  Sturm sequence.
16559: !
16560: 320  continue
16561: 
16562:      s = p - 1
16563:      u = 1.0D+00
16564: 
16565:      do i = p, q
16566: 
16567:        if ( u == 0.0D+00 ) then
16568:          v = abs ( e(i) ) / epsilon ( v )
16569:          if ( e2(i) == 0.0D+00 ) v = 0.0D+00
16570:        else
16571:          v = e2(i) / u
16572:        end if
16573: 
16574:        u = d(i) - x1 - v
16575: 
16576:        if ( u < 0.0D+00 ) then
16577:          s = s + 1
16578:        end if
16579: 
16580:      end do
16581: 
16582:      go to (60,80,200,220,360), isturm
16583: !
16584: !  Refine intervals.
16585: !
16586: 360  continue
16587: 
16588:      if ( s >= k) go to 400
16589:      xu = x1
16590:      if ( s >= m1) go to 380
16591:      rv4(m1) = x1
16592:      go to 300
16593: 
16594: 380  continue
16595: 
16596:      rv4(s+1) = x1
16597:      if ( rv5(s) > x1) rv5(s) = x1
16598:      go to 300
16599: 
16600: 400  continue
16601: 
16602:      x0 = x1
16603:      go to 300
16604: !
16605: !  K-th eigenvalue found.
16606: !
16607: 420  continue
16608: 
16609:   rv5(k) = x1
16610:   k = k - 1
16611:   if ( k >= m1 ) go to 250
16612: !
16613: !  Order eigenvalues tagged with their submatrix associations.
16614: !
16615: 900 continue
16616: 
16617:   s = r
16618:   r = r + m2 - m1 + 1
16619:   j = 1
16620:   k = m1
16621: 
16622:   do l = 1, r
16623: 
16624:      if ( j > s ) go to 910
16625:      if ( k > m2 ) go to 940
16626:      if ( rv5(k) >= w(l) ) go to 915
16627: 
16628:      do ii = j, s
16629:        i = l + s - ii
16630:        w(i+1) = w(i)
16631:        ind(i+1) = ind(i)
16632:      end do
16633: 
16634: 910  continue
16635: 
16636:      w(l) = rv5(k)
16637:      ind(l) = tag
16638:      k = k + 1
16639:      go to 920
16640: 
16641: 915  continue
16642: 
16643:      j = j + 1
16644: 
16645: 920  continue
16646: 
16647:   end do
16648: 
16649: 940 continue
16650: 
16651:   if ( q < n ) then
16652:     go to 100
16653:   end if
16654: 
16655:   go to 1001
16656: !
16657: !  Set error: interval cannot be found containing exactly the 
16658: !  desired eigenvalues.
16659: !
16660: 980 continue
16661: 
16662:   ierr = 3 * n + isturm
16663: 
16664: 1001 continue
16665: 
16666:   lb = t1
16667:   ub = t2
16668:   return
16669: end
<p><a name=tsturm><H3>tsturm</H3></a></p> Click <a href="./callingtree/tsturm_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where tsturm is used.
<hr>
16670: subroutine tsturm ( n, eps1, d, e, e2, lb, ub, mm, m, w, z, ierr )
16671: 
16672: !*****************************************************************************80
16673: !
16674: !! TSTURM computes some eigenvalues/vectors, real symmetric tridiagonal matrix.
16675: !
16676: !  Discussion:
16677: !
16678: !    This subroutine finds those eigenvalues of a tridiagonal
16679: !    symmetric matrix which lie in a specified interval and their
16680: !    associated eigenvectors, using bisection and inverse iteration.
16681: !
16682: !  Licensing:
16683: !
16684: !    This code is distributed under the GNU LGPL license.
16685: !
16686: !  Modified:
16687: !
16688: !    18 October 2009
16689: !
16690: !  Author:
16691: !
16692: !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe,
16693: !    Klema, Moler.
16694: !    FORTRAN90 version by John Burkardt.
16695: !
16696: !  Reference:
16697: !
16698: !    James Wilkinson, Christian Reinsch,
16699: !    Handbook for Automatic Computation,
16700: !    Volume II, Linear Algebra, Part 2,
16701: !    Springer, 1971,
16702: !    ISBN: 0387054146,
16703: !    LC: QA251.W67.
16704: !
16705: !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, 
16706: !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler,
16707: !    Matrix Eigensystem Routines, EISPACK Guide,
16708: !    Lecture Notes in Computer Science, Volume 6,
16709: !    Springer Verlag, 1976,
16710: !    ISBN13: 978-3540075462,
16711: !    LC: QA193.M37.
16712: !
16713: !  Parameters:
16714: !
16715: !    Input, integer ( kind = 4 ) N, the order of the matrix.
16716: !
16717: !    Input/output, real ( kind = 8 ) EPS1.  On input, an absolute error tolerance for 
16718: !    the computed eigenvalues.  It should be chosen commensurate with
16719: !    relative perturbations in the matrix elements of the order of the 
16720: !    relative machine precision.  If the input EPS1 is non-positive, it 
16721: !    is reset for each submatrix to a default value, namely, minus the
16722: !    product of the relative machine precision and the 1-norm of the submatrix.
16723: !
16724: !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix.
16725: !
16726: !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the input matrix
16727: !    in E(2:N).  E(1) is arbitrary.
16728: !
16729: !    Input/output, real ( kind = 8 ) E2(N).  On input, the squares of the corresponding 
16730: !    elements of E.  E2(1) is arbitrary.  On output, elements of E2 
16731: !    corresponding to elements of E regarded as negligible have been 
16732: !    replaced by zero, causing the matrix to split into a direct sum of 
16733: !    submatrices.  E2(1) is also set to zero.
16734: !
16735: !    Input, real ( kind = 8 ) LB, UB, define the interval to be searched for eigenvalues.
16736: !    If LB is not less than UB, no eigenvalues will be found.
16737: !
16738: !    Input, integer ( kind = 4 ) MM, an upper bound for the number of eigenvalues in 
16739: !    the interval.  If more than MM eigenvalues are determined to lie in 
16740: !    the interval, an error return is made with no values or vectors found.
16741: !
16742: !    Output, integer ( kind = 4 ) M, the number of eigenvalues determined to lie 
16743: !    in (LB, UB).
16744: !
16745: !    Output, real ( kind = 8 ) W(M), the eigenvalues in ascending order if the matrix
16746: !    does not split.  If the matrix splits, the eigenvalues are in ascending
16747: !    order for each submatrix.  If a vector error exit is made, W contains 
16748: !    those values already found.
16749: !
16750: !    Output, real ( kind = 8 ) Z(N,MM), the associated set of orthonormal eigenvectors.
16751: !    If an error exit is made, Z contains those vectors already found.
16752: !
16753: !    Output, integer ( kind = 4 ) IERR, error flag.
16754: !    0, normal return.
16755: !    3*N+1, if M exceeds MM.
16756: !    4*N+R, if the eigenvector corresponding to the R-th
16757: !      eigenvalue fails to converge in 5 iterations.
16758: !
16759:   implicit none
16760: 
16761:   integer ( kind = 4 ) mm
16762:   integer ( kind = 4 ) n
16763: 
16764:   real    ( kind = 8 ) d(n)
16765:   real    ( kind = 8 ) e(n)
16766:   real    ( kind = 8 ) e2(n)
16767:   real    ( kind = 8 ) eps1
16768:   real    ( kind = 8 ) eps2
16769:   real    ( kind = 8 ) eps3
16770:   real    ( kind = 8 ) eps4
16771:   integer ( kind = 4 ) group
16772:   integer ( kind = 4 ) i
16773:   integer ( kind = 4 ) ierr
16774:   integer ( kind = 4 ) ii
16775:   integer ( kind = 4 ) ip
16776:   integer ( kind = 4 ) isturm
16777:   integer ( kind = 4 ) its
16778:   integer ( kind = 4 ) j
16779:   integer ( kind = 4 ) jj
16780:   integer ( kind = 4 ) k
16781:   real    ( kind = 8 ) lb
16782:   integer ( kind = 4 ) m
16783:   integer ( kind = 4 ) m1
16784:   integer ( kind = 4 ) m2
16785:   real    ( kind = 8 ) norm
16786:   integer ( kind = 4 ) p
16787:   real    ( kind = 8 ) pythag
16788:   integer ( kind = 4 ) q
16789:   integer ( kind = 4 ) r
16790:   real    ( kind = 8 ) rv1(n)
16791:   real    ( kind = 8 ) rv2(n)
16792:   real    ( kind = 8 ) rv3(n)
16793:   real    ( kind = 8 ) rv4(n)
16794:   real    ( kind = 8 ) rv5(n)
16795:   real    ( kind = 8 ) rv6(n)
16796:   integer ( kind = 4 ) s
16797:   real    ( kind = 8 ) t1
16798:   real    ( kind = 8 ) t2
16799:   real    ( kind = 8 ) tst1
16800:   real    ( kind = 8 ) tst2
16801:   real    ( kind = 8 ) u
16802:   real    ( kind = 8 ) ub
16803:   real    ( kind = 8 ) uk
16804:   real    ( kind = 8 ) v
16805:   real    ( kind = 8 ) w(mm)
16806:   real    ( kind = 8 ) x0
16807:   real    ( kind = 8 ) x1
16808:   real    ( kind = 8 ) xu
16809:   real    ( kind = 8 ) z(n,mm)
16810: 
16811:   ierr = 0
16812:   s = 0
16813:   t1 = lb
16814:   t2 = ub
16815: !
16816: !  Look for small sub-diagonal entries.
16817: !
16818:   e2(1) = 0.0D+00
16819: 
16820:   do i = 2, n
16821: 
16822:     tst1 = abs ( d(i) ) + abs ( d(i-1) )
16823:     tst2 = tst1 + abs ( e(i) )
16824: 
16825:     if ( tst2 <= tst1 ) then
16826:       e2(i) = 0.0D+00
16827:     end if
16828: 
16829:   end do
16830: !
16831: !  Determine the number of eigenvalues in the interval.
16832: !
16833:   p = 1
16834:   q = n
16835:   x1 = ub
16836:   isturm = 1
16837:   go to 320
16838: 
16839: 60 continue
16840: 
16841:   m = s
16842:   x1 = lb
16843:   isturm = 2
16844:   go to 320
16845: 
16846: 80 continue
16847: 
16848:   m = m - s
16849: 
16850:   if ( m > mm ) go to 980
16851: 
16852:   q = 0
16853:   r = 0
16854: !
16855: !  Establish and process next submatrix, refining interval by the 
16856: !  Gerschgorin bounds.
16857: !
16858: 100 continue
16859: 
16860:   if ( r == m ) go to 1001
16861: 
16862:   p = q + 1
16863:   xu = d(p)
16864:   x0 = d(p)
16865:   u = 0.0D+00
16866: 
16867:   do q = p, n
16868: 
16869:      x1 = u
16870:      u = 0.0D+00
16871:      v = 0.0D+00
16872: 
16873:      if ( q /= n ) then
16874:        u = abs ( e(q+1) )
16875:        v = e2(q+1)
16876:      end if
16877: 
16878:      xu = min ( d(q)-(x1+u), xu )
16879:      x0 = max ( d(q)+(x1+u), x0 )
16880: 
16881:      if ( v == 0.0D+00 ) then
16882:        exit
16883:      end if
16884: 
16885:   end do
16886: 
16887:   x1 = max ( abs ( xu ), abs ( x0 ) ) * epsilon ( x1 )
16888: 
16889:   if ( eps1 <= 0.0D+00 ) then
16890:     eps1 = -x1
16891:   end if
16892: 
16893:   if ( p /= q ) go to 180
16894: !
16895: !  Check for isolated root within interval.
16896: !
16897:   if ( t1 > d(p) .or. d(p) >= t2 ) go to 940
16898: 
16899:   r = r + 1
16900: 
16901:   z(1:n,r) = 0.0D+00
16902: 
16903:   w(r) = d(p)
16904:   z(p,r) = 1.0D+00
16905:   go to 940
16906: 
16907: 180 continue
16908: 
16909:   u = q - p + 1
16910:   x1 = u * x1
16911:   lb = max ( t1, xu-x1 )
16912:   ub = min ( t2, x0+x1 )
16913:   x1 = lb
16914:   isturm = 3
16915:   go to 320
16916: 
16917: 200 continue
16918: 
16919:   m1 = s + 1
16920:   x1 = ub
16921:   isturm = 4
16922:   go to 320
16923: 
16924: 220 continue
16925: 
16926:   m2 = s
16927:   if ( m1 > m2 ) go to 940
16928: !
16929: !  Find roots by bisection.
16930: !
16931:   x0 = ub
16932:   isturm = 5
16933: 
16934:   rv5(m1:m2) = ub
16935:   rv4(m1:m2) = lb
16936: !
16937: !  Loop for K-th eigenvalue.
16938: !
16939:   k = m2
16940: 
16941: 250 continue
16942: 
16943:   xu = lb
16944: 
16945:   do ii = m1, k
16946: 
16947:     i = m1 + k - ii
16948: 
16949:     if ( xu < rv4(i) ) then
16950:       xu = rv4(i)
16951:       exit
16952:     end if
16953: 
16954:   end do
16955: 
16956:   if ( x0 > rv5(k) ) x0 = rv5(k)
16957: !
16958: !  Next bisection step.
16959: !
16960: 300 continue
16961: 
16962:      x1 = ( xu + x0 ) * 0.5D+00
16963:      if ( ( x0 - xu ) <= abs ( eps1 ) ) go to 420
16964:      tst1 = 2.0D+00 * ( abs ( xu ) + abs ( x0 ) )
16965:      tst2 = tst1 + (x0 - xu)
16966:      if ( tst2 == tst1 ) go to 420
16967: !
16968: !  Sturm sequence.
16969: !
16970: 320  continue
16971: 
16972:      s = p - 1
16973:      u = 1.0D+00
16974: 
16975:      do i = p, q
16976: 
16977:         if ( u /= 0.0D+00 ) go to 325
16978:         v = abs ( e(i) ) / epsilon ( v )
16979:         if ( e2(i) == 0.0D+00 ) v = 0.0D+00
16980:         go to 330
16981: 
16982: 325     continue
16983: 
16984:         v = e2(i) / u
16985: 330     continue
16986: 
16987:         u = d(i) - x1 - v
16988:         if ( u < 0.0D+00 ) s = s + 1
16989: 
16990:      end do
16991: 
16992:      go to ( 60,80,200,220,360 ), isturm
16993: !
16994: !  Refine intervals.
16995: !
16996: 360  continue
16997: 
16998:      if ( s >= k ) go to 400
16999:      xu = x1
17000:      if ( s >= m1 ) go to 380
17001:      rv4(m1) = x1
17002:      go to 300
17003: 
17004: 380  continue
17005: 
17006:      rv4(s+1) = x1
17007:      if ( rv5(s) > x1 ) then
17008:        rv5(s) = x1
17009:      end if
17010:      go to 300
17011: 
17012: 400  continue
17013: 
17014:      x0 = x1
17015:      go to 300
17016: !
17017: !  K-th eigenvalue found.
17018: !
17019: 420  continue
17020: 
17021:   rv5(k) = x1
17022:   k = k - 1
17023:   if ( k >= m1 ) go to 250
17024: !
17025: !  Find vectors by inverse iteration.
17026: !
17027:   norm = abs ( d(p) )
17028:   ip = p + 1
17029: 
17030:   do i = ip, q
17031:     norm = max ( norm, abs ( d(i) ) + abs ( e(i) ) )
17032:   end do
17033: !
17034: !  EPS2 is the criterion for grouping,
17035: !  EPS3 replaces zero pivots and equal roots are modified by eps3,
17036: !  EPS4 is taken very small to avoid overflow.
17037: !
17038:   eps2 = 0.001D+00 * norm
17039:   eps3 = abs ( norm ) * epsilon ( eps3 )
17040:   uk = q - p + 1
17041:   eps4 = uk * eps3
17042:   uk = eps4 / sqrt ( uk )
17043:   group = 0
17044:   s = p
17045: 
17046:   do k = m1, m2
17047: 
17048:      r = r + 1
17049:      its = 1
17050:      w(r) = rv5(k)
17051:      x1 = rv5(k)
17052: !
17053: !  Look for close or coincident roots.
17054: !
17055:      if ( k /= m1 ) then
17056:        if ( x1 - x0 >= eps2 ) group = -1
17057:        group = group + 1
17058:        if ( x1 <= x0 ) then
17059:          x1 = x0 + eps3
17060:        end if
17061:      end if
17062: !
17063: !  Elimination with interchanges and initialization of vector.
17064: !
17065:      v = 0.0D+00
17066: 
17067:      do i = p, q
17068: 
17069:         rv6(i) = uk
17070: 
17071:         if ( i == p ) go to 560
17072: 
17073:         if ( abs ( e(i) ) >= abs ( u ) ) then
17074:           xu = u / e(i)
17075:           rv4(i) = xu
17076:           rv1(i-1) = e(i)
17077:           rv2(i-1) = d(i) - x1
17078:           rv3(i-1) = 0.0D+00
17079:           if ( i /= q ) rv3(i-1) = e(i+1)
17080:           u = v - xu * rv2(i-1)
17081:           v = -xu * rv3(i-1)
17082:           cycle
17083:         end if
17084: 
17085:         xu = e(i) / u
17086:         rv4(i) = xu
17087:         rv1(i-1) = u
17088:         rv2(i-1) = v
17089:         rv3(i-1) = 0.0D+00
17090: 
17091: 560     continue
17092: 
17093:         u = d(i) - x1 - xu * v
17094: 
17095:         if ( i /= q ) then
17096:           v = e(i+1)
17097:         end if
17098: 
17099:      end do
17100: 
17101:      if ( u == 0.0D+00 ) u = eps3
17102:      rv1(q) = u
17103:      rv2(q) = 0.0D+00
17104:      rv3(q) = 0.0D+00
17105: !
17106: !  Back substitution.
17107: !
17108: 600  continue
17109: 
17110:      do ii = p, q
17111:         i = p + q - ii
17112:         rv6(i) = ( rv6(i) - u * rv2(i) - v * rv3(i) ) / rv1(i)
17113:         v = u
17114:         u = rv6(i)
17115:      end do
17116: !
17117: !  Orthogonalize with respect to previous members of group.
17118: !
17119:      do jj = 1, group
17120:         j = r - group - 1 + jj
17121:         xu = dot_product ( rv6(p:q), z(p:q,j) )
17122:         rv6(p:q) = rv6(p:q) - xu * z(p:q,j)
17123:      end do
17124: 
17125:      norm = sum ( abs ( rv6(p:q) ) )
17126: 
17127:      if ( norm >= 1.0D+00 ) then
17128:        go to 840
17129:      end if
17130: !
17131: !  Forward substitution.
17132: !
17133:      if ( its == 5 ) then
17134:        ierr = 4 * n + r
17135:        go to 1001
17136:      end if
17137: 
17138:      if ( norm == 0.0D+00 ) then
17139:        rv6(s) = eps4
17140:        s = s + 1
17141:        if ( s > q ) then
17142:          s = p
17143:        end if
17144:        go to 780
17145:      end if
17146: 
17147:     xu = eps4 / norm
17148: 
17149:      rv6(p:q) = rv6(p:q) * xu
17150: !
17151: !  Elimination operations on next vector iterate.
17152: !
17153: 780    continue
17154: !
17155: !  If rv1(i-1) == e(i), a row interchange was performed earlier in the
17156: !  triangularization process.
17157: !
17158:      do i = p, q
17159: 
17160:        u = rv6(i)
17161: 
17162:        if ( rv1(i-1) == e(i) ) then
17163:          u = rv6(i-1)
17164:          rv6(i-1) = rv6(i)
17165:        end if
17166: 
17167:        rv6(i) = u - rv4(i) * rv6(i-1)
17168: 
17169:      end do
17170: 
17171:      its = its + 1
17172:      go to 600
17173: !
17174: !  Normalize so that sum of squares is 1 and expand to full order.
17175: !
17176: 840  continue
17177: 
17178:      u = 0.0D+00
17179: 
17180:      do i = p, q
17181:        u = <a href="./eispack.f90.html#pythag" TARGET=CENT_PANEL>pythag</a> ( u, rv6(i) )
17182:      end do
17183: 
17184:      xu = 1.0D+00 / u
17185: 
17186:      z(1:n,r) = 0.0D+00
17187:      z(p:q,r) = rv6(p:q) * xu
17188: 
17189:      x0 = x1
17190:   
17191:   end do
17192: 
17193: 940 continue
17194: 
17195:   if ( q < n ) then
17196:     go to 100
17197:   end if
17198: 
17199:   go to 1001
17200: !
17201: !  Set error: underestimate of number of eigenvalues in interval.
17202: !
17203: 980 continue
17204: 
17205:   ierr = 3 * n + 1
17206: 
17207: 1001 continue
17208: 
17209:   lb = t1
17210:   ub = t2
17211: 
17212:   return
17213: end
</PRE>

<HR>

</BODY>
</HTML>
