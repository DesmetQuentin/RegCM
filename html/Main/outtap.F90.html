<HTML>

<HEAD>
<TITLE>outtap.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>outtap.F90</H1>
<HR>
<H2 ALIGN=CENTER>outtap.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=outtap><H3>outtap</H3></a></p> Click <a href="./callingtree/outtap_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where outtap is used.
<hr>
20:       subroutine outtap
21: 
22: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
23: !                                                                     c
24: !     this subroutine writes the model output to tape or disk for use c
25: !     in dataflow analyses.                                           c
26: !                                                                     c
27: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
28: 
29:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
30:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a>
31:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a>
32:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : r8pt
33:       use <a href="./mod_iunits.f90.html#mod_iunits" TARGET=CENT_PANEL>mod_iunits</a>
34:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
35:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a>
36:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a>
37:       use <a href="./mod_cvaria.F90.html#mod_cvaria" TARGET=CENT_PANEL>mod_cvaria</a>
38: #ifdef MPP1
39:       use <a href="./mod_mppio.F90.html#mod_mppio" TARGET=CENT_PANEL>mod_mppio</a>
40: #endif
41:       implicit none
42: !
43: ! Local variables
44: !
45:       real(4) , dimension(jxm2,iym2) :: fout
46:       real(8) , dimension(jx,iy) :: out1
47:       integer :: i , j , k , n , nn
48:       real(8) :: mmpd
49: !
50:  
51: !
52: !
53: !---------------------------------------------------------------------
54: !-----output RegCM-domain variables:
55: !
56:       if ( iotyp.eq.2 ) write (iutdat) idatex
57: !
58: !     ******  write one time of data to mm4 output file.
59:  
60:       do k = kz , 1 , -1
61:         do i = 1 , iy
62:           do j = 1 , jx
63: #ifdef MPP1
64:             out1(j,i) = ua_io(i,k,j)
65: #else
66:             out1(j,i) = ua(i,k,j)
67: #endif
68:           end do
69:         end do
70:         do i = 1 , iym2
71:           do j = 1 , jxm2
72: #ifdef MPP1
73:             fout(j,i) = 0.25*(out1(j+1,i+1)+out1(j+2,i+1)+out1(j+1,i+2) &
74:                       & +out1(j+2,i+2))/psa_io(i+1,j+1)
75: #else
76:             fout(j,i) = 0.25*(out1(j+1,i+1)+out1(j+2,i+1)+out1(j+1,i+2) &
77:                       & +out1(j+2,i+2))/psa(i+1,j+1)
78: #endif
79:           end do
80:         end do
81:         if ( iotyp.eq.1 ) then
82:           nrcout = nrcout + 1
83:           write (iutdat,rec=nrcout) fout
84:         else if ( iotyp.eq.2 ) then
85:           write (iutdat) fout
86:         else
87:         end if
88:       end do
89:       do k = kz , 1 , -1
90:         do i = 1 , iy
91:           do j = 1 , jx
92: #ifdef MPP1
93:             out1(j,i) = va_io(i,k,j)
94: #else
95:             out1(j,i) = va(i,k,j)
96: #endif
97:           end do
98:         end do
99:         do i = 1 , iym2
100:           do j = 1 , jxm2
101: #ifdef MPP1
102:             fout(j,i) = 0.25*(out1(j+1,i+1)+out1(j+2,i+1)+out1(j+1,i+2) &
103:                       & +out1(j+2,i+2))/psa_io(i+1,j+1)
104: #else
105:             fout(j,i) = 0.25*(out1(j+1,i+1)+out1(j+2,i+1)+out1(j+1,i+2) &
106:                       & +out1(j+2,i+2))/psa(i+1,j+1)
107: #endif
108:           end do
109:         end do
110:         if ( iotyp.eq.1 ) then
111:           nrcout = nrcout + 1
112:           write (iutdat,rec=nrcout) fout
113:         else if ( iotyp.eq.2 ) then
114:           write (iutdat) fout
115:         else
116:         end if
117:       end do
118:       do k = kz , 1 , -1
119:         do i = 1 , iym2
120:           do j = 1 , jxm2
121: #ifdef MPP1
122:             fout(j,i) = omega_io(i+1,k,j+1)
123: #else
124:             fout(j,i) = omega(i+1,k,j+1)
125: #endif
126:           end do
127:         end do
128:         if ( iotyp.eq.1 ) then
129:           nrcout = nrcout + 1
130:           write (iutdat,rec=nrcout) fout
131:         else if ( iotyp.eq.2 ) then
132:           write (iutdat) fout
133:         else
134:         end if
135:       end do
136:       do k = kz , 1 , -1
137:         do i = 1 , iym2
138:           do j = 1 , jxm2
139: #ifdef MPP1
140:             fout(j,i) = ta_io(i+1,k,j+1)/psa_io(i+1,j+1)
141: #else
142:             fout(j,i) = ta(i+1,k,j+1)/psa(i+1,j+1)
143: #endif
144:           end do
145:         end do
146:         if ( iotyp.eq.1 ) then
147:           nrcout = nrcout + 1
148:           write (iutdat,rec=nrcout) fout
149:         else if ( iotyp.eq.2 ) then
150:           write (iutdat) fout
151:         else
152:         end if
153:       end do
154:       do k = kz , 1 , -1
155:         do i = 1 , iym2
156:           do j = 1 , jxm2
157: #ifdef MPP1
158:             fout(j,i) = qva_io(i+1,k,j+1)/psa_io(i+1,j+1)
159: #else
160:             fout(j,i) = qva(i+1,k,j+1)/psa(i+1,j+1)
161: #endif
162:           end do
163:         end do
164:         if ( iotyp.eq.1 ) then
165:           nrcout = nrcout + 1
166:           write (iutdat,rec=nrcout) fout
167:         else if ( iotyp.eq.2 ) then
168:           write (iutdat) fout
169:         else
170:         end if
171:       end do
172:       do k = kz , 1 , -1
173:         do i = 1 , iym2
174:           do j = 1 , jxm2
175: #ifdef MPP1
176:             if ( qca_io(i+1,k,j+1).lt.1E-30 ) then
177:               fout(j,i) = 0.0
178:             else
179:               fout(j,i) = qca_io(i+1,k,j+1)/psa_io(i+1,j+1)
180:             end if
181: #else
182:             if ( qca(i+1,k,j+1).lt.1E-30 ) then
183:               fout(j,i) = 0.0
184:             else
185:               fout(j,i) = qca(i+1,k,j+1)/psa(i+1,j+1)
186:             end if
187: #endif
188:           end do
189:         end do
190:         if ( iotyp.eq.1 ) then
191:           nrcout = nrcout + 1
192:           write (iutdat,rec=nrcout) fout
193:         else if ( iotyp.eq.2 ) then
194:           write (iutdat) fout
195:         else
196:         end if
197:       end do
198:       do i = 1 , iym2
199:         do j = 1 , jxm2
200: #ifdef MPP1
201:           fout(j,i) = (psa_io(i+1,j+1)+r8pt)*10.
202: #else
203:           fout(j,i) = (psa(i+1,j+1)+r8pt)*10.
204: #endif
205:         end do
206:       end do
207:       if ( iotyp.eq.1 ) then
208:         nrcout = nrcout + 1
209:         write (iutdat,rec=nrcout) fout
210:       else if ( iotyp.eq.2 ) then
211:         write (iutdat) fout
212:       else
213:       end if
214:       mmpd = 24./tapfrq
215:       do i = 1 , iym2
216:         do j = 1 , jxm2
217: #ifdef MPP1
218:           if ( rainc_io(i+1,j+1) .gt. 1E-30 .or.                        &
219:                rainnc_io(i+1,j+1) .gt. 1E-30) then
220:             fout(j,i) = (rainc_io(i+1,j+1)+rainnc_io(i+1,j+1))*mmpd
221:           else
222:             fout(j,i) = 0.0
223:           end if
224: #else
225:           if ( rainc(i+1,j+1) .gt. 1E-30 .or.                        &
226:                rainnc(i+1,j+1) .gt. 1E-30) then
227:             fout(j,i) = (rainc(i+1,j+1)+rainnc(i+1,j+1))*mmpd
228:           else
229:             fout(j,i) = 0.0
230:           end if
231: #endif
232:         end do
233:       end do
234:       if ( iotyp.eq.1 ) then
235:         nrcout = nrcout + 1
236:         write (iutdat,rec=nrcout) fout
237:       else if ( iotyp.eq.2 ) then
238:         write (iutdat) fout
239:       else
240:       end if
241:  
242: !     ****** write out the following surface fields:
243: !     1.  temp of lower soil layer (17)
244: !     2.  total soil water in mm h2o (13)
245: !     3.  accum infiltration (30)
246:       do i = 1 , iym2
247:         do j = 1 , jxm2
248: #ifdef MPP1
249:           fout(j,i) = tgb2d_io(1,i+1,j+1)
250:           do n = 2 , nnsg
251:             fout(j,i) = fout(j,i) + tgb2d_io(n,i+1,j+1)
252:           end do
253: #else
254:           fout(j,i) = tgb2d(1,i+1,j+1)
255:           do n = 2 , nnsg
256:             fout(j,i) = fout(j,i) + tgb2d(n,i+1,j+1)
257:           end do
258: #endif
259:           fout(j,i) = fout(j,i)/float(nnsg)
260:         end do
261:       end do
262:       if ( iotyp.eq.1 ) then
263:         nrcout = nrcout + 1
264:         write (iutdat,rec=nrcout) fout
265:       else if ( iotyp.eq.2 ) then
266:         write (iutdat) fout
267:       else
268:       end if
269:  
270:       do i = 1 , iym2
271:         do j = 1 , jxm2
272:           fout(j,i) = 0.0
273:           nn = 0
274:           do n = 1 , nnsg
275: #ifdef MPP1
276:             if ( ocld2d_io(n,i+1,j+1).ge.0.5 ) then
277:               fout(j,i) = fout(j,i) + swt2d_io(n,i+1,j+1)
278:               nn = nn + 1
279:             end if
280: #else
281:             if ( ocld2d(n,i+1,j+1).ge.0.5 ) then
282:               fout(j,i) = fout(j,i) + swt2d(n,i+1,j+1)
283:               nn = nn + 1
284:             end if
285: #endif
286:           end do
287:           if ( nn.ge.max0(nnsg/2,1) ) then
288:             fout(j,i) = fout(j,i)/float(nn)
289:           else
290:             fout(j,i) = -1.E34
291:           end if
292:         end do
293:       end do
294:       if ( iotyp.eq.1 ) then
295:         nrcout = nrcout + 1
296:         write (iutdat,rec=nrcout) fout
297:       else if ( iotyp.eq.2 ) then
298:         write (iutdat) fout
299:       else
300:       end if
301:  
302:       do i = 1 , iym2
303:         do j = 1 , jxm2
304:           fout(j,i) = 0.0
305:           nn = 0
306:           do n = 1 , nnsg
307: #ifdef MPP1
308:             if ( ocld2d_io(n,i+1,j+1).ge.0.5 ) then
309:               fout(j,i) = fout(j,i) + rno2d_io(n,i+1,j+1)
310:               nn = nn + 1
311:             end if
312: #else
313:             if ( ocld2d(n,i+1,j+1).ge.0.5 ) then
314:               fout(j,i) = fout(j,i) + rno2d(n,i+1,j+1)
315:               nn = nn + 1
316:             end if
317: #endif
318:           end do
319:           if ( nn.ge.max0(nnsg/2,1) ) then
320:             fout(j,i) = fout(j,i)/float(nn)
321:           else
322:             fout(j,i) = -1.E34
323:           end if
324:         end do
325:       end do
326:       if ( iotyp.eq.1 ) then
327:         nrcout = nrcout + 1
328:         write (iutdat,rec=nrcout) fout
329:       else if ( iotyp.eq.2 ) then
330:         write (iutdat) fout
331:       else
332:       end if
333:  
334: !     changes for accum infiltration
335:    
336: #ifdef MPP1
337:       rno2d_io  = 0.0
338:       rainc_io  = 0.0
339:       rainnc_io = 0.0
340: #else
341:       rno2d  = 0.0
342:       rainc  = 0.0
343:       rainnc = 0.0
344: #endif
345:  
346:       print * , 'OUT-history written date = ' , ldatez + xtime/1440.
347:  
348:       end subroutine outtap
</PRE>

<HR>

</BODY>
</HTML>
