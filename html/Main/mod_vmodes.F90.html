<HTML>

<HEAD>
<TITLE>mod_vmodes.F90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_vmodes.F90</H1>
<HR>
<H2 ALIGN=CENTER>mod_vmodes.F90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=mod_vmodes><H3>mod_vmodes</H3></a></p>20:       module mod_vmodes
21: 
22:       private
23: 
24:       public :: vmodes
25: 
26:       contains
27: 
<p><a name=vmodes><H3>vmodes</H3></a></p> Click <a href="./callingtree/vmodes_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vmodes is used.
<hr>
28:       subroutine vmodes(lstand,sigmaf,kv1)
29: !
30:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
31:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a>
32:       use <a href="./mod_split.F90.html#mod_split" TARGET=CENT_PANEL>mod_split</a>
33:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgas , rovcp
34:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : r8pt
35:       use <a href="./mod_message.F90.html#mod_message" TARGET=CENT_PANEL>mod_message</a>
36:       implicit none
37: !
38: ! Dummy arguments
39: !
40:       integer :: kv1
41:       logical :: lstand
42:       real(8) , dimension(kv1) :: sigmaf
43:       intent (in) kv1 , lstand
44: !
45: ! Local variables
46: !
47:       real(8) , dimension(2) :: det
48:       integer :: ier , k , k1 , k2 , l , mm , numerr
49:       logical :: lhydro , lprint , lsigma
50:       real(8) :: ps2 , x
51:       real(8) , dimension(kz) :: work
52:       real(8) , dimension(1) :: pps
53: !
54: !  this subroutine determines the vertical modes of the psu/ncar meso-
55: !  scale model designated mm4.  it also computes associated transform
56: !  matrices used by the initialization software used with mm4.
57: !
58: !----------------------------------------------------------------------
59: !
60: !
61: !   the following are user set parameters:
62: !
63: ! iy,jx  = dimension of horizontal grid (later called ni,nj).
64: !          as in mm4, iy is for n-s direction, jx for w-e direction.
65: ! kz     = number of model data levels
66: ! dt     = time step used to generate tendencies (later called delt)
67: ! dx     = grid spacing at center in meters (later called delx).
68: ! clat   = latitude of central point, used to determine coriolis param.
69: ! r8pt   = model top in units of cb
70: !
71: !
72: !     programmed by ronald m. errico at ncar,  dec 1984.
73: !     revised by ronald errico and gary bates, nov 1987.
74: !     revised by ronald errico,                mar 1988.
75: !     for further info see: ncar tech note by errico and bates, 1988.
76: !
77: !  iunit is the output unit number for file of eigenvectors, etc.
78: !  lstand = .true. if standard atmosphere t to be used (ignore input
79: !            tbarh and ps in that case).  otherwise, ps and tbarh must
80: !            be defined on input.  note that in either case, r8pt must
81: !            also be defined on input (common block named cvert).
82: !
83:       data lprint/.false./  ! true if all matrices to be printed
84: !
85:       numerr = 0
86:       lprint = .false.
87: ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
88: !
89: !                            s  t  a  r  t
90: !
91: ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
92: !
93: !       set arrays describing vertical structure
94: !
95: !  set reference pressures
96:       if ( lstand ) ps = 100.
97:                             ! standard ps in cb; otherwise ps set in tav
98:       pd = ps - r8pt
99: !
100: !  read sigmaf (sigma at full (integral) index levels; kzp1 values as
101: !  in the mm4.   check that values are ordered properly.
102: !
103:       write (aline,*) 'Calculating Vertical Modes'
104:       call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
105:       if ( lstand ) then
106:         write (aline,*) '- Linearization about standard atmosphere'
107:         call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
108:       else
109:         write (aline,*) '- Linearization about horizontal mean of data'
110:         call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
111:       end if
112: !
113:       lsigma = .false.
114:       if ( sigmaf(1).ne.0. ) lsigma = .true.
115:       if ( sigmaf(kzp1).ne.1. ) lsigma = .true.
116:       do k = 1 , kz
117:         if ( sigmaf(k+1).le.sigmaf(k) ) then
118:           lsigma = .true.
119:           write (aline,99001) k , sigmaf(k+1) , sigmaf(k)
120:           call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
121:         end if
122:       end do
123:       if ( lsigma )                                                     &
124:       & call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,                                   &
125:       &          'Sigma values in list vmode inappropriate')
126: !
127: !  compute sigmah (sigma at half levels) and delta sigma
128:       do k = 1 , kz
129:         sigmah(k) = 0.5*(sigmaf(k)+sigmaf(k+1))
130:         dsigma(k) = sigmaf(k+1) - sigmaf(k)
131:       end do
132:       sigmah(kzp1) = 1.0
133: !
134: !  set tbarh (temperature at half (data) levels: indexed k + 1/2)
135:       if ( lstand ) call <a href="./vtlaps.f90.html#vtlaps" TARGET=CENT_PANEL>vtlaps</a>(tbarh,sigmah,r8pt,pd,kz)
136:       call <a href="./mod_vmodes.F90.html#vchekt" TARGET=CENT_PANEL>vchekt</a>(tbarh,sigmah,sigmaf,rovcp,r8pt,pd,kz,numerr)
137: !
138: ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
139: !
140: !      determine thermodynamic matrix
141: !
142: !  compute thetah
143: !  this array is never used: it is only computed and printed out 
144: !  the  following line causes a segfault on IBM SP6 when compiled with -q check 
145: !  because it uses F90 syntax arrays with different sizes  
146: !  S.C. 21/05/2010
147: !  I therefore decided to comment out this line 
148: !      thetah = tbarh*((sigmah+r8pt/pd)**(-rovcp))
149: 
150: !
151: !  compute tbarf and thetaf
152: !
153:       do k = 2 , kz
154:         k1 = k - 1
155:         tbarf(k) = tbarh(k1)*(sigmah(k)-sigmaf(k))                      &
156:                  & /(sigmah(k)-sigmah(k1)) + tbarh(k)                   &
157:                  & *(sigmaf(k)-sigmah(k1))/(sigmah(k)-sigmah(k1))
158:       end do
159:       tbarf(1) = 0.
160:       tbarf(kzp1) = 0.
161: !
162:       do k = 1 , kzp1
163:         if ( sigmaf(k).lt.1E-30 ) then
164:           thetaf(k) = tbarf(k)
165:         else
166:           thetaf(k) = tbarf(k)*((sigmaf(k)+r8pt/pd)**(-rovcp))
167:         end if
168:       end do
169: !
170: !  define matrices for determination of thermodynamic matrix
171: !
172:       do l = 1 , kz
173:         do k = 1 , kz
174:           if ( l.gt.k ) e2(k,l) = 0.
175:           if ( l.le.k ) e2(k,l) = 1.
176:           e1(k,l) = 1.
177:         end do
178:       end do
179: !
180:       a3 = 0.0
181:       d1 = 0.0
182:       d2 = 0.0
183:       s1 = 0.0
184:       s2 = 0.0
185:       x1 = 0.0
186: !
187:       do k = 1 , kz
188:         a3(k,k) = -tbarh(k)
189:         d1(k,k) = sigmaf(k+1) - sigmaf(k)
190:         d2(k,k) = rovcp*tbarh(k)/(sigmah(k)+r8pt/pd)
191:         s1(k,k) = sigmaf(k)
192:         s2(k,k) = sigmah(k)
193:         x1(k,k) = 1.
194:       end do
195: !
196:       do k = 1 , kz
197:         do l = 1 , kz
198:           e3(k,l) = 0.
199:           g1(k,l) = 0.
200:         end do
201:         e3(k,k) = 1.
202:         if ( k.gt.1 ) g1(k,k) = tbarf(k)
203:         if ( k.lt.kz ) g1(k,k+1) = -tbarf(k+1)
204:         if ( k.lt.kz ) e3(k,k+1) = 1.
205:       end do
206: !
207: !  compute g2 (i.e., the transform from divg. to sigma dot)
208: !
209:       w1 = e2 - x1
210:       w2 = matmul(w1,d1)
211:       g2 = matmul(e1,d1)
212:       w1 = matmul(s1,g2)
213:       g2 = w1 - w2
214: !
215: !  compute a1
216: !
217:       w2 = 0
218:       do k = 1 , kz
219:         w2(k,k) = 1.0/d1(k,k)
220:       end do
221:       w1 = matmul(g1,g2)
222:       a1 = matmul(w2,w1)
223: !
224: !  compute a2
225: !
226:       w1 = matmul(e1,d1)
227:       a2 = matmul(s2,w1)
228:       w2 = matmul(e3,g2)
229:       w2 = 0.5*w2
230:       w1 = w2-a2
231:       a2 = matmul(d2,w1)
232: !
233: !  compute a4
234: !
235:       w1 = matmul(e1,d1)
236:       a4 = matmul(a3,w1)
237:       a4 = -a4
238: !
239: !  compute a
240: !
241:       a = a1+a2+a3+a4
242: !
243: ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
244: !
245: !       determine matrices for linearized determination of geopotential
246: !
247: !  compute delta log p
248:       do k = 2 , kz
249:         w1(k,1) = dlog((sigmah(k)+r8pt/pd)/(sigmah(k-1)+r8pt/pd))
250:       end do
251: !
252: !  compute matrix which multiples t vector
253: !
254:       hydros = 0.0
255: !
256:       do k = 1 , kz - 1
257:         do l = k , kz - 1
258:           hydros(k,l) = hydros(k,l) + w1(l+1,1)*dsigma(l)               &
259:                       & /(dsigma(l+1)+dsigma(l))
260:           hydros(k,l+1) = hydros(k,l+1) + w1(l+1,1)*dsigma(l+1)         &
261:                         & /(dsigma(l+1)+dsigma(l))
262:         end do
263:       end do
264: !
265:       do k = 1 , kz
266:         hydros(k,kz) = hydros(k,kz)                                     &
267:                      & + dlog((1.+r8pt/pd)/(sigmah(kz)+r8pt/pd))
268:       end do
269: !
270: !  compute matirx which multiplies log(sigma*p+r8pt) vector
271: !
272:       hydroc = 0.0
273: !
274:       tweigh(1) = 0.
275:       do l = 2 , kz
276:         tweigh(l) = (tbarh(l)*dsigma(l)+tbarh(l-1)*dsigma(l-1))         &
277:                   & /(dsigma(l)+dsigma(l-1))
278:       end do
279: !
280:       do l = 2 , kz - 1
281:         do k = 1 , l - 1
282:           hydroc(k,l) = tweigh(l) - tweigh(l+1)
283:         end do
284:       end do
285: !
286:       do l = 1 , kz - 1
287:         hydroc(l,l) = tbarh(l) - tweigh(l+1)
288:       end do
289: !
290:       do k = 1 , kz - 1
291:         hydroc(k,kz) = tweigh(kz) - tbarh(kz)
292:       end do
293: !
294:       do k = 1 , kz
295:         hydroc(k,kzp1) = tbarh(kz)
296:       end do
297: !
298: !  test hydroc and hydros matrices (if correct, w1(k,1)=w1(k,2))
299: !
300:       lhydro = .false.
301:       do k = 1 , kz
302:         w1(k,1) = 0.
303:         do l = 1 , kz
304:           w1(k,1) = w1(k,1) + hydros(k,l)*tbarh(l)
305:         end do
306:         w1(k,2) = -tbarh(k)*dlog(sigmah(k)*pd+r8pt)
307:         do l = 1 , kzp1
308:           w1(k,2) = w1(k,2) + hydroc(k,l)*dlog(sigmah(l)*pd+r8pt)
309:         end do
310:         x = dabs(w1(k,1)-w1(k,2))/(dabs(w1(k,1))+dabs(w1(k,2)))
311:         if ( x.gt.1.E-8 ) lhydro = .true.
312:       end do
313: !
314:       if ( lhydro ) then
315:         numerr = numerr + 1
316:         print 99002
317:         call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(w1(1,1),kz,'test1   ')
318:         call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(w1(1,2),kz,'test2   ')
319:       end if
320: !
321: ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
322: !
323: !       determine tau matrix
324: !
325:       do l = 1 , kz
326:         do k = 1 , kzp1
327:           w3(k,l) = dsigma(l)/(1.+r8pt/(pd*sigmah(k)))
328:         end do
329:       end do
330: !
331:       do l = 1 , kz
332:         do k = 1 , kz
333:           w2(k,l) = 0.
334:           do mm = 1 , kzp1
335:             w2(k,l) = w2(k,l) + hydroc(k,mm)*w3(mm,l)
336:           end do
337:         end do
338:       end do
339: !
340:       w1 = matmul(hydros,a)
341:       tau = w1-w2
342:       tau = -rgas*tau
343: !
344: ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
345: !
346: !       determine other matrices and vectors
347: !
348: !  compute eigenvalues and vectors for tau (rg calls eispack routines)
349: !
350:       w1 = tau
351:       call <a href="./eispack.f90.html#rg" TARGET=CENT_PANEL>rg</a>(kz,w1,hbar,w2,1,zmatx,ier)
352:       call <a href="./mod_vmodes.F90.html#vcheki" TARGET=CENT_PANEL>vcheki</a>(ier,numerr,'zmatx   ')
353:       call <a href="./mod_vmodes.F90.html#vcheke" TARGET=CENT_PANEL>vcheke</a>(hbar,w2,kz,numerr,'tau     ')
354:       call <a href="./mod_vmodes.F90.html#vorder" TARGET=CENT_PANEL>vorder</a>(zmatx,hbar,w1,w2,kz)
355:       call <a href="./mod_vmodes.F90.html#vnorml" TARGET=CENT_PANEL>vnorml</a>(zmatx,sigmaf,kz,kzp1)
356: !
357: !  compute inverse of zmatx
358: !
359:       call <a href="./mod_vmodes.F90.html#invmtrx" TARGET=CENT_PANEL>invmtrx</a>(zmatx,kz,zmatxr,kz,kz,det,iw2,ier,work)
360:       call <a href="./mod_vmodes.F90.html#vcheki" TARGET=CENT_PANEL>vcheki</a>(ier,numerr,'zmatxr  ')
361: !
362: !  compute inverse of hydros
363: !
364:       call <a href="./mod_vmodes.F90.html#invmtrx" TARGET=CENT_PANEL>invmtrx</a>(hydros,kz,hydror,kz,kz,det,iw2,ier,work)
365:       call <a href="./mod_vmodes.F90.html#vcheki" TARGET=CENT_PANEL>vcheki</a>(ier,numerr,'hydror  ')
366: !
367: !  compute cpfac
368: !
369:       call <a href="./mod_vmodes.F90.html#invmtrx" TARGET=CENT_PANEL>invmtrx</a>(tau,kz,w1,kz,kz,det,iw2,ier,work)
370:       call <a href="./mod_vmodes.F90.html#vcheki" TARGET=CENT_PANEL>vcheki</a>(ier,numerr,'taur    ')
371: !
372:       do k = 1 , kz
373:         cpfac(k) = 0.
374:         do l = 1 , kz
375:           cpfac(k) = cpfac(k) + (sigmaf(l+1)-sigmaf(l))*w1(l,k)
376:         end do
377:       end do
378: !
379: ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
380: !
381: !       determine arrays needed for daley's variational scheme
382: !             for determination of surface pressure changes
383: !
384:       hweigh = 0.0
385:       hweigh(kz) = 1.    ! only lowest sigma level t considered
386: !
387:       do k1 = 1 , kz
388:         do k2 = 1 , kz    ! compute b(-1t) w/tbar**2 b(-1)
389:           w1(k2,k1) = 0.
390:           do k = 1 , kz
391:             w1(k2,k1) = hydror(k,k2)*hydror(k,k1)*hweigh(k)/            &
392:                     & (tbarh(k)**2)+w1(k2,k1)
393:           end do
394:         end do
395:       end do
396: !
397:       ps2 = ps*ps
398:       do k1 = 1 , kzp1
399:         do k2 = 1 , kz
400:           varpa1(k2,k1) = 0.
401:           do k = 1 , kz
402:             varpa1(k2,k1) = varpa1(k2,k1) + w1(k2,k)*hydroc(k,k1)*ps2
403:           end do
404:         end do
405:       end do
406: !
407:       do k1 = 1 , kzp1
408:         do k2 = 1 , kzp1
409:           varpa2(k2,k1) = 0.
410:           do k = 1 , kz
411:             varpa2(k2,k1) = varpa2(k2,k1) + hydroc(k,k2)*varpa1(k,k1)
412:           end do
413:         end do
414:       end do
415: !
416:       alpha1 = hydros(kz,kz)*tbarh(kz)/ps
417:       alpha2 = hweigh(kz)
418: !
419: ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
420: !
421: !       output desired arrays
422: !
423: #ifdef MPP1
424:       if ( myid.eq.0 ) then
425: #endif
426:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(sigmaf,kzp1,'sigmaf  ')
427:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(tbarh,kz,'t mean  ')
428:       pps(1) = ps
429:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(pps,1,'ps mean ')
430:       print 99003 , kz , numerr
431: #ifdef MPP1
432:       end if
433: #endif
434: !
435: !  printout if desired
436:       if ( .not.lprint ) then
437:         return
438:       end if
439:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(cpfac,kz,'cpfac   ')
440:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(dsigma,kz,'dsigma  ')
441:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(hbar,kz,'hbar    ')
442:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(sigmah,kzp1,'sigmah  ')
443:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(tbarf,kzp1,'tbarf   ')
444:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(thetah,kz,'thetah  ')
445:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(thetaf,kzp1,'thetaf  ')
446:       call <a href="./mod_vmodes.F90.html#vprntv" TARGET=CENT_PANEL>vprntv</a>(hweigh,kz,'hweigh  ')
447:       print 99004 , alpha1 , alpha2
448:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(a,kz,kz,'a       ')
449:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(hydros,kz,kz,'hydros  ')
450:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(hydror,kz,kz,'hydror  ')
451:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(hydroc,kz,kzp1,'hydroc  ')
452:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(tau,kz,kz,'tau     ')
453:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(zmatx,kz,kz,'zmatx   ')
454:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(zmatxr,kz,kz,'zmatxr  ')
455:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(varpa1,kz,kzp1,'varpa1  ')
456:       call <a href="./mod_vmodes.F90.html#vprntm" TARGET=CENT_PANEL>vprntm</a>(varpa2,kzp1,kzp1,'varpa2  ')
457: !
458:       return
459: 
460: 99001 format ('0 for k=',i3,' sigmaf(k+1)=',f9.6,' .le. sigmaf(k)=',    &
461:              & f9.6)
462: 99002 format ('0 problem with linearization of hydostatic equation')
463: 99003 format ('0 vertical mode problem completed for kx=',i3,5x,i1,     &
464:              &' errors detected   (should be 0)')
465: 99004 format ('0alpha1 =',1p,1E16.5,'       alpha2 =',1p,1E16.5)
466:  
467:       end subroutine vmodes
468: !
469: !  Check that eigenvalues are real and positive valued.
470: !
<p><a name=vcheke><H3>vcheke</H3></a></p> Click <a href="./callingtree/vcheke_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vcheke is used.
<hr>
471:       subroutine vcheke(er,ei,nk,numerr,aname)
472:       implicit none
473: !
474: ! PARAMETER definitions
475: !
476:       real(8) , parameter :: tol = 1.E-9
477: !
478: ! Dummy arguments
479: !
480:       character(8) :: aname
481:       integer :: nk , numerr
482:       real(8) , dimension(nk) :: ei , er
483:       intent (in) aname , ei , er , nk
484:       intent (inout) numerr
485: !
486: ! Local variables
487: !
488:       real(8) :: emax
489:       integer :: n , nimag , numneg
490: !
491:       numneg = 0
492:       emax = 0.
493:       do n = 1 , nk
494:         if ( er(n).le.0. ) numneg = numneg + 1
495:         if ( er(n).gt.emax ) emax = er(n)
496:       end do
497: !
498:       nimag = 0
499:       do n = 1 , nk
500:         if ( ei(n)/emax.gt.tol ) nimag = nimag + 1
501:       end do
502: !
503:       if ( numneg+nimag.eq.0 ) then
504:         return
505:       end if
506: !
507:       numerr = numerr + 1
508:       print 99001 , aname , numneg , nimag
509: 99001 format ('0 problem with equivalent depths determined from ',a8,/, &
510:             & 10x,i3,' depths are nonpositive valued',10x,i3,           &
511:              &' are not real')
512: !
513:       end subroutine vcheke
514: !
515: !  Flag of detected errors in linear algebra routines
516: !
<p><a name=vcheki><H3>vcheki</H3></a></p> Click <a href="./callingtree/vcheki_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vcheki is used.
<hr>
517:       subroutine vcheki(ier,numerr,aname)
518:       implicit none
519: !
520: ! Dummy arguments
521: !
522:       character(8) :: aname
523:       integer :: ier , numerr
524:       intent (in) aname , ier
525:       intent (inout) numerr
526: !
527:       if ( ier.ne.0 ) then
528:         numerr = numerr + 1
529:         print 99001 , aname , ier
530: 99001   format ('0 error in determination of ',a8,                      &
531:                &' using library routine     ier=',i4)
532:       end if
533: !
534:       end subroutine vcheki
535: !
536: !  This routine normalizes the columns of z such that the component
537: !  with the largest absolute value is positive, and the sum of the
538: !  mass-weighted squares equals one.
539: !
<p><a name=vnorml><H3>vnorml</H3></a></p> Click <a href="./callingtree/vnorml_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vnorml is used.
<hr>
540:       subroutine vnorml(z,s,nk,nk1)
541:       implicit none
542: !
543: ! Dummy arguments
544: !
545:       integer :: nk , nk1
546:       real(8) , dimension(nk1) :: s
547:       real(8) , dimension(nk,nk) :: z
548:       intent (in) nk , nk1 , s
549:       intent (inout) z
550: !
551: ! Local variables
552: !
553:       real(8) :: a , v , zmax
554:       integer :: k , kmax , l
555: !
556:       kmax = 1
557:       do l = 1 , nk
558:         zmax = -1.
559:         v = 0.
560: !
561:         do k = 1 , nk
562:           a = dabs(z(k,l))
563:           if ( a.gt.zmax ) then
564:             zmax = a
565:             kmax = k
566:           end if
567:           v = (s(k+1)-s(k))*a*a + v
568:         end do
569: !
570:         a = (z(kmax,l)/zmax)/dsqrt(v)
571:         do k = 1 , nk
572:           z(k,l) = a*z(k,l)
573:         end do
574:       end do
575: !
576:       end subroutine vnorml
577: !
578: !     Matrix inversion using linpack
579: !
<p><a name=invmtrx><H3>invmtrx</H3></a></p> Click <a href="./callingtree/invmtrx_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where invmtrx is used.
<hr>
580:       subroutine invmtrx(a,na,v,nv,n,d,ip,ier,work)
581:       use <a href="./mod_message.F90.html#mod_message" TARGET=CENT_PANEL>mod_message</a>
582:       implicit none
583:       integer na , nv , n , ier , info , ip(n)
584:       real(kind=8) a(n,n) , v(n,n) , work(n) , d(2)
585:       integer i , j , job
586: !
587: !     08/23/91 version 1.0
588: !     12/10/92 updated to correct bugs
589: !     note: different from cray routine invmtx
590: !     uses subroutines sgefa/sgedi from library linpack
591: !     see dick valent, (SCD, consulting) if problems
592: !
593:       if ( n.ne.na .or. n.ne.nv ) call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,         &
594:           &'valent invmtx: equate n, na, nv')
595: !
596:       do j = 1 , n
597:         do i = 1 , n
598:           v(i,j) = a(i,j)
599:         end do
600:       end do
601:       call <a href="./linpack.f90.html#sgefa" TARGET=CENT_PANEL>sgefa</a>(v,n,n,ip,info)
602:       if ( info.ne.0 ) then
603:         write (aline,*) 'sgefa info = ' , info
604:         call <a href="./mod_message.F90.html#say" TARGET=CENT_PANEL>say</a>
605:         call <a href="./mod_message.F90.html#fatal" TARGET=CENT_PANEL>fatal</a>(__FILE__,__LINE__,'sgefa error')
606:       end if
607:       job = 11
608:       call <a href="./linpack.f90.html#sgedi" TARGET=CENT_PANEL>sgedi</a>(v,n,n,ip,d,work,job)
609:       ier = info
610:       end subroutine invmtrx
611: !
612: !  This routine orders the components of hbar so they are largest to
613: !  smallest valued.  The columns of z are reorded so that they
614: !  correspond to the same (but reordered) components of hbar.
615: !
<p><a name=vorder><H3>vorder</H3></a></p> Click <a href="./callingtree/vorder_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vorder is used.
<hr>
616:       subroutine vorder(z,hbar,wz,wh,nk)
617:       implicit none
618: !
619: ! Dummy arguments
620: !
621:       integer :: nk
622:       real(8) , dimension(nk) :: hbar
623:       real(8) , dimension(nk,2) :: wh
624:       real(8) , dimension(nk,nk) :: wz , z
625:       intent (in) nk
626:       intent (inout) hbar , wh , wz , z
627: !
628: ! Local variables
629: !
630:       real(8) :: hmax
631:       integer :: k , kmax , l
632: !
633:       kmax = 1
634:       do k = 1 , nk
635:         wh(k,1) = hbar(k)
636:         wh(k,2) = 0.
637:         do l = 1 , nk
638:           wz(k,l) = z(k,l)
639:         end do
640:       end do
641: !
642:       do l = 1 , nk
643:         hmax = -1.D100
644:         do k = 1 , nk
645:           if ( (wh(k,2).eq.0.) .and. (wh(k,1).gt.hmax) ) then
646:             hmax = wh(k,1)
647:             kmax = k
648:           end if
649:         end do
650: !
651:         hbar(l) = hmax
652:         wh(kmax,2) = 1.
653:         do k = 1 , nk
654:           z(k,l) = wz(k,kmax)
655:         end do
656:       end do
657: !
658:       end subroutine vorder
659: !
660: !     Printout helpers
661: !
<p><a name=vprntv><H3>vprntv</H3></a></p> Click <a href="./callingtree/vprntv_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vprntv is used.
<hr>
662:       subroutine vprntv(a,n,nam)
663:       implicit none
664: !
665: ! Dummy arguments
666: !
667:       integer :: n
668:       character(8) :: nam
669:       real(8) , dimension(n) :: a
670:       intent (in) a , n , nam
671:  
672:       print 99001 , nam , a
673: 99001 format ('0',a8,1x,1p,11G11.3,1x,/,9x,1p,11G11.3)
674:       end subroutine vprntv
675: !
676: !
677: ! 
<p><a name=vprntm><H3>vprntm</H3></a></p> Click <a href="./callingtree/vprntm_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vprntm is used.
<hr>
678:       subroutine vprntm(a,n1,n2,nam)
679:       implicit none
680: !
681: ! Dummy arguments
682: !
683:       integer :: n1 , n2
684:       character(8) :: nam
685:       real(8) , dimension(n1,n2) :: a
686:       intent (in) a , n1 , n2 , nam
687: !
688: ! Local variables
689: !
690:       integer :: k , l
691:  
692:       print 99001 , nam
693:       do k = 1 , n1
694:         print 99002 , k , (a(k,l),l=1,n2)
695:       end do
696: 99001 format ('1',a8,/)
697: 99002 format (1x,i3,5x,1p,11G11.3,1x,/,9x,1p,11G11.3)
698:       end subroutine vprntm
699: !
700: !  Check if tbar is stable.  This is not the actual stability condition
701: !  consistent with the model finite differences.
702: !
<p><a name=vchekt><H3>vchekt</H3></a></p> Click <a href="./callingtree/vchekt_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where vchekt is used.
<hr>
703:       subroutine vchekt(tbarh,sigmah,sigmaf,xkappa,pt,pd,nk,numerr)
704:       implicit none
705: !
706: ! Dummy arguments
707: !
708:       integer :: nk , numerr
709:       real(8) :: pd , pt , xkappa
710:       real(8) , dimension(nk+1) :: sigmaf
711:       real(8) , dimension(nk) :: sigmah , tbarh
712:       intent (in) nk , pd , pt , sigmaf , sigmah , tbarh , xkappa
713:       intent (inout) numerr
714: !
715: ! Local variables
716: !
717:       real(8) :: ds1 , ds2 , g1 , g2 , tb
718:       integer :: k
719:       logical :: lstab
720: !
721:       lstab = .true.
722:       do k = 1 , nk - 1
723:         ds1 = sigmaf(k+1) - sigmaf(k)
724:         ds2 = sigmaf(k+2) - sigmaf(k+1)
725:         tb = (ds1*tbarh(k)+ds2*tbarh(k+1))/(ds1+ds2)
726:         g1 = xkappa*tb/(sigmaf(k+1)+pt/pd)
727:         g2 = (tbarh(k+1)-tbarh(k))/(sigmah(k+1)-sigmah(k))
728:         if ( g1-g2.lt.0. ) lstab = .false.
729:       end do
730:       if ( .not.lstab ) then
731:         numerr = numerr + 1
732:         print 99001
733: 99001   format ('0 indication that tbarh statically unstable')
734:       end if
735: !
736:       end subroutine vchekt
737:       end module mod_vmodes
</PRE>

<HR>

</BODY>
</HTML>
