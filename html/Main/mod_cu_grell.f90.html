<HTML>

<HEAD>
<TITLE>mod_cu_grell.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>mod_cu_grell.f90</H1>
<HR>
<H2 ALIGN=CENTER>mod_cu_grell.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=mod_cu_grell><H3>mod_cu_grell</H3></a></p>20:       module mod_cu_grell
21: 
22:       contains
23: 
<p><a name=cuparan><H3>cuparan</H3></a></p> Click <a href="./callingtree/cuparan_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cuparan is used.
<hr>
24:       subroutine cuparan(tten,qten,j)
25: 
26: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
27: !
28:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
29:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : dt , dtmin , nbatst
30:       use <a href="./mod_param3.f90.html#mod_param3" TARGET=CENT_PANEL>mod_param3</a> , only : r8pt , a
31:       use <a href="./mod_pmoist.F90.html#mod_pmoist" TARGET=CENT_PANEL>mod_pmoist</a>
32:       use <a href="./mod_rad.F90.html#mod_rad" TARGET=CENT_PANEL>mod_rad</a>
33:       use <a href="./mod_bats.F90.html#mod_bats" TARGET=CENT_PANEL>mod_bats</a> , only : pptc
34:       use <a href="./mod_main.F90.html#mod_main" TARGET=CENT_PANEL>mod_main</a>
35:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : rgti
36:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : jyear , jyear0 , ktau
37:       implicit none
38: !
39: ! Dummy arguments
40: !
41:       integer :: j
42:       real(8) , dimension(iy,kz) :: qten , tten
43:       intent (inout) qten , tten
44: !
45: ! Local variables
46: !
47:       real(8) :: aprdiv , calc , dtime , pkdcut , pkk , prainx , us , vs
48:       integer :: i , iconj , icut , iend , istart , k , kk
49:       integer , dimension(iy) :: kdet
50:       real(8) , dimension(iy,kz) :: outq , outt , p , po , q , qo , t , &
51:                                   & tn , vsp
52:       real(8) , dimension(iy) :: pret , psur , qcrit , ter11
53: !
54: !     zero out radiative clouds
55: !
56:       cldlwc = 0.0
57:       cldfra = 0.0
58:  
59:       icut = 0
60:       dtime = dt
61:       pkdcut = 75.
62:       istart = 2 + icut
63:       iend = iym2 - icut
64: !
65: !---  prepare input, erase output
66: !
67:       do i = istart , iend
68:         kdet(i) = 2
69:         qcrit(i) = 0.
70:         pret(i) = 0.
71:       end do
72: 
73:       do k = 1 , kz
74:         do i = 2 + icut , iym2 - icut
75:           kk = kz - k + 1
76:           us = ua(i,kk,j)/psb(i,j)
77:           vs = va(i,kk,j)/psb(i,j)
78:           us = 0.25*(ua(i,kk,j)/psb(i,j)+ua(i+1,kk,j)/psb(i+1,j)        &
79:              & +ua(i,kk,j+1)/psb(i,j+1)+ua(i+1,kk,j+1)/psb(i+1,j+1))
80:           vs = 0.25*(va(i,kk,j)/psb(i,j)+va(i+1,kk,j)/psb(i+1,j)        &
81:              & +va(i,kk,j+1)/psb(i,j+1)+va(i+1,kk,j+1)/psb(i+1,j+1))
82:           t(i,k) = tb(i,kk,j)/psb(i,j)
83:           q(i,k) = qvb(i,kk,j)/psb(i,j)
84:           if ( q(i,k).lt.1.E-08 ) q(i,k) = 1.E-08
85:           tn(i,k) = t(i,k) + (tten(i,kk))/psb(i,j)*dtime
86:           qo(i,k) = q(i,k) + (qten(i,kk))/psb(i,j)*dtime
87:           p(i,k) = 10.*psb(i,j)*a(kk) + 10.*r8pt
88:           vsp(i,k) = dsqrt(us**2+vs**2)
89:           if ( qo(i,k).lt.1.E-08 ) qo(i,k) = 1.E-08
90: !
91:           po(i,k) = p(i,k)
92:           psur(i) = 10.*psb(i,j) + 10.*r8pt
93:           outt(i,k) = 0.
94:           pkk = psur(i) - po(i,k)
95:           if ( pkk.le.pkdcut ) kdet(i) = kdet(i) + 1
96:           outq(i,k) = 0.
97:           ter11(i) = ht(i,j)*rgti
98:           if ( ter11(i).le.0. ) ter11(i) = 1.E-05
99:           qcrit(i) = qcrit(i) + qten(i,kk)
100:         end do
101:       end do
102: !
103: !---  call cumulus parameterization
104: !
105:       call <a href="./mod_cu_grell.f90.html#cup" TARGET=CENT_PANEL>cup</a>(qcrit,t,q,ter11,tn,qo,po,pret,p,outt,outq,dtime,psur,vsp,&
106:              & istart,iend,kdet,j)
107:       do k = 1 , kz
108:         do i = istart , iend
109:           if ( pret(i).gt.0. ) then
110:             kk = kz - k + 1
111:             tten(i,kk) = psb(i,j)*outt(i,k) + tten(i,kk)
112:             qten(i,kk) = psb(i,j)*outq(i,k) + qten(i,kk)
113:           end if
114:         end do
115:       end do
116: !
117: !---  rain in cm.
118: !
119:       calc = .5
120:       iconj = 0
121:       do i = istart , iend
122:         if ( pret(i).gt.0. ) then
123:           rainc(i,j) = rainc(i,j) + pret(i)*calc*dt
124: !         print *,'rainc(',i,j,')=',rainc(i,j)
125:           iconj = iconj + 1
126: !.....................precipitation rate for bats (mm/s)
127:           aprdiv = dble(nbatst)
128:           if ( jyear.eq.jyear0 .and. ktau.eq.0 ) aprdiv = 1.
129:           prainx = pret(i)*calc*dt
130:           pptc(i,j) = pptc(i,j) + prainx/(dtmin*60.)/aprdiv
131: !.......................................................
132:         end if
133:       end do
134:       icon(j) = iconj
135: !
136:       end subroutine cuparan
137: !
138: !    GRELL CUMULUS SCHEME
139: !
<p><a name=cup><H3>cup</H3></a></p> Click <a href="./callingtree/cup_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where cup is used.
<hr>
140:       subroutine cup(qcrit,t,q,z1,tn,qo,po,pre,p,outtem,outq,dtime,psur,&
141:                    & vsp,istart,iend,kdet,jslc)
142: 
143: !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
144: !
145:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
146:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a>
147:       use <a href="./mod_pmoist.F90.html#mod_pmoist" TARGET=CENT_PANEL>mod_pmoist</a>
148:       use <a href="./mod_rad.F90.html#mod_rad" TARGET=CENT_PANEL>mod_rad</a>
149:       use <a href="./mod_trachem.F90.html#mod_trachem" TARGET=CENT_PANEL>mod_trachem</a>
150:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : gti , rgti , cpd , tzero , wlhv ,      &
151:                                & rwat , rcpd , wlhvocp , rgas , ep2
152:       implicit none
153: !
154: ! Dummy arguments
155: !
156:       real(8) :: dtime
157:       integer :: iend , istart , jslc
158:       integer , dimension(iy) :: kdet
159:       real(8) , dimension(iy,kz) :: outq , outtem , p , po , q , qo ,   &
160:                                   & t , tn , vsp
161:       real(8) , dimension(iy) :: pre , psur , qcrit , z1
162:       intent (in) dtime , jslc , kdet , p , po , psur , qcrit , t , tn ,&
163:                 & z1
164:       intent (inout) outq , outtem , pre , q , qo
165: !
166: ! Local variables
167: !
168:       real(8) , dimension(iy) :: aa0 , aa1 , bu , buo , edt , edto ,    &
169:                                & edtx , hcd , hcdo , hkb , hkbo , pwav ,&
170:                                & pwavo , pwev , pwevo , qcd , qcdo ,    &
171:                                & qck , qcko , qkb , qkbo , vshear ,     &
172:                                & xaa0 , xhcd , xhkb , xmb , xpwav ,     &
173:                                & xpwev , xqcd , xqck , xqkb
174:       real(8) :: adw , akclth , alsixt , aup , c0 , detdo ,             &
175:                & detdoq , dg , dh , dhh , dp , dq , dt , dv1 , dv1q ,   &
176:                & dv2 , dv2q , dv3 , dv3q , dz , dz1 , dz2 , dzo , e ,   &
177:                & eo , f , agamma , gamma0 , gamma1 , gamma2 , gammo ,   &
178:                & gammo0 , mbdt , outtes , pbcdif , qrch , qrcho ,       &
179:                & tcrit , tfinv , tvbar , tvbaro , xk
180:       real(8) , dimension(2) :: ae , be , ht
181:       real(8) , dimension(iy,kz) :: dby , dbyo , dellah , dellaq ,      &
182:                                   & dellat , dkk , he , heo , hes ,     &
183:                                   & heso , pw , pwd , pwdo , pwo , qc , &
184:                                   & qco , qes , qeso , qrcd , qrcdo ,   &
185:                                   & tv , tvo , xdby , xhe , xhes , xpw ,&
186:                                   & xpwd , xq , xqc , xqes , xqrcd ,    &
187:                                   & xt , xtv , xz , z , zo
188:       integer :: i , iph , ipho , k , kbcono , kclth , kk , lpt
189:       integer , dimension(iy) :: jmin , k22 , kb , kbcon , kds , ktop
190: !
191:       tcrit = 50.
192:  
193:       tfinv = 1./tzero
194:       alsixt = dlog(610.71D0)
195:       ht(1) = wlhvocp
196:       ht(2) = 2.834E6*rcpd
197:       be(1) = ep2*ht(1)*3.50
198:       ae(1) = be(1)*tfinv + alsixt
199:       be(2) = ep2*ht(2)*3.50
200:       ae(2) = be(2)*tfinv + alsixt
201:       mbdt = dtime*5.E-03
202:       c0 = .002
203:       f = -1.
204:       xk = -1.
205: !
206: !---  environmental conditions, first heights
207: !
208:       do k = 1 , kz
209:         do i = istart , iend
210:           dkk(i,k) = 1.
211:           iph = 1
212:           ipho = 1
213:           if ( t(i,k).le.tcrit ) iph = 2
214:           if ( tn(i,k).le.tcrit ) ipho = 2
215:           e = dexp(ae(iph)-be(iph)/t(i,k))
216:           eo = dexp(ae(ipho)-be(ipho)/tn(i,k))
217:           qes(i,k) = ep2*e/(100.*p(i,k)-(1.-ep2)*e)
218:           qeso(i,k) = ep2*eo/(100.*po(i,k)-(1.-ep2)*eo)
219:           if ( qes(i,k).le.1.E-08 ) qes(i,k) = 1.E-08
220:           if ( q(i,k).gt.qes(i,k) ) q(i,k) = qes(i,k)
221:           if ( qeso(i,k).le.1.E-08 ) qeso(i,k) = 1.E-08
222:           if ( qo(i,k).gt.qeso(i,k) ) qo(i,k) = qeso(i,k)
223:           tv(i,k) = t(i,k) + .608*q(i,k)*t(i,k)
224:           tvo(i,k) = tn(i,k) + .608*qo(i,k)*tn(i,k)
225:         end do
226:       end do
227:       do i = 1 , iy
228:         hkb(i) = 0. ! EES
229:         qkb(i) = 0.
230:         hkbo(i) = 0.
231:         qkbo(i) = 0.
232:         xhkb(i) = 0.
233:         xqkb(i) = 0.
234:         edt(i) = 0.
235:         edto(i) = 0.
236:         edtx(i) = 0.
237:       end do
238:       do i = istart , iend
239: !       hkb(i)=0.
240: !       qkb(i)=0.
241: !       hkbo(i)=0.
242: !       qkbo(i)=0.
243: !       xhkb(i)=0.
244: !       xqkb(i)=0.
245:         aa1(i) = 0.
246:         aa0(i) = 0.
247:         if ( qcrit(i).le.0. ) aa0(i) = -1.
248:         xaa0(i) = 0.
249:         xpwav(i) = 0.
250:         xpwev(i) = 0.
251:         pwav(i) = 0.
252:         pwev(i) = 0.
253:         pwavo(i) = 0.
254:         pwevo(i) = 0.
255:         k22(i) = 1
256:         ktop(i) = 1
257:         kbcon(i) = 1
258:         kb(i) = 1
259:         kds(i) = 1
260:         jmin(i) = 1
261: !       edt(i)=0.
262: !       edto(i)=0.
263: !       edtx(i)=0.
264:         xmb(i) = 0.
265:         vshear(i) = 0.
266:         z(i,1) = z1(i) - (dlog(p(i,1))-dlog(psur(i)))*rgas*tv(i,1)*rgti
267:         zo(i,1) = z1(i) - (dlog(po(i,1))-dlog(psur(i)))*rgas*tvo(i,1)   &
268:                 & *rgti
269:       end do
270:       do k = 2 , kz
271:         do i = istart , iend
272:           tvbar = .5*tv(i,k) + .5*tv(i,k-1)
273:           z(i,k) = z(i,k-1) - (dlog(p(i,k))-dlog(p(i,k-1)))             &
274:                  & *rgas*tvbar*rgti
275:           tvbaro = .5*tvo(i,k) + .5*tvo(i,k-1)
276:           zo(i,k) = zo(i,k-1) - (dlog(po(i,k))-dlog(po(i,k-1)))         &
277:                   & *rgas*tvbaro*rgti
278:         end do
279:       end do
280: !
281: !---  moist static energy
282: !
283:       do k = 1 , kz
284:         do i = istart , iend
285:           cldlwc(i,k) = 0.
286:           cldfra(i,k) = 0.
287:           pw(i,k) = 0.
288:           xpw(i,k) = 0.
289:           pwo(i,k) = 0.
290:           qc(i,k) = 0.
291:           xqc(i,k) = 0.
292:           qco(i,k) = 0.
293:           pwd(i,k) = 0.
294:           pwdo(i,k) = 0.
295:           xpwd(i,k) = 0.
296:           dellah(i,k) = 0.
297:           dellaq(i,k) = 0.
298:           dellat(i,k) = 0.
299:           he(i,k) = gti*z(i,k) + cpd*t(i,k) + wlhv*q(i,k)
300:           hes(i,k) = gti*z(i,k) + cpd*t(i,k) + wlhv*qes(i,k)
301:           if ( he(i,k).ge.hes(i,k) ) he(i,k) = hes(i,k)
302:           heo(i,k) = gti*zo(i,k) + cpd*tn(i,k) + wlhv*qo(i,k)
303:           heso(i,k) = gti*zo(i,k) + cpd*tn(i,k) + wlhv*qeso(i,k)
304:           if ( heo(i,k).ge.heso(i,k) ) heo(i,k) = heso(i,k)
305:           xt(i,k) = t(i,k)
306:           xq(i,k) = q(i,k)
307:           xhe(i,k) = he(i,k)
308:           if ( k.ne.kz ) qrcd(i,k) = .5*(qes(i,k)+qes(i,k+1))
309:           if ( k.ne.kz ) qrcdo(i,k) = .5*(qeso(i,k)+qeso(i,k+1))
310:         end do
311:       end do
312: !
313: !------- determine level with highest moist static energy content.
314: !
315:       call <a href="./mod_cu_grell.f90.html#maximi" TARGET=CENT_PANEL>maximi</a>(he,iy,kz,1,kbmax2d(i,jslc),k22,istart,iend)
316:       do i = istart , iend
317:         if ( aa0(i).ge.0. ) then
318:           if ( k22(i).ge.kbmax2d(i,jslc) ) then
319:             aa0(i) = -1.
320:             go to 100
321:           end if
322:           hkb(i) = he(i,k22(i))
323:           qkb(i) = q(i,k22(i))
324:           hkbo(i) = heo(i,k22(i))
325:           qkbo(i) = qo(i,k22(i))
326:           qck(i) = qkb(i)
327:           qcko(i) = qkbo(i)
328:         end if
329:         100 continue
330:       end do
331: !
332: !---  decide for convective cloud base
333: !
334:       do i = istart , iend
335:         if ( aa0(i).ge.0. ) then
336:           do k = 1 , kdet(i)
337:             kk = kdet(i) - k + 1
338: !           dkk(i,kk)=.75*dkk(i,kk+1)
339:             dkk(i,k) = 1. - dble(kk)/dble(kdet(i))
340:           end do
341:  120      continue
342:           kb(i) = k22(i)
343: !----------------------------------
344:           kbcon(i) = kb(i)
345:  140      continue
346:           dh = .5*hes(i,kbcon(i)) + .5*hes(i,kbcon(i)+1)
347:           if ( hkb(i).lt.dh ) then
348:             kbcon(i) = kbcon(i) + 1
349:             if ( kbcon(i).gt.kbmax2d(i,jslc) ) then
350:               aa0(i) = -1.
351:               go to 200
352:             end if
353:             go to 140
354:           else
355: !
356: !---        after large-scale forcing is applied, possible lid should be
357: !---        removed!!!
358: !
359:             kbcono = kb(i)
360: !ictp
361:  150        continue
362:             if ( kbcono.gt.kbmax2d(i,jslc) ) then
363:               aa0(i) = -1.
364:               go to 200
365:             end if
366: !ictp_
367:             dh = .5*heso(i,kbcono) + .5*heso(i,kbcono+1)
368:             if ( hkbo(i).lt.dh ) then
369:               kbcono = kbcono + 1
370:               go to 150
371:             else
372:               pbcdif = -p(i,kbcono) + p(i,kb(i))
373: !----------------------------- below was commented out
374: !as           uncommenting the following lines for experiment 2/5/95
375:               if ( pbcdif.gt.pbcmax2d(i,jslc) ) then
376:                                             !this is where typo was (pbdcdif)
377:                 k22(i) = k22(i) + 1
378:                 if ( k22(i).ge.kbmax2d(i,jslc) ) then
379:                   aa0(i) = -1.
380:                   go to 200
381:                 end if
382:                 hkb(i) = he(i,k22(i))
383:                 qkb(i) = q(i,k22(i))
384:                 hkbo(i) = heo(i,k22(i))
385:                 qkbo(i) = qo(i,k22(i))
386:                 qck(i) = qkb(i)
387:                 qcko(i) = qkbo(i)
388:                 go to 120
389:               end if
390:             end if
391:           end if
392: !as
393:         end if
394:  200    continue
395:       end do
396:  
397: !
398: !---  downdraft originating level
399: !
400:       call <a href="./mod_cu_grell.f90.html#minimi" TARGET=CENT_PANEL>minimi</a>(he,iy,kz,kb,kz,jmin,istart,iend)
401:       call <a href="./mod_cu_grell.f90.html#maximi" TARGET=CENT_PANEL>maximi</a>(vsp,iy,kz,1,kz,kds,istart,iend)
402: !
403: !**************************** static control
404: !
405: !
406: !---  determine cloud top
407: !
408:       do i = istart , iend
409:         if ( aa0(i).ge.0 ) then
410:           if ( jmin(i).le.3 ) then
411:             aa0(i) = -1.
412:             go to 300
413:           end if
414:           if ( kds(i).ge.kz ) kds(i) = kz - 1
415:           if ( kds(i).le.kbcon(i) ) kds(i) = kbcon(i)
416:           dby(i,kz) = hkb(i) - hes(i,kz)
417:           dbyo(i,kz) = hkbo(i) - heso(i,kz)
418:         end if
419:  300    continue
420:       end do
421:       do k = 1 , kz - 1
422:         do i = istart , iend
423:           if ( aa0(i).ne.-1. ) then
424:             dby(i,k) = hkb(i) - .5*(hes(i,k)+hes(i,k+1))
425:             dbyo(i,k) = hkbo(i) - .5*(heso(i,k)+heso(i,k+1))
426:           end if
427:         end do
428:       end do
429:       do i = istart , iend
430:         if ( aa0(i).ne.-1. ) then
431:           do k = 2 , kz - kbcon(i) - 1
432:             kk = kz - k + 1
433:             if ( dby(i,kk).ge.0. ) then
434:               ktop(i) = kk + 1
435:               go to 320
436:             end if
437:           end do
438:           aa0(i) = -1.
439:           go to 400
440:  320      continue
441:           if ( ktop(i).gt.kz ) ktop(i) = kz
442:           if ( p(i,kbcon(i))-p(i,ktop(i)).lt.mincld2d(i,jslc) ) aa0(i)  &
443:              & = -1.
444:         end if
445:  400    continue
446:       end do
447: !
448:  
449: !------- moisture and cloud work functions
450: !
451:       do k = 2 , kz - 1
452:         do i = istart , iend
453:           if ( aa0(i).ne.-1. ) then
454:             if ( k.gt.kbcon(i) ) then
455:               if ( k.lt.ktop(i) ) then
456:                 dz = -.5*z(i,k-1) + .5*z(i,k+1)
457:                 dz1 = z(i,k) - z(i,k-1)
458:                 agamma = (wlhvocp)*(wlhv/(rwat*(t(i,k)**2)))*qes(i,k)
459:                 gamma0 = (wlhvocp)*(wlhv/(rwat*(t(i,k-1)**2)))*         &
460:                         & qes(i,k-1)
461:                 qrch = qes(i,k) + (1./wlhv)*(agamma/(1.+agamma))*       &
462:                         & dby(i,k)
463:                 qc(i,k) = (qck(i)-qrch)/(1.+c0*dz) + qrch
464:                 pw(i,k) = c0*dz*(qc(i,k)-qrch)
465:                 qck(i) = qc(i,k)
466:                 pwav(i) = pwav(i) + pw(i,k)
467:                 dz1 = z(i,k) - z(i,k-1)
468:                 aa0(i) = aa0(i)                                         &
469:                        & + dz1*(gti/(cpd*(.5*(t(i,k)+t(i,k-1)))))       &
470:                        & *dby(i,k-1)/(1.+.5*agamma+.5*gamma0)
471:                 dzo = -.5*zo(i,k-1) + .5*zo(i,k+1)
472:                 dz2 = zo(i,k) - zo(i,k-1)
473:                 gammo = (wlhvocp)*(wlhv/(rwat*(tn(i,k)**2)))*qeso(i,k)
474:                 gammo0 = (wlhvocp)*(wlhv/(rwat*(tn(i,k-1)**2)))*        &
475:                        & qeso(i,k-1)
476:                 qrcho = qeso(i,k) + (1./wlhv)*(gammo/(1.+gammo))*       &
477:                        & dbyo(i,k)
478:                 qco(i,k) = (qcko(i)-qrcho)/(1.+c0*dzo) + qrcho
479:                 pwo(i,k) = c0*dzo*(qco(i,k)-qrcho)
480:                 qcko(i) = qco(i,k)
481:                 pwavo(i) = pwavo(i) + pwo(i,k)
482:                 aa1(i) = aa1(i)                                         &
483:                        & + dz2*(gti/(cpd*(.5*(tn(i,k)+tn(i,k-1)))))     &
484:                        & *dbyo(i,k-1)/(1.+.5*gammo+.5*gammo0)
485:               end if
486:             end if
487:           end if
488:         end do
489:       end do
490: !
491: !
492:       do i = istart , iend
493:         if ( aa0(i).ne.-1. ) then
494:           k = ktop(i)
495:           dz = -.5*z(i,k-1) + .5*z(i,k)
496:           agamma = (wlhvocp)*(wlhv/(rwat*(t(i,k)**2)))*qes(i,k)
497:           qrch = qes(i,k) + (1./wlhv)*(agamma/(1.+agamma))*dby(i,k)
498:           qc(i,k) = qes(i,k)
499:           pw(i,k) = (qrch-qes(i,k))
500:           pwav(i) = pwav(i) + pw(i,k)
501: !
502:           dz = -.5*zo(i,k-1) + .5*zo(i,k)
503:           agamma = (wlhvocp)*(wlhv/(rwat*(tn(i,k)**2)))*qeso(i,k)
504:           qrcho = qeso(i,k) + (1./wlhv)*(agamma/(1.+agamma))*dbyo(i,k)
505:           qco(i,k) = qeso(i,k)
506:           pwo(i,k) = (qrcho-qeso(i,k))
507:           pwavo(i) = pwavo(i) + pwo(i,k)
508:         end if
509:       end do
510: !
511: !------- downdraft calculations
512: !
513: !
514: !---  determine downdraft strength in terms of windshear
515: !
516:       do kk = 1 , kz/2
517:         do i = istart , iend
518:           if ( aa0(i).ne.-1. ) vshear(i) = vshear(i)                    &
519:              & + dabs((vsp(i,kk+1)-vsp(i,kk))/(z(i,kk+1)-z(i,kk)))
520:         end do
521:       end do
522:       do i = istart , iend
523:         if ( aa0(i).ne.-1. ) then
524:           vshear(i) = 1.E3*vshear(i)/dble(kz/2)
525:           edt(i) = 1. - (1.591-.639*vshear(i)+.0953*(vshear(i)**2)      &
526:                  & -.00496*(vshear(i)**3))
527:  
528:           if ( edt(i).gt.shrmax2d(i,jslc) ) edt(i) = shrmax2d(i,jslc)
529:           if ( edt(i).lt.shrmin2d(i,jslc) ) edt(i) = shrmin2d(i,jslc)
530:  
531:           edto(i) = edt(i)
532:           edtx(i) = edt(i)
533:           qrcd(i,kz) = qes(i,kz)
534:           hcd(i) = .5*(he(i,jmin(i))+he(i,jmin(i)+1))
535:           qcd(i) = .5*(q(i,jmin(i))+q(i,jmin(i)+1))
536:           qrcdo(i,kz) = qeso(i,kz)
537:           hcdo(i) = heso(i,kz)
538:           hcdo(i) = .5*(heo(i,jmin(i))+heo(i,jmin(i)+1))
539:           qcdo(i) = .5*(qo(i,jmin(i))+qo(i,jmin(i)+1))
540:           bu(i) = 0.
541:           buo(i) = 0.
542:         end if
543:       end do
544:       do k = 1 , kz - 1
545:         do i = istart , iend
546:           if ( aa0(i).ne.-1. ) then
547:             if ( k.lt.jmin(i) ) then
548:               kk = jmin(i) - k
549:               dz = -(z(i,kk)-z(i,kk+2))*.5
550:               bu(i) = bu(i) + dz*(hcd(i)-.5*(hes(i,kk)+hes(i,kk+1)))
551:               dq = (qes(i,kk)+qes(i,kk+1))*.5
552:               dt = (t(i,kk)+t(i,kk+1))*.5
553:               agamma = (wlhvocp)*(wlhv/(rwat*(dt**2)))*dq
554:               dh = hcd(i) - .5*(hes(i,kk)+hes(i,kk+1))
555:               qrcd(i,kk) = (dq+(1./wlhv)*(agamma/(1.+agamma))*dh)
556:               pwd(i,kk) = dkk(i,kk)*(qcd(i)-qrcd(i,kk))
557:               qcd(i) = qrcd(i,kk)
558:               pwev(i) = pwev(i) + pwd(i,kk)
559: !
560:               dz = -(zo(i,kk)-zo(i,kk+2))*.5
561:               buo(i) = buo(i) + dz*(hcdo(i)-.5*(heso(i,kk)+heso(i,kk+1))&
562:                      & )
563:               dq = (qeso(i,kk)+qeso(i,kk+1))*.5
564:               dt = (tn(i,kk)+tn(i,kk+1))*.5
565:               agamma = (wlhvocp)*(wlhv/(rwat*(dt**2)))*dq
566:               dh = hcdo(i) - .5*(heso(i,kk)+heso(i,kk+1))
567:               qrcdo(i,kk) = (dq+(1./wlhv)*(agamma/(1.+agamma))*dh)
568:               pwdo(i,kk) = dkk(i,kk)*(qcdo(i)-qrcdo(i,kk))
569:               qcdo(i) = qrcdo(i,kk)
570:               pwevo(i) = pwevo(i) + pwdo(i,kk)
571:             end if
572:           end if
573:         end do
574:       end do
575: !
576:       do i = istart , iend
577:         if ( aa0(i).ne.-1. ) then
578:           if ( bu(i).ge.0 .or. buo(i).ge.0 .or. pwev(i).ge.0 .or.       &
579:              & pwevo(i).ge.0. ) aa0(i) = -1.
580:           edt(i) = -edt(i)*pwav(i)/pwev(i)
581:           if ( edt(i).gt.edtmax2d(i,jslc) ) edt(i) = edtmax2d(i,jslc)
582:           if ( edt(i).lt.edtmin2d(i,jslc) ) edt(i) = edtmin2d(i,jslc)
583:           edto(i) = -edto(i)*pwavo(i)/pwevo(i)
584:           if ( edto(i).gt.edtmaxo2d(i,jslc) ) edto(i)                   &
585:              & = edtmaxo2d(i,jslc)
586:           if ( edto(i).lt.edtmino2d(i,jslc) ) edto(i)                   &
587:              & = edtmino2d(i,jslc)
588:         end if
589:       end do
590: !
591: !---  what would the change be?
592: !
593:       do i = istart , iend
594:         if ( aa0(i).ne.-1. ) then
595:           k = 1
596:           dz = .5*(z(i,2)-z(i,1))
597:           dp = 50.*(psur(i)-p(i,2))
598:           dellah(i,1) = edt(i)                                          &
599:                       & *(dkk(i,1)*hcd(i)-dkk(i,1)*.5*(he(i,1)+he(i,2)))&
600:                       & *gti/dp
601:           dellaq(i,1) = edt(i)                                          &
602:                       & *(dkk(i,1)*qrcd(i,1)-dkk(i,1)*.5*(q(i,1)+q(i,2))&
603:                       & )*gti/dp
604:           xhe(i,k) = dellah(i,k)*mbdt + he(i,k)
605:           xq(i,k) = dellaq(i,k)*mbdt + q(i,k)
606:           dellat(i,k) = rcpd*(dellah(i,k)-wlhv*dellaq(i,k))
607:           xt(i,k) = (mbdt*rcpd)*(dellah(i,k)-wlhv*dellaq(i,k))+t(i,k)
608:           if ( xq(i,k).le.0. ) xq(i,k) = 1.E-08
609:         end if
610:       end do
611: !
612:       do k = 1 , kz - 1
613:         do i = istart , iend
614:           if ( aa0(i).ne.-1. ) then
615:             if ( k.ne.1 .and. k.lt.ktop(i) ) then
616:               dv1 = .5*(he(i,k)+he(i,k+1))
617:               dv2 = he(i,k)
618:               dv3 = .5*(he(i,k)+he(i,k-1))
619:               dv1q = .5*(q(i,k)+q(i,k+1))
620:               dv2q = q(i,k)
621:               dv3q = .5*(q(i,k)+q(i,k-1))
622: !
623: !---          specifiy detrainment of downdraft, has to be consistent
624: !---          with zd calculations in soundd.
625: !
626:               detdo = (1.-dkk(i,k))*(hcd(i)-dv2)
627:               detdoq = (1.-dkk(i,k))*(qrcd(i,k)-dv2q)
628:               dz = .5*(z(i,k+1)-z(i,k-1))
629: !
630: !---          changed due to subsidence and entrainment
631: !
632:               aup = 1.
633:               if ( k.le.k22(i) ) aup = 0.
634:               adw = 1.
635:               if ( k.gt.jmin(i) ) adw = 0.
636:               dp = +50.*(p(i,k-1)-p(i,k+1))
637:               dellah(i,k) = ((aup-adw*edt(i))*(dv1-dv2)+(aup-adw*edt(i))&
638:                           & *(dv2-dv3))*gti/dp + adw*edt(i)*detdo*gti/dp
639:               dellaq(i,k) = ((aup-adw*edt(i))*(dv1q-dv2q)+(aup-adw*edt(i&
640:                           & ))*(dv2q-dv3q))*gti/dp + adw*edt(i)         &
641:                           & *detdoq*gti/dp
642:               xhe(i,k) = dellah(i,k)*mbdt + he(i,k)
643:               xq(i,k) = dellaq(i,k)*mbdt + q(i,k)
644:               dellat(i,k) = rcpd*(dellah(i,k)-wlhv*dellaq(i,k))
645:               xt(i,k) = (mbdt*rcpd)*(dellah(i,k)-wlhv*dellaq(i,k))    &
646:                       & + t(i,k)
647:               if ( xq(i,k).le.0. ) xq(i,k) = 1.E-08
648:             end if
649:           end if
650:         end do
651:       end do
652: !
653: !------- cloud top
654: !
655:       do i = istart , iend
656:         if ( aa0(i).ne.-1. ) then
657:           lpt = ktop(i)
658:           dp = 100.*(p(i,lpt-1)-p(i,lpt))
659:           dv1 = .5*(he(i,lpt)+he(i,lpt-1))
660:           dellah(i,lpt) = (hkb(i)-dv1)*gti/dp
661:           dv1 = .5*(q(i,lpt)+q(i,lpt-1))
662:           dellaq(i,lpt) = (qes(i,lpt)-dv1)*gti/dp
663:           k = lpt
664:           xhe(i,k) = dellah(i,k)*mbdt + he(i,k)
665:           xq(i,k) = dellaq(i,k)*mbdt + q(i,k)
666:           dellat(i,k) = rcpd*(dellah(i,k)-wlhv*dellaq(i,k))
667:           xt(i,k) = (mbdt*rcpd)*(dellah(i,k)-wlhv*dellaq(i,k))        &
668:                   & + t(i,k)
669:           if ( xq(i,k).le.0. ) xq(i,k) = 1.E-08
670:           xhkb(i) = dellah(i,kbcon(i))*mbdt + hkb(i)
671:           xqkb(i) = dellaq(i,kbcon(i))*mbdt + qkb(i)
672:           if ( xqkb(i).le.0. ) xqkb(i) = 1.E-08
673:         end if
674:       end do
675: !
676: !---  environmental conditions, first heights
677: !
678:       do k = 1 , kz
679:         do i = istart , iend
680:           if ( aa0(i).ne.-1. ) then
681:             iph = 1
682:             if ( xt(i,k).le.tcrit ) iph = 2
683:             e = dexp(ae(iph)-be(iph)/xt(i,k))
684:             xqes(i,k) = ep2*e/(100.*p(i,k)-(1.-ep2)*e)
685:             if ( xqes(i,k).le.1.E-08 ) xqes(i,k) = 1.E-08
686:             if ( xq(i,k).gt.xqes(i,k) ) xq(i,k) = xqes(i,k)
687:             xtv(i,k) = xt(i,k) + .608*xq(i,k)*xt(i,k)
688:           end if
689:         end do
690:       end do
691: !     bug fix
692:       do k = 1 , kz - 1
693:         do i = istart , iend
694:           if ( aa0(i).ne.-1 ) xqrcd(i,k) = .5*(xqes(i,k)+xqes(i,k+1))
695:         end do
696:       end do
697: !
698:       do i = istart , iend
699:         if ( aa0(i).ne.-1. ) xz(i,1) = z1(i)                            &
700:                                      & - (dlog(p(i,1))-dlog(psur(i)))   &
701:                                      & *rgas*xtv(i,1)*rgti
702:       end do
703:       do k = 2 , kz
704:         do i = istart , iend
705:           if ( aa0(i).ne.-1. ) then
706:             tvbar = .5*xtv(i,k) + .5*xtv(i,k-1)
707:             xz(i,k) = xz(i,k-1) - (dlog(p(i,k))-dlog(p(i,k-1)))         &
708:                     & *rgas*tvbar*rgti
709:           end if
710:         end do
711:       end do
712: !
713: !---  moist static energy
714: !
715:       do k = 1 , kz
716:         do i = istart , iend
717:           if ( aa0(i).ne.-1. ) then
718:             xhes(i,k) = gti*xz(i,k) + cpd*xt(i,k) + wlhv*xqes(i,k)
719:             if ( xhe(i,k).ge.xhes(i,k) ) xhe(i,k) = xhes(i,k)
720:           end if
721:         end do
722:       end do
723: !
724: !
725: !**************************** static control
726: !
727:       do i = istart , iend
728:         if ( aa0(i).ne.-1. ) then
729:           xqck(i) = xqkb(i)
730:           xdby(i,kz) = xhkb(i) - xhes(i,kz)
731:         end if
732:       end do
733: !
734: !------- moisture and cloud work functions
735: !
736:       do k = 1 , kz - 1
737:         do i = istart , iend
738:           if ( aa0(i).ge.0. ) then
739:             xdby(i,k) = xhkb(i) - .5*(xhes(i,k)+xhes(i,k+1))
740:             if ( k.gt.kbcon(i) .and. k.lt.ktop(i) ) then
741:               dz = -.5*xz(i,k-1) + .5*xz(i,k+1)
742:               dz1 = xz(i,k) - xz(i,k-1)
743:               agamma = (wlhvocp)*(wlhv/(rwat*(xt(i,k)**2)))*xqes(i,k)
744:               gamma0 = (wlhvocp)*(wlhv/(rwat*(xt(i,k-1)**2)))*          &
745:                       & xqes(i,k-1)
746:               qrch = xqes(i,k) + (1./wlhv)*(agamma/(1.+agamma))*        &
747:                       & xdby(i,k)
748:               xqc(i,k) = (xqck(i)-qrch)/(1.+c0*dz) + qrch
749:               xpw(i,k) = c0*dz*(xqc(i,k)-qrch)
750:               xqck(i) = xqc(i,k)
751:               xpwav(i) = xpwav(i) + xpw(i,k)
752:               xaa0(i) = xaa0(i)                                         &
753:                       & + dz1*(gti/(cpd*(.5*(xt(i,k)+xt(i,k-1)))))      &
754:                       & *xdby(i,k-1)/(1.+.5*agamma+.5*gamma0)
755:             end if
756:           end if
757:         end do
758:       end do
759:       do i = istart , iend
760:         if ( aa0(i).ge.0. ) then
761:           k = ktop(i)
762:           dz = -.5*xz(i,k-1) + .5*xz(i,k)
763:           agamma = (wlhvocp)*(wlhv/(rwat*(xt(i,k)**2)))*xqes(i,k)
764:           qrch = xqes(i,k) + (1./wlhv)*(agamma/(1.+agamma))*xdby(i,k)
765:           xqc(i,k) = xqes(i,k)
766:           xpw(i,k) = (qrch-xqes(i,k))
767:           xpwav(i) = xpwav(i) + xpw(i,k)
768:           xqrcd(i,kz) = xqes(i,kz)
769:           xhcd(i) = .5*(xhe(i,jmin(i))+xhe(i,jmin(i)+1))
770:           xqcd(i) = .5*(xq(i,jmin(i))+xq(i,jmin(i)+1))
771:           xpwev(i) = 0.
772:           bu(i) = 0.
773:         end if
774:       end do
775: !
776: !------- downdraft calculations
777: !
778: !
779: !---  downdraft moisture properties
780: !
781:       do k = 1 , kz - 1
782:         do i = istart , iend
783:           if ( aa0(i).ge.0. ) then
784:             if ( k.lt.jmin(i) ) then
785:               kk = jmin(i) - k
786:               dz = -(xz(i,kk)-xz(i,kk+2))*.5
787:               bu(i) = bu(i) + dz*(xhcd(i)-.5*(xhes(i,kk)+xhes(i,kk+1)))
788:               dq = (xqes(i,kk)+xqes(i,kk+1))*.5
789:               dt = (xt(i,kk)+xt(i,kk+1))*.5
790:               agamma = (wlhvocp)*(wlhv/(rwat*(dt**2)))*dq
791:               dh = xhcd(i) - .5*(xhes(i,kk)+xhes(i,kk+1))
792:               xqrcd(i,kk) = (dq+(1./wlhv)*(agamma/(1.+agamma))*dh)
793:               xpwd(i,kk) = dkk(i,kk)*(xqcd(i)-xqrcd(i,kk))
794:               xqcd(i) = xqrcd(i,kk)
795:               xpwev(i) = xpwev(i) + xpwd(i,kk)
796:             end if
797:           end if
798:         end do
799:       end do
800:       do i = istart , iend
801:         if ( aa0(i).ge.0. ) then
802:           if ( bu(i).ge.0. ) then
803:             aa0(i) = -1.
804:             go to 500
805:           end if
806:           if ( xpwev(i).ne.0. ) edtx(i) = -edtx(i)*xpwav(i)/xpwev(i)
807:           if ( edtx(i).gt.edtmaxx2d(i,jslc) ) edtx(i)                   &
808:              & = edtmaxx2d(i,jslc)
809:           if ( edtx(i).lt.edtminx2d(i,jslc) ) edtx(i)                   &
810:              & = edtminx2d(i,jslc)
811:         end if
812:  500    continue
813:       end do
814: !
815: !
816: !---  downdraft cloudwork functions
817: !
818: !
819:       do k = 1 , kz - 1
820:         do i = istart , iend
821:           if ( aa0(i).ge.0. ) then
822:             if ( k.lt.jmin(i) ) then
823:               kk = jmin(i) - k
824: !
825: !---          original
826: !
827:               gamma1 = (wlhvocp)*(wlhv/(rwat*(t(i,kk)**2)))*qes(i,kk)
828:               gamma2 = (wlhvocp)*(wlhv/(rwat*(t(i,kk+1)**2)))*          &
829:                      & qes(i,kk+1)
830:               dhh = hcd(i)
831:               dt = .5*(t(i,kk)+t(i,kk+1))
832:               dg = .5*(gamma1+gamma2)
833:               dh = .5*(hes(i,kk)+hes(i,kk+1))
834:               dz = (z(i,kk)-z(i,kk+1))*dkk(i,kk)
835:               aa0(i) = aa0(i) + edt(i)*dz*(gti/(cpd*dt))*((dhh-dh)/     &
836:                      & (1.+dg))
837: !
838: !---          modified by larger scale
839: !
840:               gamma1 = (wlhvocp)*(wlhv/(rwat*(tn(i,kk)**2)))*qeso(i,kk)
841:               gamma2 = (wlhvocp)*(wlhv/(rwat*(tn(i,kk+1)**2)))*         &
842:                       & qeso(i,kk+1)
843:               dhh = hcdo(i)
844:               dt = .5*(tn(i,kk)+tn(i,kk+1))
845:               dg = .5*(gamma1+gamma2)
846:               dh = .5*(heso(i,kk)+heso(i,kk+1))
847:               dz = (zo(i,kk)-zo(i,kk+1))*dkk(i,kk)
848:               aa1(i) = aa1(i) + edto(i)*dz*(gti/(cpd*dt))               &
849:                      & *((dhh-dh)/(1.+dg))
850: !
851: !---          modified by cloud
852: !
853:               gamma1 = (wlhvocp)*(wlhv/(rwat*(xt(i,kk)**2)))*xqes(i,kk)
854:               gamma2 = (wlhvocp)*(wlhv/(rwat*(xt(i,kk+1)**2)))*         &
855:                      & xqes(i,kk+1)
856:               dhh = xhcd(i)
857:               dt = .5*(xt(i,kk)+xt(i,kk+1))
858:               dg = .5*(gamma1+gamma2)
859:               dh = .5*(xhes(i,kk)+xhes(i,kk+1))
860:               dz = (xz(i,kk)-xz(i,kk+1))*dkk(i,kk)
861:               xaa0(i) = xaa0(i) + edtx(i)*dz*(gti/(cpd*dt))             &
862:                       & *((dhh-dh)/(1.+dg))
863:             end if
864:           end if
865:         end do
866:       end do
867: !
868: !---  large scale forcing
869: !
870:       do i = istart , iend
871:         if ( aa0(i).ge.0. ) then
872:           if ( igcc.eq.1 ) then
873:             f = (aa1(i)-aa0(i))/dtime  ! Arakawa-Schubert closure
874:           else if ( igcc.eq.2 ) then
875:             f = aa0(i)/dtauc2d(i,jslc)   ! Fritsch-Chappell closure
876:           else
877:           end if
878:           xk = (xaa0(i)-aa0(i))/mbdt
879:           xmb(i) = -f/xk
880:           if ( f.le.0 .or. xk.ge.0. ) xmb(i) = 0.
881:         end if
882:       end do
883: !chem2
884:       mflx(i,1) = xmb(i)
885:       mflx(i,2) = xmb(i)*edt(i)
886: !chem2_
887: !
888: !---  feedback
889: !
890:       do k = 1 , kz
891:         do i = istart , iend
892:           if ( aa0(i).ge.0. ) then
893:             if ( k.le.ktop(i) ) then
894:               outtes = dellat(i,k)*xmb(i)*86400.
895:               if ( (outtes.gt.htmax2d(i,jslc)) .or.                     &
896:                  & (outtes.lt.htmin2d(i,jslc)) ) then
897:                 xmb(i) = 0.
898:                 aa0(i) = -1.
899:               else
900:                 outtem(i,k) = outtem(i,k) + dellat(i,k)*xmb(i)
901:                 outq(i,k) = outq(i,k) + dellaq(i,k)*xmb(i)
902:                 pre(i) = pre(i) + (pw(i,k)+edt(i)*pwd(i,k))*xmb(i)
903:               end if
904:             end if
905:           end if
906:         end do
907:       end do
908: !
909: !     calculate cloud fraction and water content
910: !
911:       do i = istart , iend
912: !chem2
913:         icumtop(i,jslc) = 0
914:         icumbot(i,jslc) = 0
915:         icumdwd(i,jslc) = 0
916: !chem2_
917:         if ( aa0(i).ge.0. ) then
918:  
919:           if ( ktop(i).gt.1 .and. kbcon(i).gt.1 ) then
920:             kclth = ktop(i) - kbcon(i) + 1
921:             akclth = 1./dble(kclth)
922:             do k = kbcon(i) , ktop(i)
923:               kk = kz - k + 1
924:               cldlwc(i,kk) = cllwcv
925:               cldfra(i,kk) = 1. - (1.-clfrcv)**akclth
926:             end do
927: !chem2
928: !chem2      define convection  base and top for tracers
929:             if ( ichem.eq.1 ) then
930:               if ( ktop(i).gt.1 .and. k22(i).ge.1 ) then
931:                 icumtop(i,jslc) = kzp1 - ktop(i)
932:                 icumbot(i,jslc) = kzp1 - k22(i)
933:                 icumdwd(i,jslc) = kzp1 - jmin(i)
934:               end if
935:             end if
936: !chem2_
937:           end if
938:         end if
939:  
940:       end do
941:       end subroutine cup
942: !
943: !
944: !
<p><a name=minimi><H3>minimi</H3></a></p> Click <a href="./callingtree/minimi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where minimi is used.
<hr>
945:       subroutine minimi(array,iy,kz,ks,kend,kt,istart,iend)
946: !
947:       implicit none
948: !
949: ! Dummy arguments
950: !
951:       integer :: iend , istart , iy , kend , kz
952:       real(8) , dimension(iy,kz) :: array
953:       integer , dimension(iy) :: ks , kt
954:       intent (in) array , iend , istart , iy , kend , ks , kz
955:       intent (out) kt
956: !
957: ! Local variables
958: !
959:       integer :: i , k
960:       real(8) :: x
961: !
962:       do i = istart , iend
963:         kt(i) = ks(i)
964:         x = array(i,ks(i))
965:         do k = ks(i) + 1 , kend
966:           if ( array(i,k).lt.x ) then
967:             x = array(i,k)
968:             kt(i) = k
969:           end if
970:         end do
971:       end do
972: !
973:       end subroutine minimi
974: !
975: !
976: !
<p><a name=maximi><H3>maximi</H3></a></p> Click <a href="./callingtree/maximi_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where maximi is used.
<hr>
977:       subroutine maximi(array,iy,kz,ks,ke,imax,istart,iend)
978: 
979:       implicit none
980: !
981: ! Dummy arguments
982: !
983:       integer :: iend , istart , iy , ke , ks , kz
984:       real(8) , dimension(iy,kz) :: array
985:       integer , dimension(iy) :: imax
986:       intent (in) array , iend , istart , iy , ke , ks , kz
987:       intent (out) imax
988: !
989: ! Local variables
990: !
991:       integer :: i , k
992:       real(8) :: x , xar
993: !
994:       do i = istart , iend
995:         imax(i) = ks
996:         x = array(i,ks)
997:         do k = ks , ke
998:           xar = array(i,k)
999:           if ( xar.ge.x ) then
1000:             x = xar
1001:             imax(i) = k
1002:           end if
1003:         end do
1004:       end do
1005: !
1006:       end subroutine maximi
1007: 
1008:       end module mod_cu_grell
</PRE>

<HR>

</BODY>
</HTML>
