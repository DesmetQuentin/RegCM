<HTML>

<HEAD>
<TITLE>decompMod.F90.patch</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>clmlib/patchset/decompMod.F90.patch</H1>
<HR>
<H2 ALIGN=CENTER>decompMod.F90.patch</H2>
<HR>
</FONT>

<HR>

<PRE>
<OL>
<LI>--- orig/decompMod.F90	2010-03-10 16:34:21.000000000 +0100
<LI>+++ patchd/decompMod.F90	2010-03-10 16:19:07.000000000 +0100
<LI>@@ -13,14 +13,14 @@
<LI>   use clm_mct_mod
<LI>   use shr_sys_mod , only : shr_sys_flush
<LI>   use abortutils  , only : endrun
<LI>+  use mod_clm
<LI>+  use mod_dynparam
<LI> !
<LI> ! !PUBLIC TYPES:
<LI>   implicit none
<LI>   integer, public :: clump_pproc ! number of clumps per MPI process
<LI> !
<LI> ! !PUBLIC MEMBER FUNCTIONS:
<LI>-!  public decomp_init             ! initializes land surface decomposition
<LI>-!                                 ! into clumps and processors
<LI>   public decomp_atm_init         ! initializes atm grid decomposition
<LI>                                  ! into clumps and processors
<LI>   public decomp_lnd_init         ! initializes lnd grid decomposition
<LI>@@ -136,577 +136,6 @@
<LI> contains
<LI> 
<LI> !------------------------------------------------------------------------------
<LI>-#if (1 == 0)
<LI>-! tcx DO NOT DELETE THIS YET
<LI>-!BOP
<LI>-!
<LI>-! !IROUTINE: decomp_init
<LI>-!
<LI>-! !INTERFACE:
<LI>-  subroutine decomp_init(wtxy)
<LI>-!
<LI>-! !DESCRIPTION:
<LI>-! This subroutine initializes the land surface decomposition into a clump
<LI>-! data structure.  This assumes each pe has the same number of clumps
<LI>-! set by clump_pproc
<LI>-!
<LI>-! !USES:
<LI>-    use domainMod , only : ldomain,adomain
<LI>-    use subgridMod, only : subgrid_get_gcellinfo
<LI>-    use clm_varctl, only : nsegspc
<LI>-!
<LI>-! !ARGUMENTS:
<LI>-    implicit none
<LI>-    real(r8), intent(in) :: wtxy(:,:)   ! subgrid patch weights
<LI>-!
<LI>-! !LOCAL VARIABLES:
<LI>-    integer :: lni,lnj                ! land domain global size
<LI>-    integer :: ani,anj                ! atm domain global size
<LI>-    integer :: lns,lg,ln,li,lj        ! indices
<LI>-    integer :: ans,ag,an,ai,aj        ! indices
<LI>-    integer :: anumg                  ! atm num gridcells
<LI>-    integer :: anumg_tot              ! precompute of anumg
<LI>-    real(r8):: rnsegspc               ! real value associated with nsegspc
<LI>-!    integer :: anumpc                 ! min atm gridcells/clump
<LI>-!    integer :: anumxtra               ! extra atm cells
<LI>-    integer :: cid,pid                ! indices
<LI>-    integer, pointer :: lcid(:)       ! temporary for setting adecomp
<LI>-    integer, pointer :: acid(:)       ! temporary for setting adecomp
<LI>-    integer :: n,m,np                 ! indices
<LI>-    integer :: ilunits, icols, ipfts  ! temporaries
<LI>-    integer :: ier                    ! error code
<LI>-    integer :: cnt                    ! local counter
<LI>-    integer, parameter :: dbug=3      ! 0 = min, 1=normal, 2=much, 3=max
<LI>-    integer :: npmin,npmax,npint      ! do loop values for printing
<LI>-    integer :: clmin,clmax,clint      ! do loop values for printing
<LI>-    integer :: beg,end,lsize,gsize    ! used for gsmap init
<LI>-    integer, pointer :: gindex(:)     ! global index for gsmap init
<LI>-
<LI>-    integer, pointer :: lncnt(:)      ! lnd cell count per atm cell
<LI>-    integer, pointer :: lnoff(:)      ! atm cell offset in lnmap
<LI>-    integer, pointer :: lnmap(:)      ! map from atm cell to lnd cells
<LI>-    integer, pointer :: lglo2gsn(:)   ! map from glo 2 gsn temporary
<LI>-    integer, pointer :: aglo2gsn(:)   ! map from glo 2 gsn temporary
<LI>-    integer :: lnidx
<LI>-
<LI>-! !CALLED FROM:
<LI>-! subroutine initialize
<LI>-!
<LI>-! !REVISION HISTORY:
<LI>-! 2002.09.11  Forrest Hoffman  Creation.
<LI>-! 2005.12.15  T Craig  Updated for finemesh
<LI>-! 2006.08.18  P Worley Performance optimizations
<LI>-!
<LI>-!EOP
<LI>-!------------------------------------------------------------------------------
<LI>-
<LI>-    lni = ldomain%ni
<LI>-    lnj = ldomain%nj
<LI>-    ani = adomain%ni
<LI>-    anj = adomain%nj
<LI>-    lns = ldomain%ns
<LI>-    ans = adomain%ns
<LI>-
<LI>-    !--- set and verify nclumps ---
<LI>-    if (clump_pproc > 0) then
<LI>-       nclumps = clump_pproc * npes
<LI>-       if (nclumps < npes) then
<LI>-          write (6,*) 'decomp_init(): Number of gridcell clumps= ',nclumps, &
<LI>-               ' is less than the number of processes = ', npes
<LI>-          call endrun()
<LI>-       end if
<LI>-    else
<LI>-       write(6,*)'clump_pproc= ',clump_pproc,'  must be greater than 0'
<LI>-       call endrun()
<LI>-    end if
<LI>-
<LI>-    !--- allocate and initialize procinfo and clumps ---
<LI>-    !--- beg and end indices initialized for simple addition of cells later ---
<LI>-
<LI>-    allocate(procinfo%cid(clump_pproc), stat=ier)
<LI>-    if (ier /= 0) then
<LI>-       write (6,*) 'decomp_init(): allocation error for procinfo%cid'
<LI>-       call endrun()
<LI>-    endif
<LI>-
<LI>-    procinfo%nclumps = clump_pproc
<LI>-    procinfo%cid(:)  = -1
<LI>-    procinfo%ncells  = 0
<LI>-    procinfo%nlunits = 0
<LI>-    procinfo%ncols   = 0
<LI>-    procinfo%npfts   = 0
<LI>-    procinfo%begg    = 1
<LI>-    procinfo%begl    = 1
<LI>-    procinfo%begc    = 1
<LI>-    procinfo%begp    = 1
<LI>-    procinfo%endg    = 0
<LI>-    procinfo%endl    = 0
<LI>-    procinfo%endc    = 0
<LI>-    procinfo%endp    = 0
<LI>-    procinfo%abegg   = 1
<LI>-    procinfo%aendg   = 0
<LI>-
<LI>-    allocate(clumps(nclumps), stat=ier)
<LI>-    if (ier /= 0) then
<LI>-       write (6,*) 'decomp_init(): allocation error for clumps'
<LI>-       call endrun()
<LI>-    end if
<LI>-    clumps(:)%owner   = -1
<LI>-    clumps(:)%ncells  = 0
<LI>-    clumps(:)%nlunits = 0
<LI>-    clumps(:)%ncols   = 0
<LI>-    clumps(:)%npfts   = 0
<LI>-    clumps(:)%begg    = 1
<LI>-    clumps(:)%begl    = 1
<LI>-    clumps(:)%begc    = 1
<LI>-    clumps(:)%begp    = 1
<LI>-    clumps(:)%endg    = 0
<LI>-    clumps(:)%endl    = 0
<LI>-    clumps(:)%endc    = 0
<LI>-    clumps(:)%endp    = 0
<LI>-
<LI>-    !--- assign clumps to proc round robin ---
<LI>-    cid = 0
<LI>-    do n = 1,nclumps
<LI>-       pid = mod(n-1,npes)
<LI>-       if (pid < 0 .or. pid > npes-1) then
<LI>-          write (6,*) 'decomp_init(): round robin pid error ',n,pid,npes
<LI>-          call endrun()
<LI>-       endif
<LI>-       clumps(n)%owner = pid
<LI>-       if (iam == pid) then
<LI>-          cid = cid + 1
<LI>-          if (cid < 1 .or. cid > clump_pproc) then
<LI>-             write (6,*) 'decomp_init(): round robin pid error ',n,pid,npes
<LI>-             call endrun()
<LI>-          endif
<LI>-          procinfo%cid(cid) = n
<LI>-       endif
<LI>-    enddo
<LI>-
<LI>-    allocate(lncnt(ans),lnoff(ans),lnmap(lns))
<LI>-
<LI>-    lncnt = 0
<LI>-    do ln = 1,lns
<LI>-       an = ldomain%gatm(ln)
<LI>-       if ((an > 0) .and. (an .le. ans)) then
<LI>-          lncnt(an) = lncnt(an) + 1
<LI>-       endif
<LI>-    enddo
<LI>-
<LI>-    lnoff(1) = 1
<LI>-    do an = 2,ans
<LI>-       lnoff(an) = lnoff(an-1) + lncnt(an-1)
<LI>-    enddo
<LI>-
<LI>-    lncnt = 0
<LI>-    lnmap = -1
<LI>-    do ln = 1,lns
<LI>-       an = ldomain%gatm(ln)
<LI>-       if ((an > 0) .and. (an .le. ans)) then
<LI>-         lnmap(lnoff(an)+lncnt(an)) = ln
<LI>-         lncnt(an) = lncnt(an) + 1
<LI>-       endif
<LI>-    enddo
<LI>-
<LI>-!    !--- count total pfts, like loop below, in case you need them "early"
<LI>-!    nump  = 0
<LI>-    anumg_tot = 0
<LI>-    do an = 1,ans
<LI>-       if (adomain%mask(an) == 1) then
<LI>-          anumg_tot  = anumg_tot  + 1
<LI>-!          do lnidx = 0,lncnt(an)-1
<LI>-!             ln = lnmap(lnoff(an)+lnidx)          
<LI>-!             call subgrid_get_gcellinfo (ln, wtxy, nlunits=ilunits, &
<LI>-!                                  ncols=icols, npfts=ipfts)
<LI>-!             nump = nump + ipfts
<LI>-!          enddo
<LI>-       endif
<LI>-    enddo
<LI>-!    nsegspc  = 1000000                  ! number of segments/clump
<LI>-    rnsegspc = min(float(nsegspc),float(anumg_tot)/float(nclumps))
<LI>-!    anumpc   = anumg_tot/nclumps
<LI>-!    anumxtra = mod(anumg_tot,nclumps)
<LI>-
<LI>-!    if (masterproc) write(6,*) 'precompute total pfts ',nump
<LI>-!    if (masterproc) write(6,*) 'precompute total anumg ',anumg_tot,anumpc,anumxtra
<LI>-    if (masterproc) write(6,*) 'precompute total anumg ',anumg_tot,rnsegspc
<LI>-
<LI>-    !--- assign gridcells to clumps (and thus pes) ---
<LI>-    allocate(lcid(lns),acid(ans))
<LI>-    lcid = 0
<LI>-    acid = 0
<LI>-    anumg = 0
<LI>-    numg  = 0
<LI>-    numl  = 0
<LI>-    numc  = 0
<LI>-    nump  = 0
<LI>-    do an = 1,ans
<LI>-       if (adomain%mask(an) == 1) then
<LI>-          anumg  = anumg  + 1
<LI>-
<LI>-#if (1 == 0) 
<LI>-          !--- find clump with fewest pfts ---
<LI>-          cid = 1
<LI>-          do n = 2,nclumps
<LI>-             if (clumps(n)%npfts < clumps(cid)%npfts) then
<LI>-                cid = n
<LI>-             endif
<LI>-          enddo
<LI>-#endif
<LI>-#if (1 == 0)
<LI>-          !--- give to clumps in simple round robin
<LI>-          cid = mod((anumg-1),nclumps) + 1
<LI>-#endif
<LI>-#if (1 == 1)
<LI>-          !--- give to clumps in order based on nsegspc
<LI>-          cid = int(rnsegspc*float(nclumps*(anumg-1))/float(anumg_tot))
<LI>-          cid = mod(cid,nclumps) + 1
<LI>-#endif
<LI>-          acid(an) = cid
<LI>-
<LI>-          !--- give atm cell to pe that owns cid ---
<LI>-          if (iam >  clumps(cid)%owner) then
<LI>-             procinfo%abegg = procinfo%abegg + 1
<LI>-          endif
<LI>-          if (iam >= clumps(cid)%owner) then
<LI>-             procinfo%aendg = procinfo%aendg + 1
<LI>-          endif
<LI>-
<LI>-          cnt = 0
<LI>-          do lnidx = 0,lncnt(an)-1
<LI>-             ln = lnmap(lnoff(an)+lnidx)          
<LI>-             cnt = cnt + 1
<LI>-             call subgrid_get_gcellinfo (ln, wtxy, nlunits=ilunits, &
<LI>-                                  ncols=icols, npfts=ipfts)
<LI>-             lcid(ln) = cid
<LI>-
<LI>-             !--- overall total ---
<LI>-             numg = numg + 1
<LI>-             numl = numl + ilunits
<LI>-             numc = numc + icols
<LI>-             nump = nump + ipfts
<LI>-
<LI>-             !--- give gridcell to cid ---
<LI>-             !--- increment the beg and end indices ---
<LI>-             clumps(cid)%ncells  = clumps(cid)%ncells  + 1
<LI>-             clumps(cid)%nlunits = clumps(cid)%nlunits + ilunits
<LI>-             clumps(cid)%ncols   = clumps(cid)%ncols   + icols
<LI>-             clumps(cid)%npfts   = clumps(cid)%npfts   + ipfts
<LI>-
<LI>-             do m = 1,nclumps
<LI>-                if ((clumps(m)%owner >  clumps(cid)%owner) .or. &
<LI>-                    (clumps(m)%owner == clumps(cid)%owner .and. m > cid)) then
<LI>-                   clumps(m)%begg = clumps(m)%begg + 1
<LI>-                   clumps(m)%begl = clumps(m)%begl + ilunits
<LI>-                   clumps(m)%begc = clumps(m)%begc + icols
<LI>-                   clumps(m)%begp = clumps(m)%begp + ipfts
<LI>-                endif
<LI>-
<LI>-                if ((clumps(m)%owner >  clumps(cid)%owner) .or. &
<LI>-                    (clumps(m)%owner == clumps(cid)%owner .and. m >= cid)) then
<LI>-                   clumps(m)%endg = clumps(m)%endg + 1
<LI>-                   clumps(m)%endl = clumps(m)%endl + ilunits
<LI>-                   clumps(m)%endc = clumps(m)%endc + icols
<LI>-                   clumps(m)%endp = clumps(m)%endp + ipfts
<LI>-                endif
<LI>-             enddo
<LI>-
<LI>-             !--- give gridcell to the proc that owns the cid ---
<LI>-             !--- increment the beg and end indices ---
<LI>-             if (iam == clumps(cid)%owner) then
<LI>-                procinfo%ncells  = procinfo%ncells  + 1
<LI>-                procinfo%nlunits = procinfo%nlunits + ilunits
<LI>-                procinfo%ncols   = procinfo%ncols   + icols
<LI>-                procinfo%npfts   = procinfo%npfts   + ipfts
<LI>-             endif
<LI>-
<LI>-             if (iam >  clumps(cid)%owner) then
<LI>-                procinfo%begg = procinfo%begg + 1
<LI>-                procinfo%begl = procinfo%begl + ilunits
<LI>-                procinfo%begc = procinfo%begc + icols
<LI>-                procinfo%begp = procinfo%begp + ipfts
<LI>-             endif
<LI>-
<LI>-             if (iam >= clumps(cid)%owner) then
<LI>-                procinfo%endg = procinfo%endg + 1
<LI>-                procinfo%endl = procinfo%endl + ilunits
<LI>-                procinfo%endc = procinfo%endc + icols
<LI>-                procinfo%endp = procinfo%endp + ipfts
<LI>-             endif
<LI>-          enddo
<LI>-          !--- check that atm cell has at least 1 lnd grid cell
<LI>-          if (cnt < 1) then
<LI>-             write (6,*) 'decomp_init(): map overlap error at ',an, &
<LI>-                adomain%mask(an),cnt
<LI>-             call endrun()
<LI>-          endif
<LI>-       end if
<LI>-    enddo
<LI>-
<LI>-    ! Error check on total number of gridcells
<LI>-
<LI>-    if (npes > anumg) then
<LI>-       write (6,*) 'decomp_init(): Number of processes exceeds number ', &
<LI>-            'of atm grid cells'
<LI>-       call endrun()
<LI>-    end if
<LI>-
<LI>-    ! Allocate dynamic memory for adecomp, ldecomp derived type
<LI>-
<LI>-    allocate(adecomp%gdc2gsn(anumg), adecomp%gsn2gdc(anumg), &
<LI>-             adecomp%gdc2glo(anumg), adecomp%glo2gdc(ani*anj), &
<LI>-             adecomp%gdc2i  (anumg), adecomp%gdc2j  (anumg), &
<LI>-             stat=ier)
<LI>-    if (ier /= 0) then
<LI>-       write (6,*) 'decomp_init(): allocation error1 for adecomp'
<LI>-       call endrun()
<LI>-    end if
<LI>-
<LI>-    adecomp%gdc2gsn(:)  = 0
<LI>-    adecomp%gsn2gdc(:)  = 0
<LI>-    adecomp%gdc2glo(:)  = 0
<LI>-    adecomp%glo2gdc(:)  = 0
<LI>-    adecomp%gdc2i(:)    = 0
<LI>-    adecomp%gdc2j(:)    = 0
<LI>-
<LI>-    allocate(ldecomp%gdc2gsn(numg), ldecomp%gsn2gdc(numg), &
<LI>-             ldecomp%gdc2glo(numg), ldecomp%glo2gdc(lni*lnj), &
<LI>-             ldecomp%gdc2i  (numg), ldecomp%gdc2j  (numg), &
<LI>-             stat=ier)
<LI>-    if (ier /= 0) then
<LI>-       write (6,*) 'decomp_init(): allocation error1 for ldecomp'
<LI>-       call endrun()
<LI>-    end if
<LI>-
<LI>-    ldecomp%gdc2gsn(:)  = 0
<LI>-    ldecomp%gsn2gdc(:)  = 0
<LI>-    ldecomp%gdc2glo(:)  = 0
<LI>-    ldecomp%glo2gdc(:)  = 0
<LI>-    ldecomp%gdc2i(:)    = 0
<LI>-    ldecomp%gdc2j(:)    = 0
<LI>-
<LI>-    !--- temporaries for decomp mappings
<LI>-    allocate(aglo2gsn(ani*anj),lglo2gsn(lni*lnj),stat=ier)
<LI>-    if (ier /= 0) then
<LI>-       write (6,*) 'decomp_init(): allocation error for al-glo2gsn'
<LI>-       call endrun()
<LI>-    end if
<LI>-    aglo2gsn(:) = 0
<LI>-    lglo2gsn(:) = 0
<LI>-
<LI>-    ag = 0
<LI>-    do aj = 1,anj
<LI>-    do ai = 1,ani
<LI>-       an = (aj-1)*ani + ai
<LI>-       if (acid(an) > 0) then
<LI>-          ag  = ag  + 1
<LI>-          aglo2gsn(an) = ag
<LI>-       endif
<LI>-    enddo
<LI>-    enddo
<LI>-
<LI>-    ! Set ldecomp sn indexing based on cells to be used and i,j order
<LI>-    lg  = 0
<LI>-    do lj = 1,lnj
<LI>-    do li = 1,lni
<LI>-       ln = (lj-1)*lni + li
<LI>-       if (lcid(ln) > 0) then
<LI>-          lg = lg + 1
<LI>-          lglo2gsn(ln) = lg
<LI>-       endif
<LI>-    enddo
<LI>-    enddo
<LI>-
<LI>-    ! Set ldecomp and adecomp data
<LI>-    ag = 0
<LI>-    lg = 0
<LI>-    do pid = 0,npes-1
<LI>-    do cid = 1,nclumps
<LI>-       if (clumps(cid)%owner == pid) then
<LI>-
<LI>-          do aj = 1,anj
<LI>-          do ai = 1,ani
<LI>-             an = (aj-1)*ani + ai
<LI>-             if (acid(an) == cid) then
<LI>-                ag = ag + 1
<LI>-                adecomp%gdc2i(ag) = ai
<LI>-                adecomp%gdc2j(ag) = aj
<LI>-                adecomp%gdc2gsn(ag) = aglo2gsn(an)
<LI>-                adecomp%gdc2glo(ag) = an
<LI>-                adecomp%gsn2gdc(aglo2gsn(an)) = ag
<LI>-                adecomp%glo2gdc(an) = ag
<LI>-             endif
<LI>-          enddo
<LI>-          enddo
<LI>-
<LI>-          do lj = 1,lnj
<LI>-          do li = 1,lni
<LI>-             ln = (lj-1)*lni + li
<LI>-             if (lcid(ln) == cid) then
<LI>-                lg = lg + 1
<LI>-                ldecomp%gdc2i(lg) = li
<LI>-                ldecomp%gdc2j(lg) = lj
<LI>-                ldecomp%gdc2gsn(lg) = lglo2gsn(ln)
<LI>-                ldecomp%gdc2glo(lg) = ln
<LI>-                ldecomp%gsn2gdc(lglo2gsn(ln)) = lg
<LI>-                ldecomp%glo2gdc(ln) = lg
<LI>-             endif
<LI>-          enddo
<LI>-          enddo
<LI>-       endif
<LI>-    enddo
<LI>-    enddo
<LI>-
<LI>-    deallocate(aglo2gsn,lglo2gsn)
<LI>-    deallocate(acid,lcid)
<LI>-    deallocate(lncnt,lnoff,lnmap)
<LI>-
<LI>-    ! set gsMap_lnd_gdc2glo, perm_lnd_gdc2glo
<LI>-    call get_proc_bounds(beg, end)
<LI>-    allocate(gindex(beg:end))
<LI>-    do n = beg,end
<LI>-       gindex(n) = ldecomp%gdc2glo(n)
<LI>-    enddo
<LI>-    lsize = end-beg+1
<LI>-    gsize = lni * lnj
<LI>-    allocate(perm_lnd_gdc2glo(lsize),stat=ier)
<LI>-    call mct_indexset(perm_lnd_gdc2glo)
<LI>-    call mct_indexsort(lsize,perm_lnd_gdc2glo,gindex)
<LI>-    call mct_permute(gindex,perm_lnd_gdc2glo,lsize)
<LI>-    call mct_gsMap_init(gsMap_lnd_gdc2glo, gindex, mpicom, comp_id, lsize, gsize )
<LI>-    deallocate(gindex)
<LI>-
<LI>-    ! set gsMap_atm_gdc2glo, perm_atm_gdc2glo
<LI>-    call get_proc_bounds_atm(beg, end)
<LI>-    allocate(gindex(beg:end))
<LI>-    do n = beg,end
<LI>-       gindex(n) = adecomp%gdc2glo(n)
<LI>-    enddo
<LI>-    lsize = end-beg+1
<LI>-    gsize = ani * anj
<LI>-    allocate(perm_atm_gdc2glo(lsize),stat=ier)
<LI>-    call mct_indexset(perm_atm_gdc2glo)
<LI>-    call mct_indexsort(lsize,perm_atm_gdc2glo,gindex)
<LI>-    call mct_permute(gindex,perm_atm_gdc2glo,lsize)
<LI>-    call mct_gsMap_init(gsMap_atm_gdc2glo, gindex, mpicom, comp_id, lsize, gsize )
<LI>-    deallocate(gindex)
<LI>-
<LI>-    ! Diagnostic output
<LI>-
<LI>-    if (masterproc) then
<LI>-       write (6,*)' Atm Grid Characteristics'
<LI>-       write (6,*)'   longitude points          = ',ani
<LI>-       write (6,*)'   latitude points           = ',anj
<LI>-       write (6,*)'   total number of gridcells = ',anumg
<LI>-       write (6,*)' Surface Grid Characteristics'
<LI>-       write (6,*)'   longitude points          = ',lni
<LI>-       write (6,*)'   latitude points           = ',lnj
<LI>-       write (6,*)'   total number of gridcells = ',numg
<LI>-       write (6,*)'   total number of landunits = ',numl
<LI>-       write (6,*)'   total number of columns   = ',numc
<LI>-       write (6,*)'   total number of pfts      = ',nump
<LI>-       write (6,*)' Decomposition Characteristics'
<LI>-       write (6,*)'   clumps per process        = ',clump_pproc
<LI>-       write (6,*)' gsMap Characteristics'
<LI>-       write (6,*) '  lnd gsmap glo num of segs = ',mct_gsMap_ngseg(gsMap_lnd_gdc2glo)
<LI>-       write (6,*) '  atm gsmap glo num of segs = ',mct_gsMap_ngseg(gsMap_atm_gdc2glo)
<LI>-       write (6,*)
<LI>-    end if
<LI>-
<LI>-    ! Write out clump and proc info, one pe at a time, 
<LI>-    ! barrier to control pes overwriting each other on stdout
<LI>-
<LI>-#ifndef UNICOSMP
<LI>-    call shr_sys_flush(6)
<LI>-#endif
<LI>-    call mpi_barrier(mpicom,ier)
<LI>-     npmin = 0
<LI>-     npmax = npes-1
<LI>-     npint = 1
<LI>-     if (dbug == 0) then
<LI>-        npmax = 0
<LI>-     elseif (dbug == 1) then
<LI>-        npmax = min(npes-1,4)
<LI>-     elseif (dbug == 2) then
<LI>-        npint = npes/8
<LI>-     endif
<LI>-     do np = npmin,npmax,npint
<LI>-       pid = np
<LI>-       if (dbug == 1) then
<LI>-          if (np == 2) pid=npes/2-1
<LI>-          if (np == 3) pid=npes-2
<LI>-          if (np == 4) pid=npes-1
<LI>-       endif
<LI>-       pid = max(pid,0)
<LI>-       pid = min(pid,npes-1)
<LI>-
<LI>-       if (iam == pid) then
<LI>-          write(6,*)
<LI>-          write(6,*)'proc= ',pid,' beg atmcell = ',procinfo%abegg, &
<LI>-               ' end atmcell = ',procinfo%aendg,                   &
<LI>-               ' total atmcells per proc = ',procinfo%aendg-procinfo%abegg+1
<LI>-          write(6,*)'proc= ',pid,' beg gridcell= ',procinfo%begg, &
<LI>-               ' end gridcell= ',procinfo%endg,                   &
<LI>-               ' total gridcells per proc= ',procinfo%ncells
<LI>-          write(6,*)'proc= ',pid,' beg landunit= ',procinfo%begl, &
<LI>-               ' end landunit= ',procinfo%endl,                   &
<LI>-               ' total landunits per proc= ',procinfo%nlunits
<LI>-          write(6,*)'proc= ',pid,' beg column  = ',procinfo%begc, &
<LI>-               ' end column  = ',procinfo%endc,                   &
<LI>-               ' total columns per proc  = ',procinfo%ncols
<LI>-          write(6,*)'proc= ',pid,' beg pft     = ',procinfo%begp, &
<LI>-               ' end pft     = ',procinfo%endp,                   &
<LI>-               ' total pfts per proc     = ',procinfo%npfts
<LI>-          write(6,*)'proc= ',pid,' lnd ngseg   = ',mct_gsMap_ngseg(gsMap_lnd_gdc2glo), &
<LI>-               ' lnd nlseg   = ',mct_gsMap_nlseg(gsMap_lnd_gdc2glo,iam)
<LI>-          write(6,*)'proc= ',pid,' atm ngseg   = ',mct_gsMap_ngseg(gsMap_atm_gdc2glo), &
<LI>-               ' atm nlseg   = ',mct_gsMap_nlseg(gsMap_atm_gdc2glo,iam)
<LI>-          write(6,*)'proc= ',pid,' nclumps = ',procinfo%nclumps
<LI>-
<LI>-          clmin = 1
<LI>-          clmax = procinfo%nclumps
<LI>-          if (dbug == 1) then
<LI>-            clmax = 1
<LI>-          elseif (dbug == 0) then
<LI>-            clmax = -1
<LI>-          endif
<LI>-          do n = clmin,clmax
<LI>-             cid = procinfo%cid(n)
<LI>-             write(6,*)'proc= ',pid,' clump no = ',n, &
<LI>-                  ' clump id= ',procinfo%cid(n),    &
<LI>-                  ' beg gridcell= ',clumps(cid)%begg, &
<LI>-                  ' end gridcell= ',clumps(cid)%endg, &
<LI>-                  ' total gridcells per clump= ',clumps(cid)%ncells
<LI>-             write(6,*)'proc= ',pid,' clump no = ',n, &
<LI>-                  ' clump id= ',procinfo%cid(n),    &
<LI>-                  ' beg landunit= ',clumps(cid)%begl, &
<LI>-                  ' end landunit= ',clumps(cid)%endl, &
<LI>-                  ' total landunits per clump = ',clumps(cid)%nlunits
<LI>-             write(6,*)'proc= ',pid,' clump no = ',n, &
<LI>-                  ' clump id= ',procinfo%cid(n),    &
<LI>-                  ' beg column  = ',clumps(cid)%begc, &
<LI>-                  ' end column  = ',clumps(cid)%endc, &
<LI>-                  ' total columns per clump  = ',clumps(cid)%ncols
<LI>-             write(6,*)'proc= ',pid,' clump no = ',n, &
<LI>-                  ' clump id= ',procinfo%cid(n),    &
<LI>-                  ' beg pft     = ',clumps(cid)%begp, &
<LI>-                  ' end pft     = ',clumps(cid)%endp, &
<LI>-                  ' total pfts per clump     = ',clumps(cid)%npfts
<LI>-          end do
<LI>-       end if
<LI>-#ifndef UNICOSMP
<LI>-       call shr_sys_flush(6)
<LI>-#endif
<LI>-       call mpi_barrier(mpicom,ier)
<LI>-    end do
<LI>-#ifndef UNICOSMP
<LI>-    call shr_sys_flush(6)
<LI>-#endif
<LI>-
<LI>-  end subroutine decomp_init
<LI>-#endif
<LI>-!------------------------------------------------------------------------------
<LI> !BOP
<LI> !
<LI> ! !IROUTINE: decomp_lnd_init
<LI>@@ -818,6 +247,7 @@
<LI>              !--- increment the beg and end indices ---
<LI>              if (iam == clumps(cid)%owner) then
<LI>                 procinfo%ncells  = procinfo%ncells  + 1
<LI>+
<LI>              endif
<LI> 
<LI>              if (iam >  clumps(cid)%owner) then
<LI>@@ -828,6 +258,7 @@
<LI>                 procinfo%endg = procinfo%endg + 1
<LI>              endif
<LI>           enddo
<LI>+
<LI>           !--- check that atm cell has at least 1 lnd grid cell
<LI>           if (cnt < 1) then
<LI>              write (6,*) 'decomp_lnd_init(): map overlap error at ',an,cnt
<LI>@@ -983,7 +414,9 @@
<LI>     integer, allocatable :: allvecl(:,:)  ! temporary vector "local"
<LI>     integer, pointer :: lglo2gsn(:)   ! map from glo 2 gsn temporary
<LI>     integer :: lnidx
<LI>-
<LI>+!abt rcm below
<LI>+    integer :: dummy_in               !temporary variable to store ncells
<LI>+!abt above
<LI> ! !CALLED FROM:
<LI> ! subroutine initialize
<LI> !
<LI>@@ -1231,6 +664,7 @@
<LI> 
<LI>     call shr_sys_flush(6)
<LI>     call mpi_barrier(mpicom,ier)
<LI>+
<LI>      npmin = 0
<LI>      npmax = npes-1
<LI>      npint = 1
<LI>@@ -1251,6 +685,7 @@
<LI>        pid = max(pid,0)
<LI>        pid = min(pid,npes-1)
<LI> 
<LI>+
<LI>        if (iam == pid) then
<LI>           write(6,*)
<LI>           write(6,*)'proc= ',pid,' beg atmcell = ',procinfo%abegg, &
<LI>@@ -1274,6 +709,7 @@
<LI>                ' atm nlseg   = ',mct_gsMap_nlseg(gsMap_atm_gdc2glo,iam)
<LI>           write(6,*)'proc= ',pid,' nclumps = ',procinfo%nclumps
<LI> 
<LI>+
<LI>           clmin = 1
<LI>           clmax = procinfo%nclumps
<LI>           if (dbug == 1) then
<LI>@@ -1308,8 +744,23 @@
<LI> #ifndef UNICOSMP
<LI>        call shr_sys_flush(6)
<LI> #endif
<LI>+
<LI>        call mpi_barrier(mpicom,ier)
<LI>     end do
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+!!!! total # of cells given to each processor !!! abt rcm below
<LI>+#ifdef MPP1
<LI>+    dummy_in = procinfo%ncells
<LI>+    call MPI_GATHER(dummy_in,1,MPI_INTEGER,c2rngc(iam+1),1,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
<LI>+    call MPI_BCAST(c2rngc(1),npes,MPI_INTEGER,0,MPI_COMM_WORLD,ier)
<LI>+#endif
<LI>+!!! abt above
<LI>+
<LI>+
<LI>+
<LI>     call shr_sys_flush(6)
<LI> 
<LI>   end subroutine decomp_glcp_init
<LI>@@ -1330,6 +781,7 @@
<LI> ! !USES:
<LI>     use clm_varctl, only : nsegspc
<LI>     use domainMod , only : latlon_type
<LI>+    use clm_varsur, only : landmask
<LI> !
<LI> ! !ARGUMENTS:
<LI>     implicit none
<LI>@@ -1547,6 +999,18 @@
<LI>     enddo
<LI>     enddo
<LI> 
<LI>+
<LI>+! abt rcm below (from regcmoce)
<LI>+    do aj = 1,anj
<LI>+    do ai = 1,ani
<LI>+      c2rprocmap(ai,aj) = -1
<LI>+    end do
<LI>+    end do
<LI>+!rcm above
<LI>+
<LI>+
<LI>+
<LI>+
<LI>     ! Set ldecomp and adecomp data
<LI>     ag = 0
<LI>     do pid = 0,npes-1
<LI>@@ -1557,6 +1021,11 @@
<LI>           do ai = 1,ani
<LI>              an = (aj-1)*ani + ai
<LI>              if (acid(an) == cid) then
<LI>+
<LI>+!abt rcm below
<LI>+             if (amask(an) == 1) c2rprocmap(ai,aj) = pid
<LI>+!rcm above
<LI>+
<LI>                 ag = ag + 1
<LI>                 adecomp%gdc2i(ag) = ai
<LI>                 adecomp%gdc2j(ag) = aj
<LI>@@ -1608,6 +1077,7 @@
<LI> 
<LI>     call shr_sys_flush(6)
<LI>     call mpi_barrier(mpicom,ier)
<LI>+
<LI>      npmin = 0
<LI>      npmax = npes-1
<LI>      npint = 1
<LI>@@ -1639,6 +1109,7 @@
<LI>        end if
<LI>        call shr_sys_flush(6)
<LI>        call mpi_barrier(mpicom,ier)
<LI>+
<LI>     end do
<LI> #ifndef UNICOSMP
<LI>     call shr_sys_flush(6)
</OL>
</PRE>

<HR>

</BODY>
</HTML>
