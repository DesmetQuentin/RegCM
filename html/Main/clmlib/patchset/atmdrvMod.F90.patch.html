<HTML>

<HEAD>
<TITLE>atmdrvMod.F90.patch</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>clmlib/patchset/atmdrvMod.F90.patch</H1>
<HR>
<H2 ALIGN=CENTER>atmdrvMod.F90.patch</H2>
<HR>
</FONT>

<HR>

<PRE>
<OL>
<LI>--- orig/atmdrvMod.F90	2010-03-10 16:34:21.000000000 +0100
<LI>+++ patchd/atmdrvMod.F90	2010-03-10 16:19:45.598596594 +0100
<LI>@@ -20,15 +20,24 @@
<LI>   use spmdMod      , only : masterproc, mpicom, comp_id, MPI_REAL8, MPI_INTEGER, iam
<LI>   use clm_mct_mod
<LI>   use decompMod    , only : gsMap_atm_gdc2glo, perm_atm_gdc2glo
<LI>+!c abt rcm
<LI>+  use clm_varpar   , only : lsmlon, lsmlat
<LI>+!c abt rcm
<LI>   use perf_mod
<LI>+  use mod_clm
<LI>+  use mod_dynparam
<LI> !
<LI> ! !PUBLIC TYPES:
<LI>   implicit none
<LI>   save
<LI>+! abt below rcm
<LI>+!rcm above
<LI> !
<LI> ! !PUBLIC MEMBER FUNCTIONS:
<LI>   public :: atmdrv_init  ! read atmospheric grid
<LI>   public :: atmdrv       ! read atmospheric data
<LI>+  public :: rcmdrv_init  ! read atmospheric grid regcm
<LI>+  public :: rcmdrv       ! read atmospheric data regcm
<LI> !
<LI> ! !REVISION HISTORY:
<LI> ! Created by Gordon Bonan, Sam Levis and Mariana Vertenstein
<LI>@@ -40,6 +49,11 @@
<LI>   private :: atm_openfile  ! open atmospheric forcing netCDF file
<LI>   private :: atm_readdata  ! read atmospheric forcing data
<LI>   private :: interpa2s     ! area average fields from atmosphere to surface grid
<LI>+!c abt rcm
<LI>+  private :: rcm_readdata  ! read atmospheric forcing data
<LI>+  private :: interpr2s     ! area average fields from atmosphere to surface grid
<LI>+!c abt rcm
<LI>+
<LI> !
<LI> ! PRIVATE TYPES:
<LI>   private
<LI>@@ -337,38 +351,615 @@
<LI> 
<LI>        end do
<LI> 
<LI>-       call clm_mapa2l(atm_a2l, clm_a2l)
<LI>+       call clm_mapa2l(atm_a2l, clm_a2l)
<LI>+
<LI>+       call t_stopf('atmdinterp')
<LI>+
<LI>+    end if
<LI>+
<LI>+    ! Reset open_data
<LI>+
<LI>+    if (open_data) then
<LI>+       open_data = .false.    !reset to false
<LI>+    elseif (kda == 1 .and. mcsec == 0) then
<LI>+       open_data = .true.     !for next time step
<LI>+    endif
<LI>+
<LI>+  end subroutine atmdrv
<LI>+
<LI>+
<LI>+
<LI>+!!!!! abt rcm below
<LI>+!------------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: rcmdrv
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine rcmdrv()   
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! This code reads in atmospheric fields from an input file and generates
<LI>+! the required atmospheric forcing. These data files have [atmmin] minute
<LI>+! average data for each month. Input data files are named in month-year
<LI>+! format (e.g., 09-0001 contains 240 3-hour time slices of data, 30*8, for
<LI>+! September of year one). The model will cycle through however many full
<LI>+! years of data are available [pyr]. At least one full year of data is
<LI>+! necessary for cycling. The model may start on any base date, as long as
<LI>+! this date corresponds to an existing data file. A run need not be an
<LI>+! exact multiple of a year.
<LI>+!
<LI>+! ============================
<LI>+! Possible atmospheric fields:
<LI>+! ============================
<LI>+! Name     Description                              Required/Optional
<LI>+! -----------------------------------------------------------------------------
<LI>+! TBOT     temperature (K)                          Required
<LI>+! WIND     wind:sqrt(u**2+v**2) (m/s)               Required
<LI>+! QBOT     specific humidity (kg/kg)                Required
<LI>+! Tdew     dewpoint temperature (K)                 Alternative to Q
<LI>+! RH       relative humidity (percent)              Alternative to Q
<LI>+! ZBOT     reference height (m)                     optional
<LI>+! PSRF     surface pressure (Pa)                    optional
<LI>+! FSDS     total incident solar radiation (W/m**2)  Required
<LI>+! FSDSdir  direct incident solar radiation (W/m**2) optional (replaces FSDS)
<LI>+! FSDSdif  diffuse incident solar rad (W/m**2)      optional (replaces FSDS)
<LI>+! FLDS     incident longwave radiation (W/m**2)     optional
<LI>+! PRECTmms total precipitation (mm H2O / sec)       Required
<LI>+! PRECCmms convective precipitation (mm H2O / sec)  optional (replaces PRECT)
<LI>+! PRECLmms large-scale precipitation (mm H2O / sec) optional (replaces PRECT)
<LI>+!
<LI>+! ============
<LI>+! Data format:
<LI>+! ============
<LI>+! Data format is netCDF with dimensions longitude x latitude
<LI>+! for each time slice and field. Variable names can be as in above list
<LI>+! or can be reset to desired names using [fldlst] in code below.
<LI>+!
<LI>+! ===============
<LI>+! Namelist input:
<LI>+! ===============
<LI>+! character*256 offline_atmdir = directory for input atm data files (can be Mass Store)
<LI>+!
<LI>+! !USES:
<LI>+    use nanMod
<LI>+    use decompMod   , only : adecomp, get_proc_bounds_atm
<LI>+    use clm_atmlnd  , only : clm_mapa2l, atm_a2l, clm_a2l,clm_mapr2l
<LI>+    use clm_varctl  , only : offline_atmdir, pertlim
<LI>+    use clm_varcon  , only : rair, cpair, co2_ppmv_const, o2_molar_const, tcrit, c13ratio
<LI>+    use clm_time_manager, only : get_step_size, get_curr_calday, get_curr_date
<LI>+    use fileutils   , only : getfil
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+!    integer, intent(in) :: nstep    !current time step
<LI>+!rcm below
<LI>+!    real(r8),intent(in) :: r2ctb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cqb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2czga(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cpsb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cuxb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cvxb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2crnc(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2crnnc(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2csols(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2csoll(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2csolsd(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2csolld(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cflwd(lsmlon,lsmlat)
<LI>+!rcm above
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Sam Levis
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! LOCAL VARIABLES:
<LI>+    integer :: i,j,n,k,g,g1           !indices
<LI>+    integer :: itimlast               !last time index used in atmrd
<LI>+    real(r8):: calday                 !calendar day at Greenwich (1.00 -> 365.99)
<LI>+    integer :: kda                    !day (1 -> 31)
<LI>+    integer :: kmo                    !month (1 -> 12)
<LI>+    integer :: kyr                    !year (0 -> ...)
<LI>+    integer :: ksec                   !current seconds of current date (0 -> 86400)
<LI>+    integer :: mcdate                 !current date in integer format [yyyymmdd]
<LI>+    integer :: mcsec                  !current time of day [seconds]
<LI>+    integer :: dtime                  !time step size
<LI>+    integer :: minpday = 1440         !minutes per day
<LI>+    integer :: secpmin = 60           !seconds per minute
<LI>+    integer, SAVE :: itim             !time index used in atmrd
<LI>+    integer, SAVE :: atmmin           !temporal resolution of atm data (in minutes)
<LI>+    character(len=256), SAVE :: locfn !full file name in case atmdir is in MSS
<LI>+    real(r8):: coefb        ! Slope of "Alta" expression for dependence of flfall on temp
<LI>+    real(r8):: coefa        ! Offset of  of "Alta" expression for dependence of flfall on temp
<LI>+    integer :: begg, endg   ! per-proc gridcell ending gridcell indices
<LI>+!------------------------------------------------------------------------
<LI>+
<LI>+    ! Determine necessary indices
<LI>+
<LI>+    call get_proc_bounds_atm(begg, endg)
<LI>+
<LI>+    ! -----------------------------------------------------------------
<LI>+    ! Open netcdf file and read data every [atmmin] minutes
<LI>+    ! -----------------------------------------------------------------
<LI>+
<LI>+    ! Calendar information for current [nstep]
<LI>+
<LI>+    dtime = get_step_size()
<LI>+    calday = get_curr_calday()
<LI>+    call get_curr_date(kyr, kmo, kda, mcsec)
<LI>+    mcdate = kyr*10000 + kmo*100 + kda
<LI>+
<LI>+    ! If 1st tstep of the run or of the month, then enter next if-block
<LI>+    ! Rest flag to open file and set flag to read data
<LI>+!c abt rcm below
<LI>+!    locfn = " "
<LI>+!    if (open_data) then
<LI>+!       call atm_openfile (kda, kmo, kyr, locfn, itim, atmmin)
<LI>+!    endif
<LI>+
<LI>+ !   ! Calculate time index
<LI>+!
<LI>+ !   itimlast = itim
<LI>+ !   itim = 1 + ((kda - 1)*minpday + (mcsec - dtime)/secpmin)/atmmin
<LI>+ !   if (dtime == int(atmmin*secpmin)) then
<LI>+ !      if (kda == 1 .and. mcsec == 0) itim = itimlast+1
<LI>+ !   else
<LI>+ !      if (kda == 1 .and. mcsec == 0) itim = itimlast
<LI>+ !   endif
<LI>+
<LI>+!    ! Determine if new data is to be read
<LI>+
<LI>+!    if (open_data .or. mod(nstep-1,atmmin*secpmin/dtime) ==0 ) then
<LI>+!
<LI>+!       ! Read data for current time slice
<LI>+!
<LI>+       call t_startf('atmdread')
<LI>+
<LI>+ !      if (masterproc) then
<LI>+  !        write (6,*)
<LI>+ !         write (6,'(72a1)') ("-",i=1,60)
<LI>+ !         write (6,*)'nstep= ',nstep,' date= ',mcdate,' sec= ',mcsec
<LI>+ !         if ( len_trim(locfn) > 0 )then
<LI>+ !            write (6,*)'ATMDRV: attempting to read data from ',trim(locfn)
<LI>+ !         end if
<LI>+ !         write (6,'(72a1)') ("-",i=1,60)
<LI>+ !         write (6,*)
<LI>+ !      endif
<LI>+!c abt rcm above
<LI>+
<LI>+
<LI>+       call rcm_readdata ()
<LI>+       call t_stopf('atmdread')
<LI>+
<LI>+       ! Map 2d atmospheric fields from atmospheric grid to land model surface grid.
<LI>+       ! Area-average absolute value of winds (i.e., regardless of
<LI>+       ! direction) since land model cares about magnitude not direction.
<LI>+       ! Then need to adjust resultant stresses for direction of wind.
<LI>+
<LI>+       call t_startf('atmdinterp')
<LI>+
<LI>+!abt       call interpa2s
<LI>+           call interpr2s()
<LI>+
<LI>+       ! Map data fields to atm model: [datlon] x [datlat] grid ->
<LI>+       ! [numland] vector of land points -> [numpatch] vector of subgrid patches
<LI>+
<LI>+!$OMP PARALLEL DO PRIVATE (g,i,j,n)
<LI>+#if !defined (USE_OMP)
<LI>+!CSD$ PARALLEL DO PRIVATE (g,i,j,n)
<LI>+#endif
<LI>+!dir$ concurrent
<LI>+!cdir nodep
<LI>+
<LI>+       do g = begg, endg
<LI>+          g1 = g - begg + 1
<LI>+          i = adecomp%gdc2i(g)
<LI>+          j = adecomp%gdc2j(g)
<LI>+          n = adecomp%gdc2glo(g)
<LI>+
<LI>+          !States
<LI>+          atm_a2l%forc_t(g) = r2ctb_all(i,j)
<LI>+          atm_a2l%forc_u(g) = r2cuxb_all(i,j)
<LI>+          atm_a2l%forc_v(g) = r2cvxb_all(i,j)
<LI>+          atm_a2l%forc_wind(g) = sqrt(r2cuxb_all(i,j)**2 + r2cvxb_all(i,j)**2)
<LI>+          atm_a2l%forc_q(g) = r2cqb_all(i,j)
<LI>+          atm_a2l%forc_hgt(g) = r2czga_all(i,j)
<LI>+          atm_a2l%forc_hgt_u(g) = r2czga_all(i,j) !observational height of wind [m]
<LI>+          atm_a2l%forc_hgt_t(g) = r2czga_all(i,j) !observational height of temp [m
<LI>+          atm_a2l%forc_hgt_q(g) = r2czga_all(i,j) !observational height of humidity [m]!   
<LI>+          atm_a2l%forc_pbot(g) = r2cpsb_all(i,j)
<LI>+          atm_a2l%forc_psrf(g) = r2cpsb_all(i,j)
<LI>+          atm_a2l%forc_th(g)  = atm_a2l%forc_t(g) * (atm_a2l%forc_psrf(g) &
<LI>+               / atm_a2l%forc_pbot(g))**(rair/cpair)
<LI>+          atm_a2l%forc_vp(g)  = atm_a2l%forc_q(g) * atm_a2l%forc_pbot(g) &
<LI>+               / (0.622_r8 + 0.378_r8 * atm_a2l%forc_q(g))
<LI>+          atm_a2l%forc_rho(g) = (atm_a2l%forc_pbot(g) - 0.378_r8 * atm_a2l%forc_vp(g)) &
<LI>+               / (rair * atm_a2l%forc_t(g))
<LI>+
<LI>+          !BGC tracers
<LI>+
<LI>+          atm_a2l%forc_pco2(g) = co2_ppmv_const * 1.e-6_r8 * atm_a2l%forc_pbot(g)
<LI>+          atm_a2l%forc_po2(g)  = o2_molar_const * atm_a2l%forc_pbot(g)
<LI>+          ! 4/14/05: PET
<LI>+          ! Adding isotope code
<LI>+          atm_a2l%forc_pc13o2(g) = co2_ppmv_const * c13ratio * 1.e-6_r8 * atm_a2l%forc_pbot(g)
<LI>+
<LI>+          !Fluxes
<LI>+
<LI>+          atm_a2l%forc_lwrad(g)   = r2cflwd_all(i,j)
<LI>+          atm_a2l%forc_solad(g,1) = r2csols_all(i,j)
<LI>+          atm_a2l%forc_solad(g,2) = r2csoll_all(i,j)
<LI>+          atm_a2l%forc_solai(g,1) = r2csolsd_all(i,j)
<LI>+          atm_a2l%forc_solai(g,2) = r2csolld_all(i,j)
<LI>+          atm_a2l%forc_solar(g) = atm_a2l%forc_solad(g,1) + atm_a2l%forc_solad(g,2) &
<LI>+               + atm_a2l%forc_solai(g,1) + atm_a2l%forc_solai(g,2)
<LI>+
<LI>+          ! Snow and Rain
<LI>+          ! Set upper limit of air temperature for snowfall at 275.65K.
<LI>+          ! This cut-off was selected based on Fig. 1, Plate 3-1, of Snow
<LI>+          ! Hydrology (1956).
<LI>+
<LI>+          if (r2crnc_all(i,j) + r2crnnc_all(i,j) > 0._r8) then
<LI>+             if (atm_a2l%forc_t(g) > (SHR_CONST_TKFRZ + tcrit)) then
<LI>+                atm_a2l%forc_rain(g) = r2crnc_all(i,j) + r2crnnc_all(i,j)
<LI>+                atm_a2l%forc_snow(g) = 0._r8
<LI>+                atm_a2l%flfall(g) = 1._r8
<LI>+             else
<LI>+                atm_a2l%forc_rain(g) = 0._r8
<LI>+                atm_a2l%forc_snow(g) = r2crnc_all(i,j) + r2crnnc_all(i,j)
<LI>+                if (atm_a2l%forc_t(g) <= SHR_CONST_TKFRZ) then
<LI>+                   atm_a2l%flfall(g) = 0._r8
<LI>+                else if (atm_a2l%forc_t(g) <= SHR_CONST_TKFRZ+2._r8) then
<LI>+                   atm_a2l%flfall(g) = -0.2_r8*SHR_CONST_TKFRZ + 0.2_r8*atm_a2l%forc_t(g)
<LI>+                else
<LI>+                   atm_a2l%flfall(g) = 0.4_r8
<LI>+                endif
<LI>+             endif
<LI>+          else
<LI>+             atm_a2l%forc_rain(g) = 0._r8
<LI>+             atm_a2l%forc_snow(g) = 0._r8
<LI>+             atm_a2l%flfall(g) = 1._r8
<LI>+          endif
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+          !States
<LI>+! abt rcm below         atm_a2l%forc_t(g) = aV_drv_d2a%rAttr(if_txy,g1)
<LI>+!          atm_a2l%forc_u(g) = aV_drv_d2a%rAttr(if_uxy,g1)
<LI>+!          atm_a2l%forc_v(g) = aV_drv_d2a%rAttr(if_vxy,g1)
<LI>+!          atm_a2l%forc_wind(g) = sqrt(aV_drv_d2a%rAttr(if_uxy,g1)**2 + aV_drv_d2a%rAttr(if_vxy,g1)**2)
<LI>+!          atm_a2l%forc_q(g) = aV_drv_d2a%rAttr(if_qxy,g1)
<LI>+!          atm_a2l%forc_hgt(g) = aV_drv_d2a%rAttr(izgcmxy,g1)
<LI>+!          atm_a2l%forc_hgt_u(g) = aV_drv_d2a%rAttr(izgcmxy,g1) !observational height of wind [m]
<LI>+!          atm_a2l%forc_hgt_t(g) = aV_drv_d2a%rAttr(izgcmxy,g1) !observational height of temp [m]
<LI>+!          atm_a2l%forc_hgt_q(g) = aV_drv_d2a%rAttr(izgcmxy,g1) !observational height of humidity [m]
<LI>+!          atm_a2l%forc_pbot(g) = aV_drv_d2a%rAttr(if_pbotxy,g1)
<LI>+!          atm_a2l%forc_psrf(g) = aV_drv_d2a%rAttr(if_psrfxy,g1)
<LI>+!          atm_a2l%forc_th(g)  = atm_a2l%forc_t(g) * (atm_a2l%forc_psrf(g) &
<LI>+!               / atm_a2l%forc_pbot(g))**(rair/cpair)
<LI>+!          atm_a2l%forc_vp(g)  = atm_a2l%forc_q(g) * atm_a2l%forc_pbot(g) &
<LI>+!               / (0.622_r8 + 0.378_r8 * atm_a2l%forc_q(g))
<LI>+!          atm_a2l%forc_rho(g) = (atm_a2l%forc_pbot(g) - 0.378_r8 * atm_a2l%forc_vp(g)) &
<LI>+!               / (rair * atm_a2l%forc_t(g))
<LI>+
<LI>+          !BGC tracers
<LI>+
<LI>+!          atm_a2l%forc_pco2(g) = co2_ppmv_const * 1.e-6_r8 * atm_a2l%forc_pbot(g)
<LI>+!          atm_a2l%forc_po2(g)  = o2_molar_const * atm_a2l%forc_pbot(g)
<LI>+!          ! 4/14/05: PET
<LI>+!          ! Adding isotope code
<LI>+!          atm_a2l%forc_pc13o2(g) = co2_ppmv_const * c13ratio * 1.e-6_r8 * atm_a2l%forc_pbot(g)
<LI>+
<LI>+!          !Fluxes
<LI>+
<LI>+!          atm_a2l%forc_lwrad(g) = aV_drv_d2a%rAttr(iflwdsxy,g1)
<LI>+!          atm_a2l%forc_solad(g,1) = aV_drv_d2a%rAttr(if_sols,g1)
<LI>+!          atm_a2l%forc_solad(g,2) = aV_drv_d2a%rAttr(if_soll,g1)
<LI>+!          atm_a2l%forc_solai(g,1) = aV_drv_d2a%rAttr(if_solsd,g1)
<LI>+!          atm_a2l%forc_solai(g,2) = aV_drv_d2a%rAttr(if_solld,g1)
<LI>+!          atm_a2l%forc_solar(g) = atm_a2l%forc_solad(g,1) + atm_a2l%forc_solad(g,2) &
<LI>+!               + atm_a2l%forc_solai(g,1) + atm_a2l%forc_solai(g,2)
<LI>+
<LI>+          ! Snow and Rain
<LI>+          ! Set upper limit of air temperature for snowfall at 275.65K.
<LI>+          ! This cut-off was selected based on Fig. 1, Plate 3-1, of Snow
<LI>+          ! Hydrology (1956).
<LI>+
<LI>+!          if (aV_drv_d2a%rAttr(iprcxy,g1) + aV_drv_d2a%rAttr(iprlxy,g1) > 0._r8) then
<LI>+!             if (atm_a2l%forc_t(g) > (SHR_CONST_TKFRZ + tcrit)) then
<LI>+!                atm_a2l%forc_rain(g) = aV_drv_d2a%rAttr(iprcxy,g1) + aV_drv_d2a%rAttr(iprlxy,g1)
<LI>+!                atm_a2l%forc_snow(g) = 0._r8
<LI>+!                atm_a2l%flfall(g) = 1._r8
<LI>+!             else
<LI>+!                atm_a2l%forc_rain(g) = 0._r8
<LI>+!                atm_a2l%forc_snow(g) = aV_drv_d2a%rAttr(iprcxy,g1) + aV_drv_d2a%rAttr(iprlxy,g1)
<LI>+!                if (atm_a2l%forc_t(g) <= SHR_CONST_TKFRZ) then
<LI>+!                   atm_a2l%flfall(g) = 0._r8
<LI>+!                else if (atm_a2l%forc_t(g) <= SHR_CONST_TKFRZ+2._r8) then
<LI>+!                   atm_a2l%flfall(g) = -0.2_r8*SHR_CONST_TKFRZ + 0.2_r8*atm_a2l%forc_t(g)
<LI>+!                else
<LI>+!                   atm_a2l%flfall(g) = 0.4_r8
<LI>+!                endif
<LI>+!             endif
<LI>+!          else
<LI>+!             atm_a2l%forc_rain(g) = 0._r8
<LI>+!             atm_a2l%forc_snow(g) = 0._r8
<LI>+!             atm_a2l%flfall(g) = 1._r8
<LI>+!          endif
<LI>+
<LI>+
<LI>+          !States
<LI>+!          atm_a2l%forc_t(g) = aV_atm_d2a%rAttr(if_txy,g1)
<LI>+!          atm_a2l%forc_u(g) = aV_atm_d2a%rAttr(if_uxy,g1)
<LI>+!          atm_a2l%forc_v(g) = aV_atm_d2a%rAttr(if_vxy,g1)
<LI>+!          atm_a2l%forc_wind(g) = sqrt(aV_atm_d2a%rAttr(if_uxy,g1)**2 + aV_atm_d2a%rAttr(if_vxy,g1)**2)
<LI>+!          atm_a2l%forc_q(g) = aV_atm_d2a%rAttr(if_qxy,g1)
<LI>+!          atm_a2l%forc_hgt(g) = aV_atm_d2a%rAttr(izgcmxy,g1)
<LI>+!          atm_a2l%forc_hgt_u(g) = aV_atm_d2a%rAttr(izgcmxy,g1) !observational height of wind [m]
<LI>+!          atm_a2l%forc_hgt_t(g) = aV_atm_d2a%rAttr(izgcmxy,g1) !observational height of temp [m]
<LI>+!          atm_a2l%forc_hgt_q(g) = aV_atm_d2a%rAttr(izgcmxy,g1) !observational height of humidity [m]
<LI>+!          atm_a2l%forc_pbot(g) = aV_atm_d2a%rAttr(if_pbotxy,g1)
<LI>+!          atm_a2l%forc_psrf(g) = aV_atm_d2a%rAttr(if_psrfxy,g1)
<LI>+!          atm_a2l%forc_th(g)  = atm_a2l%forc_t(g) * (atm_a2l%forc_psrf(g) &
<LI>+!               / atm_a2l%forc_pbot(g))**(rair/cpair)
<LI>+!          atm_a2l%forc_vp(g)  = atm_a2l%forc_q(g) * atm_a2l%forc_pbot(g) &
<LI>+!               / (0.622_r8 + 0.378_r8 * atm_a2l%forc_q(g))
<LI>+!          atm_a2l%forc_rho(g) = (atm_a2l%forc_pbot(g) - 0.378_r8 * atm_a2l%forc_vp(g)) &
<LI>+ !              / (rair * atm_a2l%forc_t(g))
<LI>+
<LI>+          !BGC tracers
<LI>+
<LI>+ !         atm_a2l%forc_pco2(g) = co2_ppmv_const * 1.e-6_r8 * atm_a2l%forc_pbot(g)
<LI>+ !         atm_a2l%forc_po2(g)  = o2_molar_const * atm_a2l%forc_pbot(g)
<LI>+          ! 4/14/05: PET
<LI>+          ! Adding isotope code
<LI>+!          atm_a2l%forc_pc13o2(g) = co2_ppmv_const * c13ratio * 1.e-6_r8 * atm_a2l%forc_pbot(g)
<LI>+
<LI>+          !Fluxes
<LI>+
<LI>+!          atm_a2l%forc_lwrad(g) = aV_atm_d2a%rAttr(iflwdsxy,g1)
<LI>+!          atm_a2l%forc_solad(g,1) = aV_atm_d2a%rAttr(if_sols,g1)
<LI>+!          atm_a2l%forc_solad(g,2) = aV_atm_d2a%rAttr(if_soll,g1)
<LI>+!          atm_a2l%forc_solai(g,1) = aV_atm_d2a%rAttr(if_solsd,g1)
<LI>+!          atm_a2l%forc_solai(g,2) = aV_atm_d2a%rAttr(if_solld,g1)
<LI>+!          atm_a2l%forc_solar(g) = atm_a2l%forc_solad(g,1) + atm_a2l%forc_solad(g,2) &
<LI>+!               + atm_a2l%forc_solai(g,1) + atm_a2l%forc_solai(g,2)
<LI>+
<LI>+          ! Snow and Rain
<LI>+          ! Set upper limit of air temperature for snowfall at 275.65K.
<LI>+          ! This cut-off was selected based on Fig. 1, Plate 3-1, of Snow
<LI>+          ! Hydrology (1956).
<LI>+
<LI>+!          if (aV_atm_d2a%rAttr(iprcxy,g1) + aV_atm_d2a%rAttr(iprlxy,g1) > 0._r8) then
<LI>+!             if (atm_a2l%forc_t(g) > (SHR_CONST_TKFRZ + tcrit)) then
<LI>+!                atm_a2l%forc_rain(g) = aV_atm_d2a%rAttr(iprcxy,g1) + aV_atm_d2a%rAttr(iprlxy,g1)
<LI>+!                atm_a2l%forc_snow(g) = 0._r8
<LI>+!                atm_a2l%flfall(g) = 1._r8
<LI>+!             else
<LI>+!                atm_a2l%forc_rain(g) = 0._r8
<LI>+!                atm_a2l%forc_snow(g) = aV_atm_d2a%rAttr(iprcxy,g1) + aV_atm_d2a%rAttr(iprlxy,g1)
<LI>+!                if (atm_a2l%forc_t(g) <= SHR_CONST_TKFRZ) then
<LI>+!                   atm_a2l%flfall(g) = 0._r8
<LI>+!                else if (atm_a2l%forc_t(g) <= SHR_CONST_TKFRZ+2._r8) then
<LI>+!                   atm_a2l%flfall(g) = -0.2_r8*SHR_CONST_TKFRZ + 0.2_r8*atm_a2l%forc_t(g)
<LI>+!                else
<LI>+!                   atm_a2l%flfall(g) = 0.4_r8
<LI>+!                endif
<LI>+!             endif
<LI>+!          else
<LI>+!             atm_a2l%forc_rain(g) = 0._r8
<LI>+!             atm_a2l%forc_snow(g) = 0._r8
<LI>+!             atm_a2l%flfall(g) = 1._r8
<LI>+!abt above          endif
<LI>+
<LI>+
<LI>+       end do
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+! abt      call clm_mapa2l(atm_a2l, clm_a2l)
<LI>+       call clm_mapr2l(atm_a2l, clm_a2l)
<LI>+
<LI>+       call t_stopf('atmdinterp')
<LI>+
<LI>+    ! Reset open_data
<LI>+
<LI>+!abt    if (open_data) then
<LI>+!       open_data = .false.    !reset to false
<LI>+!    elseif (kda == 1 .and. mcsec == 0) then
<LI>+!       open_data = .true.     !for next time step
<LI>+!abt    endif
<LI>+
<LI>+  end subroutine rcmdrv
<LI>+
<LI>+!!! abt rcm above
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+!------------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: atmdrv_init
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine atmdrv_init()
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Read atmospheric grid
<LI>+!
<LI>+! !USES:
<LI>+    use nanMod
<LI>+    use clm_varctl  , only : offline_atmdir
<LI>+    use domainMod   , only : alatlon, latlon_type, latlon_check, latlon_clean
<LI>+    use surfrdMod   , only : surfrd_get_latlon
<LI>+    use decompMod   , only : adecomp
<LI>+    use areaMod     , only : celledge, cellarea,map_setmapsAR
<LI>+    use fileutils   , only : getfil
<LI>+    use clm_time_manager, only : get_curr_date
<LI>+    use ncdio
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Mariana Vertenstein
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! LOCAL VARIABLES:
<LI>+    type(latlon_type)  :: dlatlon        ! data file domain
<LI>+    integer :: kda                !day (1 -> 31)
<LI>+    integer :: kmo                !month (1 -> 12)
<LI>+    integer :: kyr                !year (0 -> ...)
<LI>+    integer :: ksec               !current seconds of current date (0 -> 86400)
<LI>+    integer :: mcsec              !current time of day [seconds]
<LI>+    character(len=  7) :: ext     !month-year extension, e.g., 01-0005
<LI>+    character(len=256) :: filenam !full file name, atmdir + ext
<LI>+    character(len=256) :: locfn   !full file name in case atmdir is in MSS
<LI>+    logical :: lexist             !true => file exists, used when looking for a file
<LI>+    integer :: dimid              !netCDF dimension id
<LI>+    integer :: varid              !netCDF variable id
<LI>+    integer :: ier                !error status
<LI>+    character(len=32) :: subname = 'atmdrv_init'
<LI>+    integer :: atmlon,atmlat      !size of alatlon
<LI>+    real(r8), allocatable :: mask_d(:)   !dummy field: atm grid mask
<LI>+    real(r8), allocatable :: mask_a(:)   !dummy field: land model grid mask
<LI>+    character(len=256) :: str     ! string
<LI>+    integer :: n                  ! generic index
<LI>+    integer :: ns                 ! size
<LI>+    integer :: ngseg              ! gsmap size
<LI>+    integer :: root               ! root pe number
<LI>+    integer,allocatable :: start(:),length(:),pe_loc(:)  ! for gsmap
<LI>+!------------------------------------------------------------------------
<LI>+
<LI>+    atmlon = alatlon%ni
<LI>+    atmlat = alatlon%nj
<LI>+
<LI>+    ! ----------------------------------------------------------------------
<LI>+    ! Read offline grid data and allocate dynamic memory
<LI>+    ! ----------------------------------------------------------------------
<LI>+
<LI>+    ! Build [month]-[year] extension for file name to be read
<LI>+    ! append extension to path name to get full file name
<LI>+
<LI>+    call get_curr_date(kyr, kmo, kda, mcsec)
<LI>+    write (ext,'(i4.4,"-",i2.2)') kyr,kmo
<LI>+    filenam = trim(offline_atmdir) // '/' // ext // '.nc'
<LI>+
<LI>+    call surfrd_get_latlon(dlatlon, filenam)
<LI>+    call latlon_check(dlatlon)
<LI>+
<LI>+    datlon = dlatlon%ni
<LI>+    datlat = dlatlon%nj
<LI>+
<LI>+    ! Initialize gsmaps and attr vectors
<LI>+    ngseg = 1
<LI>+    root = 0
<LI>+    allocate(start(ngseg),length(ngseg),pe_loc(ngseg))
<LI>+    start = 1
<LI>+    length = datlon*datlat
<LI>+    pe_loc = root
<LI>+    call mct_gsMap_init(gsMap_drv_glo0,ngseg,start,length,pe_loc,root,mpicom,comp_id)
<LI>+    deallocate(start,length,pe_loc)
<LI>+
<LI>+    str = trim(av_d2a_list(1))
<LI>+    do n = 2,av_d2a_size
<LI>+       str = trim(str)//':'//trim(av_d2a_list(n))
<LI>+    enddo
<LI>+
<LI>+    ns = mct_gsMap_lsize(gsMap_drv_glo0, mpicom)
<LI>+    call mct_aVect_init(aV_drv_d2a,rlist=str,lsize=ns)
<LI>+    ns = mct_gsMap_lsize(gsMap_atm_gdc2glo, mpicom)
<LI>+    call mct_aVect_init(aV_atm_d2a,rlist=str,lsize=ns)
<LI>+
<LI>+    if_txy    = mct_aVect_indexRA(aV_drv_d2a,'f_txy'   ,perrWith=subName)
<LI>+    if_uxy    = mct_aVect_indexRA(aV_drv_d2a,'f_uxy'   ,perrWith=subName)
<LI>+    if_vxy    = mct_aVect_indexRA(aV_drv_d2a,'f_vxy'   ,perrWith=subName)
<LI>+    if_qxy    = mct_aVect_indexRA(aV_drv_d2a,'f_qxy'   ,perrWith=subName)
<LI>+    izgcmxy   = mct_aVect_indexRA(aV_drv_d2a,'zgcmxy'  ,perrWith=subName)
<LI>+    iprcxy    = mct_aVect_indexRA(aV_drv_d2a,'prcxy'   ,perrWith=subName)
<LI>+    iprlxy    = mct_aVect_indexRA(aV_drv_d2a,'prlxy'   ,perrWith=subName)
<LI>+    iflwdsxy  = mct_aVect_indexRA(aV_drv_d2a,'flwdsxy' ,perrWith=subName)
<LI>+    if_sols   = mct_aVect_indexRA(aV_drv_d2a,'f_sols'  ,perrWith=subName)
<LI>+    if_soll   = mct_aVect_indexRA(aV_drv_d2a,'f_soll'  ,perrWith=subName)
<LI>+    if_solsd  = mct_aVect_indexRA(aV_drv_d2a,'f_solsd' ,perrWith=subName)
<LI>+    if_solld  = mct_aVect_indexRA(aV_drv_d2a,'f_solld' ,perrWith=subName)
<LI>+    if_pbotxy = mct_aVect_indexRA(aV_drv_d2a,'f_pbotxy',perrWith=subName)
<LI>+    if_psrfxy = mct_aVect_indexRA(aV_drv_d2a,'f_psrfxy',perrWith=subName)
<LI>+    
<LI>+    allocate( x(datlon,datlat,14), stat=ier)
<LI>+    if (ier /= 0) then
<LI>+       write (6,*) 'atmdrv_init(): allocation error _d'
<LI>+       call endrun
<LI>+    end if
<LI>+
<LI>+    ! Initialize gridmap_d2a
<LI>+
<LI>+    allocate (mask_d(datlon*datlat),mask_a(atmlon*atmlat), stat=ier)
<LI>+    if (ier /= 0) then
<LI>+       write (6,*) 'mask_d, mask_a allocation error'
<LI>+       call endrun
<LI>+    end if
<LI>+
<LI>+    mask_d = 1._r8
<LI>+    mask_a = 0._r8
<LI>+    do n = 1,atmlon*atmlat
<LI>+       if (adecomp%glo2gdc(n) > 0) mask_a(n) = 1._r8
<LI>+    enddo
<LI>+    if (masterproc) then
<LI>+       call map_setmapsAR(dlatlon, alatlon, sMat0_d2a, fracin=mask_d, fracout=mask_a)
<LI>+    endif
<LI>+
<LI>+    deallocate (mask_d, mask_a)
<LI>+
<LI>+    call mct_sMatP_init(sMatP_d2a, sMat0_d2a, &
<LI>+                        gsMap_drv_glo0, gsMap_atm_gdc2glo, &
<LI>+                        'Xonly',0,mpicom,comp_id)
<LI>+
<LI>+#ifdef CPP_VECTOR
<LI>+    !--- initialize the vector parts of the sMat
<LI>+    call mct_sMatP_Vecinit(sMatP_d2a)
<LI>+#endif
<LI>+
<LI>+    !--- clean up the root sMat0 datatypes
<LI> 
<LI>-       call t_stopf('atmdinterp')
<LI>+    if (masterproc) then
<LI>+       call mct_sMat_clean(sMat0_d2a)
<LI>+    endif
<LI> 
<LI>+    if ( masterproc )then
<LI>+       write (6,*) 'Successfully made atm -> srf interpolation'
<LI>+       write (6,*) 'Successfully initialized area-averaging interpolation'
<LI>+       write (6,*)
<LI>     end if
<LI> 
<LI>-    ! Reset open_data
<LI>-
<LI>-    if (open_data) then
<LI>-       open_data = .false.    !reset to false
<LI>-    elseif (kda == 1 .and. mcsec == 0) then
<LI>-       open_data = .true.     !for next time step
<LI>-    endif
<LI>+    call latlon_clean(dlatlon)
<LI> 
<LI>-  end subroutine atmdrv
<LI>+  end subroutine atmdrv_init
<LI> 
<LI>+!!!!!!!! abt rcm below
<LI> !------------------------------------------------------------------------
<LI> !BOP
<LI> !
<LI>-! !IROUTINE: atmdrv_init
<LI>+! !IROUTINE: rcmdrv_init
<LI> !
<LI> ! !INTERFACE:
<LI>-  subroutine atmdrv_init()
<LI>+  subroutine rcmdrv_init()
<LI> !
<LI> ! !DESCRIPTION:
<LI> ! Read atmospheric grid
<LI> !
<LI> ! !USES:
<LI>     use nanMod
<LI>-    use clm_varctl  , only : offline_atmdir
<LI>+    use clm_varctl  , only : offline_atmdir, mksrf_offline_fnavyoro !abt
<LI>     use domainMod   , only : alatlon, latlon_type, latlon_check, latlon_clean
<LI>-    use surfrdMod   , only : surfrd_get_latlon
<LI>+    use surfrdMod   , only : rcmsurfrd_get_latlon
<LI>     use decompMod   , only : adecomp
<LI>     use areaMod     , only : celledge, cellarea,map_setmapsAR
<LI>     use fileutils   , only : getfil
<LI>@@ -397,7 +988,7 @@
<LI>     integer :: dimid              !netCDF dimension id
<LI>     integer :: varid              !netCDF variable id
<LI>     integer :: ier                !error status
<LI>-    character(len=32) :: subname = 'atmdrv_init'
<LI>+    character(len=32) :: subname = 'rcmdrv_init'
<LI>     integer :: atmlon,atmlat      !size of alatlon
<LI>     real(r8), allocatable :: mask_d(:)   !dummy field: atm grid mask
<LI>     real(r8), allocatable :: mask_a(:)   !dummy field: land model grid mask
<LI>@@ -407,6 +998,14 @@
<LI>     integer :: ngseg              ! gsmap size
<LI>     integer :: root               ! root pe number
<LI>     integer,allocatable :: start(:),length(:),pe_loc(:)  ! for gsmap
<LI>+! !LOCAL VARIABLES:
<LI>+    integer :: ni,nj               ! size of grid on file
<LI>+    integer :: ncid                ! netCDF id's
<LI>+    integer :: ncidm               ! mask file netCDF id's
<LI>+    integer :: ret, time_index
<LI>+    real(r8),pointer :: rdata(:,:) ! temporary data
<LI>+    logical :: NSEWset             ! true if lat/lon NSEW read from grid file
<LI>+    logical :: EDGEset             ! true if EDGE NSEW read from grid file
<LI> !------------------------------------------------------------------------
<LI> 
<LI>     atmlon = alatlon%ni
<LI>@@ -419,16 +1018,22 @@
<LI>     ! Build [month]-[year] extension for file name to be read
<LI>     ! append extension to path name to get full file name
<LI> 
<LI>-    call get_curr_date(kyr, kmo, kda, mcsec)
<LI>-    write (ext,'(i4.4,"-",i2.2)') kyr,kmo
<LI>-    filenam = trim(offline_atmdir) // '/' // ext // '.nc'
<LI>-
<LI>-    call surfrd_get_latlon(dlatlon, filenam)
<LI>+!!!!!!!!!! Give Corner Lat and Lon values to CLM from REGCM !!!!!!!!!!!!!
<LI>+! abt rcm below
<LI>+!    call get_curr_date(kyr, kmo, kda, mcsec)
<LI>+!    write (ext,'(i4.4,"-",i2.2)') kyr,kmo
<LI>+!    filenam = trim(offline_atmdir) // '/' // ext // '.nc'
<LI>+!
<LI>+    call rcmsurfrd_get_latlon(dlatlon,mksrf_offline_fnavyoro)
<LI>     call latlon_check(dlatlon)
<LI> 
<LI>     datlon = dlatlon%ni
<LI>     datlat = dlatlon%nj
<LI> 
<LI>+! abt rcm above
<LI>+
<LI>+
<LI>+
<LI>     ! Initialize gsmaps and attr vectors
<LI>     ngseg = 1
<LI>     root = 0
<LI>@@ -512,7 +1117,12 @@
<LI> 
<LI>     call latlon_clean(dlatlon)
<LI> 
<LI>-  end subroutine atmdrv_init
<LI>+end subroutine rcmdrv_init
<LI>+
<LI>+!!!!!! abt rcm above
<LI>+
<LI>+
<LI>+
<LI> 
<LI> !------------------------------------------------------------------------
<LI> !BOP
<LI>@@ -962,6 +1572,249 @@
<LI> 
<LI>   end subroutine atm_readdata
<LI> 
<LI>+
<LI>+!!!!!!!! abt rcm below
<LI>+!------------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: rcm_readdata
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine rcm_readdata ()
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+!  takes the 2-d regcm variable arrays and saves them into the clm
<LI>+!  grid-based format [i.e. tbot(i,j) for REGCM and CLM needs tbot to
<LI>+!  a component of the aV_drv_d2a%rAttr(tbot,1)].  Also checks if REGCM
<LI>+!  atmospheric variables are reasonable.  
<LI>+!
<LI>+! !USES:
<LI>+    use clm_varcon, only : sb
<LI>+    use fileutils , only : getfil
<LI>+    use ncdio
<LI>+!   use mod_clm
<LI>+!   use mod_dynparam
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+!
<LI>+!rcm below
<LI>+!    real(r8),intent(in) :: r2ctb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cqb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2czga(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cpsb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cuxb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cvxb(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2crnc(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2crnnc(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2csols(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2csoll(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2csolsd(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2csolld(lsmlon,lsmlat)
<LI>+!    real(r8),intent(in) :: r2cflwd(lsmlon,lsmlat)
<LI>+!rcm above
<LI>+!
<LI>+! abt rcm above
<LI>+!
<LI>+!    character(len=*), intent(in) :: fname           !history file to open and read
<LI>+!    integer, intent(in)  :: kmo, itim               !current month and time index
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Sam Levis
<LI>+! Edit by Ahmed Tawfik
<LI>+!EOP
<LI>+!
<LI>+! LOCAL VARIABLES:
<LI>+    integer :: i,j,k,n                  !do loop indices
<LI>+    integer :: ier                      !error status
<LI>+    integer :: varid                    !netCDF variable id
<LI>+    integer :: status                   !netCDF error status
<LI>+    integer :: beg3d(3)                 !netCDF 3-d start index (where to read first value)
<LI>+    integer :: len3d(3)                 !netCDF 3-d count index (number of values to read)
<LI>+    character(len=32) :: subname = 'atm_readdata'
<LI>+!
<LI>+! atm input field names
<LI>+!
<LI>+    real(r8) ea                    !atmospheric emissivity
<LI>+
<LI>+    logical atmread_err
<LI>+
<LI>+    ! use polynomials to calculate saturation vapor pressure and derivative with
<LI>+    ! respect to temperature: over water when t > 0 c and over ice when t <= 0 c
<LI>+    ! required to convert relative humidity to specific humidity
<LI>+
<LI>+    real(r8) esatw                 !saturation vapor pressure over water (Pa)
<LI>+    real(r8) esati                 !saturation vapor pressure over ice (Pa)
<LI>+    real(r8) e                     !vapor pressure (Pa)
<LI>+    real(r8) qsat                  !saturation specific humidity (kg/kg)
<LI>+    real(r8) a0,a1,a2,a3,a4,a5,a6  !coefficients for esat over water
<LI>+    real(r8) b0,b1,b2,b3,b4,b5,b6  !coefficients for esat over ice
<LI>+    real(r8) tdc, t                !Kelvins to Celcius function and its input
<LI>+
<LI>+    parameter (a0=6.107799961_r8    , a1=4.436518521e-01_r8, &
<LI>+               a2=1.428945805e-02_r8, a3=2.650648471e-04_r8, &
<LI>+               a4=3.031240396e-06_r8, a5=2.034080948e-08_r8, &
<LI>+               a6=6.136820929e-11_r8)
<LI>+
<LI>+    parameter (b0=6.109177956_r8    , b1=5.034698970e-01_r8, &
<LI>+               b2=1.886013408e-02_r8, b3=4.176223716e-04_r8, &
<LI>+               b4=5.824720280e-06_r8, b5=4.838803174e-08_r8, &
<LI>+               b6=1.838826904e-10_r8)
<LI>+
<LI>+    integer,parameter:: fldsize=14
<LI>+    character(len=8) :: fldlst(fldsize)      !name of possible atm fields in input file
<LI>+    data fldlst( 1) /'TBOT    '/
<LI>+    data fldlst( 2) /'WIND    '/
<LI>+    data fldlst( 3) /'QBOT    '/
<LI>+    data fldlst( 4) /'Tdew    '/
<LI>+    data fldlst( 5) /'RH      '/
<LI>+    data fldlst( 6) /'ZBOT    '/
<LI>+    data fldlst( 7) /'PSRF    '/
<LI>+    data fldlst( 8) /'FSDS    '/
<LI>+    data fldlst( 9) /'FSDSdir '/
<LI>+    data fldlst(10) /'FSDSdif '/
<LI>+    data fldlst(11) /'FLDS    '/
<LI>+    data fldlst(12) /'PRECTmms'/
<LI>+    data fldlst(13) /'PRECCmms'/
<LI>+    data fldlst(14) /'PRECLmms'/
<LI>+!
<LI>+! function declarations
<LI>+!
<LI>+    tdc(t) = min( 50._r8, max(-50._r8,(t-SHR_CONST_TKFRZ)) )
<LI>+    esatw(t) = 100._r8*(a0+t*(a1+t*(a2+t*(a3+t*(a4+t*(a5+t*a6))))))
<LI>+    esati(t) = 100._r8*(b0+t*(b1+t*(b2+t*(b3+t*(b4+t*(b5+t*b6))))))
<LI>+!------------------------------------------------------------------------
<LI>+
<LI>+
<LI>+
<LI>+    ! Read single level fields
<LI>+
<LI>+    if (masterproc) then
<LI>+
<LI>+       ! initialize fields to the flag value
<LI>+
<LI>+       x(:,:,:) = 1._r8  !!! changed from -1 to 1 so no errors occur
<LI>+
<LI>+!!! abt rcm below
<LI>+       ! read input data single-level fields
<LI>+
<LI>+ !      beg3d(1) = 1     ;  len3d(1) = datlon
<LI>+ !      beg3d(2) = 1     ;  len3d(2) = datlat
<LI>+ !      beg3d(3) = itim  ;  len3d(3) = 1
<LI>+ !      do k = 1, 14
<LI>+ !         do n = 1, nvar
<LI>+ !            if (varnam(n) == fldlst(k)) then
<LI>+ !               call check_ret(nf_get_vara_double(ncid,n,beg3d,len3d,x(1,1,k)), subname)
<LI>+ !            end if
<LI>+ !         end do              !end loop of fields in input file
<LI>+ !      end do                 !end loop of fields expected in input file
<LI>+
<LI>+       ! Close file at the end of the month
<LI>+       ! NOTE: as written will not close file if run ends mid-month
<LI>+
<LI>+!       if (itim == ntim) then
<LI>+!          call check_ret(nf_close (ncid), subname)
<LI>+!          write (6,*) '---------------------------------------'
<LI>+!          write (6,*) 'ATMRD: closing data for ',trim(fname)
<LI>+!          write (6,*) '---------------------------------------'
<LI>+!          write (6,*)
<LI>+!       end if
<LI>+
<LI>+    endif     !end of if-masterproc block
<LI>+
<LI>+!!! abt rcm above
<LI>+
<LI>+    ! ----------------------------------------------------------------------
<LI>+    ! Determine 2d atmospheric fields
<LI>+    ! Follow order in fldlst(14) to determine what was read and what was not
<LI>+    ! ----------------------------------------------------------------------
<LI>+
<LI>+
<LI>+    ! Loop over atmospheric longitudes and latitudes
<LI>+
<LI>+    if (masterproc) then
<LI>+
<LI>+    atmread_err = .false.
<LI>+!$OMP PARALLEL DO PRIVATE (i,j,e,ea,qsat,n)
<LI>+#if !defined (USE_OMP)
<LI>+!CSD$ PARALLEL DO PRIVATE (i,j,e,ea,qsat,n)
<LI>+#endif
<LI>+    do j = 1, datlat
<LI>+       do i = 1, datlon
<LI>+          n = (j-1)*datlon + i
<LI>+          ! FORC_TXY
<LI>+
<LI>+          if (r2ctb_all(i,j) < 50.) then
<LI>+             write(6,*)'ATM error: TBOT appears to be in deg C'
<LI>+             write(6,*)'Converting to Kelvins now'
<LI>+             aV_drv_d2a%rAttr(if_txy,n) = r2ctb_all(i,j) + SHR_CONST_TKFRZ
<LI>+          else
<LI>+             aV_drv_d2a%rAttr(if_txy,n) = r2ctb_all(i,j)
<LI>+          end if
<LI>+
<LI>+          ! FORC_UXY, FORC_VXY
<LI>+             aV_drv_d2a%rAttr(if_uxy,n) = r2cuxb_all(i,j)
<LI>+             aV_drv_d2a%rAttr(if_vxy,n) = r2cvxb_all(i,j)
<LI>+        
<LI>+
<LI>+          ! FORC_PSRFXY, FORC_PBOTXY
<LI>+             aV_drv_d2a%rAttr(if_psrfxy,n) = r2cpsb_all(i,j)
<LI>+             aV_drv_d2a%rAttr(if_pbotxy,n)  = aV_drv_d2a%rAttr(if_psrfxy,n)
<LI>+
<LI>+          !FORC_QXY
<LI>+             if (aV_drv_d2a%rAttr(if_txy,n) > SHR_CONST_TKFRZ) then
<LI>+                e = esatw(tdc(aV_drv_d2a%rAttr(if_txy,n)))
<LI>+             else
<LI>+                e = esati(tdc(aV_drv_d2a%rAttr(if_txy,n)))
<LI>+             end if
<LI>+             qsat = 0.622_r8*e / (aV_drv_d2a%rAttr(if_pbotxy,n) - 0.378_r8*e)
<LI>+             if (qsat < r2cqb_all(i,j)) then
<LI>+                aV_drv_d2a%rAttr(if_qxy,n) = qsat
<LI>+!                 write(6,*)'ATM warning: qsat < q!'
<LI>+             else
<LI>+                aV_drv_d2a%rAttr(if_qxy,n) = r2cqb_all(i,j)
<LI>+             end if
<LI>+  
<LI>+
<LI>+          ! ZGCMXY
<LI>+             aV_drv_d2a%rAttr(izgcmxy,n) = r2czga_all(i,j)
<LI>+
<LI>+          ! FORC_SOLSXY, FORC_SOLLXY, FORC_SOLSDXY, FORC_SOLLDXY
<LI>+             aV_drv_d2a%rAttr(if_sols,n)  = r2csols_all(i,j)
<LI>+             aV_drv_d2a%rAttr(if_soll,n)  = r2csoll_all(i,j)
<LI>+             aV_drv_d2a%rAttr(if_solsd,n) = r2csolsd_all(i,j)
<LI>+             aV_drv_d2a%rAttr(if_solld,n) = r2csolld_all(i,j)
<LI>+
<LI>+
<LI>+          ! PRCXY, PRLXY
<LI>+             aV_drv_d2a%rAttr(iprcxy,n) = r2crnc_all(i,j)
<LI>+             aV_drv_d2a%rAttr(iprlxy,n) = r2crnnc_all(i,j)
<LI>+
<LI>+
<LI>+          ! FLWDSXY
<LI>+             aV_drv_d2a%rAttr(iflwdsxy,n) = r2cflwd_all(i,j)
<LI>+
<LI>+       end do                 !end loop of latitudes
<LI>+    end do                    !end loop of longitudes
<LI>+#if !defined (USE_OMP)
<LI>+!CSD$ END PARALLEL DO
<LI>+#endif
<LI>+!$OMP END PARALLEL DO
<LI>+
<LI>+    if (atmread_err) then
<LI>+       write(6,*) 'atm_readdata: error reading atm data'
<LI>+       call endrun
<LI>+    end if
<LI>+
<LI>+    endif   ! masterproc
<LI>+
<LI>+  end subroutine rcm_readdata
<LI>+!!!!!! abt rcm above
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+
<LI> !------------------------------------------------------------------------
<LI> !BOP
<LI> !
<LI>@@ -1011,6 +1864,53 @@
<LI> 
<LI>   end subroutine interpa2s
<LI> 
<LI>+
<LI>+!------------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: interpr2s
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine interpr2s ()
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Area average fields from atmosphere grid to surface grid
<LI>+!
<LI>+! !USES:
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Gordon Bonan
<LI>+! Modified interpa2s to work with RegCM
<LI>+!EOP
<LI>+!
<LI>+! LOCAL VARIABLES:
<LI>+    integer  :: i,j,n,g,k,g1              !longitude,latitude loop indices
<LI>+    integer  :: begg,endg
<LI>+!------------------------------------------------------------------------
<LI>+
<LI>+    ! area-average absolute value of winds (i.e., regardless of
<LI>+    ! direction) since land model cares about magnitude not direction.
<LI>+    ! then need to adjust resultant stresses for direction of wind.
<LI>+
<LI>+    if (masterproc) then
<LI>+       do j = 1, datlat
<LI>+       do i = 1, datlon
<LI>+          n = (j-1)*datlon + i
<LI>+          r2cuxb_all(i,j) = abs(r2cuxb_all(i,j))
<LI>+          r2cvxb_all(i,j) = abs(r2cvxb_all(i,j))
<LI>+       end do
<LI>+       end do
<LI>+    endif
<LI>+
<LI>+!    call mct_Smat_AvMult(av_drv_d2a, sMatP_d2a, av_atm_d2a, vector=usevector)
<LI>+!    call mct_aVect_unpermute(av_atm_d2a, perm_atm_gdc2glo)
<LI>+
<LI>+  end subroutine interpr2s
<LI>+
<LI>+
<LI> #endif
<LI> 
<LI> end module atmdrvMod
</OL>
</PRE>

<HR>

</BODY>
</HTML>
