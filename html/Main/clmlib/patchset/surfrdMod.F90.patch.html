<HTML>

<HEAD>
<TITLE>surfrdMod.F90.patch</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>clmlib/patchset/surfrdMod.F90.patch</H1>
<HR>
<H2 ALIGN=CENTER>surfrdMod.F90.patch</H2>
<HR>
</FONT>

<HR>

<PRE>
<OL>
<LI>--- orig/surfrdMod.F90	2010-05-20 08:20:03.000000000 -0400
<LI>+++ patchd/urfrdMod.F90	2010-05-21 13:29:57.000000000 -0400
<LI>@@ -44,11 +44,22 @@
<LI>   public :: surfrd_get_latlon  ! Read surface dataset into domain
<LI>   public :: surfrd_get_frac  ! Read land fraction into domain
<LI>   public :: surfrd_get_topo  ! Read topography into domain
<LI>-
<LI>+! abt rcm below
<LI>+  public :: rcmsurfrd_get_grid     ! Read surface dataset into domain
<LI>+  public :: rcmsurfrd_get_latlon   ! Read surface dataset into domain
<LI>+  public :: rcmsurfrd_get_frac     ! Read land fraction into domain
<LI>+  public :: rcmsurfrd_get_topo     ! Read topography into domain
<LI>+  public :: rcmsurfrd_bvocs        ! Read biogenic emissions
<LI>+  private :: pft_adjustment        ! If there are gridcells with no
<LI>+                                   ! land cover type  
<LI>+  private :: clm2bats_conversion   ! convert CLM types to BATS types
<LI>+  public  :: clm_getsoitex         ! convert CLM soil types to BATS types
<LI>+! abt rcm above
<LI> !
<LI> ! !REVISION HISTORY:
<LI> ! Created by Mariana Vertenstein
<LI> ! Updated by T Craig
<LI>+! Modified by Ahmed Tawfik for RegCM
<LI> !
<LI> !EOP
<LI> !
<LI>@@ -102,8 +113,6 @@
<LI> ! !ARGUMENTS:
<LI>     implicit none
<LI>     include 'netcdf.inc'
<LI>-!    integer , intent(out) :: vegxy(:,:)   ! PFT
<LI>-!    real(r8), intent(out) :: wtxy(:,:)  ! subgrid weights
<LI>     character(len=*), intent(in) :: lfsurdat               ! surf filename
<LI>     type(domain_type),intent(in) :: domain ! domain associated with wtxy
<LI> !
<LI>@@ -135,7 +144,8 @@
<LI>     if (masterproc) then
<LI>        write (6,*) 'Attempting to read surface boundary data .....'
<LI>        if (lfsurdat == ' ') then
<LI>-          write(6,*)'lfsurdat must be specified'; call endrun()
<LI>+          write(6,*)'lfsurdat must be specified' 
<LI>+          call endrun()
<LI>        endif
<LI>     endif
<LI> 
<LI>@@ -460,7 +470,7 @@
<LI>     integer :: ier                 ! error status
<LI>     character(len=256)  :: locfn   ! local file name
<LI>     integer :: ret, time_index
<LI>-    real(r8),pointer :: rdata(:,:) ! temporary data
<LI>+    real(r8),allocatable :: rdata(:,:) ! temporary data
<LI>     logical :: NSEWset             ! true if lat/lon NSEW read from grid file
<LI>     logical :: EDGEset             ! true if EDGE NSEW read from grid file
<LI>     logical :: lpftmflag           ! is mask a pft mask, local copy
<LI>@@ -532,7 +542,7 @@
<LI>     endif
<LI> 
<LI>     if (masterproc) then
<LI>-       allocate(rdata(ni,nj))
<LI>+       if(.not.allocated(rdata)) allocate(rdata(ni,nj))
<LI> 
<LI>        start2(1)  = 1
<LI>        start2(2)  = 1
<LI>@@ -678,148 +688,225 @@
<LI> 
<LI>   end subroutine surfrd_get_latlon
<LI> 
<LI>+
<LI>+
<LI>+
<LI>+!!!!! abt rcm below
<LI> !-----------------------------------------------------------------------
<LI> !BOP
<LI> !
<LI>-! !IROUTINE: surfrd_get_frac
<LI>+! !IROUTINE: rcmsurfrd
<LI> !
<LI> ! !INTERFACE:
<LI>-  subroutine surfrd_get_frac(domain,filename)
<LI>+!  subroutine surfrd(lfsurdat, domain)
<LI>+  subroutine rcmsurfrd(lakdat,glacdat,urbdat,soidat,pftdat,domain)
<LI> !
<LI> ! !DESCRIPTION:
<LI>-! Read the landfrac dataset grid related information:
<LI>-! Assume domain has already been initialized and read
<LI>+! Read the surface dataset and create subgrid weights.
<LI>+! The model's surface dataset recognizes 5 basic land cover types within
<LI>+! a grid cell: lake, wetland, urban, glacier, and vegetated. The vegetated
<LI>+! portion of the grid cell is comprised of up to [maxpatch_pft] PFTs. These
<LI>+! subgrid patches are read in explicitly for each grid cell. This is in
<LI>+! contrast to LSMv1, where the PFTs were built implicitly from biome types.
<LI>+!    o real edges of grid
<LI>+!    o integer  number of longitudes per latitude
<LI>+!    o real latitude  of grid cell (degrees)
<LI>+!    o real longitude of grid cell (degrees)
<LI>+!    o integer surface type: 0 = ocean or 1 = land
<LI>+!    o integer soil color (1 to 20) for use with soil albedos
<LI>+!    o real soil texture, %sand, for thermal and hydraulic properties
<LI>+!    o real soil texture, %clay, for thermal and hydraulic properties
<LI>+!    o real % of cell covered by lake    for use as subgrid patch
<LI>+!    o real % of cell covered by wetland for use as subgrid patch
<LI>+!    o real % of cell that is urban      for use as subgrid patch
<LI>+!    o real % of cell that is glacier    for use as subgrid patch
<LI>+!    o integer PFTs
<LI>+!    o real % abundance PFTs (as a percent of vegetated area)
<LI> !
<LI> ! !USES:
<LI>-    use domainMod , only : domain_type
<LI>+    use clm_varctl  , only : allocate_all_vegpfts
<LI>+    use pftvarcon   , only : noveg
<LI>     use fileutils , only : getfil
<LI>+    use domainMod , only : domain_type
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI> !
<LI> ! !ARGUMENTS:
<LI>     implicit none
<LI>     include 'netcdf.inc'
<LI>-    type(domain_type),intent(inout) :: domain   ! domain to init
<LI>-    character(len=*) ,intent(in)    :: filename ! grid filename
<LI>+!    integer , intent(out) :: vegxy(:,:)   ! PFT
<LI>+!    real(r8), intent(out) :: wtxy(:,:)  ! subgrid weights
<LI>+!    character(len=*), intent(in) :: lfsurdat               ! surf filename
<LI>+    type(domain_type), optional, intent(in) :: domain ! domain associated with wtxy
<LI>+    character(len=*), intent(in) :: soidat               ! surf filename
<LI>+    character(len=*), intent(in) :: urbdat               ! surf filename
<LI>+    character(len=*), intent(in) :: glacdat              ! surf filename
<LI>+    character(len=*), intent(in) :: lakdat               ! surf filename
<LI>+    character(len=*), intent(in) :: pftdat               ! surf filename
<LI>+!    logical, intent(in) :: mask_only               ! if rank calc is done
<LI>+
<LI> !
<LI> ! !CALLED FROM:
<LI>-! subroutine initialize
<LI>+! subroutine initialize in module initializeMod
<LI> !
<LI> ! !REVISION HISTORY:
<LI>-! Created by T Craig
<LI>+! Created by Mariana Vertenstein, Sam Levis and Gordon Bonan
<LI> !
<LI> !EOP
<LI> !
<LI> ! !LOCAL VARIABLES:
<LI>-    integer :: n                   ! indices
<LI>-    integer :: ni,nj,ns            ! size of grid on file
<LI>+    character(len=256) :: locfn                          ! local file name
<LI>     integer :: ncid,dimid,varid    ! netCDF id's
<LI>+    integer  :: ncidurb,ncidlak,ncidglac,ncidsoi,ncidpft ! netCDF ids abt
<LI>+    integer  :: begg,endg   
<LI>+    logical  :: found                                    ! temporary for error check
<LI>+    integer  :: iindx, jindx                             ! temporary for error check
<LI>     integer :: ier                 ! error status
<LI>-    real(r8):: eps = 1.0e-12_r8    ! lat/lon error tolerance
<LI>-    real(r8),allocatable:: lonc(:),latc(:)  ! local lat/lon
<LI>-    character(len=256)  :: locfn   ! local file name
<LI>-    integer :: ret, time_index
<LI>-    integer  :: strt3(3)           ! Start index to read in
<LI>-    integer  :: cnt3(3)            ! Number of points to read in
<LI>-    integer  :: strt1, cnt1        ! Start and count to read in for scalar
<LI>-    real(r8) :: closelat           ! Single-column latitude value
<LI>-    real(r8) :: closelon           ! Single-column longitude value
<LI>-    integer  :: closelatidx        ! Single-column latitude index to retrieve
<LI>-    integer  :: closelonidx        ! Single-column longitude index to retrieve
<LI>-    character(len=32) :: subname = 'surfrd_get_frac'     ! subroutine name
<LI>+    character(len=32) :: subname = 'rcmsurfrd'              ! subroutine name
<LI> !-----------------------------------------------------------------------
<LI> 
<LI>-    if (masterproc) then
<LI>+    call get_proc_bounds(begg,endg)
<LI>+    allocate(pctspec(begg:endg))
<LI> 
<LI>-       if (filename == ' ') then
<LI>-          write(6,*) trim(subname),' ERROR: filename must be specified '
<LI>-          call endrun()
<LI>+    vegxy(:,:)   = noveg
<LI>+    wtxy(:,:)  = 0._r8
<LI>+    pctspec(:) = 0._r8
<LI>+
<LI>+    if (masterproc) then
<LI>+       write (6,*) 'Attempting to read surface boundary data .....'
<LI>+       if (lakdat == ' ' .or. glacdat == ' ' .or. soidat == ' ' &
<LI>+           .or. urbdat == ' ' .or. pftdat == ' ') then
<LI>+          write(6,*)'surdat must be specified'; call endrun()
<LI>+       endif
<LI>        endif
<LI> 
<LI>-       call getfil( filename, locfn, 0 )
<LI>-       call check_ret( nf_open(locfn, 0, ncid), subname )
<LI>+    ! Read surface data
<LI> 
<LI>-       if (single_column) then
<LI>-          ni = lsmlon
<LI>-          nj = lsmlat
<LI>-       else
<LI>-          call check_ret(nf_inq_dimid (ncid, 'lsmlon', dimid), subname)
<LI>-          call check_ret(nf_inq_dimlen(ncid, dimid, ni), subname)
<LI>-          call check_ret(nf_inq_dimid (ncid, 'lsmlat', dimid), subname)
<LI>-          call check_ret(nf_inq_dimlen(ncid, dimid, nj), subname)
<LI>-       endif
<LI>+    if (masterproc) then
<LI>+!       call getfil( lfsurdat, locfn, 0 )
<LI>+!       call check_ret( nf_open(locfn, 0, ncid), subname )
<LI> 
<LI>-       ns = ni*nj
<LI>+       call getfil( lakdat, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncidlak), subname )
<LI> 
<LI>-       if (domain%ni /= ni .or. domain%nj /= nj .or. domain%ns /= ns) then
<LI>-          write(6,*) trim(subname),' ERROR: landfrac file mismatch ni,nj',domain%ni,ni,domain%nj,nj,domain%ns,ns
<LI>-          call endrun()
<LI>-       endif
<LI>+       call getfil( soidat, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncidsoi), subname )
<LI> 
<LI>-       allocate(latc(ni*nj),lonc(ni*nj))
<LI>+       call getfil( glacdat, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncidglac), subname )
<LI> 
<LI>-       strt3(1)=1
<LI>-       strt3(2)=1
<LI>-       strt3(3)=1
<LI>-       cnt3(1)=domain%ni
<LI>-       cnt3(2)=domain%nj
<LI>-       cnt3(3)=1
<LI>-       strt1=1
<LI>-       cnt1=domain%nj
<LI>+       call getfil( urbdat, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncidurb), subname )
<LI> 
<LI>-       if (single_column) then
<LI>-          call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>-          strt3(1)=closelonidx
<LI>-          strt3(2)=closelatidx
<LI>-          strt1=closelatidx
<LI>-          cnt1=1
<LI>-       endif
<LI>+       call getfil( pftdat, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncidpft), subname )
<LI> 
<LI>-       call check_ret(nf_inq_varid(ncid, 'LONGXY' , varid), subname)
<LI>-       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, lonc), subname)
<LI>+    end if
<LI>           
<LI>-       call check_ret(nf_inq_varid(ncid, 'LATIXY', varid), subname)
<LI>-       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, latc), subname)
<LI>+    ! Obtain surface dataset special landunit info
<LI> 
<LI>-       do n = 1,ns
<LI>-          if (abs(latc(n)-domain%latc(n)) > eps .or. &
<LI>-               abs(lonc(n)-domain%lonc(n)) > eps) then
<LI>-             write(6,*) trim(subname),' ERROR: landfrac file mismatch lat,lon',latc(n),domain%latc(n),lonc(n),domain%lonc(n),eps
<LI>-             call endrun()
<LI>-          endif
<LI>-       enddo
<LI>+    call rcmsurfrd_wtxy_special(ncidlak,ncidglac,ncidurb,ncidsoi, domain)
<LI>+#if (defined VOC)
<LI>+    call rcmsurfrd_bvocs(domain)   !abt
<LI>+#endif
<LI>        
<LI>-       call check_ret(nf_inq_varid(ncid, 'LANDMASK', varid), subname)
<LI>-       call check_ret(nf_get_vara_int(ncid, varid, strt3, cnt3, domain%mask), subname)
<LI>        
<LI>-       call check_ret(nf_inq_varid(ncid, 'LANDFRAC', varid), subname)
<LI>-       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, domain%frac), subname)
<LI>+    ! Obtain surface dataset vegetated landunit info
<LI>+#if (! defined DGVM)     
<LI>+    if (allocate_all_vegpfts) then
<LI>+       call surfrd_wtxy_veg_all(ncidpft, domain)
<LI>+    else
<LI>+       call surfrd_wtxy_veg_rank(ncidpft, domain)
<LI>+    end if
<LI>+#else
<LI>+    call surfrd_wtxy_veg_dgvm(domain)
<LI>+#endif
<LI>        
<LI> 
<LI>-       deallocate(latc,lonc)
<LI> 
<LI>-       call check_ret(nf_close(ncid), subname)
<LI>+       ! *** abt added clm2bats_conversion call
<LI>+       ! Subrountine used to convert clm land cover types
<LI>+       ! to types compatable with RegCM
<LI>+       ! Variables modified in RegCM in subroutine init_clmser/para.F
<LI>+       ! see veg2d, veg2d1, satbrt, and satbrt1
<LI> 
<LI>-    end if   ! end of if-masterproc block
<LI>+       call clm2bats_conversion(ncidpft,ncidlak,ncidglac,ncidurb)  !abt
<LI> 
<LI>-    call mpi_bcast (domain%mask , size(domain%mask) , MPI_INTEGER, 0, mpicom, ier)
<LI>-    call mpi_bcast (domain%frac , size(domain%frac) , MPI_REAL8  , 0, mpicom, ier)
<LI> 
<LI>-  end subroutine surfrd_get_frac
<LI>+
<LI>+   
<LI>+    if ( masterproc )then
<LI>+!       call check_ret(nf_close(ncid), subname)
<LI>+       call check_ret(nf_close(ncidsoi), subname)
<LI>+       call check_ret(nf_close(ncidlak), subname)
<LI>+       call check_ret(nf_close(ncidglac), subname)
<LI>+       call check_ret(nf_close(ncidurb), subname)
<LI>+       call check_ret(nf_close(ncidpft), subname)
<LI>+       write (6,*) 'Successfully read surface boundary data'
<LI>+       write (6,*)
<LI>+    end if
<LI>+
<LI>+    if(allocated(pctspec)) deallocate(pctspec) !abt added
<LI>+
<LI>+  end subroutine rcmsurfrd
<LI>+
<LI>+
<LI>+! abt rcm above
<LI> 
<LI> !-----------------------------------------------------------------------
<LI> !BOP
<LI> !
<LI>-! !IROUTINE: surfrd_get_topo
<LI>+! !IROUTINE: rcmsurfrd_get_grid
<LI> !
<LI> ! !INTERFACE:
<LI>-  subroutine surfrd_get_topo(domain,filename)
<LI>+  subroutine rcmsurfrd_get_grid(domain,filename)
<LI> !
<LI> ! !DESCRIPTION:
<LI>-! Read the topo dataset grid related information:
<LI>-! Assume domain has already been initialized and read
<LI>+! Read the surface dataset grid related information:
<LI>+! o real edges of grid
<LI>+! o integer  number of longitudes per latitude
<LI>+! o real latitude  of grid cell (degrees)
<LI>+! o real longitude of grid cell (degrees)
<LI>+! For offline mode only the the grid does not have to be global.
<LI>+! If grid is read in from dataset, grid is assumed to be global but
<LI>+! does not have to be regular.
<LI>+! If grid is generated by model, grid does not have to be global but 
<LI>+! must then define the north, east, south, and west edges:
<LI>+!
<LI>+! o edges(1)    = northern edge of grid (degrees): >  -90 and <= 90
<LI>+! o edges(2)    = eastern edge of grid (degrees) : see following notes
<LI>+! o edges(3)    = southern edge of grid (degrees): >= -90 and <  90
<LI>+! o edges(4)    = western edge of grid (degrees) : see following notes
<LI>+!
<LI>+!   For partial grids, northern and southern edges are any latitude
<LI>+!   between 90 (North Pole) and -90 (South Pole). Western and eastern
<LI>+!   edges are any longitude between -180 and 180, with longitudes
<LI>+!   west of Greenwich negative. That is, western edge >= -180 and < 180;
<LI>+!   eastern edge > western edge and <= 180.
<LI>+!
<LI>+!   For global grids, northern and southern edges are 90 (North Pole)
<LI>+!   and -90 (South Pole). The western and eastern edges depend on
<LI>+!   whether the grid starts at Dateline or Greenwich. Regardless,
<LI>+!   these edges must span 360 degrees. Examples:
<LI>+!
<LI>+!                              West edge    East edge
<LI>+!                            --------------------------------------------------
<LI>+!  (1) Dateline            :        -180 to 180       (negative W of Greenwich)
<LI>+!  (2) Greenwich (centered):    0 - dx/2 to 360 - dx/2
<LI>+!
<LI>+!    Grid 1 is the grid for offline mode
<LI>+!    Grid 2 is the grid for cam and csm mode since the NCAR CAM
<LI>+!    starts at Greenwich, centered on Greenwich
<LI> !
<LI> ! !USES:
<LI>-    use domainMod , only : domain_type
<LI>+    use clm_varcon, only : spval
<LI>+    use domainMod , only : domain_type,domain_init
<LI>+    use areaMod   , only : celledge, cellarea                      
<LI>     use fileutils , only : getfil
<LI>+    use clm_varsur, only : landmask,landfrac,satbrt_clm,r2cimask,init_tgb
<LI>+    use clm_varsur, only : glatc,glonc
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI> !
<LI> ! !ARGUMENTS:
<LI>     implicit none
<LI>@@ -828,32 +915,38 @@
<LI>     character(len=*) ,intent(in)    :: filename ! grid filename
<LI> !
<LI> ! !CALLED FROM:
<LI>-! subroutine initialize
<LI>+! subroutine surfrd in this module
<LI> !
<LI> ! !REVISION HISTORY:
<LI>-! Created by T Craig
<LI>+! Created by Mariana Vertenstein
<LI> !
<LI> !EOP
<LI> !
<LI> ! !LOCAL VARIABLES:
<LI>-    integer :: n                   ! indices
<LI>-    integer :: ni,nj,ns            ! size of grid on file
<LI>+    integer :: ni,nj,nns,nnj,nni   ! size of grid on file
<LI>     integer :: ncid,dimid,varid    ! netCDF id's
<LI>-    integer :: ier                 ! error status
<LI>-    real(r8):: eps = 1.0e-12_r8    ! lat/lon error tolerance
<LI>-    real(r8),allocatable:: lonc(:),latc(:)  ! local lat/lon
<LI>+    integer :: ier,counter         ! error status
<LI>     character(len=256)  :: locfn   ! local file name
<LI>     integer :: ret, time_index
<LI>+    logical :: AREAset             ! true if area read from grid file
<LI>+    logical :: NSEWset             ! true if lat/lon NSEW read from grid file
<LI>+    logical :: EDGEset             ! true if EDGE NSEW read from grid file
<LI>     integer  :: strt3(3)           ! Start index to read in
<LI>     integer  :: cnt3(3)            ! Number of points to read in
<LI>     integer  :: strt1, cnt1        ! Start and count to read in for scalar
<LI>+    real(r8),allocatable :: rcmfrac(:)
<LI>+    logical ,allocatable :: mask_logic(:)
<LI>     real(r8) :: closelat           ! Single-column latitude value
<LI>     real(r8) :: closelon           ! Single-column longitude value
<LI>     integer  :: closelatidx        ! Single-column latitude index to retrieve
<LI>     integer  :: closelonidx        ! Single-column longitude index to retrieve
<LI>-    character(len=32) :: subname = 'surfrd_get_topo'     ! subroutine name
<LI>+    character(len=32) :: subname = 'rcmsurfrd_get_grid'     ! subroutine name
<LI> !-----------------------------------------------------------------------
<LI> 
<LI>+    AREAset = .false.
<LI>+    NSEWset = .false.
<LI>+    EDGEset = .false.
<LI>+
<LI>     if (masterproc) then
<LI> 
<LI>        if (filename == ' ') then
<LI>@@ -868,20 +961,39 @@
<LI>           ni = lsmlon
<LI>           nj = lsmlat
<LI>        else
<LI>-          call check_ret(nf_inq_dimid (ncid, 'lsmlon', dimid), subname)
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lon', dimid), subname)
<LI>           call check_ret(nf_inq_dimlen(ncid, dimid, ni), subname)
<LI>-          call check_ret(nf_inq_dimid (ncid, 'lsmlat', dimid), subname)
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lat', dimid), subname)
<LI>           call check_ret(nf_inq_dimlen(ncid, dimid, nj), subname)
<LI>        endif
<LI> 
<LI>-       ns = ni*nj
<LI>-
<LI>-       if (domain%ni /= ni .or. domain%nj /= nj .or. domain%ns /= ns) then
<LI>-          write(6,*) trim(subname),' ERROR: topo file mismatch ni,nj',domain%ni,ni,domain%nj,nj,domain%ns,ns
<LI>-          call endrun()
<LI>        endif
<LI> 
<LI>-       allocate(latc(ns),lonc(ns))
<LI>+    call mpi_bcast (ni, 1, MPI_INTEGER, 0, mpicom, ier)
<LI>+    call mpi_bcast (nj, 1, MPI_INTEGER, 0, mpicom, ier)
<LI>+
<LI>+    call domain_init(domain,ni,nj)
<LI>+    if(.not.allocated(landmask)) allocate(landmask(ni,nj))  !abt
<LI>+    if(.not.allocated(landfrac)) allocate(landfrac(ni,nj))  !abt
<LI>+
<LI>+
<LI>+    if (masterproc) then
<LI>+       if(.not.allocated(glatc)) allocate(glatc(ni*nj),glonc(ni*nj))
<LI>+
<LI>+       domain%edges(:) = spval
<LI>+       ier = nf_inq_varid (ncid, 'EDGEN', varid)
<LI>+       if (ier == NF_NOERR) then
<LI>+          EDGEset = .true.
<LI>+          call check_ret(nf_inq_varid(ncid, 'EDGEN', varid), subname)
<LI>+          call check_ret(nf_get_var_double(ncid, varid, domain%edges(1)), subname)
<LI>+          call check_ret(nf_inq_varid(ncid, 'EDGEE', varid), subname)
<LI>+          call check_ret(nf_get_var_double(ncid, varid, domain%edges(2)), subname)
<LI>+          call check_ret(nf_inq_varid(ncid, 'EDGES', varid), subname)
<LI>+          call check_ret(nf_get_var_double(ncid, varid, domain%edges(3)), subname)
<LI>+          call check_ret(nf_inq_varid (ncid, 'EDGEW', varid), subname)
<LI>+          call check_ret(nf_get_var_double(ncid, varid, domain%edges(4)), subname)
<LI>+          if (maxval(domain%edges) > 1.0e35) EDGEset = .false. !read garbage
<LI>+       endif
<LI> 
<LI>        strt3(1)=1
<LI>        strt3(2)=1
<LI>@@ -900,13 +1012,1266 @@
<LI>           cnt1=1
<LI>        endif
<LI> 
<LI>-       call check_ret(nf_inq_varid(ncid, 'LONGXY' , varid), subname)
<LI>-       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, lonc), subname)
<LI> 
<LI>-       call check_ret(nf_inq_varid(ncid, 'LATIXY', varid), subname)
<LI>-       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, latc), subname)
<LI>+       ier = nf_inq_varid (ncid, 'LATN', varid)
<LI>+       if (ier == NF_NOERR) then
<LI>+          NSEWset = .true.
<LI>+          call check_ret(nf_inq_varid(ncid, 'LATN', varid), subname)
<LI>+          call check_ret(nf_get_vara_double(ncid, varid,strt3,cnt3, domain%latn), subname)
<LI>+          call check_ret(nf_inq_varid(ncid, 'LONE', varid), subname)
<LI>+          call check_ret(nf_get_vara_double(ncid, varid,strt3,cnt3, domain%lone), subname)
<LI>+          call check_ret(nf_inq_varid(ncid, 'LATS', varid), subname)
<LI>+          call check_ret(nf_get_vara_double(ncid, varid,strt3,cnt3, domain%lats), subname)
<LI>+          call check_ret(nf_inq_varid(ncid, 'LONW', varid), subname)
<LI>+          call check_ret(nf_get_vara_double(ncid, varid,strt3,cnt3, domain%lonw), subname)
<LI>+       endif
<LI> 
<LI>-       do n = 1,ns
<LI>+       ier = nf_inq_varid (ncid, 'AREA', varid)
<LI>+       if (ier == NF_NOERR) then
<LI>+          AREAset = .true.
<LI>+          call check_ret(nf_inq_varid(ncid, 'AREA', varid), subname)
<LI>+          call check_ret(nf_get_vara_double(ncid, varid,strt3,cnt3, domain%area), subname)
<LI>+       endif
<LI>+
<LI>+!rcm abt below
<LI>+!       call check_ret(nf_inq_varid(ncid, 'LONGXY' , varid), subname)
<LI>+!       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, domain%lonc), subname)
<LI>+       
<LI>+!       call check_ret(nf_inq_varid(ncid, 'LATIXY', varid), subname)
<LI>+!       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, domain%latc), subname)
<LI>+
<LI>+       do nnj = 1,nj
<LI>+       do nni = 1,ni
<LI>+         nns = (nnj-1)*ni + nni
<LI>+         domain%lonc(nns) = r2cxlond_all(nni,nnj)
<LI>+         domain%latc(nns) = r2cxlatd_all(nni,nnj)
<LI>+         glonc(nns)       = r2cxlond_all(nni,nnj)
<LI>+         glatc(nns)       = r2cxlatd_all(nni,nnj)
<LI>+       enddo 
<LI>+       enddo
<LI>+         
<LI>+       domain%area(:) = r2carea
<LI>+
<LI>+       domain%edges(1) = r2cedgen
<LI>+       domain%edges(2) = r2cedgee
<LI>+       domain%edges(3) = r2cedges
<LI>+       domain%edges(4) = r2cedgew
<LI>+
<LI>+! set mask to 1 everywhere by default, override if LANDMASK exists
<LI>+! if landmask exists, use it to set pftm (for older datasets)
<LI>+! pftm should be overwritten below for newer datasets
<LI>+       domain%mask = 1
<LI>+!      ier = nf_inq_varid(ncid, 'LANDMASK', varid)
<LI>+!       if (ier == NF_NOERR) then
<LI>+!          call check_ret(nf_get_vara_int(ncid, varid, strt3, cnt3, domain%mask), subname)
<LI>+
<LI>+       if(.not.allocated(mask_logic)) allocate(mask_logic(ni*nj))
<LI>+       if(.not.allocated(rcmfrac))    allocate(rcmfrac(ni*nj))
<LI>+
<LI>+       ier = nf_inq_varid(ncid, 'LANDFRAC', varid)
<LI>+    if (ier == NF_NOERR) then
<LI>+       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, rcmfrac), subname)
<LI>+
<LI>+       counter     = 0
<LI>+      
<LI>+       do nnj = 1,nj
<LI>+       do nni = 1,ni
<LI>+          nns = (nnj-1)*ni + nni
<LI>+
<LI>+          if(r2cimask == 2) then               !using weighted landfraction method
<LI>+            landfrac(nni,nnj) = rcmfrac(nns)
<LI>+            if(rcmfrac(nns) < 0.1) then    
<LI>+              domain%mask(nns)  = 0.
<LI>+              landmask(nni,nnj) = 0.
<LI>+              landfrac(nni,nnj) = 0.
<LI>+            else
<LI>+              domain%mask(nns)  = 1.
<LI>+              landmask(nni,nnj) = 1.
<LI>+            endif
<LI>+
<LI>+          elseif(r2cimask == 1) then           !using DOMAIN.INFO landmask
<LI>+            if(satbrt_clm(nnj,nni) > 13.9 .and. satbrt_clm(nnj,nni) < 15.1) then 
<LI>+              domain%mask(nns)  = 0.
<LI>+              landmask(nni,nnj) = 0.
<LI>+              landfrac(nni,nnj) = 0.
<LI>+            else
<LI>+              domain%mask(nns)  = 1.
<LI>+              landmask(nni,nnj) = 1.
<LI>+              landfrac(nni,nnj) = 1.
<LI>+            endif
<LI>+
<LI>+          endif
<LI>+       enddo
<LI>+       enddo
<LI>+
<LI>+       domain%pftm = domain%mask
<LI>+       where (domain%mask(:) <= 0)
<LI>+            domain%pftm(:) = -1
<LI>+       endwhere
<LI>+
<LI>+       deallocate(rcmfrac) 
<LI>+
<LI>+     endif  ! if ier not error
<LI>+
<LI>+!rcm above
<LI>+
<LI>+       ier = nf_inq_varid (ncid, 'PFTDATA_MASK', varid)
<LI>+       if (ier == NF_NOERR) then
<LI>+         call check_ret(nf_get_vara_int(ncid, varid, strt3, cnt3, domain%pftm), subname)
<LI>+       endif
<LI>+       
<LI>+!tcx fix, this or a test/abort should be added so overlaps can be computed
<LI>+!tcx fix, this is demonstrated not bfb in cam bl311 test.
<LI>+!tcx fix, see also lat_o_local in areaMod.F90
<LI>+#if (1 == 0)
<LI>+       ! Check lat limited to -90,90
<LI>+       if (minval(domain%latc) < -90.0_r8 .or. &
<LI>+           maxval(domain%latc) >  90.0_r8) then
<LI>+           write(6,*) trim(subname),' Limiting lat/lon to [-90/90] from ', &
<LI>+              minval(domain%latc),maxval(domain%latc)
<LI>+           where (domain%latc < -90.0_r8) domain%latc = -90.0_r8
<LI>+           where (domain%latc >  90.0_r8) domain%latc =  90.0_r8
<LI>+       endif
<LI>+#endif
<LI>+
<LI>+
<LI>+       ! -------------------------------------------------------------------
<LI>+       ! Define edges and area of grid cells
<LI>+       ! -------------------------------------------------------------------
<LI>+
<LI>+#if (defined SEQ_MCT) || (SEQ_ESMF) || (defined COUP_CSM)
<LI>+       if (.not.NSEWset) call celledge (domain)
<LI>+       if (.not.AREAset) call cellarea (domain)
<LI>+#endif
<LI>+
<LI>+#if (defined OFFLINE)
<LI>+!       if (.not.NSEWset) then    
<LI>+!          if (.not.EDGEset) then           ! global grid without use of edges
<LI>+!            call celledge (domain)
<LI>+!          else                             ! regional regular grid 
<LI>+            call celledge (domain, &
<LI>+                           domain%edges(1), domain%edges(2), &
<LI>+                           domain%edges(3), domain%edges(4))
<LI>+!          end if
<LI>+!       endif
<LI>+!       if (.not.AREAset) then
<LI>+!          call cellarea (domain)
<LI>+!       end if
<LI>+#endif
<LI>+
<LI>+       call check_ret(nf_close(ncid), subname)
<LI>+
<LI>+    end if   ! end of if-masterproc block
<LI>+
<LI>+!abt below
<LI>+    call mpi_bcast (landmask    , size(landmask)    , MPI_INTEGER, 0, mpicom, ier)  
<LI>+    call mpi_bcast (landfrac    , size(landfrac)    , MPI_REAL8  , 0, mpicom, ier)  
<LI>+    call mpi_bcast (satbrt_clm  , size(satbrt_clm)  , MPI_REAL8  , 0, mpicom, ier)  
<LI>+    call mpi_bcast (init_tgb    , size(init_tgb)    , MPI_REAL8  , 0, mpicom, ier)  
<LI>+!abt above
<LI>+    call mpi_bcast (domain%latn , size(domain%latn) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%lats , size(domain%lats) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%lonw , size(domain%lonw) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%lone , size(domain%lone) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%area , size(domain%area) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%latc , size(domain%latc) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%lonc , size(domain%lonc) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%pftm , size(domain%pftm) , MPI_INTEGER, 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%edges, size(domain%edges), MPI_REAL8  , 0, mpicom, ier)
<LI>+
<LI>+
<LI>+  end subroutine rcmsurfrd_get_grid
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: rcmsurfrd_get_latlon
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine rcmsurfrd_get_latlon(latlon,filename,mask,mfilename,pftmflag)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Read the surface dataset grid related information:
<LI>+!
<LI>+! !USES:
<LI>+    use clm_varcon, only : spval
<LI>+    use domainMod , only : latlon_type, latlon_init
<LI>+    use areaMod   , only : celledge
<LI>+    use fileutils , only : getfil
<LI>+!abt below
<LI>+    use clm_varsur, only : satbrt_clm,r2cimask
<LI>+!abt above
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+    type(latlon_type)         ,intent(inout) :: latlon   ! domain to init
<LI>+    character(len=*)          ,intent(in)    :: filename ! grid filename
<LI>+    integer,pointer  ,optional               :: mask(:)
<LI>+    character(len=*) ,optional,intent(in)    :: mfilename ! grid filename
<LI>+    logical          ,optional,intent(in)    :: pftmflag   ! is mask pft mask?
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine surfrd in this module
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Mariana Vertenstein
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer :: ni,nj               ! size of grid on file
<LI>+    integer :: n,nni,nnj,nns        ! index
<LI>+    integer :: ncid,dimid,varid    ! netCDF id's
<LI>+    integer :: ncidm               ! mask file netCDF id's
<LI>+    integer :: ier                 ! error status
<LI>+    character(len=256)  :: locfn   ! local file name
<LI>+    integer :: ret, time_index
<LI>+    integer  :: strt3(3)           ! Start index to read in
<LI>+    integer  :: cnt3(3)            ! Number of points to read in
<LI>+    real(r8),allocatable :: rdata(:) ! temporary data
<LI>+    real(r8),allocatable :: rdata1(:) ! temporary data
<LI>+    integer :: counter
<LI>+    logical :: NSEWset             ! true if lat/lon NSEW read from grid file
<LI>+    logical :: EDGEset             ! true if EDGE NSEW read from grid file
<LI>+    logical :: lpftmflag           ! is mask a pft mask, local copy
<LI>+    integer  :: start2(2)          ! Start index to read in
<LI>+    real(r8),allocatable :: rcmfrac(:)         ! landfraction read in from RCMnavy abt
<LI>+    logical ,allocatable :: mask_logic(:)
<LI>+    integer  :: count2(2)          ! Number of points to read in
<LI>+    real(r8) :: closelat           ! Single-column latitude value
<LI>+    real(r8) :: closelon           ! Single-column longitude value
<LI>+    integer  :: closelatidx        ! Single-column latitude index to retrieve
<LI>+    integer  :: closelonidx        ! Single-column longitude index to retrieve
<LI>+    character(len=32) :: subname = 'rcmsurfrd_get_latlon'    ! subroutine name
<LI>+!-----------------------------------------------------------------------
<LI>+
<LI>+    NSEWset = .false.
<LI>+    EDGEset = .false.
<LI>+    lpftmflag = .false.
<LI>+    ni = 0
<LI>+    nj = 0
<LI>+
<LI>+    if (present(pftmflag)) then
<LI>+       lpftmflag = pftmflag
<LI>+    endif
<LI>+
<LI>+    if (masterproc) then
<LI>+
<LI>+       if (filename == ' ') then
<LI>+          write(6,*) trim(subname),' ERROR: filename must be specified '
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       call getfil( filename, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncid), subname )
<LI>+
<LI>+       if (single_column) then
<LI>+          ni = lsmlon
<LI>+          nj = lsmlat
<LI>+       else
<LI>+          ier = nf_inq_dimid (ncid, 'lon', dimid)
<LI>+          if (ier == NF_NOERR) then
<LI>+            call check_ret(nf_inq_dimlen(ncid, dimid, ni), subname)
<LI>+          endif
<LI>+          ier = nf_inq_dimid (ncid, 'lat', dimid)
<LI>+          if (ier == NF_NOERR) then
<LI>+            call check_ret(nf_inq_dimlen(ncid, dimid, nj), subname)
<LI>+          endif
<LI>+          ier = nf_inq_dimid (ncid, 'lsmlon', dimid)
<LI>+          if (ier == NF_NOERR) then
<LI>+            call check_ret(nf_inq_dimlen(ncid, dimid, ni), subname)
<LI>+          endif
<LI>+          ier = nf_inq_dimid (ncid, 'lsmlat', dimid)
<LI>+          if (ier == NF_NOERR) then
<LI>+            call check_ret(nf_inq_dimlen(ncid, dimid, nj), subname)
<LI>+          endif
<LI>+       endif
<LI>+
<LI>+       if (ni == 0 .or. nj == 0) then
<LI>+          write(6,*) trim(subname),' ERROR: ni or nj not set',ni,nj
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+    endif
<LI>+
<LI>+    call mpi_bcast (ni, 1, MPI_INTEGER, 0, mpicom, ier)
<LI>+    call mpi_bcast (nj, 1, MPI_INTEGER, 0, mpicom, ier)
<LI>+
<LI>+    call latlon_init(latlon,ni,nj)
<LI>+    if (present(mask)) then
<LI>+       allocate(mask(ni*nj))
<LI>+       mask = 1
<LI>+    endif
<LI>+
<LI>+    if (masterproc) then
<LI>+       if(.not.allocated(rdata)) allocate(rdata(ni))
<LI>+       if(.not.allocated(rdata1)) allocate(rdata1(nj))
<LI>+
<LI>+
<LI>+       start2(1)  = 1
<LI>+       start2(2)  = 1
<LI>+       count2(1)  = ni
<LI>+       count2(2)  = nj
<LI>+
<LI>+       if (single_column) then
<LI>+          call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>+          start2(1) = closelonidx
<LI>+          start2(2) = closelatidx
<LI>+       endif
<LI>+
<LI>+!abt rcm below       call check_ret(nf_inq_varid(ncid, 'lon', varid), subname)
<LI>+!       call check_ret(nf_get_vara_double(ncid, varid, start2, count2, rdata), subname)
<LI>+!       !call check_ret(nf_get_var_double(ncid, varid, rdata), subname)
<LI>+!      latlon%lonc(:) = rdata(:)
<LI>+
<LI>+
<LI>+!       call check_ret(nf_inq_varid(ncid, 'lat', varid), subname)
<LI>+!       call check_ret(nf_get_vara_double(ncid, varid, rdata1), subname)
<LI>+!       call check_ret(nf_get_var_double(ncid, varid, rdata1), subname)
<LI>+!     latlon%latc(:) = rdata1(:)
<LI>+
<LI>+
<LI>+       latlon%latc(:) = r2cxlatd_all(1,1:nj)
<LI>+       latlon%lonc(:) = r2cxlond_all(1:ni,1)
<LI>+
<LI>+
<LI>+!       latlon%edges(:) = spval
<LI>+!       ier = nf_inq_varid (ncid, 'EDGEN', varid)
<LI>+!       if (ier == NF_NOERR) then
<LI>+!          EDGEset = .true.
<LI>+!          call check_ret(nf_inq_varid(ncid, 'EDGEN', varid), subname)
<LI>+!          call check_ret(nf_get_var_double(ncid, varid, latlon%edges(1)), subname)
<LI>+!          call check_ret(nf_inq_varid(ncid, 'EDGEE', varid), subname)
<LI>+!          call check_ret(nf_get_var_double(ncid, varid, latlon%edges(2)), subname)
<LI>+!          call check_ret(nf_inq_varid(ncid, 'EDGES', varid), subname)
<LI>+!          call check_ret(nf_get_var_double(ncid, varid, latlon%edges(3)), subname)
<LI>+!          call check_ret(nf_inq_varid (ncid, 'EDGEW', varid), subname)
<LI>+!          call check_ret(nf_get_var_double(ncid, varid, latlon%edges(4)), subname)
<LI>+!          if (maxval(latlon%edges) > 1.0e35) EDGEset = .false. !read garbage
<LI>+!       endif
<LI>+! abt above
<LI>+! abt rcm edges used 
<LI>+       latlon%edges(:) = spval
<LI>+       latlon%edges(1) = r2cedgen
<LI>+       latlon%edges(2) = r2cedgee
<LI>+       latlon%edges(3) = r2cedges
<LI>+       latlon%edges(4) = r2cedgew
<LI>+
<LI>+! abt below      ier = nf_inq_varid (ncid, 'LATN', varid)
<LI>+!       if (ier == NF_NOERR) then
<LI>+!          NSEWset = .true.
<LI>+!          call check_ret(nf_inq_varid(ncid, 'LATN', varid), subname)
<LI>+!          call check_ret(nf_get_vara_double(ncid, varid, start2, count2, rdata), subname)
<LI>+!          !call check_ret(nf_get_var_double(ncid, varid, rdata), subname)
<LI>+!          latlon%latn(:) = rdata(1,:)
<LI>+!
<LI>+!          call check_ret(nf_inq_varid(ncid, 'LONE', varid), subname)
<LI>+!          call check_ret(nf_get_vara_double(ncid, varid, start2, count2, rdata), subname)
<LI>+!          !call check_ret(nf_get_var_double(ncid, varid, rdata), subname)
<LI>+!          latlon%lone(:) = rdata(:,1)
<LI>+
<LI>+!          call check_ret(nf_inq_varid(ncid, 'LATS', varid), subname)
<LI>+!          call check_ret(nf_get_vara_double(ncid, varid, start2, count2, rdata), subname)
<LI>+!          !call check_ret(nf_get_var_double(ncid, varid, rdata), subname)
<LI>+!          latlon%lats(:) = rdata(1,:)
<LI>+
<LI>+!          call check_ret(nf_inq_varid(ncid, 'LONW', varid), subname)
<LI>+!          call check_ret(nf_get_vara_double(ncid, varid, start2, count2, rdata), subname)
<LI>+!          !call check_ret(nf_get_var_double(ncid, varid, rdata), subname)
<LI>+!          latlon%lonw(:) = rdata(:,1)
<LI>+! abt above       endif
<LI>+
<LI>+#if (defined SEQ_MCT) || (defined SEQ_ESMF) || (defined COUP_CSM)
<LI>+       if (.not.NSEWset) call celledge (latlon)
<LI>+#endif
<LI>+
<LI>+#if (defined OFFLINE)
<LI>+!abt       if (.not.NSEWset) then    
<LI>+!          if (.not.EDGEset) then           ! global grid without use of edges
<LI>+!            call celledge (latlon)
<LI>+!abt          else                             ! regional regular grid 
<LI>+            call celledge (latlon, &
<LI>+                           latlon%edges(1), latlon%edges(2), &
<LI>+                           latlon%edges(3), latlon%edges(4))
<LI>+!abt          end if
<LI>+!abt       endif
<LI>+#endif
<LI>+       if (present(mask)) then
<LI>+          if (present(mfilename)) then
<LI>+             if (mfilename == ' ') then
<LI>+               write(6,*) trim(subname),' ERROR: mfilename must be specified '
<LI>+               call endrun()
<LI>+             endif
<LI>+
<LI>+             call getfil( mfilename, locfn, 0 )
<LI>+             call check_ret( nf_open(locfn, 0, ncidm), subname )
<LI>+          else
<LI>+             ncidm = ncid
<LI>+          endif
<LI>+
<LI>+!abt          ier = nf_inq_varid(ncidm, 'LANDMASK', varid)
<LI>+!          if (ier == NF_NOERR) then
<LI>+!             call check_ret(nf_get_vara_int(ncidm, varid, start2, count2, mask), subname)
<LI>+!abt          endif
<LI>+
<LI>+           strt3(1)=1
<LI>+           strt3(2)=1
<LI>+           strt3(3)=1
<LI>+           cnt3(1)=ni
<LI>+           cnt3(2)=nj
<LI>+           cnt3(3)=1
<LI>+
<LI>+           if(.not.allocated(rcmfrac))    allocate(rcmfrac(ni*nj))
<LI>+           if(.not.allocated(mask_logic)) allocate(mask_logic(ni*nj))
<LI>+           ier = nf_inq_varid(ncid, 'LANDFRAC', varid)
<LI>+         if (ier == NF_NOERR) then
<LI>+            call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, rcmfrac), subname)
<LI>+
<LI>+
<LI>+           mask = 1
<LI>+           do nnj = 1,nj
<LI>+           do nni = 1,ni
<LI>+              nns = (nnj-1)*ni + nni
<LI>+
<LI>+              if(r2cimask == 2) then               !using weighted landfraction method
<LI>+                if(rcmfrac(nns) < 0.1) then
<LI>+                  mask(nns)  = 0.
<LI>+                else
<LI>+                  mask(nns)  = 1.
<LI>+                endif
<LI>+
<LI>+              elseif(r2cimask == 1) then           !using DOMAIN.INFO landmask
<LI>+                if(satbrt_clm(nnj,nni) > 13.9 .and. satbrt_clm(nnj,nni) < 15.1) then
<LI>+                  mask(nns)  = 0.
<LI>+                else
<LI>+                  mask(nns)  = 1.
<LI>+                endif
<LI>+
<LI>+              endif
<LI>+
<LI>+           enddo
<LI>+           enddo
<LI>+
<LI>+
<LI>+       
<LI>+         endif  ! if ier not error
<LI>+!rcm above
<LI>+
<LI>+
<LI>+          !--- if this is a pft mask, then modify and look for pftdata_mask array on dataset ---
<LI>+          if (lpftmflag) then
<LI>+             do n = 1,ni*nj
<LI>+                if (mask(n) <= 0) mask(n) = -1
<LI>+             enddo
<LI>+             ier = nf_inq_varid (ncidm, 'PFTDATA_MASK', varid)
<LI>+             if (ier == NF_NOERR) then
<LI>+                call check_ret(nf_get_vara_int(ncidm, varid, start2, count2, mask), subname)
<LI>+             endif
<LI>+          endif
<LI>+
<LI>+          if (present(mfilename)) then
<LI>+             call check_ret(nf_close(ncidm), subname)
<LI>+          endif
<LI>+
<LI>+         deallocate(rcmfrac)
<LI>+
<LI>+       endif   !if mask present
<LI>+
<LI>+       deallocate(rdata)
<LI>+       deallocate(rdata1)
<LI>+
<LI>+!tcx fix, this or a test/abort should be added so overlaps can be computed
<LI>+!tcx fix, this is demonstrated not bfb in cam bl311 test.
<LI>+!tcx fix, see also lat_o_local in areaMod.F90
<LI>+#if (1 == 0)
<LI>+       ! Check lat limited to -90,90
<LI>+       if (minval(latlon%latc) < -90.0_r8 .or. &
<LI>+           maxval(latlon%latc) >  90.0_r8) then
<LI>+           write(6,*) trim(subname),' Limiting lat/lon to [-90/90] from ', &
<LI>+              minval(latlon%latc),maxval(latlon%latc)
<LI>+           where (latlon%latc < -90.0_r8) latlon%latc = -90.0_r8
<LI>+           where (latlon%latc >  90.0_r8) latlon%latc =  90.0_r8
<LI>+       endif
<LI>+#endif
<LI>+
<LI>+       call check_ret(nf_close(ncid), subname)
<LI>+
<LI>+
<LI>+    end if   ! end of if-masterproc block
<LI>+
<LI>+
<LI>+    call mpi_bcast (latlon%latc , size(latlon%latc) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (latlon%lonc , size(latlon%lonc) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (latlon%lats , size(latlon%lats) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (latlon%latn , size(latlon%latn) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (latlon%lonw , size(latlon%lonw) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (latlon%lone , size(latlon%lone) , MPI_REAL8  , 0, mpicom, ier)
<LI>+    call mpi_bcast (latlon%edges, size(latlon%edges), MPI_REAL8  , 0, mpicom, ier)
<LI>+    if (present(mask)) then
<LI>+       call mpi_bcast(mask       , size(mask)         , MPI_INTEGER, 0, mpicom, ier)
<LI>+    endif
<LI>+
<LI>+  end subroutine rcmsurfrd_get_latlon
<LI>+
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: rcmsurfrd_get_frac
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine rcmsurfrd_get_frac(domain,filename)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Read the landfrac dataset grid related information:
<LI>+! Assume domain has already been initialized and read
<LI>+!
<LI>+! !USES:
<LI>+    use domainMod , only : domain_type
<LI>+    use fileutils , only : getfil
<LI>+!abt below
<LI>+    use clm_varsur, only : satbrt_clm,r2cimask
<LI>+!abt above
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+    type(domain_type),intent(inout) :: domain   ! domain to init
<LI>+    character(len=*) ,intent(in)    :: filename ! grid filename
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine initialize
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by T Craig
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer :: n,nni,nnj,nns       ! indices
<LI>+    integer :: ni,nj,ns            ! size of grid on file
<LI>+    integer :: ncid,dimid,varid    ! netCDF id's
<LI>+    integer :: ier                 ! error status
<LI>+    real(r8):: eps = 1.0e-12_r8    ! lat/lon error tolerance
<LI>+    real(r8),allocatable:: lonc(:),latc(:)  ! local lat/lon
<LI>+    character(len=256)  :: locfn   ! local file name
<LI>+    integer :: ret, time_index
<LI>+    integer  :: strt3(3)           ! Start index to read in
<LI>+    integer  :: cnt3(3)            ! Number of points to read in
<LI>+    integer  :: strt1, cnt1        ! Start and count to read in for scalar
<LI>+    integer  :: counter
<LI>+    logical,allocatable :: mask_logic(:)
<LI>+    real(r8) :: closelat           ! Single-column latitude value
<LI>+    real(r8) :: closelon           ! Single-column longitude value
<LI>+    integer  :: closelatidx        ! Single-column latitude index to retrieve
<LI>+    integer  :: closelonidx        ! Single-column longitude index to retrieve
<LI>+    character(len=32) :: subname = 'rcmsurfrd_get_frac'     ! subroutine name
<LI>+!-----------------------------------------------------------------------
<LI>+ 
<LI>+
<LI>+    if (masterproc) then
<LI>+
<LI>+       if (filename == ' ') then
<LI>+          write(6,*) trim(subname),' ERROR: filename must be specified '
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       call getfil( filename, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncid), subname )
<LI>+
<LI>+       if (single_column) then
<LI>+          ni = lsmlon
<LI>+          nj = lsmlat
<LI>+       else
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lon', dimid), subname)
<LI>+          call check_ret(nf_inq_dimlen(ncid, dimid, ni), subname)
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lat', dimid), subname)
<LI>+          call check_ret(nf_inq_dimlen(ncid, dimid, nj), subname)
<LI>+       endif
<LI>+
<LI>+       ns = ni*nj
<LI>+
<LI>+       if (domain%ni /= ni .or. domain%nj /= nj .or. domain%ns /= ns) then
<LI>+          write(6,*) trim(subname),' ERROR: landfrac file mismatch ni,nj',domain%ni,ni,domain%nj,nj,domain%ns,ns
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       if(.not.allocated(latc)) allocate(latc(ni*nj),lonc(ni*nj))
<LI>+
<LI>+       strt3(1)=1
<LI>+       strt3(2)=1
<LI>+       strt3(3)=1
<LI>+       cnt3(1)=domain%ni
<LI>+       cnt3(2)=domain%nj
<LI>+       cnt3(3)=1
<LI>+       strt1=1
<LI>+       cnt1=domain%nj
<LI>+
<LI>+       if (single_column) then
<LI>+          call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>+          strt3(1)=closelonidx
<LI>+          strt3(2)=closelatidx
<LI>+          strt1=closelatidx
<LI>+          cnt1=1
<LI>+       endif
<LI>+
<LI>+!abt       call check_ret(nf_inq_varid(ncid, 'LONGXY' , varid), subname)
<LI>+!abt       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, lonc), subname)
<LI>+     
<LI>+!abt     call check_ret(nf_inq_varid(ncid, 'LATIXY', varid), subname)
<LI>+!abt       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, latc), subname)
<LI>+
<LI>+!rcm abt below
<LI>+       do nnj = 1,nj
<LI>+       do nni = 1,ni
<LI>+         nns = (nnj-1)*ni + nni
<LI>+         lonc(nns) = r2cxlond_all(nni,nnj)
<LI>+         latc(nns) = r2cxlatd_all(nni,nnj)
<LI>+       enddo 
<LI>+       enddo
<LI>+!rcm above         
<LI>+
<LI>+       do n = 1,ns
<LI>+          if (abs(latc(n)-domain%latc(n)) > eps .or. &
<LI>+               abs(lonc(n)-domain%lonc(n)) > eps) then
<LI>+             write(6,*) trim(subname),' ERROR: landfrac file mismatch lat,lon',latc(n),domain%latc(n),lonc(n),domain%lonc(n),eps
<LI>+             call endrun()
<LI>+          endif
<LI>+       enddo
<LI>+       
<LI>+!abt below       call check_ret(nf_inq_varid(ncid, 'LANDMASK', varid), subname)
<LI>+!       call check_ret(nf_get_vara_int(ncid, varid, strt3, cnt3, domain%mask), subname)
<LI>+       
<LI>+       call check_ret(nf_inq_varid(ncid, 'LANDFRAC', varid), subname)
<LI>+       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, domain%frac), subname)
<LI>+ 
<LI>+       do nnj = 1,nj
<LI>+       do nni = 1,ni
<LI>+          nns = (nnj-1)*ni + nni
<LI>+
<LI>+          if(r2cimask == 2) then               !using weighted landfraction method
<LI>+            if(domain%frac(nns) < 0.1) then
<LI>+              domain%mask(nns)  = 0.
<LI>+            else
<LI>+              domain%mask(nns)  = 1.
<LI>+            endif
<LI>+
<LI>+          elseif(r2cimask == 1) then           !using DOMAIN.INFO landmask
<LI>+            if(satbrt_clm(nnj,nni) > 13.9 .and. satbrt_clm(nnj,nni) < 15.1) then
<LI>+              domain%mask(nns)  = 0.
<LI>+            else
<LI>+              domain%mask(nns)  = 1.
<LI>+            endif
<LI>+
<LI>+          endif
<LI>+
<LI>+       enddo
<LI>+       enddo
<LI>+
<LI>+       where(domain%mask(:) == 0.)
<LI>+         domain%frac(:) = 0.
<LI>+       endwhere
<LI>+!abt above
<LI>+
<LI>+       deallocate(latc,lonc)
<LI>+
<LI>+       call check_ret(nf_close(ncid), subname)
<LI>+
<LI>+    end if   ! end of if-masterproc block
<LI>+
<LI>+    call mpi_bcast (domain%mask , size(domain%mask) , MPI_INTEGER, 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%frac , size(domain%frac) , MPI_REAL8  , 0, mpicom, ier)
<LI>+
<LI>+  end subroutine rcmsurfrd_get_frac
<LI>+
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: rcmsurfrd_get_topo
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine rcmsurfrd_get_topo(domain,filename)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Read the topo dataset grid related information:
<LI>+! Assume domain has already been initialized and read
<LI>+!
<LI>+! !USES:
<LI>+    use domainMod , only : domain_type
<LI>+    use fileutils , only : getfil
<LI>+    use clm_varcon, only : grav
<LI>+    use clm_varsur, only : ht_rcm
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+    type(domain_type),intent(inout) :: domain   ! domain to init
<LI>+    character(len=*) ,intent(in)    :: filename ! grid filename
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine initialize
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by T Craig
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer :: n,nni,nnj,nns                   ! indices abt
<LI>+    integer :: ni,nj,ns            ! size of grid on file
<LI>+    integer :: ncid,dimid,varid    ! netCDF id's
<LI>+    integer :: ier                 ! error status
<LI>+    real(r8):: eps = 1.0e-12_r8    ! lat/lon error tolerance
<LI>+    real(r8),allocatable:: lonc(:),latc(:)      ! local lat/lon
<LI>+    real(r8),allocatable:: TOPO(:,:)        !abt
<LI>+    character(len=256)  :: locfn   ! local file name
<LI>+    integer :: ret, time_index
<LI>+    integer  :: strt3(3)           ! Start index to read in
<LI>+    integer  :: cnt3(3)            ! Number of points to read in
<LI>+    integer  :: strt1, cnt1        ! Start and count to read in for scalar
<LI>+    real(r8) :: closelat           ! Single-column latitude value
<LI>+    real(r8) :: closelon           ! Single-column longitude value
<LI>+    integer  :: closelatidx        ! Single-column latitude index to retrieve
<LI>+    integer  :: closelonidx        ! Single-column longitude index to retrieve
<LI>+    character(len=32) :: subname = 'rcmsurfrd_get_topo'     ! subroutine name
<LI>+!-----------------------------------------------------------------------
<LI>+
<LI>+    if (masterproc) then
<LI>+
<LI>+       if (filename == ' ') then
<LI>+          write(6,*) trim(subname),' ERROR: filename must be specified '
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       call getfil( filename, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncid), subname )
<LI>+
<LI>+       if (single_column) then
<LI>+          ni = lsmlon
<LI>+          nj = lsmlat
<LI>+       else
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lon', dimid), subname)
<LI>+          call check_ret(nf_inq_dimlen(ncid, dimid, ni), subname)
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lat', dimid), subname)
<LI>+          call check_ret(nf_inq_dimlen(ncid, dimid, nj), subname)
<LI>+       endif
<LI>+
<LI>+       ns = ni*nj
<LI>+
<LI>+       if (domain%ni /= ni .or. domain%nj /= nj .or. domain%ns /= ns) then
<LI>+          write(6,*) trim(subname),' ERROR: topo file mismatch ni,nj',domain%ni,ni,domain%nj,nj,domain%ns,ns
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       if(.not.allocated(latc)) allocate(latc(ns),lonc(ns))
<LI>+
<LI>+       strt3(1)=1
<LI>+       strt3(2)=1
<LI>+       strt3(3)=1
<LI>+       cnt3(1)=domain%ni
<LI>+       cnt3(2)=domain%nj
<LI>+       cnt3(3)=1
<LI>+       strt1=1
<LI>+       cnt1=domain%nj
<LI>+
<LI>+       if (single_column) then
<LI>+          call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>+          strt3(1)=closelonidx
<LI>+          strt3(2)=closelatidx
<LI>+          strt1=closelatidx
<LI>+          cnt1=1
<LI>+       endif
<LI>+
<LI>+!abt       call check_ret(nf_inq_varid(ncid, 'LONGXY' , varid), subname)
<LI>+!abt       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, lonc), subname)
<LI>+
<LI>+!abt       call check_ret(nf_inq_varid(ncid, 'LATIXY', varid), subname)
<LI>+!abt       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, latc), subname)
<LI>+
<LI>+!rcm abt below
<LI>+       do nnj = 1,nj
<LI>+       do nni = 1,ni
<LI>+         nns = (nnj-1)*ni + nni
<LI>+         lonc(nns) = r2cxlond_all(nni,nnj)
<LI>+         latc(nns) = r2cxlatd_all(nni,nnj)
<LI>+       enddo 
<LI>+       enddo
<LI>+!rcm above
<LI>+
<LI>+
<LI>+       do n = 1,ns
<LI>+          if (abs(latc(n)-domain%latc(n)) > eps .or. &
<LI>+              abs(lonc(n)-domain%lonc(n)) > eps) then
<LI>+             write(6,*) trim(subname),' ERROR: topo file mismatch lat,lon',latc(n),domain%latc(n),lonc(n),domain%lonc(n),eps
<LI>+             call endrun()
<LI>+          endif
<LI>+       enddo
<LI>+
<LI>+!abt       call check_ret(nf_inq_varid(ncid, 'TOPO', varid), subname)
<LI>+!abt       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, domain%topo), subname)
<LI>+
<LI>+!abt added REGCM elevation for continuity between regcm and clm
<LI>+       do nnj = 1,nj
<LI>+       do nni = 1,ni
<LI>+         nns = (nnj-1)*ni + nni
<LI>+         domain%topo(nns) = ht_rcm(nnj,nni)/grav     !convert from geopotential ht to ht
<LI>+       enddo
<LI>+       enddo
<LI>+
<LI>+!       deallocate(ht_rcm)   !abt
<LI>+       deallocate(latc,lonc)
<LI>+
<LI>+    end if   ! end of if-masterproc block
<LI>+
<LI>+    call mpi_bcast (domain%topo , size(domain%topo) , MPI_REAL8  , 0, mpicom, ier)
<LI>+
<LI>+  end subroutine rcmsurfrd_get_topo
<LI>+
<LI>+
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: rcmsurfrd_wtxy_special 
<LI>+!
<LI>+! !INTERFACE:
<LI>+!  subroutine surfrd_wtxy_special(ncid, pctspec, vegxy, wtxy, domain)
<LI>+  subroutine rcmsurfrd_wtxy_special(ncidlak,ncidglac,ncidurb,ncidsoi, domain)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Determine weight with respect to gridcell of all special "pfts" as well
<LI>+! as soil color and percent sand and clay
<LI>+!
<LI>+! !USES:
<LI>+    use pftvarcon   , only : noveg
<LI>+    use domainMod   , only : domain_type,ldomain
<LI>+!abt below
<LI>+    use clm_varsur  , only : landfrac
<LI>+    use decompMod   , only : adecomp
<LI>+!abt above
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+!    integer , intent(in)    :: ncid      ! netcdf file id 
<LI>+    integer , intent(in)    :: ncidlak      ! netcdf file id for lake/wetland
<LI>+    integer , intent(in)    :: ncidglac     ! netcdf file id for glacier
<LI>+    integer , intent(in)    :: ncidurb      ! netcdf file id for urban
<LI>+    integer , intent(in)    :: ncidsoi      ! netcdf file id for soil levels
<LI>+!    real(r8), intent(inout) :: pctspec(:)! percent wrt gcell special lunits
<LI>+!    integer , intent(inout) :: vegxy(:,:)  ! PFT
<LI>+!    real(r8), intent(inout) :: wtxy(:,:) ! subgrid weights
<LI>+    type(domain_type),intent(in) :: domain ! domain associated with wtxy
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine surfrd in this module
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Mariana Vertenstein, Sam Levis and Gordon Bonan
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer  :: n,nl,ns                    ! indices
<LI>+    integer  :: nni,nnj                    ! indices
<LI>+    integer  :: begg,endg                  ! gcell beg/end
<LI>+    integer  :: dimid,varid                ! netCDF id's
<LI>+    integer  :: ret, time_index
<LI>+    real(r8) :: nlevsoidata(nlevsoi),pctspecB
<LI>+    logical  :: found                      ! temporary for error check
<LI>+    integer  :: nindx                      ! temporary for error check
<LI>+    integer  :: ier                        ! error status
<LI>+    real(r8),pointer :: pctgla(:)      ! percent of grid cell is glacier
<LI>+    real(r8),pointer :: pctlak(:)      ! percent of grid cell is lake
<LI>+    real(r8),pointer :: pctwet(:)      ! percent of grid cell is wetland
<LI>+    real(r8),pointer :: pcturb(:)      ! percent of grid cell is urbanized
<LI>+    integer  :: strt3(3)               ! Start index to read in
<LI>+    integer  :: cnt3(3)                ! Number of points to read in
<LI>+    real(r8) :: closelat               ! Single-column latitude value
<LI>+    real(r8) :: closelon               ! Single-column longitude value
<LI>+    integer  :: closelatidx            ! Single-column latitude index to retrieve
<LI>+    integer  :: closelonidx            ! Single-column longitude index to retrieve
<LI>+    character(len=32) :: subname = 'rcmsurfrd_wtxy_special'  ! subroutine name
<LI>+!!-----------------------------------------------------------------------
<LI>+
<LI>+    ns = domain%ns
<LI>+    call get_proc_bounds(begg,endg)
<LI>+
<LI>+    allocate(pctgla(begg:endg),pctlak(begg:endg))
<LI>+    allocate(pctwet(begg:endg),pcturb(begg:endg))
<LI>+
<LI>+    if (masterproc) then
<LI>+!       call check_dim(ncid, 'nlevsoi', nlevsoi)
<LI>+       call check_dim(ncidsoi, 'level', nlevsoi) ! abt
<LI>+ 
<LI>+    end if   ! end of if-masterproc
<LI>+
<LI>+    ! Obtain non-grid surface properties of surface dataset other than percent pft
<LI>+
<LI>+    strt3(1)=1
<LI>+    strt3(2)=1
<LI>+    strt3(3)=1
<LI>+    cnt3(1)=domain%ni
<LI>+    cnt3(2)=domain%nj
<LI>+    cnt3(3)=1
<LI>+
<LI>+
<LI>+!abt    if (single_column) then
<LI>+!abt       call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>+!abt       strt3(1)=closelonidx
<LI>+!abt       strt3(2)=closelatidx
<LI>+!abt    endif
<LI>+! abt rcm below
<LI>+    call ncd_iolocal(ncidlak, 'PCT_WETLAND', 'read', pctwet, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    call ncd_iolocal(ncidlak, 'PCT_LAKE'   , 'read', pctlak, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    call ncd_iolocal(ncidglac, 'PCT_GLACIER', 'read', pctgla, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    call ncd_iolocal(ncidurb, 'PCT_URBAN'  , 'read', pcturb, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+
<LI>+
<LI>+!abt set all special unit values to zero if less than 5% cover
<LI>+!
<LI>+
<LI>+    do nl = begg,endg
<LI>+      nni = adecomp%gdc2i(nl) 
<LI>+      nnj = adecomp%gdc2j(nl) 
<LI>+
<LI>+      if(ldomain%mask(nl) == 0) then
<LI>+         pctlak(nl) = 0._r8
<LI>+         pctwet(nl) = 0._r8
<LI>+         pctgla(nl) = 0._r8
<LI>+         pcturb(nl) = 0._r8
<LI>+      else
<LI>+         if(pctlak(nl) < 5._r8) pctlak(nl) = 0._r8
<LI>+         if(pctwet(nl) < 5._r8) pctwet(nl) = 0._r8
<LI>+         if(pctgla(nl) < 5._r8) pctgla(nl) = 0._r8
<LI>+         if(pcturb(nl) < 5._r8) pcturb(nl) = 0._r8
<LI>+      endif
<LI>+
<LI>+      pctspecB = pctwet(nl) + pctlak(nl) + pctgla(nl) + pcturb(nl)
<LI>+
<LI>+      if(landfrac(nni,nnj) .eq. 0) then
<LI>+         write(*,*)"landfrac =  ",landfrac(nni,nnj)," at ",nl 
<LI>+         call endrun()
<LI>+      elseif((landfrac(nni,nnj)*100._r8).lt.pctspecB) then
<LI>+         pcturb(nl) = 0._r8
<LI>+         pctgla(nl) = 0._r8
<LI>+         pctlak(nl) = 0._r8
<LI>+         pcturb(nl) = 0._r8
<LI>+         pctwet(nl) = 100._r8   !set to 100% for the land portion of the grid
<LI>+         write(*,*)"****** wetland is 100% *********"  !buggin
<LI>+      else
<LI>+         pctlak(nl) = pctlak(nl)/(landfrac(nni,nnj)*100._r8)
<LI>+         pctwet(nl) = pctwet(nl)/(landfrac(nni,nnj)*100._r8)
<LI>+         pctgla(nl) = pctgla(nl)/(landfrac(nni,nnj)*100._r8)
<LI>+         pcturb(nl) = pcturb(nl)/(landfrac(nni,nnj)*100._r8)
<LI>+      endif       
<LI>+    
<LI>+    enddo
<LI>+
<LI>+!abt rcm above
<LI>+
<LI>+
<LI>+    pctspec = pctwet + pctlak + pctgla + pcturb
<LI>+
<LI>+    ! Error check: glacier, lake, wetland, urban sum must be less than 100
<LI>+
<LI>+    found = .false.
<LI>+    do nl = begg,endg
<LI>+       if (pctspec(nl) > 100._r8+1.e-04_r8) then
<LI>+          found = .true.
<LI>+          nindx = nl
<LI>+          exit
<LI>+       end if
<LI>+       if (found) exit
<LI>+    end do
<LI>+    if ( found ) then
<LI>+       write(6,*)'surfrd error: PFT cover>100 for nl=',nindx
<LI>+       write(6,*)'pctspec/pctwet/pctlak/pcturb/pctgla  = ',pctspec(nl),pctwet(nl),pctlak(nl),pcturb(nl),pctgla(nl)
<LI>+       write(6,*)'begg/endg = ',begg,endg
<LI>+       call endrun()
<LI>+    end if
<LI>+
<LI>+    ! Error check that urban parameterization is not yet finished
<LI>+
<LI>+    found = .false.
<LI>+    do nl = begg,endg
<LI>+       if (pcturb(nl) /= 0._r8) then
<LI>+          found = .true.
<LI>+          nindx = nl
<LI>+          exit
<LI>+       end if
<LI>+       if (found) exit
<LI>+    end do
<LI>+    if ( found ) then
<LI>+       write (6,*)'surfrd error: urban parameterization not implemented at nl= ',nindx,pcturb(nl)
<LI>+       call endrun()
<LI>+    end if
<LI>+
<LI>+    ! Determine veg and wtxy for special landunits
<LI>+
<LI>+    do nl = begg,endg
<LI>+       vegxy(nl,npatch_urban)  = noveg
<LI>+       wtxy(nl,npatch_urban)   = pcturb(nl)/100._r8
<LI>+
<LI>+       vegxy(nl,npatch_lake)   = noveg
<LI>+       wtxy(nl,npatch_lake)    = pctlak(nl)/100._r8
<LI>+
<LI>+       vegxy(nl,npatch_wet)    = noveg
<LI>+       wtxy(nl,npatch_wet)     = pctwet(nl)/100._r8
<LI>+
<LI>+       vegxy(nl,npatch_glacier)= noveg
<LI>+       wtxy(nl,npatch_glacier) = pctgla(nl)/100._r8
<LI>+    end do
<LI>+
<LI>+   deallocate(pctgla,pctlak,pctwet,pcturb)
<LI>+
<LI>+  end subroutine rcmsurfrd_wtxy_special
<LI>+
<LI>+
<LI>+
<LI>+! abt rcm above
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: surfrd_get_frac
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine surfrd_get_frac(domain,filename)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Read the landfrac dataset grid related information:
<LI>+! Assume domain has already been initialized and read
<LI>+!
<LI>+! !USES:
<LI>+    use domainMod , only : domain_type
<LI>+    use fileutils , only : getfil
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+    type(domain_type),intent(inout) :: domain   ! domain to init
<LI>+    character(len=*) ,intent(in)    :: filename ! grid filename
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine initialize
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by T Craig
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer :: n                   ! indices
<LI>+    integer :: ni,nj,ns            ! size of grid on file
<LI>+    integer :: ncid,dimid,varid    ! netCDF id's
<LI>+    integer :: ier                 ! error status
<LI>+    real(r8):: eps = 1.0e-12_r8    ! lat/lon error tolerance
<LI>+    real(r8),allocatable:: lonc(:),latc(:)  ! local lat/lon
<LI>+    character(len=256)  :: locfn   ! local file name
<LI>+    integer :: ret, time_index
<LI>+    integer  :: strt3(3)           ! Start index to read in
<LI>+    integer  :: cnt3(3)            ! Number of points to read in
<LI>+    integer  :: strt1, cnt1        ! Start and count to read in for scalar
<LI>+    real(r8) :: closelat           ! Single-column latitude value
<LI>+    real(r8) :: closelon           ! Single-column longitude value
<LI>+    integer  :: closelatidx        ! Single-column latitude index to retrieve
<LI>+    integer  :: closelonidx        ! Single-column longitude index to retrieve
<LI>+    character(len=32) :: subname = 'surfrd_get_frac'     ! subroutine name
<LI>+!-----------------------------------------------------------------------
<LI>+
<LI>+    if (masterproc) then
<LI>+
<LI>+       if (filename == ' ') then
<LI>+          write(6,*) trim(subname),' ERROR: filename must be specified '
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       call getfil( filename, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncid), subname )
<LI>+
<LI>+       if (single_column) then
<LI>+          ni = lsmlon
<LI>+          nj = lsmlat
<LI>+       else
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lsmlon', dimid), subname)
<LI>+          call check_ret(nf_inq_dimlen(ncid, dimid, ni), subname)
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lsmlat', dimid), subname)
<LI>+          call check_ret(nf_inq_dimlen(ncid, dimid, nj), subname)
<LI>+       endif
<LI>+
<LI>+       ns = ni*nj
<LI>+
<LI>+       if (domain%ni /= ni .or. domain%nj /= nj .or. domain%ns /= ns) then
<LI>+          write(6,*) trim(subname),' ERROR: landfrac file mismatch ni,nj',domain%ni,ni,domain%nj,nj,domain%ns,ns
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       if(.not.allocated(latc)) allocate(latc(ni*nj),lonc(ni*nj))
<LI>+
<LI>+       strt3(1)=1
<LI>+       strt3(2)=1
<LI>+       strt3(3)=1
<LI>+       cnt3(1)=domain%ni
<LI>+       cnt3(2)=domain%nj
<LI>+       cnt3(3)=1
<LI>+       strt1=1
<LI>+       cnt1=domain%nj
<LI>+
<LI>+       if (single_column) then
<LI>+          call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>+          strt3(1)=closelonidx
<LI>+          strt3(2)=closelatidx
<LI>+          strt1=closelatidx
<LI>+          cnt1=1
<LI>+       endif
<LI>+
<LI>+       call check_ret(nf_inq_varid(ncid, 'LONGXY' , varid), subname)
<LI>+       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, lonc), subname)
<LI>+          
<LI>+       call check_ret(nf_inq_varid(ncid, 'LATIXY', varid), subname)
<LI>+       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, latc), subname)
<LI>+
<LI>+       do n = 1,ns
<LI>+          if (abs(latc(n)-domain%latc(n)) > eps .or. &
<LI>+               abs(lonc(n)-domain%lonc(n)) > eps) then
<LI>+             write(6,*) trim(subname),' ERROR: landfrac file mismatch lat,lon',latc(n),domain%latc(n),lonc(n),domain%lonc(n),eps
<LI>+             call endrun()
<LI>+          endif
<LI>+       enddo
<LI>+       
<LI>+       call check_ret(nf_inq_varid(ncid, 'LANDMASK', varid), subname)
<LI>+       call check_ret(nf_get_vara_int(ncid, varid, strt3, cnt3, domain%mask), subname)
<LI>+       
<LI>+       call check_ret(nf_inq_varid(ncid, 'LANDFRAC', varid), subname)
<LI>+       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, domain%frac), subname)
<LI>+       
<LI>+
<LI>+       deallocate(latc,lonc)
<LI>+
<LI>+       call check_ret(nf_close(ncid), subname)
<LI>+
<LI>+    end if   ! end of if-masterproc block
<LI>+
<LI>+    call mpi_bcast (domain%mask , size(domain%mask) , MPI_INTEGER, 0, mpicom, ier)
<LI>+    call mpi_bcast (domain%frac , size(domain%frac) , MPI_REAL8  , 0, mpicom, ier)
<LI>+
<LI>+  end subroutine surfrd_get_frac
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: surfrd_get_topo
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine surfrd_get_topo(domain,filename)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Read the topo dataset grid related information:
<LI>+! Assume domain has already been initialized and read
<LI>+!
<LI>+! !USES:
<LI>+    use domainMod , only : domain_type
<LI>+    use fileutils , only : getfil
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+    type(domain_type),intent(inout) :: domain   ! domain to init
<LI>+    character(len=*) ,intent(in)    :: filename ! grid filename
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine initialize
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by T Craig
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer :: n                   ! indices
<LI>+    integer :: ni,nj,ns            ! size of grid on file
<LI>+    integer :: ncid,dimid,varid    ! netCDF id's
<LI>+    integer :: ier                 ! error status
<LI>+    real(r8):: eps = 1.0e-12_r8    ! lat/lon error tolerance
<LI>+    real(r8),allocatable:: lonc(:),latc(:)  ! local lat/lon
<LI>+    character(len=256)  :: locfn   ! local file name
<LI>+    integer :: ret, time_index
<LI>+    integer  :: strt3(3)           ! Start index to read in
<LI>+    integer  :: cnt3(3)            ! Number of points to read in
<LI>+    integer  :: strt1, cnt1        ! Start and count to read in for scalar
<LI>+    real(r8) :: closelat           ! Single-column latitude value
<LI>+    real(r8) :: closelon           ! Single-column longitude value
<LI>+    integer  :: closelatidx        ! Single-column latitude index to retrieve
<LI>+    integer  :: closelonidx        ! Single-column longitude index to retrieve
<LI>+    character(len=32) :: subname = 'surfrd_get_topo'     ! subroutine name
<LI>+!-----------------------------------------------------------------------
<LI>+
<LI>+    if (masterproc) then
<LI>+
<LI>+       if (filename == ' ') then
<LI>+          write(6,*) trim(subname),' ERROR: filename must be specified '
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       call getfil( filename, locfn, 0 )
<LI>+       call check_ret( nf_open(locfn, 0, ncid), subname )
<LI>+
<LI>+       if (single_column) then
<LI>+          ni = lsmlon
<LI>+          nj = lsmlat
<LI>+       else
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lsmlon', dimid), subname)
<LI>+          call check_ret(nf_inq_dimlen(ncid, dimid, ni), subname)
<LI>+          call check_ret(nf_inq_dimid (ncid, 'lsmlat', dimid), subname)
<LI>+          call check_ret(nf_inq_dimlen(ncid, dimid, nj), subname)
<LI>+       endif
<LI>+
<LI>+       ns = ni*nj
<LI>+
<LI>+       if (domain%ni /= ni .or. domain%nj /= nj .or. domain%ns /= ns) then
<LI>+          write(6,*) trim(subname),' ERROR: topo file mismatch ni,nj',domain%ni,ni,domain%nj,nj,domain%ns,ns
<LI>+          call endrun()
<LI>+       endif
<LI>+
<LI>+       if(.not.allocated(latc)) allocate(latc(ns),lonc(ns))
<LI>+
<LI>+       strt3(1)=1
<LI>+       strt3(2)=1
<LI>+       strt3(3)=1
<LI>+       cnt3(1)=domain%ni
<LI>+       cnt3(2)=domain%nj
<LI>+       cnt3(3)=1
<LI>+       strt1=1
<LI>+       cnt1=domain%nj
<LI>+
<LI>+       if (single_column) then
<LI>+          call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>+          strt3(1)=closelonidx
<LI>+          strt3(2)=closelatidx
<LI>+          strt1=closelatidx
<LI>+          cnt1=1
<LI>+       endif
<LI>+
<LI>+       call check_ret(nf_inq_varid(ncid, 'LONGXY' , varid), subname)
<LI>+       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, lonc), subname)
<LI>+
<LI>+       call check_ret(nf_inq_varid(ncid, 'LATIXY', varid), subname)
<LI>+       call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, latc), subname)
<LI>+
<LI>+       do n = 1,ns
<LI>           if (abs(latc(n)-domain%latc(n)) > eps .or. &
<LI>               abs(lonc(n)-domain%lonc(n)) > eps) then
<LI>              write(6,*) trim(subname),' ERROR: topo file mismatch lat,lon',latc(n),domain%latc(n),lonc(n),domain%lonc(n),eps
<LI>@@ -1012,6 +2377,7 @@
<LI>     call ncd_iolocal(ncid, 'PCT_LAKE'   , 'read', pctlak, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>     call ncd_iolocal(ncid, 'PCT_GLACIER', 'read', pctgla, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>     call ncd_iolocal(ncid, 'PCT_URBAN'  , 'read', pcturb, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+
<LI>     pctspec = pctwet + pctlak + pctgla + pcturb
<LI> 
<LI>     ! Error check: glacier, lake, wetland, urban sum must be less than 100
<LI>@@ -1058,13 +2424,221 @@
<LI>        vegxy(nl,npatch_wet)    = noveg
<LI>        wtxy(nl,npatch_wet)     = pctwet(nl)/100._r8
<LI> 
<LI>-       vegxy(nl,npatch_glacier)= noveg
<LI>-       wtxy(nl,npatch_glacier) = pctgla(nl)/100._r8
<LI>-    end do
<LI>+       vegxy(nl,npatch_glacier)= noveg
<LI>+       wtxy(nl,npatch_glacier) = pctgla(nl)/100._r8
<LI>+    end do
<LI>+
<LI>+   deallocate(pctgla,pctlak,pctwet,pcturb)
<LI>+
<LI>+  end subroutine surfrd_wtxy_special
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: rcmsurfrd_bvocs 
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine rcmsurfrd_bvocs (domain)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Read in biogenic emission factor maps
<LI>+!
<LI>+! !USES:
<LI>+    use clm_varvoc
<LI>+    use clm_varpar  , only : nvoc    
<LI>+    use domainMod   , only : domain_type
<LI>+    use clm_varctl  , only : mksrf_fisop,mksrf_fmbo,mksrf_fapin,mksrf_fbpin
<LI>+    use clm_varctl  , only : mksrf_fco,mksrf_flimo,mksrf_fsabi,mksrf_fmyrc
<LI>+    use clm_varctl  , only : mksrf_focim,mksrf_facar,mksrf_fomtp,mksrf_ffarn
<LI>+    use clm_varctl  , only : mksrf_facto,mksrf_fmeoh,mksrf_fosqt,mksrf_fbcar
<LI>+    use clm_varctl  , only : mksrf_fmeth,mksrf_fno,mksrf_facta,mksrf_fform
<LI>+    use clm_varctl  , only : nsrest
<LI>+    use fileutils   , only : getfil
<LI>+    use clm_time_manager, only : get_step_size
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+!
<LI>+    type(domain_type),intent(in) :: domain ! domain associated with wtxy
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine surfrd in this module
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Ahmed Tawfik
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    character(len=256) :: locfn        ! local file name
<LI>+    integer  :: n,nl,ns,dtime          ! indices
<LI>+    integer  :: begg,endg              ! gcell beg/end
<LI>+    integer  :: dimid,varid            ! netCDF id's
<LI>+    integer  :: ncidv(nvoc)            ! netCDF ids
<LI>+    character(len=256) :: datfil(nvoc) ! filenames
<LI>+    logical  :: found                  ! temporary for error check
<LI>+    integer  :: nindx                  ! temporary for error check
<LI>+    integer  :: ier                    ! error status
<LI>+    integer  :: strt3(3)               ! Start index to read in
<LI>+    integer  :: cnt3(3)                ! Number of points to read in
<LI>+    character(len=32) :: subname = 'rcmsurfrd_bvocs'  ! subroutine name
<LI>+    logical  :: there                  ! checking file existence
<LI>+!!-----------------------------------------------------------------------
<LI>+
<LI>+    datfil(1)   = mksrf_fisop
<LI>+    datfil(2)   = mksrf_fmyrc
<LI>+    datfil(3)   = mksrf_fsabi
<LI>+    datfil(4)   = mksrf_flimo
<LI>+    datfil(5)   = mksrf_fco
<LI>+    datfil(6)   = mksrf_fmbo
<LI>+    datfil(7)   = mksrf_fapin
<LI>+    datfil(8)   = mksrf_fbpin
<LI>+    datfil(9)   = mksrf_focim
<LI>+    datfil(10)  = mksrf_facar
<LI>+    datfil(11)  = mksrf_fomtp
<LI>+    datfil(12)  = mksrf_ffarn
<LI>+    datfil(13)  = mksrf_fbcar
<LI>+    datfil(14)  = mksrf_fosqt
<LI>+    datfil(15)  = mksrf_fmeoh
<LI>+    datfil(16)  = mksrf_facto
<LI>+    datfil(17)  = mksrf_fmeth
<LI>+    datfil(18)  = mksrf_fno
<LI>+    datfil(19)  = mksrf_facta
<LI>+    datfil(20)  = mksrf_fform
<LI>+    ns = domain%ns
<LI>+    call get_proc_bounds(begg,endg)
<LI>+
<LI>+    allocate(ef_iso(begg:endg))
<LI>+    allocate(ef_mbo(begg:endg))
<LI>+    allocate(ef_bpin(begg:endg))
<LI>+    allocate(ef_apin(begg:endg))
<LI>+    allocate(ef_myrc(begg:endg))
<LI>+    allocate(ef_limo(begg:endg))
<LI>+    allocate(ef_sabi(begg:endg))
<LI>+    allocate(ef_acar(begg:endg))
<LI>+    allocate(ef_bcar(begg:endg))
<LI>+    allocate(ef_omtp(begg:endg))
<LI>+    allocate(ef_farn(begg:endg))
<LI>+    allocate(ef_osqt(begg:endg))
<LI>+    allocate(ef_meoh(begg:endg))
<LI>+    allocate(ef_meth(begg:endg))
<LI>+    allocate(ef_acto(begg:endg))
<LI>+    allocate(ef_no(begg:endg))
<LI>+    allocate(ef_ocim(begg:endg))
<LI>+    allocate(ef_co(begg:endg))
<LI>+    allocate(ef_form(begg:endg))
<LI>+    allocate(ef_acta(begg:endg))
<LI>+
<LI>+    r2cefmap(:) = 1
<LI>+
<LI>+    if (masterproc) then
<LI>+      write (6,*) 'Attempting to read Biogenic Emissions data .....'
<LI>+      do n = 1,nvoc
<LI>+         inquire(file=trim(datfil(n)),exist=there)
<LI>+         if (there) then
<LI>+           call getfil( datfil(n), locfn, 0 )
<LI>+           call check_ret( nf_open(locfn, 0, ncidv(n)), subname )
<LI>+           write(6,*)'emission file ',trim(datfil(n)),' being used '
<LI>+         else
<LI>+           write(6,*)'emission file',n,' not found, using pft for emission'; r2cefmap(n)=2
<LI>+         endif
<LI>+      enddo 
<LI>+    end if ! masterproc
<LI>+    call mpi_bcast (r2cefmap    , size(r2cefmap)    , MPI_INTEGER, 0, mpicom, ier)  
<LI>+    call mpi_bcast (ncidv       , size(ncidv)       , MPI_INTEGER, 0, mpicom, ier)  
<LI>+
<LI>+
<LI>+    ! Obtain non-grid emission factor maps
<LI>+
<LI>+    strt3(1)=1
<LI>+    strt3(2)=1
<LI>+    strt3(3)=1
<LI>+    cnt3(1)=domain%ni
<LI>+    cnt3(2)=domain%nj
<LI>+    cnt3(3)=1
<LI>+
<LI>+    if(r2cefmap(1) == 1) then
<LI>+      call ncd_iolocal(ncidv(1), 'ISOP' , 'read', ef_iso , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(6) == 1) then
<LI>+      call ncd_iolocal(ncidv(6), 'MBO'  , 'read', ef_mbo , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(8) == 1) then
<LI>+      call ncd_iolocal(ncidv(8),'BPINE', 'read', ef_bpin, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(7) == 1) then
<LI>+      call ncd_iolocal(ncidv(7),'APINE', 'read', ef_apin, begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(2) == 1) then
<LI>+      call ncd_iolocal(ncidv(2), 'MYRCENE'   , 'read', ef_myrc , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(4) == 1) then
<LI>+      call ncd_iolocal(ncidv(4), 'LIMONENE'  , 'read', ef_limo , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(3) == 1) then
<LI>+      call ncd_iolocal(ncidv(3),'SABINENE'  , 'read', ef_sabi , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(9) == 1) then
<LI>+      call ncd_iolocal(ncidv(9),'OCIMENE'   , 'read', ef_ocim , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(10) == 1) then
<LI>+      call ncd_iolocal(ncidv(10), 'A3CARENE'  , 'read', ef_acar , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(11) == 1) then
<LI>+      call ncd_iolocal(ncidv(11), 'O_MONO'    , 'read', ef_omtp , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(12) == 1) then
<LI>+      call ncd_iolocal(ncidv(12),'FARNI'     , 'read', ef_farn , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(13) == 1) then
<LI>+      call ncd_iolocal(ncidv(13),'B_CARY'    , 'read', ef_bcar , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(14) == 1) then
<LI>+      call ncd_iolocal(ncidv(14), 'O_SESQ'    , 'read', ef_osqt , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(15) == 1) then
<LI>+      call ncd_iolocal(ncidv(15), 'MEOH'      , 'read', ef_meoh , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(16) == 1) then
<LI>+      call ncd_iolocal(ncidv(16),'ACETONE'   , 'read', ef_acto , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(17) == 1) then
<LI>+      call ncd_iolocal(ncidv(17),'METHANE'   , 'read', ef_meth , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(18) == 1) then
<LI>+      call ncd_iolocal(ncidv(18), 'NO'        , 'read', ef_no   , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(19) == 1) then
<LI>+      call ncd_iolocal(ncidv(19), 'ACET_ETH'  , 'read', ef_acta , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(20) == 1) then
<LI>+      call ncd_iolocal(ncidv(20),'FORM'      , 'read', ef_form , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+    if(r2cefmap(5) == 1) then
<LI>+      call ncd_iolocal(ncidv(5),'CO'        , 'read', ef_co   , begg, endg, gsMap_lnd_gdc2glo, perm_lnd_gdc2glo, strt3, cnt3 )
<LI>+    endif
<LI>+
<LI>+    ! Initialize time accumulation variables
<LI>+    dtime = r2cdtime
<LI>+    n24   = 86400/dtime
<LI>+    n240  = 864000/dtime
<LI>+!    if(nsrest == 0) then
<LI>+      c24   = 0
<LI>+      c240  = 0
<LI>+!    endif
<LI> 
<LI>-   deallocate(pctgla,pctlak,pctwet,pcturb)
<LI>+    if (masterproc) then
<LI>+     do n = 1,nvoc
<LI>+       if(r2cefmap(n) == 1) call check_ret(nf_close(ncidv(n)), subname)
<LI>+     enddo
<LI>+       write (6,*) 'Successfully read biogenic emissions data'
<LI>+       write (6,*)  
<LI>+    end if
<LI> 
<LI>-  end subroutine surfrd_wtxy_special
<LI>+  end subroutine rcmsurfrd_bvocs
<LI> 
<LI> !-----------------------------------------------------------------------
<LI> !BOP
<LI>@@ -1082,14 +2656,13 @@
<LI>     use clm_varctl, only : create_crop_landunit
<LI>     use pftvarcon   , only : crop, noveg
<LI>     use domainMod   , only : domain_type
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI> !
<LI> ! !ARGUMENTS:
<LI>     implicit none
<LI>     include 'netcdf.inc'
<LI>     integer , intent(in)    :: ncid        ! netcdf file id 
<LI>-!    real(r8), intent(in)    :: pctspec(:)  ! percent wrt gcell of spec lunits
<LI>-!    integer , intent(inout) :: vegxy(:,:)    ! PFT
<LI>-!    real(r8), intent(inout) :: wtxy(:,:)   ! subgrid weights
<LI>     type(domain_type),intent(in) :: domain ! domain associated with wtxy
<LI> !
<LI> ! !CALLED FROM:
<LI>@@ -1104,7 +2677,7 @@
<LI>     integer  :: k,m,k1,k2,n,nl,ns               ! indices
<LI>     integer  :: begg,endg                       ! beg/end gcell index
<LI>     integer  :: dimid,varid                     ! netCDF id's
<LI>-    integer  :: start(3),count(3)               ! netCDF start/count arrays
<LI>+    integer  :: start(4),count(4)               ! netCDF start/count arrays
<LI>     integer  :: cropcount                       ! temporary counter
<LI>     real(r8),allocatable :: sumvec(:)           ! temporary vector sum
<LI>     logical  :: found                           ! temporary for error check
<LI>@@ -1120,6 +2693,12 @@
<LI>     integer ,allocatable :: cft(:,:)            ! CFT
<LI>     real(r8),allocatable :: pctcft_lunit(:,:)   ! % of crop lunit area for CFTs
<LI>     real(r8),allocatable :: pctpft_lunit(:,:)   ! % of vegetated lunit area PFTs
<LI>+!abt below
<LI>+    real(r8),allocatable :: adj_pctpft(:,:)     ! % of crop lunit area for CFTs
<LI>+    real(r8),allocatable :: adj_wst(:)          ! % of vegetated lunit area PFTs
<LI>+    real(r8) :: adj_wst_sum
<LI>+    integer  :: ipft
<LI>+!abt above
<LI>     integer  :: ier                             ! error status
<LI>     real(r8),allocatable :: pctpft(:,:)         ! percent of vegetated gridcell area for PFTs
<LI>     real(r8),pointer :: arrayl(:)               ! local array
<LI>@@ -1135,6 +2714,7 @@
<LI>     integer  :: closelatidx                     ! Single-column latitude index to retrieve
<LI>     integer  :: closelonidx                     ! Single-column longitude index to retrieve
<LI>     character(len=32) :: subname = 'surfrd_wtxy_veg_rank'  ! subroutine name
<LI>+
<LI> !-----------------------------------------------------------------------
<LI> 
<LI>     ns = domain%ns
<LI>@@ -1148,8 +2728,12 @@
<LI>     allocate(pctpft(begg:endg,0:numpft))
<LI>     allocate(wsti(maxpatch_pft))
<LI> 
<LI>+    if(.not.allocated(adj_wst)) allocate(adj_wst(0:numpft))               !abt
<LI>+    if(.not.allocated(adj_pctpft)) allocate(adj_pctpft(begg:endg,0:numpft))  !abt
<LI>+
<LI>     if (masterproc) then
<LI>-       call check_dim(ncid, 'lsmpft', numpft+1)
<LI>+!       call check_dim(ncid, 'lsmpft', numpft+1) abt
<LI>+       call check_dim(ncid, 'level', numpft+1)
<LI>     end if
<LI>     allocate(arrayl(begg:endg))
<LI>     do n = 0,numpft
<LI>@@ -1159,6 +2743,9 @@
<LI>        count(2) = domain%nj
<LI>        start(3) = n+1	 ! dataset is 1:numpft+1, not 0:numpft
<LI>        count(3) = 1
<LI>+       count(4) = 1
<LI>+       start(4) = 1   !abt added this to include time dimension
<LI>+
<LI>        if (single_column) then
<LI>           call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>           start(1)=closelonidx
<LI>@@ -1202,7 +2789,9 @@
<LI>              else
<LI>                 ! Separate crop landunit is not created
<LI> 
<LI>-                pctpft(nl,m) = pctpft(nl,m) * 100._r8/(100._r8-pctspec(nl))
<LI>+!abt                pctpft(nl,m) = pctpft(nl,m) * 100._r8/(100._r8-pctspec(nl))
<LI>+                pctpft(nl,m) = pctpft(nl,m)   !input file already is %pft of vegetation (sum of pfts = 100%)
<LI>+
<LI>              end if
<LI>           end do
<LI> 
<LI>@@ -1218,6 +2807,7 @@
<LI>           call endrun()
<LI> 
<LI>        end if
<LI>+
<LI>     end do
<LI> 
<LI>     ! Find pft and pct arrays 
<LI>@@ -1232,12 +2822,43 @@
<LI>           wst_sum = wst_sum + pctpft(nl,m)
<LI>        end do
<LI> 
<LI>+!!!abt below!! Correct for gridcells that do not have any percent of pft cover
<LI>+             ! Use BATS landuse types from DOMAIN.INFO and convert to the equivalent 
<LI>+             ! CLM landuse/pft type.  For example, BATS Evergreen Shrub type would be
<LI>+             ! Broadleaf Evergreen Shrub in CLM.
<LI>+
<LI>+       if(sum(wst(:))<95 .or. sum(wst(:))>105) then 
<LI>+         do m = 0,numpft
<LI>+           wst(m)       = 0._r8
<LI>+           pctpft(nl,m) = 0._r8
<LI>+           wst_sum      = 0._r8
<LI>+           adj_wst(m)   = 0._r8
<LI>+           adj_pctpft(nl,m) = 0._r8
<LI>+           wst_sum          = 0._r8
<LI>+         enddo
<LI>+
<LI>+         call pft_adjustment(begg,endg,ipft,nl,adj_wst,adj_wst_sum,adj_pctpft,domain)  !abt
<LI>+        
<LI>+         do m = 0,numpft
<LI>+           wst(m)       = adj_wst(m)
<LI>+           pctpft(nl,m) = adj_pctpft(nl,m) 
<LI>+         enddo
<LI>+           wst_sum      = adj_wst_sum
<LI>+       endif
<LI>+
<LI>+
<LI>+
<LI>+!!!abt rcm above
<LI>+
<LI>+
<LI>+
<LI>        if (domain%pftm(nl) >= 0) then
<LI> 
<LI>           ! Rank [wst] in ascendg order to obtain the top [maxpatch_pft] PFTs
<LI> 
<LI>           call surfrd_mkrank (numpft, wst, miss, wsti, maxpatch_pft)
<LI> 
<LI>+
<LI>           ! Fill in [pft] and [pctpft] with data for top [maxpatch_pft] PFTs.
<LI>           ! If land model grid cell is ocean, set to no PFTs.
<LI>           ! If land model grid cell is land then:
<LI>@@ -1361,6 +2982,7 @@
<LI> 
<LI>     end do   ! end of latitude loop
<LI> 
<LI>+
<LI>     ! Determine array [veg], which sets the PFT type for each of the [maxpatch]
<LI>     ! patches and array [wtxy], which sets the relative abundance of the PFT.
<LI>     ! Fill in PFTs for vegetated portion of grid cell. Fractional areas for
<LI>@@ -1400,11 +3022,10 @@
<LI>              end do
<LI>           end if
<LI> 
<LI>+
<LI>        end if
<LI>     end do
<LI> 
<LI>-    ! Error check
<LI>-
<LI>     found = .false.
<LI>     sumvec(:) = abs(sum(wtxy,dim=2)-1._r8)
<LI>     do nl = begg,endg
<LI>@@ -1415,12 +3036,17 @@
<LI>        endif
<LI>     end do
<LI>     if ( found ) then
<LI>-       write (6,*)'surfrd error: WTXY > 1 occurs at nl= ',nindx; call endrun()
<LI>+       write (6,*)'surfrd error: WTXY > 1 occurs at nl= ',nindx  !; call endrun()
<LI>+       call endrun()
<LI>     end if
<LI> 
<LI>     deallocate(sumvec,cft,pft)
<LI>     deallocate(pctcft_lunit,pctpft_lunit,pctpft)
<LI>     deallocate(wsti)
<LI>+!abt below
<LI>+    deallocate(adj_wst,adj_pctpft)
<LI>+!abt above
<LI>+
<LI> 
<LI>   end subroutine surfrd_wtxy_veg_rank
<LI> 
<LI>@@ -1460,7 +3086,7 @@
<LI>     integer  :: m,mp7,mp8,mp11,n,nl,ns         ! indices
<LI>     integer  :: begg,endg                      ! beg/end gcell index
<LI>     integer  :: dimid,varid                    ! netCDF id's
<LI>-    integer  :: start(3),count(3)              ! netcdf start/count arrays
<LI>+    integer  :: start(4),count(4)              ! netcdf start/count arrays
<LI>     integer  :: ier                            ! error status	
<LI>     real(r8) :: sumpct                         ! sum of %pft over maxpatch_pft
<LI>     real(r8),allocatable :: pctpft(:,:)        ! percent of vegetated gridcell area for PFTs
<LI>@@ -1481,7 +3107,8 @@
<LI>     allocate(pctpft(begg:endg,0:numpft))
<LI> 
<LI>     if (masterproc) then
<LI>-       call check_dim(ncid, 'lsmpft', numpft+1)
<LI>+!       call check_dim(ncid, 'lsmpft', numpft+1) abt
<LI>+       call check_dim(ncid, 'level', numpft+1)
<LI>     endif
<LI> 
<LI>     allocate(arrayl(begg:endg))
<LI>@@ -1492,6 +3119,10 @@
<LI>        count(2) = domain%nj
<LI>        start(3) = n+1         ! dataset is 1:numpft+1, not 0:numpft
<LI>        count(3) = 1
<LI>+
<LI>+       start(4) = 1
<LI>+       count(4) = 1     ! abt added to include time dimesion
<LI>+
<LI>        if (single_column) then
<LI>           call scam_setlatlonidx(ncid,scmlat,scmlon,closelat,closelon,closelatidx,closelonidx)
<LI>           start(1)=closelonidx
<LI>@@ -1718,4 +3349,716 @@
<LI> 
<LI>   end subroutine surfrd_mkrank
<LI> 
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: pft_adjustment
<LI>+!
<LI>+! !INTERFACE:
<LI>+!  subroutine pft_adjustment(begg,endg,numpft,pftpct,domain)
<LI>+  subroutine pft_adjustment(begg,endg,ipft,nns,pft_wst,pft_wst_sum,pft_pctpft,domain)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Checks to see if there are gridcells with positive pftmask but no
<LI>+! percent pft cover.  If there is no vegetation cover in a gridcell
<LI>+! with a pftmask = 1 then use the BATS landuse type and assign the
<LI>+! equivalent CLM pft type (using the technique in Bonan et al 2002)
<LI>+!
<LI>+! !USES:
<LI>+    use domainMod   , only : domain_type 
<LI>+    use decompMod   , only : adecomp
<LI>+    use clm_varsur  , only : wtxy,satbrt_clm
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI>+!
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    integer  , intent(in)     :: nns                   !
<LI>+    integer  , intent(in)     :: endg                  !
<LI>+    integer  , intent(in)     :: begg                  !
<LI>+    integer  , intent(out)    :: ipft                  !
<LI>+    real(r8) , intent(out)    :: pft_wst_sum           !
<LI>+    real(r8) , intent(out)    :: pft_wst(0:numpft)            ! total number of pfts 
<LI>+    real(r8) , intent(out)    :: pft_pctpft(begg:endg,0:numpft)       ! percent pft cover 
<LI>+    type(domain_type),intent(in) :: domain               ! domain type structure
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine surfrd_wtxy_veg_rank in this module
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Ahmed Tawfik
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer :: nni,ni,nj                       ! size of grid on file
<LI>+    integer :: ncid,dimid,varid                ! netCDF id's
<LI>+    integer :: nnj                             ! error status
<LI>+    integer :: n                               ! counters
<LI>+    real(r8) :: summ                           ! Number of points to read in
<LI>+    real(r8),allocatable :: pft2d(:,:)         ! temp array for pftmask calc
<LI>+    real(r8),allocatable :: sumpft(:)          ! landfraction read in from RCMnavy abt
<LI>+    real(r8) :: bats_lu                        ! temporary array from BATS landuse
<LI>+    character(len=32) :: subname = 'pft_adjustment'     ! subroutine name
<LI>+!-----------------------------------------------------------------------
<LI>+
<LI>+           pft_pctpft(nns,:) = 0._r8
<LI>+           pft_wst(:)        = 0._r8          
<LI>+           ipft = 0
<LI>+          
<LI>+           nni = adecomp%gdc2i(nns)
<LI>+           nnj = adecomp%gdc2j(nns)
<LI>+           if(satbrt_clm(nnj,nni).lt.0.9 .or. satbrt_clm(nnj,nni).gt.20.1) then
<LI>+              write(*,*)"BATS landuse correction is not set properly :::: at nl = ",nns
<LI>+              write(*,*)"SATBRT   = ",satbrt_clm(nnj,nni)
<LI>+              write(*,*)"lat/lat  = ",nnj,nni
<LI>+              call endrun()
<LI>+           else
<LI>+              bats_lu = satbrt_clm(nnj,nni)
<LI>+           endif
<LI>+              
<LI>+            ! Desert/Tundra/semidesert from BATS equals no veg for CLM
<LI>+              if(bats_lu.eq.8 .or. bats_lu.eq.9 .or. bats_lu.eq.11) then
<LI>+                 pft_pctpft(nns,0) = 100._r8
<LI>+                 pft_wst_sum      = 100._r8
<LI>+                 pft_wst(0)       = 100._r8
<LI>+              endif
<LI>+            
<LI>+            ! Short/Tall grass from BATS equals grass for CLM
<LI>+              if(bats_lu.eq.2 .or. bats_lu.eq.7) then
<LI>+                 pft_pctpft(nns,14) = 100._r8
<LI>+                 pft_wst_sum       = 100._r8
<LI>+                 pft_wst(14)       = 100._r8  
<LI>+              endif
<LI>+
<LI>+            ! Evergreen Needleleaf from BATS eq NeEvTemp and Boreal
<LI>+              if(bats_lu.eq.3) then
<LI>+                 if(domain%latc(nns).gt.47) then  !boreal
<LI>+                    pft_pctpft(nns,2)  = 100._r8
<LI>+                    pft_wst_sum       = 100._r8
<LI>+                    pft_wst(2)        = 100._r8
<LI>+                 else                             !temperate
<LI>+                    pft_pctpft(nns,1)  = 100._r8
<LI>+                    pft_wst_sum       = 100._r8
<LI>+                    pft_wst(1)        = 100._r8
<LI>+                 endif
<LI>+              endif
<LI>+           
<LI>+            ! Decidious Needleleaf from BATS eq NeDeBo
<LI>+              if(bats_lu.eq.4) then
<LI>+                pft_pctpft(nns,3)  = 100._r8
<LI>+                pft_wst_sum       = 100._r8
<LI>+                pft_wst(3)        = 100._r8
<LI>+              endif 
<LI>+
<LI>+            ! Deciduous Broadleaf from BATS eq Broadleaf Deciduous tropical/temperate/boreal
<LI>+              if(bats_lu.eq.5) then
<LI>+                 if(domain%latc(nns).gt.47) then  !boreal
<LI>+                    pft_pctpft(nns,8)  = 100._r8
<LI>+                    pft_wst_sum       = 100._r8
<LI>+                    pft_wst(8)        = 100._r8
<LI>+                 elseif(domain%latc(nns).lt.15 .and. domain%latc(nns).gt.-15) then     !tropical
<LI>+                    pft_pctpft(nns,6)  = 100._r8
<LI>+                    pft_wst_sum       = 100._r8
<LI>+                    pft_wst(6)        = 100._r8
<LI>+                 else                              !temperate
<LI>+                    pft_pctpft(nns,7)  = 100._r8
<LI>+                    pft_wst_sum        = 100._r8
<LI>+                    pft_wst(7)         = 100._r8
<LI>+                 endif
<LI>+              endif
<LI>+
<LI>+            ! Evergreen Broadleaf from BATS eq Broadleaf evergreen tropical/temperate
<LI>+              if(bats_lu.eq.6) then
<LI>+                 if(domain%latc(nns).lt.15 .and. domain%latc(nns).gt.-15) then     !tropical
<LI>+                    pft_pctpft(nns,4)  = 100._r8
<LI>+                    pft_wst_sum       = 100._r8
<LI>+                    pft_wst(4)        = 100._r8
<LI>+                 else                              !temperate
<LI>+                    pft_pctpft(nns,5)  = 100._r8
<LI>+                    pft_wst_sum        = 100._r8
<LI>+                    pft_wst(5)         = 100._r8
<LI>+                 endif
<LI>+              endif
<LI>+              
<LI>+            ! Evergreen Shrub from BATS eq Broadleaf Evergreen Shrub
<LI>+              if(bats_lu.eq.16) then
<LI>+                pft_pctpft(nns,9)  = 100._r8
<LI>+                pft_wst_sum       = 100._r8
<LI>+                pft_wst(9)        = 100._r8
<LI>+              endif
<LI>+
<LI>+            ! Deciduous Shrub from BATS eq Broadleaf Deciduous temperate/boreal shurbs
<LI>+              if(bats_lu.eq.17) then
<LI>+                 if(domain%latc(nns).gt.47) then  !boreal
<LI>+                    pft_pctpft(nns,11)  = 100._r8
<LI>+                    pft_wst_sum         = 100._r8
<LI>+                    pft_wst(11)         = 100._r8
<LI>+                 else                              !temperate
<LI>+                    pft_pctpft(nns,10)  = 100._r8
<LI>+                    pft_wst_sum         = 100._r8
<LI>+                    pft_wst(10)         = 100._r8
<LI>+                 endif
<LI>+              endif
<LI>+
<LI>+            ! Mixed forest from BATS eq some percent of needleleaf and broadleaf
<LI>+              if(bats_lu.eq.18) then
<LI>+                 if(domain%latc(nns).gt.47) then  !boreal
<LI>+                    pft_pctpft(nns,8)  = 50._r8
<LI>+                    pft_pctpft(nns,2)  = 25._r8
<LI>+                    pft_pctpft(nns,3)  = 25._r8
<LI>+                    pft_wst_sum        = 100._r8
<LI>+                    pft_wst(8)         = 50._r8
<LI>+                    pft_wst(2)         = 25._r8
<LI>+                    pft_wst(3)         = 25._r8
<LI>+                 elseif(domain%latc(nns).lt.15 .and. domain%latc(nns).gt.-15) then     !tropical
<LI>+                    pft_pctpft(nns,4)  = 50._r8
<LI>+                    pft_pctpft(nns,6)  = 50._r8
<LI>+                    pft_wst_sum        = 100._r8
<LI>+                    pft_wst(6)         = 50._r8
<LI>+                    pft_wst(4)         = 50._r8
<LI>+                 else                              !temperate
<LI>+                    pft_pctpft(nns,1)  = 33._r8
<LI>+                    pft_pctpft(nns,5)  = 33._r8
<LI>+                    pft_pctpft(nns,7)  = 34._r8
<LI>+                    pft_wst_sum        = 100._r8
<LI>+                    pft_wst(7)         = 34._r8
<LI>+                    pft_wst(5)         = 33._r8
<LI>+                    pft_wst(1)         = 33._r8
<LI>+                 endif
<LI>+              endif
<LI>+
<LI>+            ! Forest mosaic from BATS eq some forests and grass
<LI>+             if(bats_lu.eq.19) then
<LI>+                 if(domain%latc(nns).gt.47) then  !boreal
<LI>+                    pft_pctpft(nns,8)  = 18._r8
<LI>+                    pft_pctpft(nns,2)  = 16._r8
<LI>+                    pft_pctpft(nns,3)  = 16._r8
<LI>+                    pft_pctpft(nns,14) = 50._r8
<LI>+                    pft_wst_sum        = 100._r8
<LI>+                    pft_wst(8)         = 18._r8
<LI>+                    pft_wst(2)         = 16._r8
<LI>+                    pft_wst(3)         = 16._r8
<LI>+                    pft_wst(14)        = 50._r8
<LI>+                 elseif(domain%latc(nns).lt.15 .and. domain%latc(nns).gt.-15) then     !tropical
<LI>+                    pft_pctpft(nns,4)  = 25._r8
<LI>+                    pft_pctpft(nns,6)  = 25._r8
<LI>+                    pft_pctpft(nns,14) = 50._r8
<LI>+                    pft_wst_sum        = 100._r8
<LI>+                    pft_wst(6)         = 25._r8
<LI>+                    pft_wst(4)         = 25._r8
<LI>+                    pft_wst(14)        = 50._r8
<LI>+                 else                              !temperate
<LI>+                    pft_pctpft(nns,1)  = 16._r8
<LI>+                    pft_pctpft(nns,5)  = 16._r8
<LI>+                    pft_pctpft(nns,7)  = 18._r8
<LI>+                    pft_pctpft(nns,14) = 50._r8
<LI>+                    pft_wst_sum        = 100._r8
<LI>+                    pft_wst(7)         = 18._r8
<LI>+                    pft_wst(5)         = 16._r8
<LI>+                    pft_wst(1)         = 16._r8
<LI>+                    pft_wst(14)        = 50._r8
<LI>+                 endif
<LI>+              endif
<LI>+
<LI>+            ! Glacier from BATS equals glacier for CLM
<LI>+              if(bats_lu.eq.12) then
<LI>+                 pft_pctpft(nns,0)  = 100._r8
<LI>+                 pft_wst_sum        = 100._r8
<LI>+                 pft_wst(0)         = 100._r8
<LI>+                 pctspec(nns)   = 100._r8
<LI>+                 wtxy(nns,npatch_glacier) = 1._r8  
<LI>+              endif
<LI>+
<LI>+            ! Wetland from BATS equals wetland for CLM
<LI>+              if(bats_lu.eq.13) then
<LI>+                 pft_pctpft(nns,0)  = 100._r8
<LI>+                 pft_wst_sum        = 100._r8
<LI>+                 pft_wst(0)         = 100._r8
<LI>+                 pctspec(nns)   = 100._r8
<LI>+                 wtxy(nns,npatch_wet) = 1._r8  
<LI>+              endif
<LI>+
<LI>+            ! Bare ground for any other landtype 
<LI>+             if(bats_lu.eq.14 .or. bats_lu.eq.15 .or. bats_lu.eq.20) then
<LI>+                 pft_pctpft(nns,0)  = 100._r8
<LI>+                 pft_wst_sum        = 100._r8
<LI>+                 pft_wst(0)         = 100._r8
<LI>+              endif
<LI>+
<LI>+            ! Crop/irrigated from BATS eq half corn and wheat mix
<LI>+              if(bats_lu.eq.1 .or. bats_lu.eq.10) then
<LI>+                 pft_pctpft(nns,15)  = 50._r8
<LI>+                 pft_pctpft(nns,16)  = 50._r8
<LI>+                 pft_wst_sum         = 100._r8
<LI>+                 pft_wst(16)         = 50._r8
<LI>+                 pft_wst(15)         = 50._r8
<LI>+              endif           
<LI>+
<LI>+
<LI>+  end subroutine pft_adjustment
<LI>+
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: clm2bats_conversion
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine clm2bats_conversion(ncidpft,ncidlak,ncidglac,ncidurb)
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! 1) Uses the maximum land cover type in CLM to describe the land cover 
<LI>+! type in terms of BATS land use categories.  In some cases use some
<LI>+! percent threshold limits to make the conversion from CLM land use to
<LI>+! to BATS land use.  For example, BATS cropland land use type would be
<LI>+! equivalent to having the sum of wheat and corn being greater than
<LI>+! 50%.  
<LI>+!
<LI>+! Reference for vegetation cover conversion:
<LI>+! Bonan GB, Levis S,Kergoat L et al.(2002a) Landscapes as
<LI>+! patches of plant functional types: an integrating concept for 
<LI>+! climate and ecosystem models. Global Biogeochemical Cycles, 
<LI>+! 16, 1021
<LI>+!
<LI>+! !USES:
<LI>+    use clm_varsur  , only : clm2bats_veg,clm_fracveg,satbrt_clm
<LI>+    use clm_varsur  , only : landmask
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI>+!
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+    integer , intent(in)    :: ncidlak      ! netcdf file id for lake/wetland
<LI>+    integer , intent(in)    :: ncidglac     ! netcdf file id for glacier
<LI>+    integer , intent(in)    :: ncidurb      ! netcdf file id for urban
<LI>+    integer , intent(in)    :: ncidpft      ! netcdf file id for soil
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine rcmsurf in this module
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Ahmed Tawfik
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer  :: nni,ni                         ! longitude index
<LI>+    integer  :: nnj,nj                         ! latitude index
<LI>+    integer  :: n,nns,ier                      ! counters
<LI>+    integer  :: varid,ncid,strt3(4),cnt3(4)    !
<LI>+    real(r8) :: summ                           ! temporary
<LI>+    real(r8) :: sum2                           ! temporary 
<LI>+    real(r8) :: pctveg                         ! percent vegetation in gridcell
<LI>+    real(r8) :: purb                           ! percent urban in gridcell
<LI>+    real(r8) :: plake                          ! percent lake in gridcell
<LI>+    real(r8) :: pwet                           ! percent wetland in gridcell
<LI>+    real(r8) :: pgla                           ! percent glacier in gridcell
<LI>+    real(r8), allocatable :: perpft(:,:)
<LI>+    real(r8), allocatable :: pcturb(:)
<LI>+    real(r8), allocatable :: pctlak(:)
<LI>+    real(r8), allocatable :: pctwet(:)
<LI>+    real(r8), allocatable :: pctgla(:)
<LI>+    real(r8), allocatable :: pctpft(:)
<LI>+    real(r8), allocatable :: array1(:)
<LI>+    character(len=32) :: subname = 'clm2bats_conversion'     ! subroutine name
<LI>+!-----------------------------------------------------------------------
<LI>+
<LI>+    if(masterproc) then
<LI>+
<LI>+!******* read in landunit variables
<LI>+      allocate(pcturb(lsmlat*lsmlon),pctwet(lsmlat*lsmlon))  
<LI>+      allocate(pctgla(lsmlat*lsmlon),pctlak(lsmlat*lsmlon))  
<LI>+      allocate(perpft(lsmlat*lsmlon,0:numpft))
<LI>+      allocate(pctpft(0:numpft))
<LI>+
<LI>+      strt3(1) = 1
<LI>+      cnt3(1)  = lsmlon
<LI>+      strt3(2) = 1
<LI>+      cnt3(2)  = lsmlat
<LI>+      strt3(3) = 1
<LI>+      cnt3(3)  = 1
<LI>+      cnt3(4)  = 1
<LI>+      strt3(4) = 1   !abt added this to include time dimension
<LI>+
<LI>+      ncid = ncidurb
<LI>+      call check_ret(nf_inq_varid(ncid, 'PCT_URBAN', varid), subname)
<LI>+      call check_ret(nf_get_vara_double(ncid, varid, strt3(1:3), cnt3(1:3), pcturb), subname)
<LI>+
<LI>+      ncid = ncidlak
<LI>+      call check_ret(nf_inq_varid(ncid, 'PCT_WETLAND', varid), subname)
<LI>+      call check_ret(nf_get_vara_double(ncid, varid, strt3(1:3), cnt3(1:3), pctwet), subname)
<LI>+
<LI>+      call check_ret(nf_inq_varid(ncid, 'PCT_LAKE', varid), subname)
<LI>+      call check_ret(nf_get_vara_double(ncid, varid, strt3(1:3), cnt3(1:3), pctlak), subname)
<LI>+
<LI>+      ncid = ncidglac 
<LI>+      call check_ret(nf_inq_varid(ncid, 'PCT_GLACIER', varid), subname)
<LI>+      call check_ret(nf_get_vara_double(ncid, varid, strt3(1:3), cnt3(1:3), pctgla), subname)
<LI>+
<LI>+      ncid = ncidpft
<LI>+      allocate(array1(lsmlat*lsmlon))
<LI>+      do n = 0,numpft
<LI>+        strt3(3) = n+1 ! dataset is 1:numpft+1, not 0:numpft
<LI>+        cnt3(3)  = 1
<LI>+        cnt3(4)  = 1
<LI>+        strt3(4) = 1   !abt added this to include time dimension
<LI>+
<LI>+        call check_ret(nf_inq_varid(ncid, 'PCT_PFT', varid), subname)
<LI>+        call check_ret(nf_get_vara_double(ncid, varid, strt3, cnt3, array1), subname)
<LI>+
<LI>+        perpft(:,n) = array1(:)
<LI>+      enddo
<LI>+      deallocate(array1)
<LI>+
<LI>+
<LI>+!******* Figure out what land use type covers the most area per gridcell
<LI>+   
<LI>+      do nnj = 1,lsmlat
<LI>+      do nni = 1,lsmlon
<LI>+         nns = (nnj-1)*lsmlon + nni
<LI>+
<LI>+
<LI>+       ! Make sure only land points are counted
<LI>+        if(landmask(nni,nnj).lt.0.0001) then
<LI>+           clm2bats_veg(nni,nnj) = 0
<LI>+           clm_fracveg(nnj,nni)  = 0
<LI>+
<LI>+        else
<LI>+           purb  = pcturb(nns)
<LI>+           plake = pctlak(nns)
<LI>+           pgla  = pctgla(nns)
<LI>+           pwet  = pctwet(nns)
<LI>+
<LI>+           pctveg = 100._r8 - (purb + pwet + plake + pgla)
<LI>+           pctpft(:) = perpft(nns,:) 
<LI>+
<LI>+           clm_fracveg(nnj,nni) = (((100._r8 - pctpft(0))/100._r8)*pctveg)/100._r8
<LI>+           clm2bats_veg(nni,nnj) = satbrt_clm(nnj,nni)   
<LI>+
<LI>+ 
<LI>+         ! clm2bats_veg is initialized to all ocean and the respective 
<LI>+         ! land description is filled in below. clm2bats_veg is
<LI>+         ! initialized init_clm(ser/para).F
<LI>+
<LI>+         ! Urban land in CLM equates to nothing and is currently not
<LI>+         ! parameterized so set to BATS irrigated crop for now
<LI>+           if( purb.gt.pctveg .and. purb.gt.pwet .and. purb.gt.plake &
<LI>+               .and. purb.gt.pgla) then
<LI>+               
<LI>+               clm2bats_veg(nni,nnj) = 10
<LI>+           end if            
<LI>+
<LI>+
<LI>+
<LI>+         ! Wetland in CLM equates to BATS bogs/marsh type (number 13)
<LI>+           if( pwet.gt.pctveg .and. pwet.gt.purb .and. pwet.gt.plake &
<LI>+               .and. pwet.gt.pgla) then
<LI>+               
<LI>+               clm2bats_veg(nni,nnj) = 13
<LI>+           end if            
<LI>+
<LI>+
<LI>+
<LI>+         ! Glacier in CLM equates to BATS glacier/ice cap type (number 12)
<LI>+           if( pgla.gt.pctveg .and. pgla.gt.purb .and. pgla.gt.plake &
<LI>+               .and. pgla.gt.pwet) then
<LI>+               
<LI>+               clm2bats_veg(nni,nnj) = 12
<LI>+           end if            
<LI>+
<LI>+
<LI>+
<LI>+         ! Lake in CLM equates to BATS inland water type (number 14)
<LI>+           if( plake.gt.pctveg .and. plake.gt.purb .and. plake.gt.pwet &
<LI>+               .and. plake.gt.pgla) then
<LI>+               
<LI>+               clm2bats_veg(nni,nnj) = 14
<LI>+           end if            
<LI>+
<LI>+
<LI>+         ! Vegetation is the dominant land cover type
<LI>+         ! If it is the most dominant then we must discriminate
<LI>+         ! to only use the correct BATS type
<LI>+
<LI>+           if( pctveg.gt.pwet .and. pctveg.gt.purb .and. pctveg.gt.plake &
<LI>+               .and. pctveg.gt.pgla) then
<LI>+
<LI>+              ! Sum of wheat and corn from CLM equates to BATS cropland  
<LI>+               summ = pctpft(15) + pctpft(16)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 1
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Non-artic grass from CLM equates to BATS short grass  
<LI>+               summ = pctpft(13)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 2
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Sum of all needleleaf evergreens from CLM equates to
<LI>+              ! same in BATS   
<LI>+               summ = pctpft(1) + pctpft(2)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 3
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Deciduous needleleaf from CLM equates to BATS
<LI>+              ! deciduous needleleaf  
<LI>+               summ = pctpft(3)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 4
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Deciduous broadleaf from CLM equates to BATS
<LI>+              ! deciduous broadleaf  
<LI>+               summ = pctpft(6) + pctpft(7) + pctpft(8)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 5
<LI>+               end if
<LI>+
<LI>+              ! Evergreen Broadleaf from CLM equates to BATS
<LI>+              ! evergreen broadleaf  
<LI>+               summ = pctpft(4) + pctpft(5)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 6
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! C4 grasses from CLM equates to BATS
<LI>+              ! Tall grass  
<LI>+               summ = pctpft(15)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 7
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Bare Ground from CLM equates to BATS
<LI>+              ! Desert  
<LI>+               summ = pctpft(0)
<LI>+               sum2 = pgla + plake + pwet + purb
<LI>+               if(summ.ge.98 .and. sum2.lt.95) then
<LI>+                 clm2bats_veg(nni,nnj)  = 8
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Artic Grass from CLM equates to BATS
<LI>+              ! Tundra  
<LI>+               summ = pctpft(12)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 9
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Bare ground percent from CLM equates to BATS
<LI>+              ! semi-desert  
<LI>+               summ = pctpft(0)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ.gt.90 .and. summ.lt.98 ) then
<LI>+                 clm2bats_veg(nni,nnj)  = 11
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Broadleaf Evergreen Shrub from CLM equates to BATS
<LI>+              ! Evergreen Shrub  
<LI>+               summ = pctpft(9)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 16
<LI>+               end if
<LI>+
<LI>+
<LI>+              ! Sum of Deciduous Shrub from CLM equates to BATS
<LI>+              ! Deciduous Shrub  
<LI>+               summ = pctpft(10) + pctpft(11)
<LI>+               sum2 = sum(pctpft(:)) - summ
<LI>+               if(summ .gt. sum2) then
<LI>+                 clm2bats_veg(nni,nnj)  = 17
<LI>+               end if
<LI>+               
<LI>+           end if      ! vegetation dominant gridcell if statement
<LI>+
<LI>+        end if  ! landmask if statement
<LI>+      
<LI>+      end do
<LI>+      end do
<LI>+
<LI>+      deallocate(pcturb,pctlak,pctgla,pctwet)
<LI>+      deallocate(perpft)
<LI>+
<LI>+    end if !masterproc
<LI>+
<LI>+    call mpi_bcast (clm2bats_veg, size(clm2bats_veg), MPI_REAL8, 0, mpicom, ier)
<LI>+    call mpi_bcast (clm_fracveg, size(clm_fracveg), MPI_REAL8, 0, mpicom, ier)
<LI>+
<LI>+
<LI>+
<LI>+  end subroutine clm2bats_conversion
<LI>+
<LI>+
<LI>+
<LI>+!-----------------------------------------------------------------------
<LI>+!BOP
<LI>+!
<LI>+! !IROUTINE: clm_getsoitex
<LI>+!
<LI>+! !INTERFACE:
<LI>+  subroutine clm_getsoitex()
<LI>+!
<LI>+! !DESCRIPTION:
<LI>+! Subrountine only called when RegCM Aerosol/Dust module is on
<LI>+! Used only for the RegCM Dust scheme (Zakey Dust Scheme)
<LI>+! Divide the soil texture fractions into soil texture classes
<LI>+! defined in inidust.F.  
<LI>+!
<LI>+! !USES:
<LI>+    use domainMod   , only : domain_type 
<LI>+    use clm_varsur  , only : clm_soitex
<LI>+    use clm_varctl  , only : mksrf_fsoitex
<LI>+    use fileutils   , only : getfil
<LI>+    use mod_clm
<LI>+    use mod_dynparam
<LI>+!
<LI>+    implicit none
<LI>+    include 'netcdf.inc'
<LI>+!
<LI>+! !ARGUMENTS:
<LI>+!
<LI>+! !CALLED FROM:
<LI>+! subroutine rcmsurf in this module
<LI>+!
<LI>+! !REVISION HISTORY:
<LI>+! Created by Ahmed Tawfik
<LI>+!
<LI>+!EOP
<LI>+!
<LI>+! !LOCAL VARIABLES:
<LI>+    integer  :: nnj,nni,ns,n,ni,nj
<LI>+    integer  :: nlat,nlon
<LI>+    integer  :: varid,ncid
<LI>+    integer  :: start(4),count(4)
<LI>+    real(r8) :: slt                                    ! temporary variable for Silt
<LI>+    logical  :: vpresent
<LI>+    real(r8), allocatable :: sand1d(:)                 ! used for percent sand
<LI>+    real(r8), allocatable :: clay1d(:)                 ! used for percent clay
<LI>+    character(len=256) :: locfn                        ! local filename
<LI>+    character(len=32) :: subname = 'clm_getsoitex'     ! subroutine name
<LI>+!-----------------------------------------------------------------------
<LI>+
<LI>+            nlat = iy
<LI>+            nlon = jx
<LI>+
<LI>+            start(1) = 1
<LI>+            start(2) = 1
<LI>+            start(3) = 1
<LI>+            start(4) = 1
<LI>+            count(1) = nlon
<LI>+            count(2) = nlat
<LI>+            count(3) = 1
<LI>+            count(4) = 1
<LI>+            
<LI>+            call getfil ("../Input/RCMsoitex.10level.nc", locfn, 0)
<LI>+            call check_ret(nf_open(locfn, 0, ncid), subname)
<LI>+
<LI>+            if(.not.allocated(clm_soitex)) allocate(clm_soitex(nlat,nlon))
<LI>+            if(.not.allocated(sand1d)) allocate(sand1d(nlat*nlon))
<LI>+            if(.not.allocated(clay1d)) allocate(clay1d(nlat*nlon))
<LI>+
<LI>+            do n = 1,1
<LI>+              start(3) = n
<LI>+              call check_ret(nf_inq_varid(ncid, 'PCT_SAND', varid), subname)
<LI>+              call check_ret(nf_get_vara_double(ncid,varid, &
<LI>+              start,count,sand1d), subname)
<LI>+
<LI>+              call check_ret(nf_inq_varid(ncid, 'PCT_CLAY', varid), subname)
<LI>+              call check_ret(nf_get_vara_double(ncid,varid, &
<LI>+              start,count,clay1d), subname)
<LI>+            enddo
<LI>+
<LI>+            do nj = 1,nlat
<LI>+            do ni = 1,nlon
<LI>+               ns = (nj-1)*nlon + ni
<LI>+
<LI>+              slt = 100._r8 - (sand1d(ns) + clay1d(ns)) 
<LI>+
<LI>+             ! Class 1
<LI>+              if(sand1d(ns).ge.90) then
<LI>+                 clm_soitex(nj,ni) = 1                  
<LI>+
<LI>+ 
<LI>+             ! Classes 2 3 11 or 10
<LI>+              elseif(sand1d(ns).ge.60 .and. sand1d(ns).lt.89) then
<LI>+                 if(slt.lt.2) then
<LI>+                   if(clay1d(ns).lt.35) clm_soitex(nj,ni) = 10 
<LI>+                   if(clay1d(ns).ge.35) clm_soitex(nj,ni) = 11  
<LI>+                 else
<LI>+                   if(clay1d(ns).lt.5)  clm_soitex(nj,ni) = 2 
<LI>+                   if(clay1d(ns).ge.5 .and. clay1d(ns).le.10) clm_soitex(nj,ni) = 3 
<LI>+                 end if
<LI>+
<LI>+
<LI>+             ! Classes 4 and 12
<LI>+              elseif(sand1d(ns).ge.50 .and. sand1d(ns).lt.60) then
<LI>+                 if(slt.lt.2) then
<LI>+                   clm_soitex(nj,ni) = 12
<LI>+                 else
<LI>+                   clm_soitex(nj,ni) = 4  
<LI>+                 end if
<LI>+
<LI>+
<LI>+             ! Classes 5
<LI>+              elseif(sand1d(ns).ge.45 .and. sand1d(ns).lt.50) then
<LI>+                clm_soitex(nj,ni) = 5    
<LI>+
<LI>+
<LI>+             ! Classes 6
<LI>+              elseif(sand1d(ns).ge.35 .and. sand1d(ns).lt.45) then
<LI>+                clm_soitex(nj,ni) = 6    
<LI>+
<LI>+
<LI>+             ! Classes 7 and 8
<LI>+              elseif(sand1d(ns).ge.30 .and. sand1d(ns).lt.35) then
<LI>+                 if(clay1d(ns).gt.15 .and. clay1d(ns).lt.23) then
<LI>+                   clm_soitex(nj,ni) = 7   
<LI>+                 elseif(clay1d(ns).ge.23 .and. clay1d(ns).lt.30) then
<LI>+                   clm_soitex(nj,ni) = 8 
<LI>+                 end if
<LI>+
<LI>+
<LI>+             ! Classes 6
<LI>+              elseif(sand1d(ns).ge.0.0000000000005 .and. sand1d(ns).lt.30) then
<LI>+                clm_soitex(nj,ni) = 9    
<LI>+
<LI>+
<LI>+              end if
<LI>+              
<LI>+
<LI>+            end do ! end of gridcell loop 
<LI>+            end do ! end of gridcell loop 
<LI>+
<LI>+            if(allocated(sand1d)) deallocate(sand1d)
<LI>+            if(allocated(clay1d)) deallocate(clay1d)
<LI>+            call check_ret(nf_close(ncid), subname)
<LI>+
<LI>+
<LI>+     end subroutine clm_getsoitex
<LI>+
<LI>+
<LI> end module surfrdMod
</OL>
</PRE>

<HR>

</BODY>
</HTML>
