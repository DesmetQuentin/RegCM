<HTML>

<HEAD>
<TITLE>radclw.f90</TITLE>
</HEAD>

<BODY background="back_granite.gif">
<FONT COLOR="#000000" FACE="Times">
<H1 ALIGN=CENTER>radclw.f90</H1>
<HR>
<H2 ALIGN=CENTER>radclw.f90</H2>
<HR>
</FONT>

<HR>

<PRE>
1: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
2: !
3: !    This file is part of ICTP RegCM.
4: !
5: !    ICTP RegCM is free software: you can redistribute it and/or modify
6: !    it under the terms of the GNU General Public License as published by
7: !    the Free Software Foundation, either version 3 of the License, or
8: !    (at your option) any later version.
9: !
10: !    ICTP RegCM is distributed in the hope that it will be useful,
11: !    but WITHOUT ANY WARRANTY; without even the implied warranty of
12: !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13: !    GNU General Public License for more details.
14: !
15: !    You should have received a copy of the GNU General Public License
16: !    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
17: !
18: !::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
19:  
<p><a name=radclw><H3>radclw</H3></a></p> Click <a href="./callingtree/radclw_rite.html" TARGET=RITE_PANEL>HERE</a> to see the where radclw is used.
<hr>
20:       subroutine radclw(jslc,ts,tnm,qnm,o3vmr,pmid,pint,pmln,piln,plco2,&
21:                       & plh2o,n2o,ch4,cfc11,cfc12,cld,tclrsf,qrl,flns,  &
22:                       & flnt,flnsc,flntc,flwds,emiss1d,aerlwfo,aerlwfos)
23: 
24: !-----------------------------------------------------------------------
25: !
26: ! Compute longwave radiation heating rates and boundary fluxes
27: !
28: ! Uses broad band absorptivity/emissivity method to compute clear sky;
29: ! assumes randomly overlapped clouds with variable cloud emissivity to
30: ! include effects of clouds.
31: !
32: ! Computes clear sky absorptivity/emissivity at lower frequency (in
33: ! general) than the model radiation frequency; uses previously computed
34: ! and stored values for efficiency
35: !
36: ! Note: This subroutine contains vertical indexing which proceeds
37: !       from bottom to top rather than the top to bottom indexing
38: !       used in the rest of the model.
39: !
40: !---------------------------Code history--------------------------------
41: !
42: ! Original version:  CCM1
43: ! Standardized:      J. Rosinski, June 1992
44: ! Reviewed:          J. Kiehl, B. Briegleb, August 1992
45: !
46: !-----------------------------------------------------------------------
47: !
48:       use <a href="./mod_dynparam.F90.html#mod_dynparam" TARGET=CENT_PANEL>mod_dynparam</a>
49:       use <a href="./mod_param1.f90.html#mod_param1" TARGET=CENT_PANEL>mod_param1</a> , only : ifrabe
50:       use <a href="./mod_param2.F90.html#mod_param2" TARGET=CENT_PANEL>mod_param2</a> , only : iemiss , idirect
51:       use <a href="./mod_radbuf.F90.html#mod_radbuf" TARGET=CENT_PANEL>mod_radbuf</a>
52:       use <a href="./mod_aerosol.F90.html#mod_aerosol" TARGET=CENT_PANEL>mod_aerosol</a>, only : aerlwtr
53:       use <a href="./mod_date.F90.html#mod_date" TARGET=CENT_PANEL>mod_date</a> , only : jyear , jyear0 , ktau
54:       use <a href="./mod_constants.F90.html#mod_constants" TARGET=CENT_PANEL>mod_constants</a> , only : gocp , stebol
55:       use <a href="./mod_when.f90.html#mod_when" TARGET=CENT_PANEL>mod_when</a> , only : whenne , whenflt
56:       implicit none
57: !
58: !     Input arguments
59: !
60: ! ts      - Ground (skin) temperature
61: ! emiss1d - Emissivity of surface
62: !
63: !     Input arguments which are only passed to other routines
64: !
65: ! tnm     - Level temperature
66: ! qnm     - Level moisture field
67: ! o3vmr   - ozone volume mixing ratio
68: ! pmid    - Level pressure
69: ! pint    - Model interface pressure
70: ! pmln    - Ln(pmid)
71: ! piln    - Ln(pint)
72: ! plco2   - Path length co2
73: ! plh2o   - Path length h2o
74: ! n2o     - nitrous oxide mass mixing ratio
75: ! ch4     - methane mass mixing ratio
76: ! cfc11   - cfc11 mass mixing ratio
77: ! cfc12   - cfc12 mass mixing ratio
78: !
79: !     Input/Output arguments
80: !
81: ! cld     - Cloud cover
82: ! tclrsf  - Clear sky fraction
83: !
84: !     Output arguments
85: !
86: ! qrl     - Longwave heating rate
87: ! flns    - Surface cooling flux
88: ! flnt    - Net outgoing flux
89: ! flnsc   - Clear sky surface cooing
90: ! flntc   - Net clear sky outgoing flux
91: ! flwds   - Down longwave flux at surface
92: !
93: ! Dummy arguments
94: !
95:       integer :: jslc
96:       real(8) , dimension(iym1,kz) :: cfc11 , cfc12 , ch4 , n2o ,    &
97:            & o3vmr , pmid , pmln , qnm , qrl , tnm
98:       real(8) , dimension(iym1,kzp1) :: cld , piln , pint , plco2 ,   &
99:            & plh2o , tclrsf
100:       real(8) , dimension(iym1) :: emiss1d , flns , flnsc , flnt ,     &
101:                                   & flntc , flwds , ts
102:       real(8), dimension(iym1) :: aerlwfo , aerlwfos
103: 
104: 
105:       intent (in) cld , emiss1d
106:       intent (out) flns , flnsc , flnt , flntc , flwds , qrl , aerlwfo, &
107:                  & aerlwfos
108: 
109:       intent (inout) tclrsf
110: !
111: !---------------------------Local variables-----------------------------
112: !
113: ! i       - Longitude index
114: ! k       - Level index
115: ! k1      - Level index
116: ! k2      - Level index
117: ! k3      - Level index
118: ! km      - Level index
119: ! km1     - Level index
120: ! km2     - Level index
121: ! km3     - Level index
122: ! km4     - Level index
123: ! tmp     - Temporary
124: ! tmp1    - Temporary 1
125: ! absbt   - Downward emission at model top
126: ! plol    - O3 pressure wghted path length
127: ! plos    - O3 path length
128: ! co2em   - Layer co2 normalized planck funct. derivative
129: ! co2eml  - Interface co2 normalized planck funct. deriv.
130: ! delt    - Diff t**4 mid layer to top interface
131: ! delt1   - Diff t**4 lower intrfc to mid layer
132: ! bk1     - Absrptvty for vertical quadrature
133: ! bk2     - Absrptvty for vertical quadrature
134: ! ful     - Total upwards longwave flux
135: ! fsul    - Clear sky upwards longwave flux
136: ! fdl     - Total downwards longwave flux
137: ! fsdl    - Clear sky downwards longwv flux
138: ! fclb4   - Sig t**4 for cld bottom interfc
139: ! fclt4   - Sig t**4 for cloud top interfc
140: ! s       - Flx integral sum
141: ! tplnka  - Planck fnctn temperature
142: ! s2c     - H2o cont amount
143: ! s2t     - H2o cont temperature
144: ! w       - H2o path
145: ! tplnke  - Planck fnctn temperature
146: ! h2otr   - H2o trnmsn for o3 overlap
147: ! co2t    - Prs wghted temperature path
148: ! tint    - Interface temperature
149: ! tint4   - Interface temperature**4
150: ! tlayr   - Level temperature
151: ! tlayr4  - Level temperature**4
152: ! rtclrsf - 1./tclrsf(i,k)
153: ! klov    - Cloud lowest level index
154: ! khiv    - Cloud highest level index
155: ! khivm   - khiv(i) - 1
156: !
157: !     Trace gas variables
158: !
159: ! ucfc11  - CFC11 path length
160: ! ucfc12  - CFC12 path length
161: ! un2o0   - N2O path length
162: ! un2o1   - N2O path length (hot band)
163: ! uch4    - CH4 path length
164: ! uco211  - CO2 9.4 micron band path length
165: ! uco212  - CO2 9.4 micron band path length
166: ! uco213  - CO2 9.4 micron band path length
167: ! uco221  - CO2 10.4 micron band path length
168: ! uco222  - CO2 10.4 micron band path length
169: ! uco223  - CO2 10.4 micron band path length
170: ! bn2o0   - pressure factor for n2o
171: ! bn2o1   - pressure factor for n2o
172: ! bch4    - pressure factor for ch4
173: ! uptype  - p-type continuum path length
174: ! abplnk1 - non-nearest layer Plack factor
175: ! abplnk2 - nearest layer factor
176: !
177: ! Local variables
178: !
179:       real(8) , dimension(14,iym1,kzp1) :: abplnk1 , abplnk2
180:       real(8) , dimension(iym1) :: absbt , bk1 , bk2 , delt , delt1 ,  &
181:                                   & tmp , tplnke
182:       real(8) , dimension(iym1,kzp1) :: bch4 , bn2o0 , bn2o1 , co2em ,&
183:            & co2t , fdl , fsdl , fsul , ful , h2otr , plol , plos ,     &
184:            & rtclrsf , s2c , s2t , tint , tint4 , tlayr , tlayr4 ,      &
185:            & tplnka , ucfc11 , ucfc12 , uch4 , uco211 , uco212 ,        &
186:            & uco213 , uco221 , uco222 , uco223 , un2o0 , un2o1 ,        &
187:            & uptype , w , fsul0 , fsdl0
188:       real(8) , dimension(iym1,kz) :: co2eml , fclb4 , fclt4
189:       logical , dimension(iym1) :: done , start
190:       real(8) :: tmp1
191:       integer :: i , ii , k , k1 , k2 , k3 , khighest , km , km1 , km2 ,&
192:                & km3 , km4 , iym1c , rad , n
193:       integer , dimension(iym1) :: indx , khiv , khivm , klov
194:       real(8) , dimension(iym1,kzp1,kzp1) :: s
195:       real(8) , dimension(iym1,kzp1,kzp1) :: tone
196: !
197:       integer , external :: <a href="./intmax.f90.html#intmax" TARGET=CENT_PANEL>intmax</a>
198: 
199:       tone(:,:,:)=1. 
200: !
201:       do i = 1 , iym1
202:         rtclrsf(i,1) = 1.0/tclrsf(i,1)
203:       end do
204: !
205:       do k = 1 , kz
206:         do i = 1 , iym1
207:           fclb4(i,k) = 0.
208:           fclt4(i,k) = 0.
209:           tclrsf(i,k+1) = tclrsf(i,k)*(1.-cld(i,k+1))
210:           rtclrsf(i,k+1) = 1./tclrsf(i,k+1)
211:         end do
212:       end do
213: !
214: !     Calculate some temperatures needed to derive absorptivity and
215: !     emissivity, as well as some h2o path lengths
216: !
217:       call <a href="./radtpl.f90.html#radtpl" TARGET=CENT_PANEL>radtpl</a>(tnm,ts,qnm,pint,plh2o,tplnka,s2c,s2t,w,tplnke,tint,   &
218:                 & tint4,tlayr,tlayr4,pmln,piln)
219:  
220: !     do emissivity and absorptivity calculations
221: !     only if abs/ems computation
222: !
223:       if ( (jyear.eq.jyear0 .and. ktau.eq.0) .or.                       &
224:          & (mod(ktau+1,ifrabe).eq.0) ) then
225:  
226: !
227: !       Compute ozone path lengths at frequency of a/e calculation.
228: !
229:         call <a href="./radoz2.f90.html#radoz2" TARGET=CENT_PANEL>radoz2</a>(o3vmr,pint,plol,plos)
230: !
231: !       Compute trace gas path lengths
232: !
233:         call <a href="./trcpth.f90.html#trcpth" TARGET=CENT_PANEL>trcpth</a>(tnm,pint,cfc11,cfc12,n2o,ch4,qnm,ucfc11,ucfc12,     &
234:                   & un2o0,un2o1,uch4,uco211,uco212,uco213,uco221,uco222,&
235:                   & uco223,bn2o0,bn2o1,bch4,uptype)
236: !
237: !
238: !       Compute total emissivity:
239: !
240:         call <a href="./radems.f90.html#radems" TARGET=CENT_PANEL>radems</a>(s2c,s2t,w,tplnke,plh2o,pint,plco2,tint,tint4,tlayr, &
241:                   & tlayr4,plol,plos,ucfc11,ucfc12,un2o0,un2o1,uch4,    &
242:                   & uco211,uco212,uco213,uco221,uco222,uco223,uptype,   &
243:                   & bn2o0,bn2o1,bch4,co2em,co2eml,co2t,h2otr,abplnk1,   &
244:                   & abplnk2,jslc)
245: !
246: !       Compute total absorptivity:
247: !
248:         call <a href="./radabs.f90.html#radabs" TARGET=CENT_PANEL>radabs</a>(pmid,pint,co2em,co2eml,tplnka,s2c,s2t,w,h2otr,plco2,&
249:                   & plh2o,co2t,tint,tlayr,plol,plos,pmln,piln,ucfc11,   &
250:                   & ucfc12,un2o0,un2o1,uch4,uco211,uco212,uco213,uco221,&
251:                   & uco222,uco223,uptype,bn2o0,bn2o1,bch4,abplnk1,      &
252:                   & abplnk2,jslc)
253: 
254:          abstot0(:,:,:,jslc) = abstot(:,:,:,jslc)
255:          emstot0(:,:,jslc) = emstot(:,:,jslc)
256:          absnxt0(:,:,:,jslc) = absnxt(:,:,:,jslc)   
257:  
258:       end if
259: !
260: !     Find the lowest and highest level cloud for each grid point
261: !     Note: Vertical indexing here proceeds from bottom to top
262: !
263:       do i = 1 , iym1
264:         klov(i) = 0
265:         done(i) = .false.
266:       end do
267:       do k = 1 , kz
268:         do i = 1 , iym1
269:           if ( .not.done(i) .and. cld(i,kzp2-k).gt.0.0 ) then
270:             done(i) = .true.
271:             klov(i) = k
272:           end if
273:         end do
274:       end do
275:       call <a href="./mod_when.f90.html#whenne" TARGET=CENT_PANEL>whenne</a>(iym1,klov,1,0,indx,iym1c)
276:       do i = 1 , iym1
277:         khiv(i) = klov(i)
278:         done(i) = .false.
279:       end do
280:       do k = kz , 1 , -1
281:         do ii = 1 , iym1c
282:           i = indx(ii)
283:           if ( .not.done(i) .and. cld(i,kzp2-k).gt.0.0 ) then
284:             done(i) = .true.
285:             khiv(i) = k
286:           end if
287:         end do
288:       end do
289:       do i = 1 , iym1
290:         khivm(i) = khiv(i) - 1
291:       end do
292: !
293: !     Note: Vertical indexing here proceeds from bottom to top
294: !
295:       do ii = 1 , iym1c
296:         i = indx(ii)
297:         do k = klov(i) , khiv(i)
298:           fclt4(i,kzp1-k) = stebol*tint4(i,kzp2-k)
299:           fclb4(i,kzp1-k) = stebol*tint4(i,kzp3-k)
300:         end do
301:       end do
302: 
303: !
304: ! option to calculate LW aerosol radiative forcing
305: 
306: !     CCFAB LW radiative forcing ( rad=1 : avec dust)
307:       fsul0(:,:) = 0.
308:       fsdl0(:,:) = 0.
309:       abstot(:,:,:,jslc) = abstot0(:,:,:,jslc)
310:       emstot(:,:,jslc) = emstot0(:,:,jslc)
311:       absnxt(:,:,:,jslc) = absnxt0(:,:,:,jslc)
312: 
313:       do rad = 1 , 2
314:         if ( rad==2 ) then
315: 
316:           abstot(:,:,:,jslc) = 1-(1-abstot0(:,:,:,jslc))*aerlwtr(:,:,:)
317: 
318:           emstot(:,:,jslc) = 1-(1-emstot0(:,:,jslc))*aerlwtr(:,:,1)
319:        
320:           do k = 1 , kz  ! aerlwtr defined on plev levels
321:             do n = 1 , 4
322:               absnxt(:,k,n,jslc) = 1-(1-absnxt0(:,k,n,jslc))*           &
323:                                 & (aerlwtr(:,k,k+1)**xuinpl(:,k,n,jslc))
324: !             print* , 'z' , jslc , xuinpl(:,k,n,jslc)
325:             end do
326:           end do
327:       
328: !         print * , jslc, minval(absnxt(:,:,:,jslc)),                   &
329: !        &   maxval(absnxt(:,:,:,jslc)), minval(absnxt0(:,:,:,jslc)),   &
330: !        &   maxval(absnxt0(:,:,:,jslc))
331: 
332:         end if
333: !
334: !     Compute sums used in integrals (all longitude points)
335: !
336: !     Definition of bk1 & bk2 depends on finite differencing.  for
337: !     trapezoidal rule bk1=bk2. trapezoidal rule applied for nonadjacent
338: !     layers only.
339: !
340: !     delt=t**4 in layer above current sigma level km.
341: !     delt1=t**4 in layer below current sigma level km.
342: !
343:         do i = 1 , iym1
344:           delt(i) = tint4(i,kz) - tlayr4(i,kzp1)
345:           delt1(i) = tlayr4(i,kzp1) - tint4(i,kzp1)
346:           s(i,kzp1,kzp1) = stebol*(delt1(i)*absnxt(i,kz,1,jslc)         &
347:                          & +delt(i)*absnxt(i,kz,4,jslc))
348:           s(i,kz,kzp1) = stebol*(delt(i)*absnxt(i,kz,2,jslc)+delt1(i)   &
349:                         & *absnxt(i,kz,3,jslc))
350:         end do
351:         do k = 1 , kz - 1
352:           do i = 1 , iym1
353:             bk2(i) = (abstot(i,k,kz,jslc)+abstot(i,k,kzp1,jslc))*0.5
354:             bk1(i) = bk2(i)
355:             s(i,k,kzp1) = stebol*(bk2(i)*delt(i)+bk1(i)*delt1(i))
356:           end do
357:         end do
358: !
359: !       All k, km>1
360: !
361:         do km = kz , 2 , -1
362:           do i = 1 , iym1
363:             delt(i) = tint4(i,km-1) - tlayr4(i,km)
364:             delt1(i) = tlayr4(i,km) - tint4(i,km)
365:           end do
366:           do k = kzp1 , 1 , -1
367:             if ( k.eq.km ) then
368:               do i = 1 , iym1
369:                 bk2(i) = absnxt(i,km-1,4,jslc)
370:                 bk1(i) = absnxt(i,km-1,1,jslc)
371:               end do
372:             else if ( k.eq.km-1 ) then
373:               do i = 1 , iym1
374:                 bk2(i) = absnxt(i,km-1,2,jslc)
375:                 bk1(i) = absnxt(i,km-1,3,jslc)
376:               end do
377:             else
378:               do i = 1 , iym1
379:                 bk2(i) = (abstot(i,k,km-1,jslc)+abstot(i,k,km,jslc))*0.5
380:                 bk1(i) = bk2(i)
381:               end do
382:             end if
383:             do i = 1 , iym1
384:               s(i,k,km) = s(i,k,km+1)                                   &
385:                       & + stebol*(bk2(i)*delt(i)+bk1(i)*delt1(i))
386:             end do
387:           end do
388:         end do
389: !
390: !       Computation of clear sky fluxes always set first level of fsul
391: !
392:         do i = 1 , iym1
393:           if ( iemiss.eq.1 ) then
394:             fsul(i,kzp1) = emiss1d(i)*(stebol*(ts(i)**4))
395:           else
396:             fsul(i,kzp1) = stebol*(ts(i)**4)
397:           end if
398:         end do
399: !
400: !       Downward clear sky fluxes store intermediate quantities in down
401: !       flux Initialize fluxes to clear sky values.
402: !
403:         do i = 1 , iym1
404:           tmp(i) = fsul(i,kzp1) - stebol*tint4(i,kzp1)
405:           fsul(i,1) = fsul(i,kzp1) - abstot(i,1,kzp1,jslc)*tmp(i)       &
406:                   & + s(i,1,2)
407:           fsdl(i,1) = stebol*(tplnke(i)**4)*emstot(i,1,jslc)
408:           ful(i,1) = fsul(i,1)
409:           fdl(i,1) = fsdl(i,1)
410:         end do
411: !
412: !       fsdl(i,kzp1) assumes isothermal layer
413: !
414:         do k = 2 , kz
415:           do i = 1 , iym1
416:             fsul(i,k) = fsul(i,kzp1) - abstot(i,k,kzp1,jslc)*tmp(i)     &
417:                     & + s(i,k,k+1)
418:             ful(i,k) = fsul(i,k)
419:             fsdl(i,k) = stebol*(tplnke(i)**4)*emstot(i,k,jslc)          &
420:                     & - (s(i,k,2)-s(i,k,k+1))
421:             fdl(i,k) = fsdl(i,k)
422:           end do
423:         end do
424: !
425: !       Store the downward emission from level 1 = total gas emission *
426: !       sigma t**4.  fsdl does not yet include all terms
427: !
428:         do i = 1 , iym1
429:           ful(i,kzp1) = fsul(i,kzp1)
430:           absbt(i) = stebol*(tplnke(i)**4)*emstot(i,kzp1,jslc)
431:           fsdl(i,kzp1) = absbt(i) - s(i,kzp1,2)
432:           fdl(i,kzp1) = fsdl(i,kzp1)
433:         end do
434: 
435: !     FAB radiative forcing sur fsul
436: 
437:         if ( rad==1 ) then
438:           fsul0(:,:) = fsul(:,:)! save fsul0 = no dust
439:           fsdl0(:,:) = fsdl(:,:)!
440:         end if
441: 
442:       end do ! end rad loop
443: 
444: !     FAB after this DO loop fsul account for dust LW effect
445: !     which is OK in case of idirect=2
446: 
447:       aerlwfo(:) = fsul0(:,1) - fsul(:,1)
448: 
449: !     surface lw net ! fsul(i,plevp) - fsdl(i,plevp)
450: !     aerlwfos(:)= fsdl0(:,kz)-fsdl(:,kz)
451:       aerlwfos(:) = (fsul0(:,kzp1)-fsdl0(:,kzp1))-                      &
452:                &    (fsul(:,kzp1) - fsdl(:,kzp1))
453:          
454: !     return to no aerosol LW effect  situation if idirect ==1
455:       if ( idirect==1 ) then
456:         fsul(:,:) = fsul0(:,:)
457:         fsdl(:,:) = fsdl0(:,:)
458:       end if 
459: 
460: !
461: !     Modifications for clouds
462: !
463: !     Further qualify longitude subset for computations.  Select only
464: !     those locations where there are clouds (total cloud fraction <=
465: !     1.e-3 treated as clear)
466: !
467:       call <a href="./mod_when.f90.html#whenflt" TARGET=CENT_PANEL>whenflt</a>(iym1,tclrsf(1,kzp1),1,0.999D0,indx,iym1c)
468: !
469: !     Compute downflux at level 1 for cloudy sky
470: !
471:       do ii = 1 , iym1c
472:         i = indx(ii)
473: !
474: !       First clear sky flux plus flux from cloud at level 1
475: !
476:         fdl(i,kzp1) = fsdl(i,kzp1)*tclrsf(i,kz)                     &
477:                      & *rtclrsf(i,kzp1-khiv(i)) + fclb4(i,kz-1)      &
478:                      & *cld(i,kz)
479:       end do
480: !
481: !     Flux emitted by other layers
482: !     Note: Vertical indexing here proceeds from bottom to top
483: !
484:       khighest = khiv(<a href="./intmax.f90.html#intmax" TARGET=CENT_PANEL>intmax</a>(iym1,khiv,1))
485:       do km = 3 , khighest
486:         km1 = kzp1 - km
487:         km2 = kzp2 - km
488:         km4 = kzp4 - km
489:         do ii = 1 , iym1c
490:           i = indx(ii)
491:           if ( km.le.khiv(i) ) then
492:             tmp1 = cld(i,km2)*tclrsf(i,kz)*rtclrsf(i,km2)
493:             fdl(i,kzp1) = fdl(i,kzp1) + (fclb4(i,km1)-s(i,kzp1,km4)) &
494:                          & *tmp1
495:           end if
496:         end do
497:       end do
498: !
499: !     Note: Vertical indexing here proceeds from bottom to top
500: !
501:       do k = 1 , khighest - 1
502:         k1 = kzp1 - k
503:         k2 = kzp2 - k
504:         k3 = kzp3 - k
505:         do ii = 1 , iym1c
506:           i = indx(ii)
507:           if ( k.ge.klov(i) .and. k.le.khivm(i) ) ful(i,k2) = fsul(i,k2)&
508:              & *(tclrsf(i,kzp1)*rtclrsf(i,k1))
509:         end do
510:         do km = 1 , k
511:           km1 = kzp1 - km
512:           km2 = kzp2 - km
513:           km3 = kzp3 - km
514:           do ii = 1 , iym1c
515:             i = indx(ii)
516: !
517:             if ( k.le.khivm(i) .and. km.ge.klov(i) .and. km.le.khivm(i) &
518:                & ) ful(i,k2) = ful(i,k2)                                &
519:                              & + (fclt4(i,km1)+s(i,k2,k3)-s(i,k2,km3))  &
520:                              & *cld(i,km2)*(tclrsf(i,km1)*rtclrsf(i,k1))
521:           end do
522:         end do             ! km=1,k
523:       end do               ! k=1,khighest-1
524: !
525:       do k = 1 , kzp1
526:         k2 = kzp2 - k
527:         k3 = kzp3 - k
528:         do i = 1 , iym1
529:           start(i) = .false.
530:         end do
531:         do ii = 1 , iym1c
532:           i = indx(ii)
533:           if ( k.ge.khiv(i) ) then
534:             start(i) = .true.
535:             ful(i,k2) = fsul(i,k2)*tclrsf(i,kzp1)                      &
536:                       & *rtclrsf(i,kzp1-khiv(i))
537:           end if
538:         end do
539:         do km = 1 , khighest
540:           km1 = kzp1 - km
541:           km2 = kzp2 - km
542:           km3 = kzp3 - km
543:           do ii = 1 , iym1c
544:             i = indx(ii)
545:             if ( start(i) .and. km.ge.klov(i) .and. km.le.khiv(i) )     &
546:                & ful(i,k2) = ful(i,k2)                                  &
547:                            & + (cld(i,km2)*tclrsf(i,km1)*rtclrsf(i,     &
548:                            & kzp1-khiv(i)))                            &
549:                            & *(fclt4(i,km1)+s(i,k2,k3)-s(i,k2,km3))
550:           end do
551:         end do          ! km=1,khighest
552:       end do            ! k=1,kzp1
553: !
554: !     Computation of the downward fluxes
555: !
556:       do k = 2 , khighest - 1
557:         k1 = kzp1 - k
558:         k2 = kzp2 - k
559:         k3 = kzp3 - k
560:         do ii = 1 , iym1c
561:           i = indx(ii)
562:           if ( k.le.khivm(i) ) fdl(i,k2) = 0.
563:         end do
564:         do km = k + 1 , khighest
565:           km1 = kzp1 - km
566:           km2 = kzp2 - km
567:           km4 = kzp4 - km
568:           do ii = 1 , iym1c
569:             i = indx(ii)
570: !
571:             if ( k.le.khiv(i) .and. km.ge.max0(k+1,klov(i)) .and.       &
572:                & km.le.khiv(i) ) fdl(i,k2) = fdl(i,k2)                  &
573:                & + (cld(i,km2)*tclrsf(i,k1)*rtclrsf(i,km2))             &
574:                & *(fclb4(i,km1)-s(i,k2,km4)+s(i,k2,k3))
575:           end do
576:         end do             ! km=k+1,khighest
577:         do ii = 1 , iym1c
578:           i = indx(ii)
579:           if ( k.le.khivm(i) ) fdl(i,k2) = fdl(i,k2) + fsdl(i,k2)       &
580:              & *(tclrsf(i,k1)*rtclrsf(i,kzp1-khiv(i)))
581:         end do
582:       end do               ! k=1,khighest-1
583: !
584: !     End cloud modification loops
585: !
586: !     All longitudes: store history tape quantities
587: !
588:       do i = 1 , iym1
589: !
590: !       Downward longwave flux
591: !
592:         flwds(i) = fdl(i,kzp1)
593: !
594: !       Net flux
595: !
596:         flns(i) = ful(i,kzp1) - fdl(i,kzp1)
597: !
598: !       Clear sky flux at top of atmosphere
599: !
600:         flntc(i) = fsul(i,1)
601:         flnsc(i) = fsul(i,kzp1) - fsdl(i,kzp1)
602: !
603: !       Outgoing ir
604: !
605:         flnt(i) = ful(i,1) - fdl(i,1)
606:       end do
607: !
608: !     Computation of longwave heating (k per sec)
609: !
610:       do k = 1 , kz
611:         do i = 1 , iym1
612:           qrl(i,k) = (ful(i,k)-fdl(i,k)-ful(i,k+1)+fdl(i,k+1))          &
613:                    & *gocp/((pint(i,k)-pint(i,k+1)))
614:         end do
615:       end do
616: !
617:       end subroutine radclw
</PRE>

<HR>

</BODY>
</HTML>
